[{"categories":["Back","note"],"content":"记录2022春招面经","date":"2022-02-26","objectID":"/face-exp-note/","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"XLXS汽车一面 ","date":"2022-02-26","objectID":"/face-exp-note/:1:0","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"ArrayLsit循环删除重复元素 方法 结果 for正序 部分元素删不掉 for倒序 正确、单线程多线程ok foreach ConcurrentModificationException ArrayList Remove ConcurrentModificationException Iterator Remove 正确、单线程ok；多线程不一定 ","date":"2022-02-26","objectID":"/face-exp-note/:1:1","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"b树、b+树区别 B树与B+树的区别 B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。 B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 B树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整)-1,m-1](根节点为[1,m-1])，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整),m](根节点为[1,m])，具有n个关键字的节点包含（n）棵子树。 B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。 B树的优点 1.B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B+树的优点 所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 b+树的中间节点不保存数据，能容纳更多节点元素。 B树和B+树的共同优点 考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。 ","date":"2022-02-26","objectID":"/face-exp-note/:1:2","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"HashMap数据结构 HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 ","date":"2022-02-26","objectID":"/face-exp-note/:1:3","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"HashMap优化避免链表死循环 1.7之前（包括），put冲突时使用的时头插法，当多线程下，A线程设置了e =node1，next =node2，又根据头插法，线程B设置了e=node2，next=node1，产生了死循环，cpu100。 1.8以后开始使用尾插法，企图避免多线程下死循环，cpu100，然而还是会主要原因有如下 链表转换树或者对树进行操作，即Node节点转换为TreeNode结点异常 ","date":"2022-02-26","objectID":"/face-exp-note/:1:4","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"mysql innodb间隙锁 当查询某条数据时，会对非主键的数据加间隙锁比如每天访客顺序属性（非主键），1、3，那么无法重新添加2，但是可以添加4。与隔离级别无关 ","date":"2022-02-26","objectID":"/face-exp-note/:1:5","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"Spring设计模式 简单工厂(非23种设计模式中的一种) BeanFactory创建Spring Bean 工厂方法 FactoryBean延迟创建Bean 单例模式 提供单例注册器、创建出的Spring Bean 适配器模式 AOP 的增强或通知(Advice)，适配方法前后通知 Spring MVC中，DispatcherServlet适配不同Controller重定向 装饰器模式 DataSource 装饰多个数据源 代理模式 aop面向切面编程运行时增强的动态代理 观察者模式 事件驱动模型中事件、事件监听、时间发布者 策略模式 MethodNameResolver设置类可以处理那些请求，已过时 模版方法模式 jdbcTemplate、hibernateTemplate ","date":"2022-02-26","objectID":"/face-exp-note/:1:6","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"Redis缓存穿透和雪崩 缓存雪崩 原因：大量redis key在同一时间失效，导致大量请求访问数据库，数据库服务器宕机，线上服务大面积报错。 解决办法： （1）redis高可用 （2）加锁排队，限流降级 （3）缓存失效时间均匀分布 缓存穿透 原因：指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决办法： （1）接口层增加校验 （2）采用布隆过滤器 ","date":"2022-02-26","objectID":"/face-exp-note/:1:7","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"Redis扩容 集群 复制配置文件 **src/redis-cli –cluster add-node **增加主节点 **src/redis-cli –cluster add-node -cluster-slave –cluster-master-id **增加从节点 src/redis-cli –cluster reshard 192.168.209.128:6379 分配槽位 内存渐进式扩容 初始hashsize为4，当数组个数与hash表大小一致，将扩容为两倍 每次的增删改查则扩容（rehashindex）+1，收缩类似，分而治之 ","date":"2022-02-26","objectID":"/face-exp-note/:1:8","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"多线程执行顺序 private static int a = 0; @Override public void run() { for (int i = 0;i \u003c 100; i++) { a++; } } public static void main(String[] args) { new Thread(new Whyzero()).start(); new Thread(new Whyzero()).start(); // try { // Thread.sleep(200); // } catch (InterruptedException e) { // e.printStackTrace(); // } System.out.println(a); } 一共有三个线程 t1、t2、main由于指令重排，谁先执行不一定，默认是父线程优先，故无论怎么改都是0 当加上sleep，让两个子线程先执行，就能得到正确结果 static volatile long i; static volatile long n; public Add100(long i, long n) { this.i = i; this.n = n; } public void run() { for (int m = 0; m \u003c n; m++) { i++; } } public static void main(String[] args) { for (int j = 8000; j \u003e 100; j--) { test1(j); boolean flag = i == 2 * j; System.out.println(\"i==\" + i + \";j==\" + j + \"; \" + flag); } } public static void test1(long n) { Add100 add = new Add100(0, n); Thread t1 = new Thread(add); Thread t2 = new Thread(add); t1.start(); t2.start(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } 当循环次数增加时，会发现结果并不是循环次数的两倍，单核一倍到两倍；多核2到两倍 ","date":"2022-02-26","objectID":"/face-exp-note/:1:9","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["Back","note"],"content":"总结 想说点什么，准备的很多面试内容要么记得不是很熟悉，要么准备的太浅了，还需要继续努力啊！ ","date":"2022-02-26","objectID":"/face-exp-note/:1:10","tags":["Java","Spring","Mysql"],"title":"面经","uri":"/face-exp-note/"},{"categories":["SoftwareDesign","note"],"content":"记录设计模式相关笔记","date":"2021-12-10","objectID":"/design-mode/","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"UML类图是描述类之间的关系 ","date":"2021-12-10","objectID":"/design-mode/:1:0","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"概念 类（Class）：使用三层矩形框表示。 第一层显示类的名称，如果是抽象类，则就用斜体显示。 第二层是字段和属性。 第三层是类的方法。 注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。 接口：使用两层矩形框表示，与类图的区别主要是顶端有\u003c\u003e显示 。 第一行是接口名称。 第二行是接口方法。 继承类（extends）：用空心三角形+实线来表示。 实现接口（implements）：用空心三角形+虚线来表示 关联（Association）：用实线箭头来表示，例如：燕子与气候 聚合（Aggregation）：用空心的菱形+实线箭头来表示 聚合：表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，例如：公司和员工 组合（Composition）：用实心的菱形+实线箭头来表示 组合：部分和整体的关系，并且生命周期是相同的。例如：人与手 依赖（Dependency） ：用虚线箭头来表示，例如：动物与氧气 基数 ：连线两端的数字表明这一端的类可以有几个实例，比如：一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联、聚合、组合是有基数的。 ","date":"2021-12-10","objectID":"/design-mode/:1:1","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"重复度： 单重复度，只存在一对一的关系。 多重复度，用列表、vector或其它的数据结构维护一对多，多对多的关系 这里再说一下重复度，其实看完了上面的描述之后，我们应该清楚了各个关系间的关系以及具体对应到代码是怎么样的，所谓的重复度，也只不过是上面的扩展，例如A和B有着“1对多”的重复度，那在A中就有一个列表，保存着B对象的N个引用，就是这样而已。 形式：依赖/关联, 组合/聚合,继承/实现 Dependency /Association,Composition/ Aggregation,Generalization/Realization ","date":"2021-12-10","objectID":"/design-mode/:1:2","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"关联-属性指针-associate 双向关联-相互关联， ** 相互把对方作为自己的指针** C1-C2：指双方都知道对方的存在，都可以调用对方的公共属性和方法。 在GOF的设计模式书上是这样描述的：虽然在分析阶段这种关系是适用的，但我们觉得它对于描述设计模式内的类关系来说显得太抽象了，因为在设计阶段关联关 系必须被映射为对象引用或指针。对象引用本身就是有向的，更适合表达我们所讨论的那种关系。所以这种关系在设计的时候比较少用到，关联一般都是有向的。 使用ROSE 生成的代码是这样的： class C1{ public C2 theC2; } class C2 { public C1 theC1; } 双向关联在代码的表现为双方都拥有对方的一个指针，当然也可以是引用或者是值。 单向关联-关联到它就把它当做自己的属性指针 C3-\u003eC4：表示相识关系，指C3知道C4，C3可以调用C4的公共属性和方法。 没有生命期的依赖。一般是表示为一种引用 生成代码如下： class C3{ public C4 theC4; } class C4{ } 单向关联的代码就表现为C3有C4的指针，而C4对C3一无所知。 自身关联（反身关联）-关联到自己，就是把自己当做属性指针 自己引用自己，带着一个自己的引用 代码如下： class C5{ public C5 theC5; } 就是在自己的内部有着一个自身的引用。 2.依赖-依赖 就把它的指针或引用，作为自己的函数形参-dependency (1)单向依赖 依赖: 指C5可能要用到C6的一些方法，也可以这样说，要完成C5里的所有功能，一定要有C6的方法协助才行。C5依赖于C6的定义，一般是在C5类的头文件中包含了C6的头文件。ROSE对依赖关系不产生属性。 注意，要避免双向依赖。一般来说，不应该存在双向依赖。 ROSE生成的代码如下： class C6{ public void Func(C7 *pC7Obj); } class C7{ } (2)双向依赖 双向依赖关系图没有看到标准的画法，知道时候补上。 那依赖和聚合\\组合、关联等有什么不同呢？ 关联是类之间的一种关系，例如老师教学生，老公和老婆，水壶装水等就是一种关系。这种关系是非常明显的，在问题领域中通过分析直接就能得出。 依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖 也可说是一种偶然的关系，而不是必然的关系，就是“我在某个方法中偶然用到了它，但在现实中我和它并没多大关系”。例如我和锤子，我和锤子本来是没关系 的，但在有一次要钉钉子的时候，我用到了它，这就是一种依赖，依赖锤子完成钉钉子这件事情。 组合是一种整体-部分的关系，在问题域中这种关系很明显，直接分析就可以得出的。例如轮胎是车的一部分，树叶是树的一部分，手脚是身体的一部分这种的关系，非常明显的整体-部分关系。 上述的几种关系（关联、聚合/组合、依赖）在代码中可能以指针、引用、值等的方式在另一个类中出现，不拘于形式，但在逻辑上他们就有以上的区别。 这里还要说明一下，所谓的这些关系只是在某个问题域才有效，离开了这个问题域，可能这些关系就不成立了，例如可能在某个问题域中，我是一个木匠，需要拿着 锤子去干活，可能整个问题的描述就是我拿着锤子怎么钉桌子，钉椅子，钉柜子；既然整个问题就是描述这个，我和锤子就不仅是偶然的依赖关系了，我和锤子的关 系变得非常的紧密，可能就上升为组合关系（让我突然想起武侠小说的剑不离身，剑亡人亡…）。这个例子可能有点荒谬，但也是为了说明一个道理，就是关系 和类一样，它们都是在一个问题领域中才成立的，离开了这个问题域，他们可能就不复存在了 3.组合/聚合-属性对象-composite/aggreate (1)组合-自己是实心的，去组合它，把它当做自己的属性对象，只是被组合的类不会单独存在(自己构造函数中使用) 组合（也有人称为包容）：一般是实心菱形加实线箭头表示，如上图所示，表示的是C8被C7包容，而且C8不能离开C7而独立存在。但这是视问题域而定的， 例如在关心汽车的领域里，轮胎是一定要组合在汽车类中的，因为它离开了汽车就没有意义了。但是在卖轮胎的店铺业务里，就算轮胎离开了汽车，它也是有意义 的，这就可以用聚合了。 在《敏捷开发》中还说到，A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。 他们的代码如下： class C8{ public C9 theC9; } class C9{ } 可以看到，代码和聚合是一样的。具体如何区别，可能就只能用语义来区分了。 (2)聚合-自己空心的，去聚合它，把它当做自己的属性对象，被聚合的类可以单独存在(自己构造函数中不使用) 当类之间有整体-部分关系的时候，我们就可以使用组合或者聚合。 聚合：表示C9聚合C10，但是C10可以离开C9而独立存在（独立存在的意思是在某个应用的问题域中这个类的存在有意义。这句话怎么解，请看下面组合里的解释）。 代码如下： class C10{ public C11 theC11; } class C11{ } ","date":"2021-12-10","objectID":"/design-mode/:1:3","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"总结聚合和组合： 问题域的语义上：组合中被组合类单独存在没有意义; 聚合中被聚合类在可以有单独存在的意义。 生命期上：组合中必须要负责被组合类的生命期; 聚合中可不负责被聚合类的声明期，可以由外部程序来创建和消亡（可用赋值）。 4.泛化和实现 derived/implement (1)继承（Derived）-子对象指向父对象 泛化关系：如果两个类存在泛化的关系时就使用，例如父和子，动物和老虎，植物和花等。 ROSE生成的代码很简单，如下： class C12 extends C13{ } (2)接口实现（implement） 实现关系指定两个实体之间的一个合约。换言之，一个实体定义一个 合约 ，而另一个实体保证履行该合约 。 ","date":"2021-12-10","objectID":"/design-mode/:1:4","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"六大准则 ","date":"2021-12-10","objectID":"/design-mode/:2:0","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"单一职责原则 单一职责原则(Single Pesponsibility Principle, SRP)，又称单一功能原则，面向对象五个基本原则（S.O.L.I.D）之一 定义 一个类应该只有一个发生变化的原因 编码实现 ifelse，判断实现，但是不易维护 场景 不同用户看不同清晰度的视频，则每种角色写在不同类中，进行自己的逻辑判断 ","date":"2021-12-10","objectID":"/design-mode/:2:1","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"开闭原则 开闭原则（Open Closed Principle, OCP）规定“软件中的对象（类，模块，函数等等）应该对于扩展时开放的但是对于修改是关闭的” 定义 扩展开放，修改关闭 编码实现 破坏方法，继承实现 场景 长方形，三角形，圆形，计算面积精度不同时，需要继承实现，而不是直接修改源码 ","date":"2021-12-10","objectID":"/design-mode/:2:2","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"里氏替换原则 里氏替换原则（Liskov Substitution Principle LSP），继承必须确保超类所拥有的性质在子类中依然成立 定义 兼容性、维护性、扩展性 编码实现 继承，子类扩展父类，同时保留父类的基础功能 场景 银行卡（信用卡、储蓄卡、地铁卡、饭卡），信用卡继承储蓄卡同时，保留储蓄卡，及储信用卡类可以用作储蓄卡，但是储蓄卡不能用作信用卡 ","date":"2021-12-10","objectID":"/design-mode/:2:3","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"迪米特法则 迪米特法则（Law of Demeter, LOD），意义在于降低类之间的哦i和。由于每个对象尽量减少对其它对象的了解，因此，很容易是的系统的功能模块功能独立，相互之间不存在（或还很少有）依赖关系 定义 最少知道，减少依赖 编码实现 高内聚、低耦合 场景 校长、教师、学生成绩、排名，老师处理自己的学生成绩查询排名，校长通过老师获取结果 ","date":"2021-12-10","objectID":"/design-mode/:2:4","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"接口隔离原则 接口隔离原则（Interface Segregation Principle, ISP）要求程序员尽量将臃肿庞大的接口拆分为更小的和更具体的接口，让接口中只包含客户感兴趣的方法 定义 更小的接口、更具体的接口 编码实现 高内聚、低耦合，将不同功能接口分开，而不是继承后重写为空 场景 dota英雄的不同技能，创建不同接口，有技能则实现，没有不需要实现接口，避免实现后重写为空函数 ","date":"2021-12-10","objectID":"/design-mode/:2:5","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["SoftwareDesign","note"],"content":"依赖倒置原则 依赖倒置原则（Dependence Inversion Principle, DIP），程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现编程，这样就将i了客户与实现模块间的耦合 定义 以来接口、降低耦合 编码实现 高内聚、低耦合，将功能抽象，实现，不要放入同一个类。 场景 随机抽奖，权重抽奖，设置抽奖父类，继承后分开实现，不要写入同一个类 ","date":"2021-12-10","objectID":"/design-mode/:2:6","tags":["DesignMode","UML"],"title":"设计模式笔记","uri":"/design-mode/"},{"categories":["Learning","note"],"content":"记录算法笔记","date":"2021-10-14","objectID":"/algorithm-note/","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"结构 ","date":"2021-10-14","objectID":"/algorithm-note/:0:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"数组 ","date":"2021-10-14","objectID":"/algorithm-note/:1:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"排序 知识 总结 时间复杂度 最好 最好情况 最坏 最坏情况 平均时间复杂度 冒泡排序 O(n) 原序列顺序 O(n^2) 原序列顺序倒序 O(n^2) 插入排序 O(n) 原序列顺序 O(n^2) 原序列顺序倒序 O(n^2) 选择排序 O(n^2) 原序列顺序 O(n^2) 原序列顺序倒序 O(n^2) 希尔排序 O(n) 原序列顺序 O(n^1.5)？O(n^2) 原序列顺序倒序 O(n^1.3) 快速排序 O(nlogn) 每一次划分的时候都是轴值 O(n^2) 正序或者逆序 O(nlogn) 归并排序 O(nlogn) 两个序列直接连接 O(nlogn) 最后一次比较两个有序子序列各自剩最后一个数据元素 O(nlogn) 计数排序 O(n+k)，k 是数据范围 原序列顺序 O(n+k)，k 是数据范围 原序列顺序倒序 O(n+k)，k 是数据范围 桶排序 O(n) n个元素平均分桶 O(n) n个元素一直一个桶 O(n) 基数排序 O(nk)，k 是维度 原序列顺序 O(nk)，k 是维度 原序列顺序倒序 O(n*k)，k 是维度 堆排序 O(nlogn) 所有叶子铺满最底层 O(nlogn) 所有叶子铺满半层的时候 O(nlogn) 稳定性 重要稳定算法：冒泡、插入、归并、桶 重要不稳定算法：选择、快排、堆 也就是说一个序列中的相同值，它排序后，它的相同值的顺序不会改变即稳定 排序名称 稳定性 分析 冒泡 稳定 冒泡原理遵循大数下沉小数冒泡，思路是每次相邻两个进行交换，因为是每次找到当前最小数然后进行一格一格的移动，因为是一格一格的一道，相同的数字并不会出现后一个数字跳两格的情况跳到前面，只可能是两个数一起前移或者后移，所以该排序是稳定的 选择 不稳定 选择原理和冒泡差不多，但是它省去了相邻交换的这个步骤，直接找到最小的位置，直接换过来，这个的交换移动位置就是跳跃式的，也可能出现两个数，前一个被换到后面去 例子 5 9 5 2 第一个5会与2进行交换，然后就出现了两个相同值出现顺序改变的情况，因为第一个5在移动，而第二个5没有移动，所以就可能出现这种情况，冒泡是整体的移动 插入 稳定 插入就是从后往前一个一个的找，然后找到适合位置就放在这，也是整体往后移，很明显，稳不稳定取决于当前判断是\u003c=还是\u003c，这种人为可以操控的都是稳定的 快速排序 不稳定 快排的话很明显的一个不稳定的地方就是一个指针从前往后，一个指针从后往前，然后后一个指针换到前一个位置，但是这个指针又是往另一方向走的，这就和我们顺序相悖了 例子 2 3 3 3 1 1 1 这样相同的数肯定是以相反的顺序换过去 归并 稳定 归并的核心地方就在于有序归并这块儿，归并的时候是判断两个数的大小然后再放，那么我们只要控制两个相同数都是前一个序列先放那么就能保证稳定性了 堆排 不稳定 这个就比较那个了，一棵树，然后下沉的时候可能是左子树可能是右子树，如果相同值在左子树，然后自己降到右子树那么就不稳定了 例子 3 3 2 ;3(1) 3 (2) 2;-\u003e2 3(2) 3(1) 希尔排序 不稳定 希尔排序的是通过取增量然后划分成不同分组，最后增量不断减小，来将分组合并的，主要利用了插入排序的最好情况O(n)的思想，如果本身大量有序，那么需要比较次数就减小了很多，因为希尔排序是同各国不同分组的，也就是说如果两个相同值划分在了不同分组的话，那么就有可能出现顺序颠倒问题，从而不稳定 例子 3(1) 3(2) 1 4 第一轮 1 3(2) 3(1) 4 第二轮 同上 稳定性时间空间 稳定性和时间空间对比 时间 空间 稳定性 选择排序 O（N^2） O(1) × 冒泡排序 O（N^2） O(1) √ 插入排序 O（N^2） O(1) √ 归并排序 O（N*logN） O（N） √ 快速排序 O（N*logN） O（logN） × 堆排序 O（N*logN） O(1) × 时间复杂度暂时2022-02没有低于O（N*logN） 归并排序额外空间变成O(1),但算法困难，且不再稳定（归并排序 内部缓存法），不如用堆排序？ 原地归并排序时间复杂度变为O（N^2），增加算法难度，虽然空间O(1)不如用插入 01 stable sort 快排可以保证稳定性，但是算法复杂，空间变为O（N），不如直接用归并 以上三种算法性能三选二，没有三个都好的（稳定、时间O（N*logN）、空间O(1)） 奇偶分开，要求相对奇数和偶数次序不变，空间复杂度O(1)，时间复杂度O（N），时间复杂度说不会直接问怎么做（01 stable sort ） 实际工程排序分开排序如数组长度小于60插入（或归并）常数低，大于60快排变量低（利用各自的优势） 考虑稳定性 其他 是否原地排序 是否稳定 最好、最坏、平均时间复杂度 空间复杂度 冒泡排序 是 是 O(1) 是 插入排序 是 是 O(1) 是 选择排序 是 否 O(1) 是 希尔排序 是 否 O(1) 是 快速排序 是 否 O(logn)~O(n) 是 归并排序 否 是 O(n) 是 计数排序 否 是 O(n+k) 否 桶排序 否 是 O(N+M)，N表示待排数据个数，M表示桶个数 否 基数排序 否 是 O(n+k) 否 堆排序 是 否 O(1) 是 插入排序 升序，从左至右小则交换，插入前方局部有序，且都有序 选择排序 循环选择无序部分最小值放到队首，再取n-1最值放队首，直到结束(遍历，找最小值，与数组0位置交换，再找次小，再放1，直到最后) 计数排序 如年龄列表，第一次遍历统计个数，第二次遍历还原数组（根据下标索引，分区还原），时间复杂度O（n） 奇数排序（桶排序） 先根据个位数字放10个桶，倒出还原（从右往左，词频–，保证先入桶先出，保证排序稳定），再根据十位，倒出还原，直到最高位 归并排序 两个数组分别有序，再统一拷贝到一个数组（三个while模式） 冒泡排序 右边比左边大则交换，循环 题目 二分排序 二分查找 找大于等于某个数的最左侧index 局部最小 极限的概念，二分一边单调增，一边单调减，中间存在极限 数值整数次方 二分幂、快速幂，累乘 奇数排序 奇偶分开 计数排序思想，统计奇数，分片，遍历，奇数一片，偶数另一片。 归并排序 小和问题 左边小的数的和，在归并过程中，求左边小的个数和，等价于右边大的个数和，故当合并时，先拷贝的（左边比右边小）的产生1个数，累加后为结果 逆序对问题 左边的数比右边大，则两个数构成逆序对，在归并过程中当出现小于则打印 查找两个数组的相同字符 方法 方法1：对A中的数组进行排序，采取同样的排序方法对B中的数组进行排序 从A，B中各自取出a，b进行比较 如果a\u003eb,那么从B中取出下一个数据b进行比较 如果a\u003cb,那么从A中取出下一个数据a进行比较 如果a=b,那么找到一个，继续 方法2：hash 对A中的m个数据装入到hash表 对B中的n个数据一次去hash表中查询，如果找到那么就是相同元素 海量数据 升级：如果数据特别大，内存无法装下。 两个大文件，查找相同字符串 一、hash，分治法： 采用hash算法对A文件进行hash成a个小文件 采取同样的hash算法对B文件进行hash成b个小文件 比较小文件对\u003ca1,b1\u003e………因为hash的问题，所以相同的字符串肯定在同个文件对里面。 统计小文件对，可以继续采用hash，对a1的每一字符串建立hash表，遍历b1的字符串看是否在之前构建的hash表里面（和上面一样） 一般来说，如果内存可以存放，可以构造hash表，进行查找。如果内存无法加载，那么可以通过hash把大文件分成多个小文件，从而进行比较。 二、位图+布隆过滤器 注 hash算法在海量数据中的运用： ​ 单机处理大数据的问题也和mapreduce一样，分而治之，把海量数据切分成若干个小份进行处理。 分而治之 采用hash进行取模进行等价映射，将巨大的文件进行等价分割（符合一定规律的数据会被划分到同一个文件），划分成若干个小文件再进行处理。 利用hashmap进行内存统计 利用hashMap对小文件里面的数据进行统计 排序 快速排序 荷兰国旗问题 数组分区，小于等于一个数左边，大于则右边（快排1.0） 小于左边，数字中间，大于右边（快排2.0） （快排3.0从数组中找随机数进行分区迭代） ","date":"2021-10-14","objectID":"/algorithm-note/:1:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"二维数组排序 知识 二维数组按行和按列遍历的效率 按行遍历的效率大概是是按列遍历的0.5倍 在c语言中，数组在内存中是按行存储的，按行遍历时可以由指向数组第一个数的指针一直向后遍历，由于二维数组的内存地址是连续的，当前行的尾与下一行的头相邻，所以可以直接到下一行 我们眼中的二维数组： 内存中的二维数组： 按行遍历比按列遍历的效率高体现在这些方面：  1. CPU高速缓存：在计算机系统中，CPU高速缓存（英语：CPU Cache，在本文中简称缓存）是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。（百度百科解释）。 2. 缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。随着数组元素越来越多，按列读取速度也会越来越慢。 可以用以下代码自行测试： #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003cctime\u003eusing namespace std; int main() { const int MAX_ROW = 2000; const int MAX_COL = 2000; int(*a)[MAX_COL] = new int[MAX_ROW][MAX_COL]; clock_t start, finish; //先行后列 start = clock(); for (int i = 0; i\u003cMAX_ROW; i++) for (int j = 0; j\u003cMAX_COL; j++) a[i][j] = 1; finish = clock(); //totaltime=(double)()/CLOCKS_PER_SEC; cout \u003c\u003c \"先行后列遍历时间为：\" \u003c\u003c finish - start \u003c\u003c \"ms\" \u003c\u003c endl; //先列后行 start = clock(); for (int i = 0; i\u003cMAX_COL; i++) for (int j = 0; j\u003cMAX_ROW; j++) a[j][i] = 1; finish = clock(); //totaltime=(double)()/CLOCKS_PER_SEC; cout \u003c\u003c \"先列后行遍历时间为：\" \u003c\u003c finish - start \u003c\u003c \"ms\" \u003c\u003c endl; return 0; } 题目 有序二维数组查找 增序，从左下角起，目标大则右移，目标小则上移 ","date":"2021-10-14","objectID":"/algorithm-note/:1:2","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"异或 题目 数组中有一个数不一样 循环异或，最后的结果即为这个数 数组中有两个数不一样 循环异或，最后的结果即为这两个数异或，获取两个数二进制最低位，异或结果取反+1再与源结果相与，提起最小为1，两个数二进制某一位不同，则用此位为1其他位为0的数区分源数组，获取其中一个数，再将异或和与其异或得到另一个数。 ","date":"2021-10-14","objectID":"/algorithm-note/:1:3","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"字符串 ","date":"2021-10-14","objectID":"/algorithm-note/:2:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"搜索 知识 KMP 算法 空间换时间，匹配字符串切分，寻找最大公共子字符串，用匹配长度减去最大公共，为位数。主要就是优化匹配串中存在局部相同的部分的移动，时间： O(m+n) BM算法 从右侧对比，不相等为坏，相等为好，字符串长度-好为位移，移动不相等部分最大值，即为求出的位移 Sunday算法 左侧对比，不匹配，看源串下一位是否在匹配串，在则移动匹配串从右向左位数+1.不存在则移动长度+1 ","date":"2021-10-14","objectID":"/algorithm-note/:2:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"回文 题目 最长回文串 输入无序材料串，用HashSet，第一次入，第二次出，统计个数，注意中间可以有最小 最长回文串2 输入有序材料串，中心扩展法：循环中心，两边扩展，记录最大,也要记录。动态规划：类似中心扩展，扩展相等 dp[i][j] = dp[i+1][j-1] + 2，不等为前后+一位的最大值，结果位dp[0][n-1] 验证回文串 双指针，非为字母则++，否则对比，前后。 ","date":"2021-10-14","objectID":"/algorithm-note/:2:2","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"其他 题目 替换空格 使用StringBuilder，如果是空格则append其他，如果不是空格，则append自己，str.replace()先搜索，再创建新数组速度收敛为3n，所有查找替换则为5n 字符串数组最长公共前缀序列 调用Arrays.sort()方法，将第一个字符串和最后一个字符串对比获取最长公共前缀序列 括号深度 左括号++即可 字符串转int 判断符号，按位取char-’0‘的int结果为位，结果*10+位，加上符号即可 ","date":"2021-10-14","objectID":"/algorithm-note/:2:3","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"链表 ","date":"2021-10-14","objectID":"/algorithm-note/:3:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"第k个节点 题目 链表中倒数第k个节点 首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点 删除链表的倒数第N个节点 首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点，k-1==k-1.next.next ","date":"2021-10-14","objectID":"/algorithm-note/:3:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"两条链表 题目 合并两个排序的链表 递归，next非空，a小，merge（a.next,b）,b小，merge（a,b.next）,while+if else也可以，类似归并排序三个while，由于链表，其中一个为空，判断赋值一次即可 打印两个有序链表的公共部分 小于移动，相等打印共同移动 两条链表是否相交 判断是否有环，若无环，长链先走，相等时一起next，判断最后节点是否一致，一致则相交，不一致则不相交； 有环判断入环节点是否一致，一致相交，类似无环，终点为入环节点；若入环不一致，双方一致next，其中一个节点走回自己之前若和另外一个节点相同则相交，遇不到则不相交 ","date":"2021-10-14","objectID":"/algorithm-note/:3:2","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"其他 知识 解题方法论 笔试，空间不用太在乎，主要为了时间复杂度 面试，时间复杂度放第一位，但空间复杂度也要求最省 重要技巧 额外数据结构（哈希表） 快慢指针 题目 翻转链表 遍历，存next，next赋值位pre（初始null），now 赋值给pre，存的next复制给now 递归让this=change（this） 回文单链表 笔试：右边放到栈中，遍历另一半省空间，需要使用快慢指针，快指针两步，慢指针一步，快指针结束，慢指针中间，即可压栈 面试：同样取到中点，将后半翻转，双向对比空间O（1）、时间O（2*N） 单链表左边小，中间，右边打分区 笔试：放到数组（Node[]）中快排一轮，再构造链表 面试：设置三个区的头尾共6条链表，遍历分开放，当节点超过一个以后，head.next=tail,tail=newNode，最后串起来就好，注意最后连起来是空的部分。空间O（1）、时间O（N） 复制含有随机指针节点的链表 笔试：第一遍，将链表value拷贝挂到HashMap\u003cNode,Node\u003e中。第二遍，查map设置索引。空间O（1）、时间O（2*N） 面试：第一遍，将每个节点复制加在被复制的节点和下个节点之间，第二遍，复制随机指针(new.rand=pre.rand.next)，第三遍，两个两个处理分成两条链 判断链表中是否有环 笔试：将链表加入HashSet，执行next，当next在HashSet中出现第二次时，就存在环，且为环的头节点，否则不存在环。 面试：快慢指针，快指针走两步，慢指针走一步，当快慢相遇时，快指针回到链表头部，快慢指针都走一步，最后相遇则为环的头节点 ","date":"2021-10-14","objectID":"/algorithm-note/:3:3","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"栈 ","date":"2021-10-14","objectID":"/algorithm-note/:4:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"其他 题目 两个栈实现队列 入正常入一个栈，出时先全部压入另一个，弹出，再压回来，类似汉诺塔思想 判断栈的弹出序列 按照入栈压入，当和出栈顶相等时，出栈（入了再出），不相等则继续压栈直到个数，根据栈是否为空或出数组是否走到最后 ","date":"2021-10-14","objectID":"/algorithm-note/:4:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"树 ","date":"2021-10-14","objectID":"/algorithm-note/:5:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"遍历 知识 遍历序列 每个节点会走三次如1 2 3的树，遍历序列为1，2，2，2，1，3，3，3，1； 递归遍历 调整子树和打印的顺序，进行递归遍历 题目 先序遍历 先序遍历（深度优先） 弹出打印，先右再左入栈（如果有子节点） 二叉树序列化和反序列化 序列化：先序遍历：null用特殊符号代替（“#”），数字之间用特殊符号分割（“_”） 反序列化：分隔符切分为数组，建头节点，递归先左后右建树，遇到特殊符号给null 中序遍历 中序遍历 next有left就进栈，弹出打印，若有右树，对右树判断left… 判断是否搜索二叉树 中序遍历，都是升序 递归 记录上一个值，空值返回true，判断左，和上一个值比：降序return，升序更新上一个值，判断右，出现降序return，否则继续 无脑办法，中序放入list，判断递增 非递归 记录上一个值，弹出时判断增序，降序return，升序更新上一个值 动态规划：左右树最大h值、h最小值;左右是，高度差，左小右大判断 （微软）纸条对折，凹折痕和凸折痕个数 中序遍历，头节点凹，之后子节点左凹右凸 递归动态循环次数：左，打印，右 后序遍历 后序遍历 弹出放入另一个栈，先左再右入栈（如果有子节点），弹出打印另一个栈 层序遍历 宽度优先（层序优先） 头节点放入队列，弹出打印，放左右，周而复始 求最大宽度 笔试：宽度优先遍历，初始化一个HashMap记录节点和层的映射，初始化头节点为一层，当前层节点个数0，最大值为最小；宽度优先放入map，和队列，弹出时判断层是否变化，变化了计算层节点个数，注意当前层节点个数重置为1，因为若层无节点意味着不会不相等，即层数不会+1 面试：记录当前层最后一个节点初始化为head，下一层最后一个节点初始化为null，当前层个数为0，最大值为最小；弹出打印，判断left!=null?下一层最后一个节点=当前进栈节点=left； right!=null？下一层最后一个节点=当前进栈节点=right；弹出，当前层个数+1，判断是否等于当前层最后一个节点，若是，更新max，当前层最后一个节点=下一层最后一个节点下一层最后一个节点=null，当前层个数归0，若不是只+1（和ifelse无关，都会+1），放入左右，周而复始 判断是否完全二叉树 层序遍历，记是否遇到孩子不双全节点为false，放头节点到队列，放左右，弹出打印，判断1、2条件，成立继续，否则返回false 情况分析 任意节点，有右无左false 1成立，遇到了第一个左右子叶不全，后续节点均为子节点 递归套路 是否满二叉树 求最大深度，和节点个数；2^最大深度-1=节点个数（1«最大深度-1==节点个数） 取左右树信息，高度和节点个数，最后判断满足上面条件 树的高度，左右子树组大+1 是否平衡二叉树（二叉树题目套路） 动态规划：取左右树信息，左右树平衡，左h-右h小于等于1；处理当前逻辑和返回结果 树的高度，左右子树组大+1 两个节点最低公共祖先 回溯法：使用Hashmap存节点的父节点，head父节点head，递归放入左右子树；创建hashSet，cur=o1，如果cur！=map.getCur？set添加cur，更新cur（往上窜） set1加head，判断s2在不在set中，再往上窜，在则返回，不在更新cur（往上窜） 核心思想，生成父指针，放入一个向头的路径，另一个节点向上查找回溯，若相遇则碰撞 递归动态规划：null，o1，o2返回head，（情况1，先遇到即为结果，）左右子树递归，都非空返回头，（情况2，一边一个）一个非空返回不空的，都空返回空 情况分析 o1是o2祖先，或o2是o1祖先 o1、o2分开，不互为祖先 找一个节点的后继节点，O(N)-\u003eO(k)（有父指针） 情况分析 有右树，右树左节点； 无右树，是否par.left，是则找到，不是继续向上窜；parent为null返回parent（最右借点） ","date":"2021-10-14","objectID":"/algorithm-note/:5:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"堆 ","date":"2021-10-14","objectID":"/algorithm-note/:6:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"排序 知识 大分堆加入 队尾放元素，若小于父节点则交换（i-1）/2 大分堆堆弹出（堆顶） 尾部放到首部（size–；拷贝）；和子孩子比，换小的，递归直到叶子节点（2xi+1，2xi-1） 特点 完全二叉树，插入和计算（上浮下沉） 优先队列使用的堆 题目 队列前k部分有序，怎么排序最好 将有序部分放入堆，取堆首放入数组，将无序数放堆首，直到无序耗尽，在取堆首放入数组，直到堆空，时间复杂度O（nlogk） 给二叉树堆排序 从最下边三个数（1棵树）排序，再排倒数第二层，直到到堆顶（略快于尾部或首部添加）- ","date":"2021-10-14","objectID":"/algorithm-note/:6:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"图 ","date":"2021-10-14","objectID":"/algorithm-note/:7:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"总结 知识 存储方式 邻接表 A：B，C B： C: 邻接矩阵 1 1 1 1 1 1 1 1 1 其他 特殊的图，但不能表示所有的图 5 2 2 4 2 1 二维数组 [ [3,0,2], [2,0,2] ] 技巧 记住模板，将特殊形式转化为模板存储结构 模板 ","date":"2021-10-14","objectID":"/algorithm-note/:7:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"遍历 宽度优先 知识 利用队列实现（使用set避免死循环） 从源节点开始依次按照宽度进队列，然后弹出 每弹出一个点，把该节点所有没有进过队列的临界点放入队列 直到队列变空 广度优先 知识 利用栈实现（set避免死循环） 从源节点开始把节点按深度放入栈，然后弹出 每弹出一个节点，把该节点下一个没有进过栈的邻接点放入栈 直到栈变空 题目 拓扑排序（编译顺序，避免死循环） 找入度为0的点，找到后将入度为0的点及其出度删除，循环找入度为0的点（队列+map） ","date":"2021-10-14","objectID":"/algorithm-note/:7:2","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"最小生成树 题目（无向有权图） KrusKal算法（类并查集，判断图是否有环） 加入最小的边，检测图是否形成环，若有环，则不加（从最小的边开始，维护n个集合，当入节点和出节点在同一个集合则生成环，否则合并集合（单独的加入集合）） Prim算法 与出发点无关，将点加入Set（第一次出现），将当前点连通的边加入优先队列（小根堆），从堆中取出最小的边，若其指向的点是新出现的点（set没有），则边添加至结果集合，并将其边添加至堆中（会将重复的边添加到堆中，但是不会影响结果，因为重复的边添加后，对应的点也是再set中注册过的，故后面出堆的时候会舍弃） 若存在多个森林问题（两个图之间不连通，则需要对全部的node进行遍历，返回多个图的最小生成树） ","date":"2021-10-14","objectID":"/algorithm-note/:7:3","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"单元最短路径算法 题目 Dijkstra算法（没有权值为负数的边，需要指定出发点） 设置map，记录node到出发点的距离，头节点放入map，设置set记录节点是否用过，根据set和map获取一个距离最小的节点（可以直接取head节点），且没有在set中注册过的点，当这个节点不为空，循环，遍历当前节点的链接节点，若map中无则计算距离，否则将计算距离和map中比较取小的，遍历完节点后，set中注册当前最小值节点，更新最小值节点，直到最小值为空（所有节点都在set中注册过） 堆可以优化：入堆值，不需要改值，系统的好，若入堆值仍要改变，系统会全局扫描开销较大 //TODO A星算法 //TODO ","date":"2021-10-14","objectID":"/algorithm-note/:7:4","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"其他 题目 判断图是否存在环（类并查集） n个节点，各自作为set。遍历所有的边，当入点和出点不在同一个集合，则合并两个集合（单独的加入集合）并继续，若存在同一个集合则存在环 ","date":"2021-10-14","objectID":"/algorithm-note/:7:5","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"集合 ","date":"2021-10-14","objectID":"/algorithm-note/:8:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"并查集 知识 定义 并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些不相交集合的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先（LCA）等。 方法 makeSets 初始化，将所有节点单独设置set isSameSet 判断是否为同一个set find 递归查询最高父节点 union 合并 路径压缩 每递归查询父节点时，直接将最高父节点替换当前的父节点，提高查询效率 ","date":"2021-10-14","objectID":"/algorithm-note/:8:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"其他数据结构 算法 ","date":"2021-10-14","objectID":"/algorithm-note/:9:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"递归 ","date":"2021-10-14","objectID":"/algorithm-note/:10:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"时间复杂度 知识 Master公式 T(N) = a*T(N/b) + O(N^d) 条件 复杂度 log(b,a) \u003e d O(N^log(b,a)) log(b,a) = d O(N^d * logN) log(b,a) \u003c d O(N^d) ","date":"2021-10-14","objectID":"/algorithm-note/:10:1","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"动态规划 题目 青蛙跳1或2，n阶方法个数 斐波那契数列，找规律 青蛙1-n，n阶方法个数 动态规划，错位相减。1 « –number;//2^(number-1) 小知识 ","date":"2021-10-14","objectID":"/algorithm-note/:11:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"取中点 l+r-l»1，防溢出 ","date":"2021-10-14","objectID":"/algorithm-note/:12:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"取一个数二进制最低位为1的数 x\u0026（~x+1） ","date":"2021-10-14","objectID":"/algorithm-note/:13:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Learning","note"],"content":"2^n-1 1«n-1 ","date":"2021-10-14","objectID":"/algorithm-note/:14:0","tags":["Algorithm"],"title":"算法笔记","uri":"/algorithm-note/"},{"categories":["Back","note"],"content":"Java后端面试题整理的笔记","date":"2021-06-08","objectID":"/java-audition-note/","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"什么是面向对象? 对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者(对象)、及各自需要做什么 比如:洗衣机洗衣服 ","date":"2021-06-08","objectID":"/java-audition-note/:1:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向过程 面向过程会将任务拆解成一系列的步骤(函数)，1、打开洗衣机—\u003e2、放衣服–\u003e3、放洗衣粉—\u003e4、清洗—–\u003e5、烘干 面向对象会拆出人和洗衣机两个对象: 人:打开洗衣机放衣服放洗衣粉洗衣机:清洗烘干 从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护 ","date":"2021-06-08","objectID":"/java-audition-note/:1:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"封装 封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项内部细节对外部调用透明，外部调用无需修改或者关心内部实现 两个经典的场景 1、javabean举例： javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改 private string name ; public void setName(string name){ this.name = \"tuling_\"+name; } 该name有自己的命名规则，明显不能由外部直接赋值 2、orm框架举例 操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可 ","date":"2021-06-08","objectID":"/java-audition-note/:1:4","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"继承 继承基类的方法，并做出自己的改变和/或扩展 子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的 ","date":"2021-06-08","objectID":"/java-audition-note/:1:5","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"多态 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。 继承，方法重写，父类引用指向子类对象 父类类型变量名=new子类对象; 变量名.方法名(); 无法调用子类特有的功能 ","date":"2021-06-08","objectID":"/java-audition-note/:1:6","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、JVM性能调优实战相关 ","date":"2021-06-08","objectID":"/java-audition-note/:2:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"3、JDK JRE JVM ","date":"2021-06-08","objectID":"/java-audition-note/:3:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JDK Java Develpment Kit java开发工具 ","date":"2021-06-08","objectID":"/java-audition-note/:3:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JRE Java Runtime Environment java运行时环境 ","date":"2021-06-08","objectID":"/java-audition-note/:3:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JVM: java Virtual Machine java虚拟机 ","date":"2021-06-08","objectID":"/java-audition-note/:3:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"4、==equals ==和equals比较==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址 equals: object中默认也是采用==比较，通常会重写 Object pub1ic boolean equals(Object obj) { return (this == obj); } String pub1ic boolean equals (Object anObject) { if(this ==anobject) { return true; } if (anObject instanceof String) i String anotherstring = (String)anobject; int n = value.length; if (n == anotherstring.value.length) { char v1[] = value; char v2[] = anotherstring. value;int i = o; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。 public class StringDemo { public static void main(string args[]) { String str1 = \"He11o\"; String str2 new string ( \"He11o\"); String str3 = str2; //引用传递 System.out.println(str1 == str2); //false System.out.println(str1 == str3); // false System.out.println(str2 == str3); // true System.out.println(str1.equals (str2));// true System.out.println(str1.equals (str3));//true System.out.println(str2.equals (str3)); // true } } ","date":"2021-06-08","objectID":"/java-audition-note/:4:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"5、final ","date":"2021-06-08","objectID":"/java-audition-note/:5:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、简述final作用 最终的 修饰类:表示类不可被继承 修饰方法:表示方法不可被子类覆盖，但是可以重载 修饰变量:表示变量一旦被赋值就不可以更改它的值。 (1)修饰成员变量 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。 (2）修饰局部变量 系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。 因此使用final修饰局部变量时，即可以在定义时指定默认值（后面的代码不能对变量再赋值)，也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次) pub1ic class Fina1var { final static int a = 0;//再声明的时候就需要赋值或者静态代码块赋值 /** static{ a =o; } */ final int b = 0;//再声明的时候就需要赋值或者代码块中赋值或者构造器赋值 /*{ b = 0; } */ public static void main(string[]args) { final int localA;//局部变量只声明没有初始化，不会报错,与fina1无关。 loca1A = 0;//在使用之前一定要赋值I //localA = 1;但是不允许第二次赋值 } } (3）修饰基本类型数据和引用类型数据 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改; 如果是引用类型的变量，则在对某初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。 pub1ic class Fina1ReferenceTest{ public static void main(){ final int[] iArr={1,2,3,4}; iArr[2]=-3;//合法 iArr=nu1;//非法，对iArr不能重新赋值 final Person p = new Person(25); p.setAge(24);//合法 p=null;//非法 } } 为什么局部内部类和匿名内部类只能访问局部final变量? 编译之后会生成两个class文件，Test.class Test1.class public class Test { public static void main(string[] args){} //局部fina1变量a,b public void test(final int b) { final int a = 10; //匿名内部类 new Thread(){ pub1ic void run() i System.out.print1n(a); System.out.print1n(b); }; }.start(); } } c1ass outc1ass { private int age = 12; public void outPrint(final int x) { c1ass Inclass i pub1ic void InPrint() { System. out.println(x); System.out.println(age); } } new Inc1ass(().InPrint(; } } ","date":"2021-06-08","objectID":"/java-audition-note/:5:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、为什么局部内部类和匿名内部类只能访问局部final变量? 首先需要知道的一点是:内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 这里就会产生问题:当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾:内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的\"copy\"。这样就好像延长了局部变量的生命周期 将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的,也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢? 就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。 ","date":"2021-06-08","objectID":"/java-audition-note/:5:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ","date":"2021-06-08","objectID":"/java-audition-note/:6:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ArrayList: 基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) ","date":"2021-06-08","objectID":"/java-audition-note/:6:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"LinkedList: 基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐—遍历 遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexof等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:6:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"6、Stringbuilfer String、StringBuffer、StringBuilder String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和stringBuilder都是在原对象上操作 StringBuffer是线程安全的，StringBuilder线程不安全的 StringBuffer方法都是synchronized修饰的 性能: StringBuilder \u003e StringBuffer \u003e String 场景:经常需要改变字符串内容时使用后面两个 优先使用StringBuilder，多线程使用共享变量时使用StringBuffer ","date":"2021-06-08","objectID":"/java-audition-note/:7:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"7、重载和重写的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:8:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 ","date":"2021-06-08","objectID":"/java-audition-note/:8:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重写 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类就不能重写该方法。 public int add(int a,String b) public string add(int a,String b)//编译报错,产生二义性，并不知道返回什么值 ","date":"2021-06-08","objectID":"/java-audition-note/:8:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"8、接口和抽象类的区别 抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。（java8之前，java9变了） 抽象类只能继承一个，接口可以实现多个。 接口的设计目的，是对类的行为进行约束（更准确的说是一种“有\"约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。 而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来(否则当调用到A-B时，无法执行)。 抽象类是对类本质的抽象，表达的是is a 的关系，比如: BMw is a car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是like a的关系。比如: Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 使用场景:当你关注一个事物的本质的时候，用抽象类;当你关注一个操作的时候，用接口。 抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。 ","date":"2021-06-08","objectID":"/java-audition-note/:9:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"9、List和Set的区别 List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用lterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下表的元素 Set:无序，不可重复，最多允许有一个Nul元素对象，取元素时只能用lterator接口取得所有元素，在逐一遍历各个元素 ","date":"2021-06-08","objectID":"/java-audition-note/:10:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"10、hashCode与equals ","date":"2021-06-08","objectID":"/java-audition-note/:11:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"hashCode介绍 hashCode()的作用是获取哈希码，也称为散列码;它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-value)，它的特点是:能根据\"键\"快速的检索出对应的“值\"。这其中就利用到了散列码!(可以快速找到所需要的对象) ","date":"2021-06-08","objectID":"/java-audition-note/:11:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"为什么要有hashCode 以\"Hashset如何检查重复\"为例子来说明为什么要有hashcode: 对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals ()方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。 如果两个对象相等，则hashcode—定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的·因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 因此,equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如 何都不会相等（即使这两个对象指向相同的数据） ","date":"2021-06-08","objectID":"/java-audition-note/:11:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ArrayList:基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过geti)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:12:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"12、HashMap和HashTable的区别?底层实现是什么? 1.区别: (1) HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全; (2)HashMap允许key和value为null，而HashTable不允许 2.底层实现:数组+链表实现 jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标， 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组， 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表 key为null，存在下标0的位置 数组扩容 ","date":"2021-06-08","objectID":"/java-audition-note/:13:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"13、ConcurrentHashMap原理,jdk7和jdk8版本的区别 jdk7: 数据结构:ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构 元素查询:二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部 锁: Segment分段锁Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度 为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment get方法无需加锁，volatile保证(避免脏数据) jdk8: 数据结构: synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性 查找，替换，赋值操作都使用CAS 锁:锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容 读操作无锁: Node的val和next使用volatile修饰，读写线程对该变量互相可见 数组用volatile修饰，保证扩容时被读线程感知 ","date":"2021-06-08","objectID":"/java-audition-note/:14:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"14、如何实现一个IOC容器 配置文件配置包扫描路径 递归包扫描获取.class文件 反射、确定需要交给IOC管理的类 对需要注入的类进行依赖注入 配置文件中指定需要扫描的包路径 定义一些注解，分别表示访问控制层、业务服务层、数据持久层、 依赖注入注解、获取配置文件注解 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储 遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个lOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入 ","date":"2021-06-08","objectID":"/java-audition-note/:15:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"15、什么是字节码?采用字节码的好处是什么? java中的编译器和解释器: Java中引入了虚拟机的概念，即在机器和编译程序之间加入了 -层抽象的虚拟的机器。这台虚拟的机器在任何平台 上都提供给编译程序一个的共同的接口。 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。 每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。 Java源代码—\u003e编译器—\u003ejvm可执行的Java字节码(即虚拟指令)—\u003ejvm—\u003ejvm中解释器—-\u003e机器可执行的二进制机器码—-\u003e程序运行。 采用字节码的好处: Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 ","date":"2021-06-08","objectID":"/java-audition-note/:16:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"34、谈谈你对AOP的理解 系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用 AOP:将程序中的交叉业务逻辑(比如安全，日志，事务等)，封装成一个切面，然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情 ","date":"2021-06-08","objectID":"/java-audition-note/:17:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"35、谈谈你对IOC的理解 ","date":"2021-06-08","objectID":"/java-audition-note/:18:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"容器概念、控制反转、依赖注入 ioc容器:实际上就是个map (key,value)，里面存的是各种对象（在xml里配置的bean节点、@repository.@service、@controller、@component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。 这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(autowired.resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入; id就是对象名）。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"控制反转: 没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转\"这个名称的由来。 全部对象的控制权全部上缴给\"第三方\"“OC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似\"粘合剂的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂”，对象与对象之间会彼此失去联系，这就是有人把lOC容器比喻成′粘合剂\"的由来。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"依赖注入: “获得依赖对象的过程被反转了\"。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"66、简述MylSAM和InnoDB的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:19:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"MyISAM: 不支持事务，现在支持了，但是每次查询都是原子的;支持表级锁，即每次操作是对整个表加锁;存储表的总行数; 一个MyISAM表有三个文件:索引文件、表结构文件、数据文件; 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯—性。 ","date":"2021-06-08","objectID":"/java-audition-note/:19:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"lnnoDB: 支持ACID的事务，支持事务的四种隔离级别;支持行级锁及外键约束:因此可以支持写并发;不存储总行数; 一个InnoDB引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能 为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为2G)，受操作系统文件大小的限制; ","date":"2021-06-08","objectID":"/java-audition-note/:19:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"88、Spring Cloud和Dubbo的区别 底层协议: springcloud基于http协议，dubbo基于Tcp协议，决定了dubbo的性能相对会比较好 注册中心: Spring Cloud 使用的eureka , dubbo推荐使用zookeeper 模型定义: dubbo将一个接口定义为一个服务，SpringCloud则是将一个应用定义为一个服务 SpringCloud是一个生态，而Dubbo是SpringCloud生态中关于服务调用一种解决方案(服务治理) ","date":"2021-06-08","objectID":"/java-audition-note/:20:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ACID靠什么保证的? A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql C一致性由其他三大特性保证、程序代码要保证业务上的一致性 I隔离性由MVCC来保证 D持久性由内存+redo log来保证，Mysq|修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redolog恢复 InnoDB redo log写盘，InnoDB事务进入prepare状态。 如果前面prepare成功，bin1og 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么、InnoDB事务则进入commit状态(在 redo log 里面写一个commit记录) redolog的刷盘会在系统空闲时进行 ","date":"2021-06-08","objectID":"/java-audition-note/:21:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"end ","date":"2021-06-08","objectID":"/java-audition-note/:22:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"记录Jvm结构的笔记","date":"2022-06-06","objectID":"/jvm-memory-structure-note/","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"对象实例数据和对象类型数据 对象实例数据（堆）:对象中各个实例字段的数据 对象类型数据（方法区）：对象的类型、父类、实现的接口、方法等 静态区（也在方法区中）用来存放静态变量，静态块 ","date":"2022-06-06","objectID":"/jvm-memory-structure-note/:1:0","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"HotSpot为什么要分为新生代和老年代？为什么要有Survivor区？ ","date":"2022-06-06","objectID":"/jvm-memory-structure-note/:2:0","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"HotSpot为什么要分为新生代和老年代？ 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。 ","date":"2022-06-06","objectID":"/jvm-memory-structure-note/:2:1","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"为什么要有Survivor区？ 如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的，解决办法： 增加老年代内存，那么老年代清理频次减少，但清理一次花费时间更长。 减少老年代内存，老年代一次FullGC时间更少，频率增加。 都不行，只有再加一层Survivor。将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。 ","date":"2022-06-06","objectID":"/jvm-memory-structure-note/:2:2","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"为什么要加两个Survivor？ 先来看一下一个的 清理内存，很容易产生内存碎片，为了不产生内存碎片，我才用复制算法，将Eden区和Survivor区存活的对象整齐的放到一个空的内存。因为生命周期一般都比较短，所以在存活对象不多的情况下，复制算法效率还是比较高的。 复制算法 这样就需要一个空内存，而我如果有三个区，这样就总可以保持一个是空的，这样我清理垃圾的时候，就可以将存活对象全部都整齐的放到一个空的内存中，不产生内存碎片了。 ","date":"2022-06-06","objectID":"/jvm-memory-structure-note/:2:3","tags":["Python","Error"],"title":"Jvm结构笔记","uri":"/jvm-memory-structure-note/"},{"categories":["Back","note"],"content":"记录java中的TLAB的笔记","date":"2022-06-06","objectID":"/jvm-tlab-note/","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"前言 好久，好久….没有更博客了。这一次利用闲暇时间，来扯一下关于JVM中的TLAB。 什么是TLAB？它是干什么的？咋们先抛开这个问题，一切的开始得从new对象到指针碰撞开始讲起。 ","date":"2022-06-06","objectID":"/jvm-tlab-note/:1:0","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"new对象与指针碰撞 ","date":"2022-06-06","objectID":"/jvm-tlab-note/:2:0","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"new对象怎么就出问题了呢？ java中我们要创建一个对象,用关键字new就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如： public void dome(){ User user=new user(); user.sayhi(); } 这种对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。 假设JVM所有的对象都放在堆内存中(为什么用假设，因为JVM并不是这样)一旦方法结束，没有了指向该对象的引用，该对象就需要被GC回收，如果存在很多这样的情况，对GC来说压力山大呀。 ","date":"2022-06-06","objectID":"/jvm-tlab-note/:2:1","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"那么什么又是指针碰撞呢？ 假设JVM虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。 图1.png\r好，问题来了。如果我们用多线程执行刚才的dome方法，一个线程正在给A对象分配内存，指针还没有来的及修改，同时为B对象分配内存的线程，仍引用这之前的指针指向。这样就出现毛病了。 (要注意的是，上面两种情况解决方案不止一个，我今天主要是讲TLAB，其他方案自行查询) ","date":"2022-06-06","objectID":"/jvm-tlab-note/:2:2","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"TLAB的出现 我们现在已经搞清楚，我们出现了哪些问题。我在为大家介绍一下今天的主角。 TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。 如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。 TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。 TLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。 TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点 当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。 ","date":"2022-06-06","objectID":"/jvm-tlab-note/:3:0","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Back","note"],"content":"TLAB的缺点 事务总不是完美的，TLAB也又自己的缺点。因为TLAB通常很小，所以放不下大对象。 1，TLAB空间大小是固定的，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象) 2，TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象) 所以JVM开发人员做了以下处理，设置了最大浪费空间。 当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那你这个对象太大了，去Eden区直接创建吧！ 当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间。 当然，又回造成新的病垢。 3，Eden空间够的时候，你再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC， 4，TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。 ","date":"2022-06-06","objectID":"/jvm-tlab-note/:4:0","tags":["Java","Jvm","TLAB"],"title":"浅析java中的TLAB","uri":"/jvm-tlab-note/"},{"categories":["Learning","note"],"content":"记录从头到尾彻底理解KMP的笔记","date":"2022-06-06","objectID":"/algorithm-kmp-note/","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"1. 引言 本KMP原文最初写于2年多前的2011年12月，因当时初次接触KMP，思路混乱导致写也写得混乱。所以一直想找机会重新写下KMP，但苦于一直以来对KMP的理解始终不够，故才迟迟没有修改本文。 然近期因开了个算法班，班上专门讲解数据结构、面试、算法，才再次仔细回顾了这个KMP，在综合了一些网友的理解、以及算法班的两位讲师朋友曹博、邹博的理解之后，写了9张PPT，发在微博上。随后，一不做二不休，索性将PPT上的内容整理到了本文之中（后来文章越写越完整，所含内容早已不再是九张PPT 那样简单了）。 KMP本身不复杂，但网上绝大部分的文章（包括本文的2011年版本）把它讲混乱了。下面，咱们从暴力匹配算法讲起，随后阐述KMP的流程 步骤、next 数组的简单求解 递推原理 代码求解，接着基于next 数组匹配，谈到有限状态自动机，next 数组的优化，KMP的时间复杂度分析，最后简要介绍两个KMP的扩展算法。 全文力图给你一个最为完整最为清晰的KMP，希望更多的人不再被KMP折磨或纠缠，不再被一些混乱的文章所混乱。有何疑问，欢迎随时留言评论，thanks。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:1:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"2. 暴力匹配算法 假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？ 如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有： 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符； 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下： int ViolentMatch(char* s, char* p) { int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i \u003c sLen \u0026\u0026 j \u003c pLen) { if (s[i] == p[j]) { //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ i++; j++; } else { //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0 i = i - j + 1; j = 0; } } //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1; } 举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示： 1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0） 2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） 3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1） 4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去 5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0） 6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ 答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:2:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"3. KMP算法 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:3:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"3.1 定义 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k \u003e 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 转换成代码表示，则是： int KmpSearch(char* s, char* p) { int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i \u003c sLen \u0026\u0026 j \u003c pLen) { //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) { i++; j++; } else { //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; } } if (j == pLen) return i - j; else return -1; } 继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。 向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:3:1","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"3.2 步骤 ①寻找前缀后缀最长公共元素长度 对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示： 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。 ②求next数组 next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示： 比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。 ③根据next数组进行匹配 匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示： 综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。 接下来，分别具体解释上述3个步骤。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:3:2","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"3.3 解释 3.3.1 寻找最长前缀后缀 如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）： 3.3.2 基于《最大长度表》匹配 因为模式串中首尾可能会有重复的字符，故可得出下述结论： 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： 1. 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功： 2. 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。 3. 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。 4. A与空格失配，向右移动1 位。 5. 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。 6. 经历第5步后，发现匹配成功，过程结束。 通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。 3.3.3 根据《最大长度表》求next 数组 由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为： 而且，根据这个表可以得出下述结论 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： 把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下： 根据最大长度表求出了next 数组后，从而有 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值 而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为： 根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值 而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值 其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。 所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。 3.3.4 通过代码递推计算next 数组 接下来，咱们来写代码求下next 数组。 基于之前的理解，可知计算next 数组的方法可以采用递推： 1 . 如果 对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k 。 此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。 举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。 向右移动4位后，模式串中的字符C继续跟文本串匹配。 2. 下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？ 对于P的前j+1个序列字符： 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀\"p0 p1, …, pk-1 pk\"跟后缀“pj-k pj-k+1, …, pj-1 pj\"相等，那么是否可能存在另一个值t+1 \u003c k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。 一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。 如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。 但如果pk != pj 呢？说明“p0 pk-1 pk” ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。 结合上图来讲，若能在前缀****“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk'-1 pk' = pj-k' pj-1 pj，则最大相同的前缀后缀长度为k' + 1，从而next [j + 1] = k’ + 1 = next [k' ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。 那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要*寻找长度更短的相同前缀后缀*，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示： 关于k = next [k]这个问题，再补充下本文两个读者给的意见/补充： 读者wudehua55555于本文评论下留言，以辅助大家从另一个角度理解：“ 一直以为博主在用递归求next数组时没讲清楚，为何要用k = next[k],仔细看了这个红黄蓝分区图才突然恍然大悟，就是找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。以上是一些个人看法，非常感谢博主提供的解析，非计算机的学生也能看懂，虽然从昨晚9点看到了现在。高兴。” 另一个读者OnlyotDN特意在上面图的基础上又做了一些注解，供大家参考： 所以，因最终在前缀ABC中没有找到D，故E的next 值为0： 模式串的后缀：AB DE 模式串的前缀：AB C 前缀右移两位： ABC 读到此，有的","date":"2022-06-06","objectID":"/algorithm-kmp-note/:3:3","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"3.4 KMP的时间复杂度分析 相信大部分读者读完上文之后，已经发觉其实理解KMP非常容易，无非是循序渐进把握好下面几点： 如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, …, pj-1 = p0 p1, …, pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1…pk-1对应着文本串si-k si-k+1…si-1，而后让pk跟si继续匹配。 之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。 因为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。 而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。 如之前的图所示： 接下来，咱们来分析下KMP的时间复杂度。分析之前，先来回顾下KMP匹配算法的流程： **“**KMP的算法流程： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。” 我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。 所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:3:4","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"4. 扩展1：BM算法 KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。 BM算法定义了两个规则： 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果\"坏字符\"不包含在模式串之中，则最右出现位置为-1。 好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。 1. 首先，“文本串\"与\"模式串\"头部对齐，从尾部开始比较。“S\"与\"E\"不匹配。这时，“S\"就被称为\"坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且\"S\"不包含在模式串\"EXAMPLE\"之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到\"S\"的后一位。 2. 依然从尾部开始比较，发现\"P\"与\"E\"不匹配，所以\"P\"是\"坏字符”。但是，“P\"包含在模式串\"EXAMPLE\"之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个\"P\"对齐。 3. 依次比较，得到 “MPLE”匹配，称为\"好后缀”（good suffix），即所有尾部匹配的字符串。注意，“MPLE”、“PLE”、“LE”、“E\"都是好后缀。 4. 发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？ 5. 更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。 可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。 6. 继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。 由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:4:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"5. 扩展2：Sunday算法 上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串\"substring searching algorithm\"中查找模式串\"search”。 1. 刚开始时，把模式串与文本串左边对齐： substring searching algorithm search ^ 2. 结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： substring searching algorithm search ^ 3. 结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r'，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： substring searching algorithm search ^ 4. 匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:5:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"6. 参考文献 《编程之法：面试和算法心得》 《算法导论》的第十二章：字符串匹配； 本文中模式串“ABCDABD”的部分图来自于此文：字符串匹配的KMP算法 - 阮一峰的网络日志； 本文3.3.7节中有限状态自动机的图由微博网友@龚陆安 绘制：http://d.pr/i/NEiz； 北京7月暑假班邹博半小时KMP视频：http://www.julyedu.com/video/play/id/5； 北京7月暑假班邹博第二次课的PPT：北京7月暑假班第2次课：回文子串-KMP等若干问题的讨论_邹博.ppt_免费高速下载|百度网盘-分享无限制； 理解KMP 的9张PPT：Sina Visitor System； 详解KMP算法（多图）：（原创）详解KMP算法 - 孤~影 - 博客园； 本文第4部分的BM算法参考自此文：字符串匹配的Boyer-Moore算法 - 阮一峰的网络日志； http://youlvconglin.blog.163.com/blog/static/5232042010530101020857； 《数据结构 第二版》，严蔚敏 \u0026 吴伟民编著； 六之续、由KMP算法谈到BM算法_结构之法 算法之道-CSDN博客； 经典算法研究系列：六、教你初步了解KMP算法、updated_结构之法 算法之道-CSDN博客； Sunday算法的原理与实现：Sunday算法原理与实现（模式匹配）-red_eyed_hare-ChinaUnix博客； 模式匹配之Sunday算法：【模式匹配】之 —— Sunday算法_超然于物外 烟火于一瞬-CSDN博客_sunday算法； 一篇KMP的英文介绍：Knuth-Morris-Pratt algorithm； 我2014年9月3日在西安电子科大的面试\u0026算法讲座视频（第36分钟~第94分钟讲KMP）：http://www.julyedu.com/video/play/21； 一幅图理解KMP next数组的求法：http://v.atob.site/kmp-next.html ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:6:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Learning","note"],"content":"7. 后记 对之前混乱的文章给广大读者带来的困扰表示致歉，对重新写就后的本文即将给读者带来的清晰表示欣慰。希望大部分的初学者，甚至少部分的非计算机专业读者也能看懂此文。有任何问题，欢迎随时批评指正 ","date":"2022-06-06","objectID":"/algorithm-kmp-note/:7:0","tags":["Algorithm","KMP"],"title":"从头到尾彻底理解KMP","uri":"/algorithm-kmp-note/"},{"categories":["Net"],"content":"记录如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Net"],"content":"〇引言 我在购买Minecraft正版之前曾遇到一个问题：无法注册mojang帐号。其实许多国外网站都有这个问题，但Minecraft官网提示的不明显。这个问题的根本原因就是无法加载reCAPTCHA。 reCAPTCHA是谷歌的验证码服务。我们知道，中国大陆是无法访问谷歌的，谷歌的reCAPTCHA自然也无法访问。而国外很多网站一般都是用谷歌的reCAPTCHA验证码服务的。那么要想访问reCAPTCHA服务来注册mojang帐号（或者在其它网站正常输入验证码），那该怎么办呢？ ","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/:1:0","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Net"],"content":"①获取Gooreplacer 本文建议使用Firefox浏览器，谷歌Chrome浏览器安装Gooreplacer需要*****（自己解决问题）** 1.1 谷歌Chrome 1.1.1 官方安装方法 在https://chrome.google.com/webstore/detail/chromefor/jnlkjeecojckkigmchmfoigphmgkgbip?hl=zh-CN下载扩展。需要**（自己解决无法访问问题）** 1.2.2 开发者模式安装方法 在http://hk.chromefor.com/down.php?key=VNUIZDgb2ih1Fpzb5cHp获取crx文件，然后使用压缩软件打开并解压。 在地址栏输入chrome://extensions/并回车，打开右上角的开发者模式，把解压之后的一个文件夹拖入浏览器。 1.2 火狐Firefox 在https://addons.mozilla.org/zh-CN/firefox/addon/gooreplacer/下载扩展。 1.3 安装成功标志 如果你在右上角看见了专栏开始时的刷子图标，即为安装成功。 ","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/:2:0","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Net"],"content":"②设置 点击刷子图标，会打开一个新标签页，如下。 点击新增（Add）按钮，输入如下的信息，点击提交。 匹配模式：www.google.com/recaptcha 目标地址：recaptcha.net/recaptcha 添加完毕的界面： san\rs\r","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/:3:0","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Net"],"content":"③测试 打开minecraft.net，登录mojang帐号，右下角有reCAPTCHA图标，点击登录的时候会发现有验证码弹出，即为设置成功，以后reCAPTCHA都可以使用了。 ","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/:4:0","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Net"],"content":"④原理与拓展 4.1 基本原理 这个解决方案的基本原理，就是把原本国内不能访问的www.google.com/recaptcha替换为国内可以访问的recaptcha.net/recaptcha。 4.2 拓展实验 Gooreplacer还可以进行下列实验，我们用百度做小白鼠。 1.将百度替换为哔哩哔哩 这样当你输入www.baidu.com时，就会自动跳到www.bilibili.com 2.屏蔽网站，例如百度 这样当你输入百度的网址时会出现“被扩展程序屏蔽”的提示。 这个功能可以配合F12来屏蔽某些广告。 ","date":"2022-06-06","objectID":"/gooreplacer-recaptcha-note/:5:0","tags":["Gooreplacer","ReCAPTCHA","Error"],"title":"如何使用Gooreplacer解决reCAPTCHA不显示问题？ ","uri":"/gooreplacer-recaptcha-note/"},{"categories":["Hardware"],"content":"记录海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。的解决办法","date":"2022-06-06","objectID":"/apple-id-not-active-error/","tags":["Apple","AppleID","Active"],"title":"海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。","uri":"/apple-id-not-active-error/"},{"categories":["Hardware"],"content":"背景 近段时间，很多人问我说：「我的美国Apple ID出现了“不在激活状态”，该怎么办？」 ","date":"2022-06-06","objectID":"/apple-id-not-active-error/:1:0","tags":["Apple","AppleID","Active"],"title":"海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。","uri":"/apple-id-not-active-error/"},{"categories":["Hardware"],"content":"原因 非大陆Apple ID出现“个人不在激活状态”是很容易发生的事情。因为苹果公司在我国国内需要发展，就必须遵守我国的条款条例！对于很多人使用海外ID来下载海外App， 从我国的互联网相关规定来讲：国家肯定是不允许的。所以苹果公司也对于我国制定了：大陆用户不允许使用海外Apple ID。 既然不允许，那么你去使用海外Apple ID就很容易触发到苹果自检系统的机制。一但触碰到苹果自检系统机制，就很有可能“停用”或者“个人不在激活状态”了。当然为了避免这个情况，尽量保存好自己的密保和完善账户资料。比如：绑定安全邮箱、绑定手机号、开启双重认证。让自己的账户变得安全，这样可以减少苹果自检系统的排查！当然完善了这些也有可能排查的到，毕竟你是在大陆使用海外ID，这一点都无法避免。甚至就在6月份的时候，我2个用了近4年的海外老账号也被封了，大势已去，我也无法阻挡！ ","date":"2022-06-06","objectID":"/apple-id-not-active-error/:2:0","tags":["Apple","AppleID","Active"],"title":"海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。","uri":"/apple-id-not-active-error/"},{"categories":["Hardware"],"content":"解决经历 在去年的时候，我也有一个ID，里面购买了很多付费APP，最终也被自检系统给排查到了，然后就变为“未激活状态”。当然去年的时候，我是直接联系苹果客服400-666-8800云上贵州，直接提供资料就可以解决！ 但是今年年初的时候我连续联系苹果客服5-6次，他们给我的答复都是统一：“账号查询不到、无法激活、我们没这个权限、不好意思！”通过几次联系之后，从一个高级顾问口中得知：可以联系美国客服（苹果总部），权限绝对够大！但是拨打了电话001 800 275 2273之后，听不懂！呜呜呜~~~ ","date":"2022-06-06","objectID":"/apple-id-not-active-error/:3:0","tags":["Apple","AppleID","Active"],"title":"海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。","uri":"/apple-id-not-active-error/"},{"categories":["Hardware"],"content":"亲测、成功解决方法 准备工具： 1、PC电脑一台，MAC也行！ 2、谷歌浏览器。（无须翻强，谷歌浏览器带有自动翻译功能，所以这里推荐谷歌） 3、出现问题的海外Apple ID。（必须记得出生年月日和密保问答资料） 开始解决： 第一步：在谷歌浏览器中打开苹果官网：Apple，进入官网，把浏览页面滑动到最下面，找到「管理你的Apple ID」点进去。（大家可以看到右下角的国家是“美国”，只有这样进入，才能让联系美国客服，不这样进入，联系的基本是国内客服了。） 第二步：在Apple ID管理中心，选择“忘记了Apple ID或者密码”！（下图是谷歌自动翻译后的截图，你们的界面可能是英文。） 第三步：选择「FAQ」，这个就是中文的“常见问题”！ 第四步：到了常见问题的页面，在最下面点击「请访问Apple支持」 第五步：到了Apple支持的页面后，继续滑动到最下面，然后点击“得到支持”!(有可能我和你的页面显示的不一样，你可能是英文，所以你可以参考我图片点击也一样的效果） 第六步：进入了“得到支持”的页面后，点击「禁用的Apple ID」。 第七步：选择“主题未列出”，然后再框框中填写你出现的问题。框框之中必须得使用英文填写，美国客服看不懂！（不会英语的就用“在线汉译英”） （图1） （图2） 第八步：点击聊天室！（有时候可能没有聊天室的时候，那么就是美国苹果客服下班了！美国客服在线时间是：9：00-21:00，以美国加利福利亚现在的时间为准！） 第九步：把自己出现“个人不在激活状态”通过汉译英后表述给美国苹果客服看！他们问你什么，你就如实回答即可！他们会一步一步的帮你解决！（下图是我和客服的聊天记录，你可以作为参考） 以上都是我和客服聊天的记录，其中我并不懂英语！但是他们每问我一个问题。我会立刻使用汉译英来进行翻译，并做出相应的回答！然后客服帮我解封了，之后挂断客服了后，我立刻登录了ID到苹果管理中心，发现能正常的登录，但是在手机上面登录上后，发现无法下载APP。提示“在App Store与iTunes Store里禁用”。 之后我又再次以上面的方式联系上了美国客服，他们又帮我解决了这个问题！ 感觉整个过程有点复杂，其实自己操作一遍之后，就发现非常的简单了！ ","date":"2022-06-06","objectID":"/apple-id-not-active-error/:4:0","tags":["Apple","AppleID","Active"],"title":"海外Apple ID出现“这个人不在激活状态”解决方法！2022年3月亲测有效。","uri":"/apple-id-not-active-error/"},{"categories":["Back","note"],"content":"记录用Adb揪出安卓APP弹窗广告的原形的笔记","date":"2022-06-06","objectID":"/android-adb-adv-locate-note/","tags":["Android","Adb"],"title":"用Adb揪出安卓APP弹窗广告的原形","uri":"/android-adb-adv-locate-note/"},{"categories":["Back","note"],"content":"背景 　相信不少安卓用户中过影子弹窗广告的困扰，这种推广APP本体在后台运行，而且可以在其他APP上弹出覆盖广告，一不小心就会误操作，点击广告或者下载APP，着实令人恶心。 　以前的广告软件只在通知栏会推送广告，4.4以上版本或者一些rom可以轻易长按管理并找到元凶。 　而此升级版却是直接覆盖其他应用程序在屏幕中心和底部直接弹出广告。浏览器、QQ、微信，无一幸免，切换到桌面和最近的应用程序居然可以自动隐藏，大写的服。 (中招截图) 　无奈之下，笔者把**管家，36*，LE*，金* 全试了一次，竟然没有一个能找到罪魁祸首，简直不能忍！ ","date":"2022-06-06","objectID":"/android-adb-adv-locate-note/:1:0","tags":["Android","Adb"],"title":"用Adb揪出安卓APP弹窗广告的原形","uri":"/android-adb-adv-locate-note/"},{"categories":["Back","note"],"content":"准备工作 　1.要进入开发者模式打开USB调试，安装驱动，这部分属于比较初级，就略过了。 　2.下载adb工具包。 　4.找一根稳定的数据线，将手机连接电脑，在手机的弹出窗口中允许USB调试。 ","date":"2022-06-06","objectID":"/android-adb-adv-locate-note/:2:0","tags":["Android","Adb"],"title":"用Adb揪出安卓APP弹窗广告的原形","uri":"/android-adb-adv-locate-note/"},{"categories":["Back","note"],"content":"正式开始 　1.然后用管理员进CMD，输入 cd /d \"Z:\\Desktop\\adb\" 　将双引号内的路径换成你电脑上****ADB工具所在路径 　2.查看设备，输入 adb devices 　如果你的驱动安装正确，应该可以看到有设备，如果没有，返回准备工作，检查驱动是否正确安装。 　3.尝试运行手机中每一个APP**，直到弹出广告。**笔者画了3分钟时间，在运行到一个清理应用的时候，弹出了广告，按home键返回桌面广告滞留了一瞬间，说明有可能不是APP内的广告。 　4.电脑上迅速清理日志，输入 adb logcat -c 　清理一次设备日志记录，这时候开始不要操作手机。 　5.然后点击一下广告，广告肯定会打开浏览器或者什么别的操作。 　6.电脑上输入 adb logcat -d \u003e c:/b.log 　在C盘下会创建一个b.log，储存了刚才的设备操作。 　7.用notepad++或者其他文本编辑器打开b.log，搜索**”Touch event’s”**，可以忽略大小写来查找。 　如图,不出意外应可以找到2个事件，一次是按下，一次是弹起，我们接着往下分析。 　如图可以看到，在点击事件下方，一个ID为10640的进程拉起了浏览器。 　我们把这个ID记下来 　8.回到adb，输入 adb shell 　进入shell界面，再输入 ps | grep \"10640\" 　将10640换成你找到的ID 　返回结果如下 这个com.zdworks.android.zdcalendar就是罪魁祸首，应用名称我就不说了，还是个比较出名的APP，各大防护软件没反应也许和这个有关？ 　后面的事情就简单了，可以直接在adb中输入，卸载之。 adb uninstall com.zdworks.android.zdcalendar 　9.返回手机，关闭USB调试。 　教程至此，我们已经成功揪出这个家伙，教程分2段写的，所以命令的时间会有差异。 ","date":"2022-06-06","objectID":"/android-adb-adv-locate-note/:3:0","tags":["Android","Adb"],"title":"用Adb揪出安卓APP弹窗广告的原形","uri":"/android-adb-adv-locate-note/"},{"categories":["Back","note"],"content":"再说两句 笔者在此给广大安卓用户提个醒，国内应用市场危机四伏，这个软件还是从三星官方应用商店下载，所以不了解的的软件千万不要安装，拒绝当小白鼠，从我做起。 PS：笔者教程抛砖引玉，有更好的方法欢迎交流共勉。 ","date":"2022-06-06","objectID":"/android-adb-adv-locate-note/:4:0","tags":["Android","Adb"],"title":"用Adb揪出安卓APP弹窗广告的原形","uri":"/android-adb-adv-locate-note/"},{"categories":["Back"],"content":"记录SpringMVC 请求无法到达Controller，出现404的解决办法","date":"2022-06-06","objectID":"/spring-mvc-view-404-error/","tags":["Java","J2EE","Spring","SpringMVC","Controller","404","Error"],"title":"SpringMVC 请求无法到达Controller，出现404","uri":"/spring-mvc-view-404-error/"},{"categories":["Back"],"content":"背景 今天在配置SpringMVC时，访问项目一直出现404，无法访问。 ","date":"2022-06-06","objectID":"/spring-mvc-view-404-error/:1:0","tags":["Java","J2EE","Spring","SpringMVC","Controller","404","Error"],"title":"SpringMVC 请求无法到达Controller，出现404","uri":"/spring-mvc-view-404-error/"},{"categories":["Back"],"content":"报错 The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. 调试了一下，发现没有到达controller层里面。 运行后没有到达controller层的解决方法： 1.检查web.xml文件中的SpringMVC的配置是否正确。 \u003c!-- Spring MVC servlet --\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003c!--\u003cinit-param\u003e表示启动时初始化的配置文件--\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spring-mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003casync-supported\u003etrue\u003c/async-supported\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003c!--\u003cservlet-mapping\u003e中的\u003c/servlet-name\u003e必须与\u003cservlet\u003e里面的\u003cservlet-name\u003e保持一致--\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003c!-- 一般定义为 / ，表示所有请求都通过DispatcherServlet来处理--\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 2.检查spring-mvc.xml，是否添加了注解驱动 \u003c!--注解驱动--\u003e \u003cmvc:annotation-driven/\u003e ","date":"2022-06-06","objectID":"/spring-mvc-view-404-error/:2:0","tags":["Java","J2EE","Spring","SpringMVC","Controller","404","Error"],"title":"SpringMVC 请求无法到达Controller，出现404","uri":"/spring-mvc-view-404-error/"},{"categories":["Back","note"],"content":"记录There is no getter for property named解决方案","date":"2022-06-06","objectID":"/mybatis-no-getter-property-named-error/","tags":["ORM","Mybatis","Error"],"title":"There is no getter for property named解决方案","uri":"/mybatis-no-getter-property-named-error/"},{"categories":["Back","note"],"content":"问题 这个问题也是我昨天遇到的。 看问题描述我还以为是我VO对象（实体类）里面的没有对应的getter方法。一直检查将getter方法。检查半天也没找到原因。 后面去网上找，也没找到好的解决方案（我有看到相关的解决方案，然而觉得那些解决方案不够优雅。就没有去尝试） 问题的原因是什么？确实是实体类没有对应的get方法 ","date":"2022-06-06","objectID":"/mybatis-no-getter-property-named-error/:1:0","tags":["ORM","Mybatis","Error"],"title":"There is no getter for property named解决方案","uri":"/mybatis-no-getter-property-named-error/"},{"categories":["Back","note"],"content":"解决 上面这个是我修复了问题的示范。 我开始是 test = “city ==‘dl’” 因为我数据库表的字段叫city，但是我实体类里面的属性名字是cityEn。 如果我写city，属性里面确实没 getCity()方法 然后网上的方案很多是让我把实例类里面的属性名字改成city，和数据库一样。这样确实应该能够解决。但是我这个bean文件是用来接收前端参数的。如果我改了，前端接口也要改。 然后我试了下，将\u003cif test =\u003e 里面的city改成cityEn问题解决了 ","date":"2022-06-06","objectID":"/mybatis-no-getter-property-named-error/:2:0","tags":["ORM","Mybatis","Error"],"title":"There is no getter for property named解决方案","uri":"/mybatis-no-getter-property-named-error/"},{"categories":["Back","note"],"content":"总结 mybatis动态查询里面， if test = 里面的那个字段应该和对应实体类的字段名字相同。而不是数据库的字段（就是对应数据库的字段）。 因为我们一般数据库字段和实体类的字段相同。导致我误以为那个字段应该是数据库的字段。让我出了问题。 ","date":"2022-06-06","objectID":"/mybatis-no-getter-property-named-error/:3:0","tags":["ORM","Mybatis","Error"],"title":"There is no getter for property named解决方案","uri":"/mybatis-no-getter-property-named-error/"},{"categories":["Back"],"content":"记录Mybatis/Mybatis Plus报错：Invalid bound statement (not found) 解决方法汇总","date":"2022-06-06","objectID":"/mybatis-invalid-bound-error/","tags":["ORM","Mybatis","MybatisPlus","Error"],"title":"Mybatis/Mybatis Plus报错：Invalid bound statement (not found) 解决方法汇总","uri":"/mybatis-invalid-bound-error/"},{"categories":["Back"],"content":"一、问题描述 mybatis/mybatis plus报：Invalid bound statement (not found) 错误，基本上都是mapper文件引起的，我将它总结三类： mapper.xml文件不存在 mapper.xml文件里内容有误 mapper.xml文件路径配置有误 ","date":"2022-06-06","objectID":"/mybatis-invalid-bound-error/:1:0","tags":["ORM","Mybatis","MybatisPlus","Error"],"title":"Mybatis/Mybatis Plus报错：Invalid bound statement (not found) 解决方法汇总","uri":"/mybatis-invalid-bound-error/"},{"categories":["Back"],"content":"二、解决方法 以下是自己遇到的和参考了网上的一些解决方法，可以对着过一遍： 1.检查xml的namespace是否和xml文件的package名称一一对应 2.检查xml中是否使用了type别名，如果用了别名，检查下别名包名是否配置正确，如果不确定，可以将实体类全包名加上去，还有就是看下实体类里面是否使用了typeHandler类型处理器，如果使用了，记得将完整包名加上去。 # MyBatis配置mybatis:# 搜索指定包别名typeAliasesPackage:com.xxx.**.domain \u003cresultMap id=\"xxxxResultMap\" type=\"xxx.xxx.SiteEntity\"\u003e \u003cresult column=\"xxx\" property=\"xx\" javaType=\"java.util.List\" typeHandler=\"xxx.mybatis.plus.core.type.JsonLongListTypeHandler\"/\u003e \u003c/resultMap\u003e 3.Mapper.java的方法在Mapper.xml中没有，然后执行Mapper的方法会报错 4.xxxMapper.java的方法返回值是List,而select元素没有正确配置ResultMap,或者只配置ResultType 5.Mapper.xml不存在，一般mapper.xml会放在源码目录下，或resources目录下，检查mapper.xml打包后，在target/classes目录下是否存在，使用idea打包时，会过滤一些文件，导致没有打xml文件打包到target/classes目录下，在pom.xml文件里添加如下配置： \u003cbuild\u003e \u003c!-- 项目打包时会将java目录中的*.xml文件也进行打包 --\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 6.注意mybatis/mybatis plus配置与@MapperScan 注解 @MapperScan 注解和 mybatis.mapper-locations 配置两者缺一不可 @MapperScan(basePackages=“xxx.xxx.xxx”) 这个注解是用户扫描 mapper 接口的，也就是dao类； mybatis.mapper-locations 配置是用于扫描 mapper.xml 的，两者用途不同，故缺一不可。 mybatis-plus:mapper-locations:classpath*:mapper/*.xml //classpath后添加你xml文件的目录 # 方法一：只有一个路径mybatis:mapper-locations:classpath:mapper/*.xml# 方法二：有多个路径mybatis:mapper-locations:classpath:mapper/*.xml,classpath:mapper/user*.xml# 方法三：通配符 ** 表示任意级的目录mybatis:mapper-locations:classpath:**/*.xml 7.还有个问题就是，如果是多模块的情况下，我这里出现了如下情况，比如A模块是启动模块，B模块是业务模块，A模板引入了B模块，两个jar包中的mapper.xml都放在resources/mapper/目录下，打包启动之后，调用B模块mapper.xml中的方法也会报Invalid bound statement错误，最后发现是两个模块mapper重名引起的，导致B模块中的mapper.xml加载不出来，虽然存在，但就是加载不出来，通过DEBUG的方法发现的，然后将B模块resources/mapper/改成resources/xxx-mapper/然后就可以了。 8.后面发现还有种情况也会报错，在IDEA下，resource下新建目录层级有问题 这是正确的目录层级： 这个是错误的目录层级： 在IDEA下两者显示的是一模一样，不在文件下查看，根本发现不了。。 ","date":"2022-06-06","objectID":"/mybatis-invalid-bound-error/:2:0","tags":["ORM","Mybatis","MybatisPlus","Error"],"title":"Mybatis/Mybatis Plus报错：Invalid bound statement (not found) 解决方法汇总","uri":"/mybatis-invalid-bound-error/"},{"categories":["Back"],"content":"三、提高扩展 如果上面你都检查过了，还没有解决，直接看源码吧，首先断点打在调用mapper方法的地方 List\u003cSiteEntity\u003e siteList= siteMapper.selectSiteList(); 往下走，进入MybatisMapperMethod.java类 public SqlCommand(Configuration configuration, Class\u003c?\u003e mapperInterface, Method method) { //methodName就是调用的方法名 getCapitalTypeListAll final String methodName = method.getName(); //declaringClass就是 Mapper接口类 final Class\u003c?\u003e declaringClass = method.getDeclaringClass(); //问题出在这里 返回为空：原因是没有找到该接口类 MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration); if (ms == null) { if (method.getAnnotation(Flush.class) != null) { name = null; type = SqlCommandType.FLUSH; } else { throw new BindingException(\"Invalid bound statement (not found): \" + mapperInterface.getName() + \".\" + methodName); } } else { name = ms.getId(); type = ms.getSqlCommandType(); if (type == SqlCommandType.UNKNOWN) { throw new BindingException(\"Unknown execution method for: \" + name); } } } private MappedStatement resolveMappedStatement(Class\u003c?\u003e mapperInterface, String methodName, Class\u003c?\u003e declaringClass, Configuration configuration) { //XXMapper.xxMethod String statementId = mapperInterface.getName() + \".\" + methodName; //configuration有一个大集合，缓存了所有的Mapper及所有的方法 if (configuration.hasStatement(statementId)) { return configuration.getMappedStatement(statementId); } else if (mapperInterface.equals(declaringClass)) { return null; } for (Class\u003c?\u003e superInterface : mapperInterface.getInterfaces()) { if (declaringClass.isAssignableFrom(superInterface)) { MappedStatement ms = resolveMappedStatement(superInterface, methodName, declaringClass, configuration); if (ms != null) { return ms; } } } return null; } } 报错的位置一般出在： if (configuration.hasStatement(statementId)) { return configuration.getMappedStatement(statementId); } else if (mapperInterface.equals(declaringClass)) { return null; } ","date":"2022-06-06","objectID":"/mybatis-invalid-bound-error/:3:0","tags":["ORM","Mybatis","MybatisPlus","Error"],"title":"Mybatis/Mybatis Plus报错：Invalid bound statement (not found) 解决方法汇总","uri":"/mybatis-invalid-bound-error/"},{"categories":["Back"],"content":"记录解决 Maven ‘parent.relativePath‘ of POM报错","date":"2022-06-06","objectID":"/maven-parent-relative-path-error/","tags":["Mven","Xml","Error"],"title":"Maven ‘parent.relativePath‘ of POM报错","uri":"/maven-parent-relative-path-error/"},{"categories":["Back"],"content":"异常信息 parent.relativePath’ of POM 包名:xxx (E:\\app\\IdeaProjects\\xxx的上一级\\xxx\\pom.xml) points at 包名:xxx的上一级 instead of org.springframework.boot:spring-boot-starter-parent, please verify your project structure @ line 5, column 13It is highly recommended to fix these problems because they threaten the stability of your build. For this reason, future Maven versions might no longer support building such malformed projects. ","date":"2022-06-06","objectID":"/maven-parent-relative-path-error/:1:0","tags":["Mven","Xml","Error"],"title":"Maven ‘parent.relativePath‘ of POM报错","uri":"/maven-parent-relative-path-error/"},{"categories":["Back"],"content":"解决 xxx的parent里写的并不是xxx的上一级，而是继承了springboot \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.5.RELEASE\u003c/version\u003e \u003c/parent\u003e 加上 \u003crelativePath /\u003e 修改为 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.5.RELEASE\u003c/version\u003e \u003crelativePath /\u003e \u003c/parent\u003e ","date":"2022-06-06","objectID":"/maven-parent-relative-path-error/:2:0","tags":["Mven","Xml","Error"],"title":"Maven ‘parent.relativePath‘ of POM报错","uri":"/maven-parent-relative-path-error/"},{"categories":["Software","note"],"content":"记录Foxmail笔记","date":"2022-06-06","objectID":"/email-foxmail-note/","tags":["EMail","Foxmail"],"title":"Foxmail笔记","uri":"/email-foxmail-note/"},{"categories":["Software","note"],"content":"Foxmail怎么导出所有邮件 1、打开Foxmail——进入想备份的文件夹——显示邮件的区域——点下鼠标——确认是在此区域内——Ctrl+A全选所有邮件，打开菜单“文件”——导出邮件——选择要保存的地方，确认导出邮件。 2、进入Foxmail文件夹，如D:\\Foxmail\\mail\\账户名\\，里面是所有账户内容，可直接复制。用导入账户方式可打开原来的邮件； 3、打开foxmail邮件客户端工具，找到需要导出的邮件选中，然后鼠标右键—导出邮件；如下图： 4、然后出现的foxmail文件保存向导，点击选择需要保存的文件位置； 批量导出邮件方法：按住键盘CTRL键加鼠标点击 如全选，点击ctrl+A。 5、再次打开，找到刚刚导出邮件文件夹目录，可找到导出的邮件，以eml格式文件显示的。 导出邮件鼠标操作方法：选择需要导出的邮件，按住鼠标拖动出来。 阅读导出的邮件/导入邮件：点击打开——找到对应的客户端——选择文件— 导入。 ","date":"2022-06-06","objectID":"/email-foxmail-note/:1:0","tags":["EMail","Foxmail"],"title":"Foxmail笔记","uri":"/email-foxmail-note/"},{"categories":["Software","note"],"content":"记录Sublime笔记","date":"2022-06-06","objectID":"/editer-sublime-note/","tags":["Editer","Sublime"],"title":"Sublime笔记","uri":"/editer-sublime-note/"},{"categories":["Software","note"],"content":"如何查看sublime安装了哪些插件 你应该安装过package control。 那么只要这样：按ctrl+shift+p，输入package，选择list packages，就看到了。 或者直接查看Installed Packages目录。 ","date":"2022-06-06","objectID":"/editer-sublime-note/:1:0","tags":["Editer","Sublime"],"title":"Sublime笔记","uri":"/editer-sublime-note/"},{"categories":["Back"],"content":"记录Python笔记","date":"2022-06-06","objectID":"/java-threadlocals-diff/","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"使用场景 在我们日常 Java Web 开发中难免遇到需要把一个参数层层的传递到最内层。 例如，用户进行操作需要在拦截器中从redis等缓存中间件去获取用户信息并判断是否过期，如果接下来的的业务方法需要用到用户信息时怎么获取呢? Java的Web项目大部分都是基于Tomcat，每次访问都是一个新的线程，这样让我们联想到了ThreadLocal，每一个线程都独享一个ThreadLocal，在接收请求的时候set特定内容，在需要的时候get这个值。 先附上本文中demo源码演示地址，有兴趣的可以看下 ThreadLocalDemo地址 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:1:0","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"ThreadLocal ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:2:0","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"Demo 模拟一个普通的用户请求(新启动一个线程) 请求先经过拦截器，拦截器中必然需要获取用户信息，同时调用ThreadLocal.set(userInfo)将用户信息塞入线程上下文中 进行业务处理(业务处理时从ThreadLocal中获取用户信息，避免参数层层传递) ThreadLocal封装类 public class ThreadLocalHolder { /** * 普通THREAD_LOCAL */ private static final ThreadLocal\u003cUserInfo\u003e THREAD_LOCAL = new ThreadLocal\u003c\u003e(); public static UserInfo getUser() { return THREAD_LOCAL.get(); } public static void setUser(UserInfo userInfo) { THREAD_LOCAL.set(userInfo); } } 测试类，启动一个线程模拟一个普通的Web同步请求 public static void main(String[] args) { BusinessService businessService = new BusinessService(); LoginInterceptor loginInterceptor = new LoginInterceptor(); //模拟一个普通的同步web请求 new Thread(() -\u003e { // 模拟用户身份拦截器 loginInterceptor.userInterceptor(); System.out.println(Thread.currentThread().getName() + \":\" + ThreadLocalHolder.getUser()); // 拦截器通过后 同步处理业务 businessService.doBusiness(); }).start(); } 模拟Web项目中的拦截器实现，从缓存中获取用户信息，塞入ThreadLocal中 public class LoginInterceptor { /** * 模拟拦截方法 */ public void userInterceptor() { UserInfo userInfo = getUserFromRedis(); //将用户信息塞入ThreadLocal中 ThreadLocalHolder.setUser(userInfo); } /** * 模拟从redis中获取信息，这里写死直接返回 * * @return */ public UserInfo getUserFromRedis() { UserInfo userInfo = new UserInfo(); userInfo.setId(1L); userInfo.setUserName(\"chenyin\"); return userInfo; } } 业务处理类，获取用户信息，再处理业务 public class BusinessService { /** * 模拟同步处理业务 */ public void doBusiness() { //获取用户信息，避免显示参数传递 System.out.println(Thread.currentThread().getName() + \":\" + ThreadLocalHolder.getUser()); //业务处理。。略去 } /** * 模拟异步处理业务 */ public void doBusinessAsync() { new Thread(() -\u003e { //获取用户信息，避免显示参数传递 System.out.println(Thread.currentThread().getName() + \":\" + ThreadLocalHolder.getUser()); //业务处理。。略去 }).start(); } } main方法执行结果如下 可以看到，同一个线程中，即无论调用层级多深，也不需要将UserInfo作为参数层层传递，直接调用ThreadLocal.get()方法即可获取用户信息 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:2:1","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"ThreadLocal存储结构 首先提出一个问题，ThreadLocal中set()方法设的值具体存储在哪里？ 先看几个关键的变量定义 Thread类中变量定义 public class Thread implements Runnable { //略去其他变量定义 //普通线程上下文存储所在Map ThreadLocal.ThreadLocalMap threadLocals = null; //InheritableThreadLocal可继承线程本地变量存储所在Map ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; } ThreadLocal.ThreadLocalMap中变量定义，Entry中的Key(ThreadLocal类型)是个WeakReference弱引用 static class ThreadLocalMap { static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** * The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } private Entry[] table; } 再看下set方法实现 public void set(T value) { //获取当前线程对象t Thread t = Thread.currentThread(); //获取t中的 ThreadLocal.ThreadLocalMap变量 ThreadLocalMap map = getMap(t); //往ThreadLocalMap中的tables中加入数据，key为当前ThreadLocal对象，value为用户传入的值 if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocal之所以能做不到不同线程之间的隔离性，就是因为set方法设的值不是存在我们定义的ThreadLocal变量中，而是存储在每个线程的变量(ThreadLocal.ThreadLocalMap)中 再提出一个问题，ThreadLocalMap.Entry中的key值为什么是ThreadLocal类型？ 假设有如下场景，同一个线程中同时使用了2个ThreadLocal public static void main(String[] args) { ThreadLocal\u003cInteger\u003e threadLocalA = new ThreadLocal\u003c\u003e(); ThreadLocal\u003cInteger\u003e threadLocalB = new ThreadLocal\u003c\u003e(); threadLocalA.set(1); threadLocalB.set(2); } 同一线程中可能定义了不同的ThreadLocal变量，这些ThreadLocal实例共享一个table数组，然后每个ThreadLocal实例在table中的索引i是不同的，因此Key为ThreadLocal能够根据ThreadLocal中的hashCode唯一确定其value在table中的下标 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:2:2","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"关键API //从线程上下文中获取值 public T get() ; //将值设入线程上下文中，供同一线程后续使用 public void set(T value) ; //清除线程上下文 public void remove() ; set方法实现 源码如下 public void set(T value) { //获取当前线程对象t Thread t = Thread.currentThread(); //获取线程t实例对象中的 ThreadLocal.ThreadLocalMap变量 ThreadLocalMap map = getMap(t); //往ThreadLocalMap中的tables中加入数据，key为当前ThreadLocal对象，value为用户传入的值 if (map != null) map.set(this, value); else createMap(t, value); } 实现核心为java.lang.ThreadLocal.ThreadLocalMap#set方法，看下实现 private void set(ThreadLocal\u003c?\u003e key, Object value) { Entry[] tab = table; int len = tab.length; //根据当前ThreadLocal变量的hashCode与数组长度做位运算得到在Entry[] tab数组中的存储下标 int i = key.threadLocalHashCode \u0026 (len - 1); //e != null说明hash冲突，下标往后+1 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u003c?\u003e k = e.get(); if (k == key) { e.value = value; return; } // 可能threadLocal对象已经被gc回收，此时key为null，清除无效的entry if (k == null) { replaceStaleEntry(key, value, i); return; } } //找不到对应entry,新建一个Entry，塞入下标为i的槽位处 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) \u0026\u0026 sz \u003e= threshold) rehash(); } get方法实现 基本思路与get类似，先获取当前调用线程对象t，再获取其ThreadLocalMap对象，再调用 ThreadLocal.ThreadLocalMap#getEntry方法获取值 java.lang.ThreadLocal#get public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T) e.value; return result; } } return setInitialValue(); } ThreadLocal.ThreadLocalMap#getEntry private Entry getEntry(ThreadLocal\u003c?\u003e key) { int i = key.threadLocalHashCode \u0026 (table.length - 1); Entry e = table[i]; //找到key，直接返回 if (e != null \u0026\u0026 e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private Entry getEntryAfterMiss(ThreadLocal\u003c?\u003e key, int i, Entry e) { Entry[] tab = table; int len = tab.length; //hash冲突时，遍历tab，直到key值相等 while (e != null) { ThreadLocal\u003c?\u003e k = e.get(); if (k == key) return e; if (k == null) //清楚key为null的无效entry expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:2:3","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"缺点 内存泄露 为什么ThreadLocal会出现内存泄露？ static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** * The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } java.lang.ThreadLocal.ThreadLocalMap.Entry的定义中，ThreadLocal是个WeakReference弱引用类型，什么是WeakReference(弱引用)？ 强引用:我们平时使用的最多的引用，是最普遍的引用。JVM不会回收这些引用，即使当内存空间不足时，JVM宁可抛出OutOfMemoryError异常也不会回收这些对象 String str = \"abc\"; List\u003cString\u003e list = new Arraylist\u003cString\u003e(); list.add(str); 弱引用:当垃圾回收器进行线程扫描时，无论此时内存空间是否充足，都会将其回收掉，即弱引用生命周期只在一次GC周期中 再回到问题中来，假设定义如下变量 ThreadLocal\u003cInteger\u003e threadLocalA = new ThreadLocal\u003c\u003e(); threadLocalA.set(1); 此时，ThreadLocalMap中的Entry[] table的数据存储情况如下，外部的引用threadLocalA与Entry[] table中key的引用都指向一个threadLocal实例。 假设此时执行 threadLocalA = null; 堆区threadLocal的实例对象有2个引用链 threadLocal引用-\u003e堆区threadLocal实例(由于执行threadLocalA=null被切断) thread引用-\u003e堆区thread实例-\u003ethreadLocalMap-\u003eentryTable-\u003eentry-\u003e找到threadLocal实例的弱引用key值(由于key是弱引用，下次GC后会被回收) GC后，threadLocal实例有可能被JVM回收，Entry[] table中的key就会存在为null的情况，因此该entry永远不能被访问到。 但此时key对应的value存在如下引用链：栈区线程对象引用(threadRef)-\u003ethread实例-\u003eThreadLocalMap对象-\u003eEntry[] table数组-\u003eentry对象-\u003evalue对象，因此Value可达，GC时不会回收 entry中key为null导致value不能被访问+value不会被回收是造成内存泄露的主要原因 目前源码中针对key为null的情况已有优化方案，set()，get()，remove()中的replaceStaleEntry、cleanSomeSlots、expungeStaleEntry即为清除key为null的方法 那key为什么不使用强引用？ 和上面分析value对象可达的引用链路类似，如果key使用强引用，即使调用threadLocalA = null，此时线程中threadLocalMap中仍然持有threadLocal实例的引用，threadLocalA实例仍然不会被GC回收，造成异常情况 value为什么不使用弱引用？ value只存在thread引用-\u003e堆区thread实例-\u003ethreadLocalMap-\u003eentryTable-\u003eentry-\u003evalue这一条引用链，假设value为弱引用，则GC后会被回收，再也无法通过ThreadLocal.get()方法获取value值 父子线程传值问题 修改测试代码如下，doBusinessAsync方法又启动了一个子线程来执行业务(模拟异步处理) public static void main(String[] args) { BusinessService businessService = new BusinessService(); LoginInterceptor loginInterceptor = new LoginInterceptor(); //模拟一个普通的异步web请求 new Thread(() -\u003e { // 模拟用户身份拦截器 loginInterceptor.userInterceptor(); System.out.println(Thread.currentThread().getName() + \":\" + ThreadLocalHolder.getUser()); // 拦截器通过后 异步处理业务 businessService.doBusinessAsync(); }).start(); } 输出结果如下 子线程中无法获取到ThreadLocal中的value，从上面的存储原理分析中，已经很明白了，子线程拥有自己的ThreadLocalMap，自然无法获取父线程ThreadLocalMap中的值。 但往往很多操作是需要异步操作的，因此父子线程直接共享ThreadLocal中的值是有必要的，下面介绍以下InheritableThreadLocal，看下它是如何实现父子线程之间共享线程上下文的。 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:2:4","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"InheritableThreadLocal 其实现原理就是在创建子线程将父线程当前存在的本地线程变量拷贝到子线程的本地线程变量中 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:3:0","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"线程上下文复制 重新回顾下Thread中定义的两个变量 其中inheritableThreadLocals即为存储InheritableThreadLocal的Map变量，下面称为InheritableThreadLocalMap 先看下线程的创建过程 step1：java.lang.Thread#Thread(java.lang.Runnable) step2：java.lang.Thread#init(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long) step3：java.lang.Thread#init(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long, java.security.AccessControlContext, boolean) 其中有如下实现 判断：如果当前线程(父线程)中有inheritableThreadLocals变量，则子线程的InheritableThreadLocalMap对象由ThreadLocal.createInheritedMap方法产生 再看下ThreadLocal.createInheritedMap方法，最终调用ThreadLocalMap并传入父线程中的inheritableThreadLocals完成拷贝复制 static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { return new ThreadLocalMap(parentMap); } 既然子线程创建时被赋值的也是InheritableThreadLocalMap变量，那么通过InheritableThreadLocal获取线程上下文时也应该操作的是线程中的InheritableThreadLocalMap对象，因此InheritableThreadLocal重写了几个有关ThreadLocalMap获取和赋值的方法 实现如下 public class InheritableThreadLocal\u003cT\u003e extends ThreadLocal\u003cT\u003e { protected T childValue(T parentValue) { return parentValue; } //返回子线程的InheritableThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } //为InheritableThreadLocalMap执行初始化 void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:3:1","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"Demo 使用InheritableThreadLocal，在线程中再new一个线程，模拟异步方法执行 public class InheritableThreadLocalDemo { private static final InheritableThreadLocal\u003cUserInfo\u003e INHERITABLE_THREAD_LOCAL = new InheritableThreadLocal\u003c\u003e(); public static void main(String[] args) { LoginInterceptor loginInterceptor = new LoginInterceptor(); //模拟一个普通的异步web请求 new Thread(() -\u003e { UserInfo userInfo = loginInterceptor.getUserFromRedis(); // 模拟用户身份拦截器 INHERITABLE_THREAD_LOCAL.set(userInfo); System.out.println(Thread.currentThread().getName() + \":\" + INHERITABLE_THREAD_LOCAL.get()); new Thread(() -\u003e { //获取用户信息，避免显示参数传递 System.out.println(Thread.currentThread().getName() + \":\" + INHERITABLE_THREAD_LOCAL.get()); //业务处理。。略去 }).start(); }).start(); } } 结果输出如下 由此可见，子线程中也能正常获取父线程中线程上下文的数据 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:3:2","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"缺点 InheritableThreadLocal的核心思想即：创建线程的时候将父线程中的线程上下文变量值复制到子线程 ,在平时开发中，不可能每一个异步请求都new一个单独的子线程来处理（内存会被撑爆），因此需要使用到线程池，线程池中即存在线程复用的情况，假设线程池中后面创建的线程中的上下文数据否都来自线程池中被复用的线程，这就出现父子线程的上下文变量复制混乱的情况。 举个例子 /** * 演示InheritableThreadLocal的缺陷 * * @author: chenyin * @date: 2019-10-22 13:13 */ public class InheritableThreadLocalWeaknessDemo { private static final InheritableThreadLocal\u003cInteger\u003e INHERITABLE_THREAD_LOCAL = new InheritableThreadLocal\u003c\u003e(); //模拟业务线程池 private static final ExecutorService threadPool = Executors.newFixedThreadPool(5); public static void main(String[] args) throws InterruptedException { //模拟同时10个web请求，一个请求一个线程 for (int i = 0; i \u003c 10; i++) { new TomcatThread(i).start(); } Thread.sleep(3000); threadPool.shutdown(); } static class TomcatThread extends Thread { //线程下标 int index; public TomcatThread(int index) { this.index = index; } @Override public void run() { String parentThreadName = Thread.currentThread().getName(); //父线程中将index值塞入线程上下文变量 System.out.println(parentThreadName + \":\" + index); INHERITABLE_THREAD_LOCAL.set(index); threadPool.submit(new BusinessThread(parentThreadName)); } } static class BusinessThread implements Runnable { //父进程名称 private String parentThreadName; public BusinessThread(String parentThreadName) { this.parentThreadName = parentThreadName; } @Override public void run() { System.out.println(\"parent:\" + parentThreadName + \":\" + INHERITABLE_THREAD_LOCAL.get()); } } } 代码模拟了同时有10个web请求(启动10个线程)，每个线程内部又向业务线程池中提交一个异步任务。执行结果如下图所示 子线程中输出的父线程名称与下标index无法一一对应，即ThreadLocal线程上下文变量出现混乱的情况，应用需要的实际上是把 任务提交给线程池时的ThreadLocal值传递到 任务执行时 这种情况就需要使用阿里开源的TransmittableThreadLocal来解决了 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:3:3","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"TransmittableThreadLocal TransmittableThreadLocal能将任务提交给线程池时的ThreadLocal值传递到任务执行时。 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:4:0","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"Demo 使用TransmittableThreadLocal代替InheritableThreadLocal，同时提交线程时结合TtlRunnable使用，使用TtlRunnable.get()来提交一个TtlRunnable到线程池中执行。 Demo中的TransmittableThreadLocal版本如下 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003etransmittable-thread-local\u003c/artifactId\u003e \u003cversion\u003e2.11.0\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e public class TransmittableThreadLocalDemo { private static final TransmittableThreadLocal\u003cInteger\u003e INHERITABLE_THREAD_LOCAL = new TransmittableThreadLocal\u003c\u003e(); //模拟业务线程池 private static final ExecutorService threadPool = Executors.newFixedThreadPool(5); public static void main(String[] args) throws InterruptedException { //模拟同时10个web请求，一个请求一个线程 for (int i = 0; i \u003c 10; i++) { new TomcatThread(i).start(); } Thread.sleep(3000); threadPool.shutdown(); } static class TomcatThread extends Thread { //线程下标 int index; public TomcatThread(int index) { this.index = index; } @Override public void run() { String parentThreadName = Thread.currentThread().getName(); //父线程中将index值塞入线程上下文变量 System.out.println(parentThreadName + \":\" + index); INHERITABLE_THREAD_LOCAL.set(index); threadPool.submit(TtlRunnable.get(new BusinessThread(parentThreadName))); } } static class BusinessThread implements Runnable { //父进程名称 private String parentThreadName; public BusinessThread(String parentThreadName) { this.parentThreadName = parentThreadName; } @Override public void run() { System.out.println(\"parent:\" + parentThreadName + \":\" + INHERITABLE_THREAD_LOCAL.get()); } } } 执行结果如下，子线程中输出内容与父线程一致，没有出现线程上下文变量复制混乱的情况 ","date":"2022-06-06","objectID":"/java-threadlocals-diff/:4:1","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"原理 TransmittableThreadLocal实现的核心思想有两点 1、线程(TtlRunnable)提交时从父线程中捕获(复制一份)TransmittableThreadLocal上下文对象 2、TtlRunnable重写Run方法，在run方法执行时，根据捕获的线程上下文重新执行TransmittableThreadLocal#set方法达到父子线程 TransmittableThreadLocal#holder 先看下TransmittableThreadLocal中的holder实现，有几个关键点需要注意 holder是个InheritableThreadLocal，本身是个线程上下文 holder中value是WeakHashMap类型(防止内存泄露) WeakHashMap中的key是TransmittableThreadLocal对象(之所以做key是因为可能存在多个TransmittableThreadLocal实例)，其value是null值(WeakHashMap允许value为null) private static InheritableThreadLocal\u003cWeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, ?\u003e\u003e holder = new InheritableThreadLocal\u003cWeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, ?\u003e\u003e() { @Override protected WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, ?\u003e initialValue() { return new WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e(); } @Override protected WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, ?\u003e childValue(WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, ?\u003e parentValue) { return new WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e(parentValue); } }; TransmittableThreadLocal#set @Override public final void set(T value) { //向InheritableThreadLocal中写入value super.set(value); // may set null to remove value if (null == value) removeValue(); else addValue(); } holder其实更多的是个set的作用，存储了当前线程中设有ttlValue的TransmittableThreadLocal的引用 private void addValue() { //以当前TransmittableThreadLocal为key，塞入holder中 if (!holder.get().containsKey(this)) { holder.get().put((TransmittableThreadLocal\u003cObject\u003e) this, null); } } TransmittableThreadLocal#set首先往super.set(value)中写入value，后调用addValue方法将当前TransmittableThreadLocal塞入了holder中 至于为什么要塞到holder中，用处是: 当用户向线程池中提交包装后的Runnable对象(TtlRunnble)时，TtlRunnble能从holder中捕获(获取)父线程中TransmittableThreadLocal上下文存储的值 捕获与重放 先看下官方介绍中的流程时序图 https://github.com/alibaba/transmittable-thread-local 根据时序图的步骤来说明 createTtl()、setTtlValue()其实就是调用TransmittableThreadLocal的线程上下文值，ttlValue就是上下文中的值 createBizTaskRunnable就是执行业务的线程，createTtlRunnableWrapper(Runnable)就是使用TtlRunnable.get()来封装了Runnable，捕获操作captureAllTtlValues就是发生这里 看下TtlRunnable的关键实现 变量如下 //捕获的父线程的存储了ttlvalue的上下文对象，并存储在capturedRef引用指向的对象中 private final AtomicReference\u003cObject\u003e capturedRef; //业务中执行的线程 private final Runnable runnable; 初始化方法 private TtlRunnable(@NonNull Runnable runnable, boolean releaseTtlValueReferenceAfterRun) { //调用TransmittableThreadLocal.Transmitter父线程中捕获上下文对象 this.capturedRef = new AtomicReference\u003cObject\u003e(capture()); this.runnable = runnable; this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun; } 在调用TtlRunnable.get()时会触发上述初始化方法，capture()方法最终调用的是TransmittableThreadLocal.Transmitter#capture方法 下面就进入到了时序图中captureAllTtlValues、get()、copy(T value)的实现。看下TransmittableThreadLocal.Transmitter#capture方法的具体实现 public static Object capture() { return new Snapshot(captureTtlValues(), captureThreadLocalValues()); } private static WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e captureTtlValues() { WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e ttl2Value = new WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e(); //调用holder.get().keySet()获取当前线程中存在ttlValue的TransmittableThreadLocal引用列表 for (TransmittableThreadLocal\u003cObject\u003e threadLocal : holder.get().keySet()) { //将TransmittableThreadLocal实例为key，TransmittableThreadLocal的value为值塞入WeakHashMap\u003cTransmittableThreadLocal\u003cObject\u003e, Object\u003e中，最终作为Snapshot的一个属性返回给子线程 TtlRunnable ttl2Value.put(threadLocal, threadLocal.copyValue()); } return ttl2Value; } get()对应holder.get() copy(T value)对应threadLocal.copyValue() submitTtlRunnableToThreadPool、run()对应线程池开始执行任务 看下TtlRunnable中重写的run方法 public void run() { //捕获的父线程的线程上下文 Object captured = capturedRef.get(); if (captured == null || releaseTtlValueReferenceAfterRun \u0026\u0026 !capturedRef.compareAndSet(captured, null)) { throw new IllegalStateException(\"TTL value reference is released after run!\"); } //在子线程中重放(调用TransmittableThreadLocal#set方法)重新设置线程上下文 Object backup = replay(captured); try { runnable.run(); } finally { //恢复线程中子线程原先的本地线程变量，避免被父线程的线程上下文污染 restore(backup); } } 其实现的关键在于replay方法 接下来就进入到了时序图中的beforeExecu","date":"2022-06-06","objectID":"/java-threadlocals-diff/:4:2","tags":["Java","Thread","ThreadLocal","Difference"],"title":"ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal解析","uri":"/java-threadlocals-diff/"},{"categories":["Back"],"content":"记录Error:java: Compilation failed: internal java compiler error(内部Java编译器错误)，已解决","date":"2022-06-05","objectID":"/idea-internal-java-compiler-error/","tags":["IDE","Idea","Java","Error"],"title":"Idea 报错Error:java: Compilation failed: internal java compiler error","uri":"/idea-internal-java-compiler-error/"},{"categories":["Back"],"content":"报错 今天在用idea创建maven项目时候报了一个错误（如上图） Error:java: Compilation failed: internal java compiler error 错误：Java：编译失败：内部Java编译器错误 ","date":"2022-06-05","objectID":"/idea-internal-java-compiler-error/:1:0","tags":["IDE","Idea","Java","Error"],"title":"Idea 报错Error:java: Compilation failed: internal java compiler error","uri":"/idea-internal-java-compiler-error/"},{"categories":["Back"],"content":"解决办法 File–\u003eSettings…–\u003eBuild,Execution,Deployment–\u003eCompiler–\u003eJava Compiler，设置相应Module的 Target bytecode version 的合适版本（跟你jkd版本一致），这里我改成1.8版本的。 ","date":"2022-06-05","objectID":"/idea-internal-java-compiler-error/:2:0","tags":["IDE","Idea","Java","Error"],"title":"Idea 报错Error:java: Compilation failed: internal java compiler error","uri":"/idea-internal-java-compiler-error/"},{"categories":["Software"],"content":"记录Tomcat网站上的core和deployer的区别","date":"2022-06-05","objectID":"/tomcat-version-diff/","tags":["Tomcat","Difference"],"title":"Tomcat网站上的core和deployer的区别","uri":"/tomcat-version-diff/"},{"categories":["Software"],"content":"8.5.13 Please see the README file for packaging information. It explains what every distribution(分布) contains. Binary Distributions Core: zip (pgp, md5, sha1) tar.gz (pgp, md5, sha1) 32-bit Windows zip (pgp, md5, sha1) 64-bit Windows zip (pgp, md5, sha1) 32-bit/64-bit Windows Service Installer (pgp, md5, sha1) Full documentation (文件材料) : tar.gz (pgp, md5, sha1) Deployer: zip (pgp, md5, sha1) tar.gz (pgp, md5, sha1) Extras: JMX Remote jar (pgp, md5, sha1) Web services jar (pgp, md5, sha1) Embedded: tar.gz (pgp, md5, sha1) zip (pgp, md5, sha1) Source Code Distributions tar.gz (pgp, md5, sha1) zip (pgp, md5, sha1) 看到这里大家知道同一个版本的Tomcat有不同的下载版本，Binary Distributions和Source Code Distributions大家应该能分清楚，分别是二进制版本和源代码本。困惑在于Binary Distributions下面又有Core和Deployer两个，这两个有什么区别？我们到底应该选择哪个呢？ ","date":"2022-06-05","objectID":"/tomcat-version-diff/:0:1","tags":["Tomcat","Difference"],"title":"Tomcat网站上的core和deployer的区别","uri":"/tomcat-version-diff/"},{"categories":["Software"],"content":"先说这两者的区别。 Core：是Tomcat正式的二进制发布版本，一般大家做开发或者学习的时候应该下载Core下的。 Deployer：是基于Tomcat的web应用的发布器，就是在把写好的JavaEE应用发布到Tomcat的时候可以使用Deployer来动态的发布。所以它不是真正的Tomcat二进制版本，它只是一个用以发布基于Tomcat的Web应用的发布工具而已。因此，大家在下载的时候不应该下载这个东西，除非想动态的发布Web应用到Tomcat中去。 那么Deployer既然是用来发布Web应用到Tomcat中去的，那么它都能做些什么呢？ 这里有必要跟大家交代一下Tomcat中的Web应用发布的概念。 发布：指的是把一个Web应用安装到Tomcat服务器中的过程。 在Tomcat中发布Web应用可以有两种方式： 1、静态发布：指的是在Tomcat未启动的时候，把做好的Web应用直接复制到Tomcat服务器中。 2、动态发布：有两种情况 ​ 2.1 指的是在Tomcat已经启动运行的情况下，通过Tomcat的自动部署功能动态操作已经发布的Web应用. ​ 2.2 指的是通过Tomcat Manager这个Web应用通过远程把做好的Web应用发布到正在运行的Tomcat中去。 Deployer的作用就在动态发布Web应用到Tomcat中去的时候体现出来的。 Deployer是一个命令行的工具，它可以编译、验证Web应用，还可以把Web应用的全部资源打包到War文件中。 ","date":"2022-06-05","objectID":"/tomcat-version-diff/:1:0","tags":["Tomcat","Difference"],"title":"Tomcat网站上的core和deployer的区别","uri":"/tomcat-version-diff/"},{"categories":["Front"],"content":"记录【npm】core-js@2.6.12: core-js@\u003c3.3 is no longer maintained and not recommended 。。。。。的解决办法","date":"2022-06-05","objectID":"/npm-core-js-no-longer-maintained-recommended-error/","tags":["Npm","Core-Js"],"title":"【npm】core-js@2.6.12: core-js@\u003c3.3 is no longer maintained and not recommended 。。。。。","uri":"/npm-core-js-no-longer-maintained-recommended-error/"},{"categories":["Front"],"content":"错误代码 core-js@2.6.12: core-js@❤️.3 is no longer maintained and not recommended for usage due to the number of issues. Because of the V8 engine whims, feature detection in old core-js versions could cause a slowdown up to 100x even if nothing is polyfilled. Please, upgrade your dependencies to the actual version of core-js. 由于问题太多，不再维护3.3，也不推荐使用。由于V8引擎的怪想，旧core-js版本的特性检测可能会导致速度下降100倍，即使没有填充。请将你的依赖升级到core-js的实际版本。 ","date":"2022-06-05","objectID":"/npm-core-js-no-longer-maintained-recommended-error/:1:0","tags":["Npm","Core-Js"],"title":"【npm】core-js@2.6.12: core-js@\u003c3.3 is no longer maintained and not recommended 。。。。。","uri":"/npm-core-js-no-longer-maintained-recommended-error/"},{"categories":["Front"],"content":"解决 网上找了一大堆解决方法，排行前几的都不靠谱，最后发现是自己的npm版本太高了，是7.x.x，建议退回 6 版本,成功解决！！ npm install npm@6.14.13 -g ","date":"2022-06-05","objectID":"/npm-core-js-no-longer-maintained-recommended-error/:2:0","tags":["Npm","Core-Js"],"title":"【npm】core-js@2.6.12: core-js@\u003c3.3 is no longer maintained and not recommended 。。。。。","uri":"/npm-core-js-no-longer-maintained-recommended-error/"},{"categories":["Back"],"content":"记录在window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf的解决办法","date":"2022-06-05","objectID":"/redis-fail-open-conf-error/","tags":["Redis","Error"],"title":"在Window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf","uri":"/redis-fail-open-conf-error/"},{"categories":["Back"],"content":"版本 当前redis版本 redis-cli -v redis-cli 3.0.503 网上给的命令（在redis所在文件夹下执行）： redis-server –service-install redis.windows.conf –loglevel verbose ","date":"2022-06-05","objectID":"/redis-fail-open-conf-error/:1:0","tags":["Redis","Error"],"title":"在Window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf","uri":"/redis-fail-open-conf-error/"},{"categories":["Back"],"content":"问题1 Invalid argument during startup: Failed to open the .conf file: verbose CWD=C:\\developer\\redis 解决办法亲测 redis-server --service-install redis.windows.conf --loglevel verbose ","date":"2022-06-05","objectID":"/redis-fail-open-conf-error/:1:1","tags":["Redis","Error"],"title":"在Window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf","uri":"/redis-fail-open-conf-error/"},{"categories":["Back"],"content":"问题2 在服务中设置自动启动并启动，但提示失败 windows could not start the redis 7034 解决办法 关闭已启动的redis服务端CMD窗口，重新启动服务 ","date":"2022-06-05","objectID":"/redis-fail-open-conf-error/:1:2","tags":["Redis","Error"],"title":"在Window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf","uri":"/redis-fail-open-conf-error/"},{"categories":["Back"],"content":"问题3 HandleServiceCommands: system error caught. error code=1073, message = CreateService failed: unknow 解决办法 1)先卸载服务： redis-server --service-uninstall 2)然后再安装： redis-server--service-install redis.windows.conf 线上下载地址 https://github.com/MicrosoftArchive/redis/releases https://github.com/ServiceStack/redis-windows/tree/master/downloads 启停： 启动服务：redis-server –service-start 停止服务：redis-server –service-stop ","date":"2022-06-05","objectID":"/redis-fail-open-conf-error/:1:3","tags":["Redis","Error"],"title":"在Window系统上安装redis服务-Invalid argument during startup: Failed to open the .conf","uri":"/redis-fail-open-conf-error/"},{"categories":["Back","note"],"content":"记录Python笔记","date":"2022-06-05","objectID":"/win-middleware-install-service-note/","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"通用步骤（以Nacos为例） ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:1:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"1、插件下载 ​ 地址：Releases · winsw/winsw · GitHub ​ 选择下面这个插件： ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:1:1","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"2、配置文件和插件安装 ​ 1、在nacos解压包的bin目录下创建nacos-service.xml文件 ​ 2、在nacos-service.xml输入以下内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cservice\u003e \u003cid\u003enacos\u003c/id\u003e \u003cname\u003eNacos Service\u003c/name\u003e \u003cdescription\u003eNacos-service\u003c/description\u003e \u003clogpath\u003eD:\\tool\\nacos\\nacos\\bin\\logs\\\u003c/logpath\u003e \u003clogmode\u003eroll\u003c/logmode\u003e \u003cexecutable\u003eD:\\tool\\nacos\\nacos\\bin\\startup.cmd\u003c/executable\u003e \u003cstopexecutable\u003eD:\\tool\\nacos\\nacos\\bin\\shutdown.cmd\u003c/stopexecutable\u003e \u003c/service\u003e 先说注意的点：不要有中文！！不要有中文！！不要有中文！！ 博主就是在中文这块折腾很久，保险起见哪怕注释都不要有中文 另外，要将三个地址改为你自己的： 解释下相关配置： id：服务id，需在windows系统上唯一，不能与其他服务有冲突 name：注册完服务后显示的服务名称 description：随便写，但尽量不要有中文 ​ 3、将刚刚下载的 WinSW-x64.exe插件移动到nacos解压目录的bin目录下，改名为：nacos-service.exe，exe是后缀 ​ 4、在bin目录下输入cmd，打开命令行，输入：nacos-service.exe install ​ 5、在cmd命令行输入：net start nacos，启动服务 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:1:2","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"3、服务的查看与开启关闭 ​ 1、查看 ​ win + R ​ 输入：services.msc ​ 2、开启关闭服务 net start nacos net stop nacos 其他中间间仅需修改xml即可 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:1:3","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"Mysql 自带脚本运行即可 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:2:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"RabbitMq 自带脚本运行即可 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:3:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"Redis 自带脚本运行即可 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:4:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"ElasticSearch 自带脚本运行即可 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:5:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"Logstash \u003cservice\u003e \u003c!-- 唯一服务ID--\u003e \u003cid\u003elogstash\u003c/id\u003e \u003c!-- 显示服务的名称 --\u003e \u003cname\u003eLogstash Service\u003c/name\u003e \u003c!-- 服务描述 --\u003e \u003cdescription\u003eLogstash服务\u003c/description\u003e \u003c!-- 日志路径 --\u003e \u003clogpath\u003eC:\\Program_Green\\Java_env\\logstash-8.2.0\\logs\\\u003c/logpath\u003e \u003c!-- 日志模式 --\u003e \u003clogmode\u003eroll\u003c/logmode\u003e \u003c!-- 可执行文件的命令 --\u003e \u003cexecutable\u003eC:\\Program_Green\\Java_env\\logstash-8.2.0\\bin\\ry-cloud-aa-comp_start.cmd\u003c/executable\u003e \u003c!-- \u003cexecutable\u003eC:\\Program_Green\\Java_env\\logstash-8.2.0\\bin\\logstash.bat\u003c/executable\u003e --\u003e \u003c!-- \u003carguments\u003e-f C:\\Program_Green\\Java_env\\logstash-8.2.0\\ry-cloud-aa-comp\\config\\config.conf - -path.data=C:\\Program_Green\\Java_env\\logstash-8.2.0\\ry-cloud-aa-comp\\data\\\u003c/arguments\u003e --\u003e \u003c!-- 停止可执行文件的命令 --\u003e \u003cstopexecutable\u003eC:\\Program_Green\\Java_env\\logstash-8.2.0\\bin\\logstash_stop.bat\u003c/stopexecutable\u003e \u003c/service\u003e ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:6:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"ry-cloud-aa-comp_start.cmd cd C:\\Program_Green\\Java_env\\logstash-8.2.0\\bin logstash.bat -f C:\\Program_Green\\Java_env\\logstash-8.2.0\\ry-cloud-aa-comp\\config\\config.conf --path.data=C:\\Program_Green\\Java_env\\logstash-8.2.0\\ry-cloud-aa-comp\\data\\ ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:6:1","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"logstash_stop.bat 根据jps找java进程，拿到进程号startkill掉 @echo off set program=org.logstash.Logstash echo program: %program% for /f \"usebackq tokens=1-2\" %%a in (`jps -l ^| findstr %program%`) do ( set pid=%%a set image_name=%%b ) if not defined pid (echoprocess%program% does not exists) else ( echo prepare to kill %image_name% echo startkill %pid% ... rem 根据进程ID，kill进程 taskkill /f /pid %pid% ) ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:6:2","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"ElasticHD 直接startkill掉进行关闭 \u003cservice\u003e \u003c!-- 唯一服务ID--\u003e \u003cid\u003eelastic_hd\u003c/id\u003e \u003c!-- 显示服务的名称 --\u003e \u003cname\u003eElasticHD Service\u003c/name\u003e \u003c!-- 服务描述 --\u003e \u003cdescription\u003eElasticHD服务\u003c/description\u003e \u003c!-- 日志路径 --\u003e \u003clogpath\u003eC:\\Program_Green\\Java_env\\ElasticHD\\logs\\\u003c/logpath\u003e \u003c!-- 日志模式 --\u003e \u003clogmode\u003eroll\u003c/logmode\u003e \u003c!-- 可执行文件的命令 --\u003e \u003cexecutable\u003eC:\\Program_Green\\Java_env\\ElasticHD\\ElasticHD.exe\u003c/executable\u003e \u003c!-- 停止可执行文件的命令 --\u003e \u003cstopexecutable\u003etaskkill -f -PID ElasticHD.exe\u003c/stopexecutable\u003e \u003c/service\u003e ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:7:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"Nginx \u003cservice\u003e \u003c!-- 唯一服务ID--\u003e \u003cid\u003enginx\u003c/id\u003e \u003c!-- 显示服务的名称 --\u003e \u003cname\u003eNginx Service\u003c/name\u003e \u003c!-- 服务描述 --\u003e \u003cdescription\u003eNginx服务\u003c/description\u003e \u003c!-- 日志路径 --\u003e \u003clogpath\u003eC:\\Program_Green\\Java_env\\nginx-1.20.2\\logs\\\u003c/logpath\u003e \u003c!-- 日志模式 --\u003e \u003clogmode\u003eroll\u003c/logmode\u003e \u003c!-- 可执行文件的命令 --\u003e \u003cexecutable\u003eC:\\Program_Green\\Java_env\\nginx-1.20.2\\nginx.exe\u003c/executable\u003e \u003c!-- 停止可执行文件的命令 --\u003e \u003cstopexecutable\u003eC:\\Program_Green\\Java_env\\nginx-1.20.2\\nginx.exe -s stop\u003c/stopexecutable\u003e \u003c/service\u003e ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:8:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"我的脚本 ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:9:0","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"启动 net start mysql net start redis net start nacos net start RabbitMQ net start elasticsearch-service-x64 net start elastic_hd net start logstash net start nginx ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:9:1","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back","note"],"content":"关闭 net stop nacos net stop redis net stop mysql net stop RabbitMQ net stop elasticsearch-service-x64 net stop elastic_hd net stop logstash net stop nginx ","date":"2022-06-05","objectID":"/win-middleware-install-service-note/:9:2","tags":["Python"],"title":"Windows 各种中间件安装为服务","uri":"/win-middleware-install-service-note/"},{"categories":["Back"],"content":"记录Swagger配置OAuth2登陆失败解决办法","date":"2022-06-05","objectID":"/swagger-no-token-error/","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"前言 用别人的脚手架发现Swagger登录oauth2失败，一开始未发现问题，后通过尝试更改启动顺序解决，但也顺便学习了下Swagger如何配置OAuth2登录 SpringCloud搭建OAuth2时应先启动授权鉴权服务器，后启动网关，否则导致Swagger无法被授权**//TODO** ","date":"2022-06-05","objectID":"/swagger-no-token-error/:1:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"解决 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:2:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"方法一：白名单 不推荐但最方便，紧急情况下使用 首先先放行拦截器 然后不用配置什么参数,直接去拦截器里面 你的项目访问swagger就是这个路径,加进去就可以无token使用了 是不是很简单粗暴,仅限测试环境使用哦~ ","date":"2022-06-05","objectID":"/swagger-no-token-error/:2:1","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"方法二：配置 大佬写过 Spring Boot+Swagger 的用法： ​SpringBoot 整合 Swagger2​​ 也写过 OAuth2 + Jwt 的用法： ​想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演​​ 没写过Spring Securty和Swagger组合，因为现在使用令牌登录的场景越来越多，在这种情况下，如果使用 Swagger 来测试接口，要怎么在请求头中携带 Token 呢？ ","date":"2022-06-05","objectID":"/swagger-no-token-error/:2:2","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"1.项目规划 如果小伙伴们没有看过松哥之前发的 OAuth2 系列文章，建议一定先看下（公众号江南一点雨后台回复 OAuth2 获取），再来看本文内容，否则接下来的内容可能会犯迷糊。 这里松哥搭建一个 OAuth2+JWT 的环境来做演示。一共搭建两个服务： 服务名 端口 备注 auth-server 8080 授权服务器 user-server 8081 资源服务器 我稍微解释一下： auth-server 就是我的资源服务器，用来颁发 JWT 令牌。 user-server 则是资源服务器，访问 user-server 上的资源，都需要携带令牌才能访问。 swagger 则用来给 user-server 上的接口生成文档。 OK，这是我们项目的一个大致规划。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:3:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"2.环境搭建 接下来我们来搭建 OAuth2 测试环境。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:4:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"2.1 授权服务器搭建 首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖： Web Spring Cloud Security Spirng Cloud OAuth2 项目创建完成后，首先提供一个 Spring Security 的基本配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"sang\") .password(passwordEncoder().encode(\"123\")) .roles(\"admin\") .and() .withUser(\"javaboy\") .password(passwordEncoder().encode(\"123\")) .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().formLogin(); } } 在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。 这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。 这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。 需要注意的是，在当前案例中，我将采用 OAuth2 中的 password 模式进行登录，因此这里还需要明确的提供一个 AuthenticationManager 的 Bean。 基本的用户信息配置完成后，接下来我们来配置授权服务器。 首先来配置 TokenStore： @Configuration public class AccessTokenConfig { @Bean TokenStore tokenStore() { return new JwtTokenStore(jwtAccessTokenConverter()); } @Bean JwtAccessTokenConverter jwtAccessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(\"javaboy\"); return converter; } } TokenStore 我们使用 JwtTokenStore 这个实例。使用了 JWT，access_token 实际上就不用存储了（无状态登录，服务端不需要保存信息），因为用户的所有信息都在 jwt 里边，所以这里配置的 JwtTokenStore 本质上并不是做存储。 另外我们还提供了一个 JwtAccessTokenConverter，这个 JwtAccessTokenConverter 可以实现将用户信息和 JWT 进行转换（将用户信息转为 jwt 字符串，或者从 jwt 字符串提取出用户信息）。 另外，在 JWT 字符串生成的时候，我们需要一个签名，这个签名需要自己保存好。 接下来对授权服务器进行详细配置： @EnableAuthorizationServer @Configuration public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired TokenStore tokenStore; @Autowired ClientDetailsService clientDetailsService; @Autowired AuthenticationManager authenticationManager; @Autowired PasswordEncoder passwordEncoder; @Autowired JwtAccessTokenConverter jwtAccessTokenConverter; @Bean AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); services.setSupportRefreshToken(true); services.setTokenStore(tokenStore); services.setAccessTokenValiditySeconds(60 * 60 * 24 * 2); services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 7); TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter)); services.setTokenEnhancer(tokenEnhancerChain); return services; } @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"javaboy\") .secret(passwordEncoder.encode(\"123\")) .resourceIds(\"res1\") .authorizedGrantTypes(\"password\", \"refresh_token\") .scopes(\"all\") .redirectUris(\"http://localhost:8082/index.html\"); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints .authenticationManager(authenticationManager) .tokenServices(tokenServices()); } } 这段代码有点长，我来给大家挨个解释： 创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。 在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。 AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。 ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在​​之前文章​​​中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在​​之前文章​​中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操","date":"2022-06-05","objectID":"/swagger-no-token-error/:4:1","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"2.2 资源服务器搭建 接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。 资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。 我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖： 项目创建成功之后，先把前面的 AccessTokenConfig 拷贝到资源服务器上，然后添加如下配置： @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Autowired TokenStore tokenStore; @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\"res1\").tokenStore(tokenStore); } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .anyRequest().authenticated(); } } 这段配置代码很简单，我简单的说一下： 首先在 configure 方法中配置资源 ID 和 TokenStore，这里配置好之后，会自动调用 JwtAccessTokenConverter 将 jwt 解析出来，jwt 里边就包含了用户的基本信息，所以就不用远程校验 access_token 了。 最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。 接下来我们再来配置两个测试接口： @RestController public class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello\"; } @GetMapping(\"/admin/hello\") public String admin() { return \"admin\"; } } 如此之后，我们的资源服务器就算配置成功了。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:4:2","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"2.3 测试 分别启动授权服务器和资源服务器，先访问授权服务器获取 access_token： 再利用拿到的 access_token 去访问资源服务器： OK，测试没问题。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:4:3","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"3.整合 Swagger 接下来，我们在 user-server 中加入 swagger 功能，首先我们加入 swagger 依赖： \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e 这里加入的依赖有两个，一个用来生成接口数据，另一个 swagger-ui 用来做数据展示。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:5:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"3.1 认证方式一 请求头加参数，这里给大家介绍两种，先来看第一种。 先配置一个 Docket 实例，如下： @Configuration @EnableSwagger2 public class Swagger2Config { @Bean Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(\"org.javaboy.oauth2.res.controller\")) .paths(PathSelectors.any()) .build() .securityContexts(Arrays.asList(securityContexts())) .securitySchemes(Arrays.asList(securitySchemes())) .apiInfo(new ApiInfoBuilder() .description(\"接口文档的描述信息\") .title(\"微人事项目接口文档\") .contact(new Contact(\"javaboy\",\"http://www.javaboy.org\",\"wangsong0210@gmail.com\")) .version(\"v1.0\") .license(\"Apache2.0\") .build()); } private SecurityScheme securitySchemes() { return new ApiKey(\"Authorization\", \"Authorization\", \"header\"); } private SecurityContext securityContexts() { return SecurityContext.builder() .securityReferences(defaultAuth()) .forPaths(PathSelectors.any()) .build(); } private List\u003cSecurityReference\u003e defaultAuth() { AuthorizationScope authorizationScope = new AuthorizationScope(\"xxx\", \"描述信息\"); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Arrays.asList(new SecurityReference(\"Authorization\", authorizationScopes)); } } 这里的配置稍微有点长，我来给大家解释下： 首先通过 @EnableSwagger2 注解启用 Swagger2。 配置一个 Docket Bean，这个 Bean 中，配置映射路径和要扫描的接口的位置。 在 apiInfo 中，主要配置一下 Swagger2 文档网站的信息，例如网站的 title，网站的描述，联系人的信息，使用的协议等等。 通过 securitySchemes 来配置全局参数，这里的配置是一个名为 Authorization 的请求头（OAuth2 中需要携带的请求头）。 securityContexts 则用来配置有哪些请求需要携带 Token，这里我们配置了所有请求。 配置完成后，我们还需要给 swagger-ui 放行，否则 swagger-ui 相关的静态资源会被 Spring Security 拦截下来： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override public void configure(WebSecurity web) throws Exception { web.ignoring().antMatchers(\"/swagger-ui.html\") .antMatchers(\"/webjars/**\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\"); } } 配置完成后，重启 user-server，浏览器输入 http://localhost:8081/swagger-ui.html，结果如下： 大家可以看到，页面中多了一个 Authorize 按钮，点击该按钮，输入 ​ \u0026#x200B;Bearer ${token}\u0026#x200B;​，如下： 输入完成后，点击 Authorize 按钮，完成认证，接下来，user-server 中的各种接口就可以直接调用测试了。 上面这种方式比较通用，不仅仅适用于 OAuth2，也适用于其他一些自定义的 token 登录方式。 但是这种方式需要开发者先通过其他途径获取到 access_token，有的人会觉得这样有点麻烦，那么有没有更好的办法呢？请看方式二。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:5:1","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"3.2 认证方式二 认证方式二就是直接在 Swagger 中填入认证信息，这样就不用从外部去获取 access_token 了，效果如下： 我们来看下这个怎么配置。 由于 swagger 去请求 ​ \u0026#x200B;/oauth/token\u0026#x200B;​ 接口会跨域，所以我们首先要修改 auth-server ，使之支持跨域： 主要是两方面的修改，首先是配置 CorsFilter，允许跨域，如下： @Configuration public class GlobalCorsConfiguration { @Bean public CorsFilter corsFilter() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowCredentials(true); corsConfiguration.addAllowedOrigin(\"*\"); corsConfiguration.addAllowedHeader(\"*\"); corsConfiguration.addAllowedMethod(\"*\"); UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); urlBasedCorsConfigurationSource.registerCorsConfiguration(\"/**\", corsConfiguration); return new CorsFilter(urlBasedCorsConfigurationSource); } } 然后在 SecurityConfig 中开启跨域支持： @Configuration @Order(Ordered.HIGHEST_PRECEDENCE) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... ... @Override protected void configure(HttpSecurity http) throws Exception { http .requestMatchers().antMatchers(HttpMethod.OPTIONS, \"/oauth/**\") .and() .csrf().disable().formLogin() .and() .cors(); } } 经过这两步的配置，服务端的跨域支持就开启了。 接下来我们在 user-server 中修改关于 Docket bean 的定义： @Configuration @EnableSwagger2 public class Swagger2Config { @Bean Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(\"org.javaboy.oauth2.res.controller\")) .paths(PathSelectors.any()) .build() .securityContexts(Arrays.asList(securityContext())) .securitySchemes(Arrays.asList(securityScheme())) .apiInfo(new ApiInfoBuilder() .description(\"接口文档的描述信息\") .title(\"微人事项目接口文档\") .contact(new Contact(\"javaboy\",\"http://www.javaboy.org\",\"wangsong0210@gmail.com\")) .version(\"v1.0\") .license(\"Apache2.0\") .build()); } private AuthorizationScope[] scopes() { return new AuthorizationScope[]{ new AuthorizationScope(\"all\", \"all scope\") }; } private SecurityScheme securityScheme() { GrantType grant = new ResourceOwnerPasswordCredentialsGrant(\"http://localhost:8080/oauth/token\"); return new OAuthBuilder().name(\"OAuth2\") .grantTypes(Arrays.asList(grant)) .scopes(Arrays.asList(scopes())) .build(); } private SecurityContext securityContext() { return SecurityContext.builder() .securityReferences(Arrays.asList(new SecurityReference(\"OAuth2\", scopes()))) .forPaths(PathSelectors.any()) .build(); } } 这段配置跟前面的类似，主要是 SecurityScheme 不同。这里采用了 OAuthBuilder 来构建，构建时即得配置 token 的获取地址。 好了，配置完成，重启 auth-server 和 user-server 进行测试。测试效果就是松哥前面给出的图片，不再赘述。 这种方式最大的好处就是不用通过其他途径获取 access_token，直接在 swagger-ui 页面输入 password 模式的认证参数即可。非常方便，仅限于 OAuth2 模式。 ","date":"2022-06-05","objectID":"/swagger-no-token-error/:5:2","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Back"],"content":"4.小结 好了，今天就和小伙伴们介绍了在 Swagger 请求中，如何修改请求头的问题，感兴趣的小伙伴可以下来试试哦～ 本文案例下载地址：​​https://github.com/lenve/spring-security-samples​ ","date":"2022-06-05","objectID":"/swagger-no-token-error/:6:0","tags":["Swagger","Oauth2","Error"],"title":"Swagger配置OAuth2登陆失败","uri":"/swagger-no-token-error/"},{"categories":["Operation","note"],"content":"记录The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"报错 如上图 ","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/:1:0","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"解决 通过官方指导链接可以看到，github最新修改了安全协议，不再支持git，需要用https进行请求。 所以解决方式就是把git@github.com的请求都改为https://github.com ","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/:2:0","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"方法一 进入git文件中搜索gitconfig 找到该文件在后面添加 [url \"https://\"] insteadOf = ssh:// [url \"https://\"] insteadOf = git:// 尝试是否能成功，如果不成控制台输入 git config --global --edit 查看，至于用不用global，看你想写在哪里了 ","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/:2:1","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"方法二 然后找到该文件位置在后面也加上 ","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/:2:2","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"方法三 也可以直接控制台输入如下指令 git config --global url.\"https://github.com/\".insteadof git@github.com: // 或（根据使用远程包的原先的地址来替换） git config --global url.\"https://github.com/\".insteadof git://github.com/ ","date":"2022-06-05","objectID":"/github-clone-protocol-port-9418-no-longer-supported-error/:2:3","tags":["Git","Error"],"title":"The unauthenticated git protocol on port 9418 is no longer supported.的解决方法","uri":"/github-clone-protocol-port-9418-no-longer-supported-error/"},{"categories":["Operation","note"],"content":"记录Git安装以及配置SSH Key的笔记","date":"2022-06-05","objectID":"/git-install-note/","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"1|0下载安装包 安装 Git 官网下载一个Windows版本的Git。 然后一直下一步即可，如下图 环境变量自动配好的，可以去检查一下环境变量中PATH中有没有Git的环境变量 然后在桌面右击鼠标，选择Git bash here，然后输入下面代码： git --version #验证git是否安装成功，输出版本号就代表安装成功 ","date":"2022-06-05","objectID":"/git-install-note/:1:0","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"2|0配置全局用户名和邮箱 安装完成有配置一下全局的用户名和邮箱，输入如下命令： 安装完成有配置一下全局的用户名和邮箱，输入如下命令： git config --global user.name \"自定义用户名\" git config --global user.email \"邮箱\" 使用如下命令可以取消全局设置： git config --global --unset user.name git config --global --unset user.email 可以使用如下命令查看当前的全局变量： git config --global --list ","date":"2022-06-05","objectID":"/git-install-note/:2:0","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"3|0生成SSH Key ","date":"2022-06-05","objectID":"/git-install-note/:3:0","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"3|1管理多个SSH Key 问题说明 当有多个git账号的时候，比如一个github，用于自己进行一些开发活动，再来一个gitlab，一般是公司内部的git。这两者你的邮箱如果不同的话，就会涉及到一个问题，生成第二个git的key的时候会覆盖第一个的key，导致必然有一个用不了。 解决方法 我们可以在【~/.ssh】目录下新建一个config文件配置一下，就可以解决问题 具体步骤 生成 生成第一个ssh key（这里我用的是公司的邮箱） 进入【C:\\Users\\用户名.ssh】，点击鼠标右键-选择Git bash here，这一步很重要，不然在下面输入密钥名称的时候，会将密钥生成在当前打开git bash的路径下，比如我在桌面打开的git bash，就会生成在桌面上，当然也可以在输入名称前将路径补全。如下图： ssh-keygen -t rsa -C \"yourmail@glanway.com\" 在输入文件名及路径的时候，生成的密钥命名为【id_rsa_gitlab】,下面连续回车，没有给密钥设置密码（看个人需求） 生成第二个ssh key（这里用的我的GitHub邮箱） ssh-keygen -t rsa -C \"yourmail@qq.com\" 生成后的文件如下图： 执行ssh-agent命令 ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程 添加私钥，执行下面命令 ssh-add ~/.ssh/id_rsa_github ssh-add ~/.ssh/id_rsa_gitlab 在执行上面的添加私钥命令时，如果出现如下错误： 解决方法如下： 输入如下命令查看已开启的ssh-agent线程 ps aux | grep ssh 执行如下命令杀死线程： kill -9 线程号 进入用户名目录下的.ssh目录，打开git bash，执行如下命令 exec ssh-agent bash eval ssh-agent -s 再执行如下命令，将私钥放进去 ssh-add ./id_rsa_github ssh-add ./id_rsa_gitlab 创建并修改config文件 创建config文件，将文件创建在【.ssh】目录下 4.1 在windows下新建一个txt文本，然后将名字改成config（包括.txt后缀） 4.2 在git bash下,直接touch config即可创建一个config文件 编辑config文件,修改如下内容： gitlab Host gitool.glanway.com HostName gitool.glanway.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab User mingyue github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User mingyue 配置文件说明： 每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令 例如： Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithub git clone git@mygithub:PopFisher/AndroidRotateAnim.git 就相当于你配置的HostName真正的域名，映射成了Host后面的配置的名字 HostName #这个是真实的域名地址 IdentityFile #这里是id_rsa的地址 PreferredAuthentications #配置登录时用什么权限认证--可设置publickey,password publickey,keyboard-interactive等 User #配置使用用户名 【注意】不要在配置文件中添加下面这样的注释 这种注释在读取该配置文件时会导致报错，不被识别 HostName git.glanway.com //这里填你们公司的git网址即可 ","date":"2022-06-05","objectID":"/git-install-note/:3:1","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"3|2生成单个ssh key 输入如下命令， ssh-keygen -t rsa -C \"yourmail@xxxl.com\" 生成单个SSH Key时可以连续回车，不输入密钥文件名字和密码: 生成后会在【C:\\Users\\用户名.ssh】下产生两个文件，如图： ","date":"2022-06-05","objectID":"/git-install-note/:3:2","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"4|0将公钥添加到gitlab或者GitHub上 找到GitLab或者GitHub的SSH Key设置，将生成的*.pub文件内容添加进去 ","date":"2022-06-05","objectID":"/git-install-note/:4:0","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Operation","note"],"content":"5|0测试 输入如下代码，见到下图即配置成功 ssh -T git@github.com ssh -T git@gitool.glanway.com ","date":"2022-06-05","objectID":"/git-install-note/:5:0","tags":["Git","Install","Windows"],"title":"Git安装以及配置SSH Key","uri":"/git-install-note/"},{"categories":["Back","note"],"content":"记录Swagger报错No operations defined in spec!解决办法","date":"2022-06-05","objectID":"/swagger-no-operations-defined-in-spec-error/","tags":["Python"],"title":"Swagger报错No operations defined in spec!解决 ","uri":"/swagger-no-operations-defined-in-spec-error/"},{"categories":["Back","note"],"content":"分析 Swagger报错No operations defined in spec! 一般有2个原因： basePackage错误； path错误； 第1个basePackage错误，主要是扫描的包内没有controller，或者controller类上没有@Controller注解。 其中第2个path错误，path要是全匹配url，url是完整的，包含方法的url，本人因为path只写controller上的url，没写方法上的url，找了1天也没找到原因，看之前项目才发现url不是完整的url；如果不是完整的url，正则是/path/rest/pic/.*， 正则是 .* 完整可用的配置类如下： @Configuration @EnableSwagger2 public class Swagger2Config { @Value(\"${swagger.enable}\") boolean swagger2enable; @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(swagger2enable) .select() .apis(RequestHandlerSelectors.basePackage(\"com.test.controller\")) .paths(doFilteringRules()) .build(); } private Predicate\u003cString\u003e doFilteringRules() { // return PathSelectors.any(); // return PathSelectors.regex(\"/report/.*\"); // return Predicates.not(PathSelectors.regex(\"/error.*\")); // return or(regex(\"/hello.*\"), regex(\"/rest/adxSspFinanceManagement.*\"));//success return or(regex(\"/rest/pic/url/query\"), //此处必须为完整的url，到方法级别 regex(\"/rest/text/url/query/.*\") //部分url的正则是 .* // regex(\"/api/v1/pop/bms/audit/.*\") ); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Check APIs\") .description(\" 测试环境地址：http://10.179.88.216:8083\") .termsOfServiceUrl(\"http://10.179.88.216:8083\") .contact(\"开发团队\") .version(\"1.0\") .build(); } } ","date":"2022-06-05","objectID":"/swagger-no-operations-defined-in-spec-error/:1:0","tags":["Python"],"title":"Swagger报错No operations defined in spec!解决 ","uri":"/swagger-no-operations-defined-in-spec-error/"},{"categories":["Back"],"content":"记录处理Swagger报错 Could not resolve pointer: /definitions/String does not exist in document","date":"2022-06-05","objectID":"/swagger-could-not-resolve-pointer-error/","tags":["Swagger","note"],"title":"Swagger报错Could not resolve pointer: /definitions/String does not exist in document","uri":"/swagger-could-not-resolve-pointer-error/"},{"categories":["Back"],"content":"报错 Errors Hide Resolver error at paths./tasks/detail.post.parameters.0.schema.$ref Could not resolve reference because of: Could not resolve pointer: /definitions/String does not exist in document ","date":"2022-06-05","objectID":"/swagger-could-not-resolve-pointer-error/:1:0","tags":["Swagger","note"],"title":"Swagger报错Could not resolve pointer: /definitions/String does not exist in document","uri":"/swagger-could-not-resolve-pointer-error/"},{"categories":["Back"],"content":"解决 把版本升级到2.9.2版本中同样的存在问题 结果解决其实很简单 String 改成小写的 就不报错了~ ~ ","date":"2022-06-05","objectID":"/swagger-could-not-resolve-pointer-error/:2:0","tags":["Swagger","note"],"title":"Swagger报错Could not resolve pointer: /definitions/String does not exist in document","uri":"/swagger-could-not-resolve-pointer-error/"},{"categories":["Back"],"content":"反思 查询一番: dataType ：参数的数据类型。 (参数类型，可传基本类型、类、泛型类等) 不知道有没有人遇到,反正记录一下~ ~ ","date":"2022-06-05","objectID":"/swagger-could-not-resolve-pointer-error/:3:0","tags":["Swagger","note"],"title":"Swagger报错Could not resolve pointer: /definitions/String does not exist in document","uri":"/swagger-could-not-resolve-pointer-error/"},{"categories":["Front","note"],"content":"记录解决Vue处理超过16位数字精度丢失问题","date":"2022-06-05","objectID":"/vue-longid-len-error/","tags":["Vue","Json"],"title":"解决Vue处理超过16位数字精度丢失问题","uri":"/vue-longid-len-error/"},{"categories":["Front","note"],"content":"当我们使用MyBatis-Plus 使用 ID_WORKER 或者 ASSIGN_ID(雪花算法) 生成的id作为主键时，因为其长度,为19位，而前端一般能处理16位，如果不处理的话在前端会造成精度丢失，最后两位会变成00，如下图，感觉像是四舍五入后的效果。 处理这种问题有两种方案，要么后端出处理，要么前端处理 后端处理： 直接把id类型改为String就行，这样是可以，但是我们如果非要用Long呢？ 我们可以给对应的实体类主键属性加入注解@JsonSerialize import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; @JsonSerialize(using = ToStringSerializer.class) @TableId private Long id; 前端处理： 前端一般都是用axios进行数据请求，我们通过引入json-bigint来解决 yarnaddjson-bigint//或npminstalljson-bigint 在封装的请求工具类中添加如下代码即可。 axios.defaults.transformResponse = [ function (data) { const json = JSONBIG({ storeAsString: true }) const res = json.parse(data) return res } ] 两种方案皆可。 ","date":"2022-06-05","objectID":"/vue-longid-len-error/:0:0","tags":["Vue","Json"],"title":"解决Vue处理超过16位数字精度丢失问题","uri":"/vue-longid-len-error/"},{"categories":["Back"],"content":"记录上线后数据库出现 too many connection问题的解决办法","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Back"],"content":"Mysql 查看连接数,状态 最大并发数 发包后，程序出错，看到了大量的too many connection。。 这是数据库的没有做好优化导致，用mysql来说，他的默认最大连接数的150，如果不优化很快就会超负荷，导致无法继续调用，程序自然会出现错误。。 ","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/:1:0","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Back"],"content":"优化过程 ","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/:2:0","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Back"],"content":"1、进入数据库查看链接状态： mysql\u003eshow status like ‘Threads%’; mysql\u003eshow processlist; +——————-+——-+ | Variable_name | Value | +——————-+——-+ | Threads_cached | 58 | | Threads_connected | 40 | ###这个数值指的是打开的连接数 | Threads_created | 70 | | Threads_running | 1 | ###这个数值指的是激活的连接数，这个数值一般远低于connected数值 +——————-+——-+ 这两个命令返回参数差不多。 ","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/:2:1","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Back"],"content":"2、查看当前设置最大连接数： mysql\u003eshow variables like ‘%max_connections%’; +—————–+——-+ | Variable_name | Value | +—————–+——-+ | max_connections | 151 | +—————–+——-+ 这个其实可以在mysql的主配置文件当中去修改 可以在/etc/my.cnf里面设置数据库的最大连接数 [mysqld] max_connections = 1000 也可以在命令行直接修改： mysql\u003eset GLOBAL max_connections=连接数; mysql\u003eflush privileges; ","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/:2:2","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Back"],"content":"3、查看当前连接数 mysql\u003eshow processlist 显示当前正在执行的MySQL连接 完美解决too many connection 问题。。。。 ","date":"2022-06-05","objectID":"/mysql-too-many-connection-error/:2:3","tags":["Database","Mysql","Error"],"title":"上线后数据库出现 too many connection问题","uri":"/mysql-too-many-connection-error/"},{"categories":["Operation","note"],"content":"记录Nginx笔记","date":"2022-06-05","objectID":"/nginx-note/","tags":["Nginx","Server"],"title":"Nginx笔记","uri":"/nginx-note/"},{"categories":["Operation","note"],"content":"Nginx请求转发配置 ","date":"2022-06-05","objectID":"/nginx-note/:1:0","tags":["Nginx","Server"],"title":"Nginx笔记","uri":"/nginx-note/"},{"categories":["Operation","note"],"content":"1、请求转发配置项 location ~ /eduservice/ { proxy_pass http://127.0.0.1:8001; } location ~ /eduoss/ { proxy_pass http://127.0.0.1:8002; } 1、~代表进行正则匹配。 2、背后的代表路径，如果请求地址包含这个路径就进行转发。 3、proxy_pass 背后的是要转发的地址 ","date":"2022-06-05","objectID":"/nginx-note/:1:1","tags":["Nginx","Server"],"title":"Nginx笔记","uri":"/nginx-note/"},{"categories":["Operation","note"],"content":"2、使用 server { listen 9001; server_name localhost; # charset koi8 - r; # access_log logs / host.access.log main; location~/eduservice/ { proxy_pass http: //127.0.0.1:8001; } location~/eduoss/ { proxy_pass http: //127.0.0.1:8002; } # error_page 404 / 404. html; # redirect server error pages to the static page / 50 x.html# error_page 500 502 503 504 / 50 x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } ","date":"2022-06-05","objectID":"/nginx-note/:1:2","tags":["Nginx","Server"],"title":"Nginx笔记","uri":"/nginx-note/"},{"categories":["Back"],"content":"记录IDEA使用Maven创建module出现Ignored pom.xml解决方法","date":"2022-06-05","objectID":"/idea-maven-ignored-pom/","tags":["Idea","Maven","Pom","Error"],"title":"IDEA使用Maven创建module出现Ignored pom.xml报错","uri":"/idea-maven-ignored-pom/"},{"categories":["Back"],"content":"1、问题描述 在创建Maven项目时，创建module时没有正确创建，出现ignored pom,xml问题，如上图； ","date":"2022-06-05","objectID":"/idea-maven-ignored-pom/:1:0","tags":["Idea","Maven","Pom","Error"],"title":"IDEA使用Maven创建module出现Ignored pom.xml报错","uri":"/idea-maven-ignored-pom/"},{"categories":["Back"],"content":"2、原因解析 由于相同名称的module在之前被创建过，在IDEA中留有痕迹。重新创建一个新的同名module会让IDEA误以为是之前被删除掉的module，所以才自动将这个pom.xml文件忽略。 ","date":"2022-06-05","objectID":"/idea-maven-ignored-pom/:2:0","tags":["Idea","Maven","Pom","Error"],"title":"IDEA使用Maven创建module出现Ignored pom.xml报错","uri":"/idea-maven-ignored-pom/"},{"categories":["Back"],"content":"3、解决方法 1. 选择“File——Settings”命令； 2. 选择Build,Execution,Deployment选项底下的\"Build Tools\"中的“Maven”底下的“Ignored Files”选项，取消勾选，单击ok。 3. 点击右上角maven项目，点击刷新，即可恢复。如图所示； 这样pom.xml就会恢复原状啦！ ","date":"2022-06-05","objectID":"/idea-maven-ignored-pom/:3:0","tags":["Idea","Maven","Pom","Error"],"title":"IDEA使用Maven创建module出现Ignored pom.xml报错","uri":"/idea-maven-ignored-pom/"},{"categories":["Back","note"],"content":"记录Java枚举笔记","date":"2022-06-05","objectID":"/java-enum-note/","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举类型介绍 　枚举类型（Enumerated Type） 很早就出现在编程语言中，它被用来将一组类似的值包含到一种类型当中。而这种枚举类型的名称则会被定义成独一无二的类型描述符，在这一点上和常量的定义相似。不过相比较常量类型，枚举类型可以为申明的变量提供更大的取值范围。 ","date":"2022-06-05","objectID":"/java-enum-note/:1:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"QuickStart 使用enum作为关键字。 枚举类型的常用在一个函数多个不同的返回状态，如果是两个返回状态可以使用boolean类型，但是如果是多个返回类型状态(情况)时需要使用枚举类型。 尽量不要使用int类型作为返回值，因为这样可以随时修改返回值的值，程序也不会报错。 boolean类型也是特殊的枚举类型。 枚举是一种引用数据类型 枚举类型怎么定义，语法是？ enum 枚举类型名{ 枚举值1,枚举值2 } 结果只有两种情况的，建议使用布尔类型。结果超过两种并且还是可以一枚一枚列举出来的，建议使用枚举类型。例如：颜色、四季、星期等都可以使用枚举类型。 枚举中的每一个值，可以看做是“常量” 枚举编译之后也是生成class文件。 ","date":"2022-06-05","objectID":"/java-enum-note/:2:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"理解枚举类型 枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。下面先来看看什么是枚举？如何定义枚举？ ","date":"2022-06-05","objectID":"/java-enum-note/:3:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举的定义 回忆一下下面的程序，这是在没有枚举类型时定义常量常见的方式 //使用普通方式定义日期常量 public class DayDemo { public static final int MONDAY =1; public static final int TUESDAY=2; public static final int WEDNESDAY=3; public static final int THURSDAY=4; public static final int FRIDAY=5; public static final int SATURDAY=6; public static final int SUNDAY=7; } 上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，但它存在许多不足，存在着一些问题。 类型不安全 由于颜色常量的对应值是整数形，所以程序执行过程中很有可能给颜色变量传入一个任意的整数值，导致出现错误。 没有命名空间 由于颜色常量只是类的属性，当你使用的时候不得不通过类来访问。 一致性差 因为整形枚举属于编译期常量，所以编译过程完成后，所有客户端和服务器端引用的地方，会直接将整数值写入。这样，当你修改旧的枚举整数值后或者增加新的枚举值后，所有引用地方代码都需要重新编译，否则运行时刻就会出现错误。 类型无指意性 由于颜色枚举值仅仅是一些无任何含义的整数值，如果在运行期调试时候，你就会发现日志中有很多魔术数字，但除了程序员本身，其他人很难明白其奥秘。 如在类型安全和使用方便性上并没有多少好处，如果存在定义int值相同的变量，混淆的几率还是很大的，编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡， 为了改进 Java 语言在这方面的不足弥补缺陷，5.0 版本 SDK 发布时候，在语言层面上增加了枚举类型。枚举类型的定义也非常的简单，用 enum 关键字加上名称和大括号包含起来的枚举值体即可， 现在我们利用枚举类型来重新定义上述的常量，同时也感受一把枚举定义的方式，如下定义周一到周日的常量 //枚举类型，使用关键字enum enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } 相当简洁，在定义枚举类型时我们使用的关键字是enum，与class关键字类似，只不过前者是定义枚举类型，后者是定义类类型。枚举类型Day中分别定义了从周一到周日的值，这里要注意，值一般是大写的字母，多个值之间以逗号分隔。 从上面的定义形式来看，似乎 Java 中的枚举类型很简单，但实际上 Java 语言规范赋予枚举类型的功能非常的强大，它不仅是简单地将整形数值转换成对象，而是将枚举类型定义转变成一个完整功能的类定义。这种类型定义的扩展允许开发者给枚举类型增加任何方法和属性，也可以实现任意的接口。另外，Java 平台也为 Enum 类型提供了高质量的实现，比如默认实现 Comparable 和 Serializable 接口，让开发者一般情况下不用关心这些细节。 回到本文的主题上来，引入枚举类型到底能够给我们开发带来什么样好处呢？一个最直接的益处就是扩大 switch 语句使用范围。5.0 之前，Java 中 switch 的值只能够是简单类型，比如 int、long、char, 有了枚举类型之后，就可以使用对象了。这样一来，程序的控制选择就变得更加的方便，看下面的例子： // 定义一周七天的枚举类型 public enum WeekDayEnum { Mon, Tue, Wed, Thu, Fri, Sat, Sun } // 读取当天的信息 WeekDayEnum today = readToday(); // 根据日期来选择进行活动 switch(today) { Mon: do something; break; Tue: do something; break; Wed: do something; break; Thu: do something; break; Fri: do something; break; Sat: play sports game; break; Sun: have a rest; break; } 对于这些枚举的日期，JVM 都会在运行期构造成出一个简单的对象实例一一对应。这些对象都有唯一的 identity，类似整形数值一样，switch 语句就根据此来进行执行跳转。 同时我们应该知道的是枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的，比如上述描述的一周共有七天。那么该如何使用呢？如下： public class EnumDemo { public static void main(String[] args){ Day day =Day.MONDAY;//直接引用 System.out.println(day == Day.MONDAY ? \"周一\" : \"不是周一\"); } } // 枚举：一枚一枚可以列举出来的，才建议使用枚举类型。 // 枚举编译之后也是生成class文件。 // 枚举也是一种引用数据类型。 // 枚举中的每一个值可以看做是常量。 //定义枚举类型 enum Day { //都是枚举Result类型中的一个值,枚举中的每一个值，可以看做是“常量” MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } 就像上述代码那样，直接引用枚举的值即可，这便是枚举类型的最简单模型。 ","date":"2022-06-05","objectID":"/java-enum-note/:3:1","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举实现原理 我们大概了解了枚举类型的定义与简单使用后，现在有必要来了解一下枚举类型的基本实现原理。实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。下面我们编译前面定义的EnumDemo.java并查看生成的class文件来验证这个结论： //查看目录下的java文件 wqd$ ls EnumDemo.java //利用javac命令编译EnumDemo.java wqd$ javac EnumDemo.java //查看生成的class文件，注意有Day.class和EnumDemo.class 两个 wqdd$ ls Day.class EnumDemo.class EnumDemo.java 利用javac编译前面定义的EnumDemo.java文件后分别生成了Day.class和EnumDemo.class文件，而Day.class就是枚举类型，这也就验证前面所说的使用关键字enum定义枚举类型并编译后，编译器会自动帮助我们生成一个与枚举相关的类。我们再来看看反编译Day.class文件： //反编译Day.class final class Day extends Enum { //编译器为我们添加的静态的values()方法 public static Day[] values() { return (Day[])$VALUES.clone(); } //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static Day valueOf(String s) { return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s); } //私有构造函数 private Day(String s, int i) { super(s, i); } //前面定义的7种枚举实例 public static final Day MONDAY; public static final Day TUESDAY; public static final Day WEDNESDAY; public static final Day THURSDAY; public static final Day FRIDAY; public static final Day SATURDAY; public static final Day SUNDAY; private static final Day $VALUES[]; static { //实例化枚举实例 MONDAY = new Day(\"MONDAY\", 0); TUESDAY = new Day(\"TUESDAY\", 1); WEDNESDAY = new Day(\"WEDNESDAY\", 2); THURSDAY = new Day(\"THURSDAY\", 3); FRIDAY = new Day(\"FRIDAY\", 4); SATURDAY = new Day(\"SATURDAY\", 5); SUNDAY = new Day(\"SUNDAY\", 6); $VALUES = (new Day[] { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }); } } 从反编译的代码可以看出编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()。ok~，到此相信我们对枚举的实现原理也比较清晰，下面我们深入了解一下java.lang.Enum类以及values()和valueOf()的用途。 ","date":"2022-06-05","objectID":"/java-enum-note/:3:2","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举的常见方法 Enum抽象类常见方法 Enum是所有 Java 语言枚举类型的公共基本类（注意Enum是抽象类），以下是它的常见方法： 返回类型 方法名称 方法说明 int compareTo(E o) 比较此枚举与指定对象的顺序 boolean equals(Object other) 当指定对象等于此枚举常量时，返回 true。 Class getDeclaringClass() 返回与此枚举常量的枚举类型相对应的 Class 对象 String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明 int ordinal() 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零） String toString() 返回枚举常量的名称，它包含在声明中 static\u003e T static valueOf(Class enumType, String name) 返回带指定名称的指定枚举类型的枚举常量。 这里主要说明一下ordinal()方法，该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法，毕竟它总是变幻莫测的。compareTo(E o)方法则是比较枚举的大小，注意其内部实现是根据每个枚举的ordinal值大小进行比较的。name()方法与toString()几乎是等同的，都是输出变量的字符串形式。至于valueOf(Class enumType, String name)方法则是根据枚举类的Class对象和枚举名称获取枚举常量，注意该方法是静态的，后面在枚举单例时，我们还会详细分析该方法，下面的代码演示了上述方法： public class EnumDemo { public static void main(String[] args){ //创建枚举数组 Day[] days=new Day[]{Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.THURSDAY, Day.FRIDAY, Day.SATURDAY, Day.SUNDAY}; for (int i = 0; i \u003cdays.length ; i++) { System.out.println(\"day[\"+i+\"].ordinal():\"+days[i].ordinal()); } System.out.println(\"-------------------------------------\"); //通过compareTo方法比较,实际上其内部是通过ordinal()值比较的 System.out.println(\"days[0].compareTo(days[1]):\"+days[0].compareTo(days[1])); System.out.println(\"days[0].compareTo(days[1]):\"+days[0].compareTo(days[2])); //获取该枚举对象的Class对象引用,当然也可以通过getClass方法 Class\u003c?\u003e clazz = days[0].getDeclaringClass(); System.out.println(\"clazz:\"+clazz); System.out.println(\"-------------------------------------\"); //name() System.out.println(\"days[0].name():\"+days[0].name()); System.out.println(\"days[1].name():\"+days[1].name()); System.out.println(\"days[2].name():\"+days[2].name()); System.out.println(\"days[3].name():\"+days[3].name()); System.out.println(\"-------------------------------------\"); System.out.println(\"days[0].toString():\"+days[0].toString()); System.out.println(\"days[1].toString():\"+days[1].toString()); System.out.println(\"days[2].toString():\"+days[2].toString()); System.out.println(\"days[3].toString():\"+days[3].toString()); System.out.println(\"-------------------------------------\"); Day d=Enum.valueOf(Day.class,days[0].name()); Day d2=Day.valueOf(Day.class,days[0].name()); System.out.println(\"d:\"+d); System.out.println(\"d2:\"+d2); } /** 执行结果: day[0].ordinal():0 day[1].ordinal():1 day[2].ordinal():2 day[3].ordinal():3 day[4].ordinal():4 day[5].ordinal():5 day[6].ordinal():6 ------------------------------------- days[0].compareTo(days[1]):-1 days[0].compareTo(days[1]):-2 clazz:class com.zejian.enumdemo.Day ------------------------------------- days[0].name():MONDAY days[1].name():TUESDAY days[2].name():WEDNESDAY days[3].name():THURSDAY ------------------------------------- days[0].toString():MONDAY days[1].toString():TUESDAY days[2].toString():WEDNESDAY days[3].toString():THURSDAY ------------------------------------- d:MONDAY d2:MONDAY */ } enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } 到此对于抽象类Enum类的基本内容就介绍完了，这里提醒大家一点，Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的，不妨看看Enum类的主要源码： //实现了Comparable public abstract class Enum\u003cE extends Enum\u003cE\u003e\u003e implements Comparable\u003cE\u003e, Serializable { private final String name; //枚举字符串名称 public final String name() { return name; } private final int ordinal;//枚举顺序值 public final int ordinal() { return ordinal; } //枚举的构造方法，只能由编译器调用 protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } public String toString() { return name; } public final boolean equals(Object other) { return this==other; } //比较的是ordinal值 public final int compareTo(E o) { Enum\u003c?\u003e other = (Enum\u003c?\u003e)o; Enum\u003cE\u003e self = this; if (self.getClass() != other.getClass() \u0026\u0026 // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal;//根据ordinal值比较大小 } @SuppressWarnings(\"unchecked\") public final Class\u003cE\u003e getDeclaringClass() { //获取class对象引用，getClass()是Object的方法 Class\u003c?\u003e clazz = getClass(); //获取父类Class对象引用 Class\u003c?\u003e zuper =","date":"2022-06-05","objectID":"/java-enum-note/:3:3","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举与Class对象 上述我们提到当枚举实例向上转型为Enum类型后，values()方法将会失效，也就无法一次性获取所有枚举实例变量，但是由于Class对象的存在，即使不使用values()方法，还是有可能一次获取到所有枚举实例变量的，在Class对象中存在如下方法： 返回类型 方法名称 方法说明 T[] getEnumConstants() 返回该枚举类型的所有元素，如果Class对象不是枚举类型，则返回null。 boolean isEnum() 当且仅当该类声明为源代码中的枚举时返回 true 因此通过getEnumConstants()方法，同样可以轻而易举地获取所有枚举实例变量下面通过代码来演示这个功能： //正常使用 Day[] ds=Day.values(); //向上转型Enum Enum e = Day.MONDAY; //无法调用,没有此方法 //e.values(); //获取class对象引用 Class\u003c?\u003e clasz = e.getDeclaringClass(); if(clasz.isEnum()) { Day[] dsz = (Day[]) clasz.getEnumConstants(); System.out.println(\"dsz:\"+Arrays.toString(dsz)); } /** 输出结果: dsz:[MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY] */ 正如上述代码所展示，通过Enum的class对象的getEnumConstants方法，我们仍能一次性获取所有的枚举实例常量。 ","date":"2022-06-05","objectID":"/java-enum-note/:4:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举的进阶用法 在前面的分析中，我们都是基于简单枚举类型的定义，也就是在定义枚举时只定义了枚举实例类型，并没定义方法或者成员变量，实际上使用关键字enum定义的枚举类，除了不能使用继承(因为编译器会自动为我们继承Enum抽象类而Java只支持单继承，因此枚举类是无法手动实现继承的)，可以把enum类当成常规类，也就是说我们可以向enum类中添加方法和变量，甚至是mian方法，下面就来感受一把。 ","date":"2022-06-05","objectID":"/java-enum-note/:5:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"向enum类添加方法与自定义构造函数 重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下： public enum Day2 { MONDAY(\"星期一\"), TUESDAY(\"星期二\"), WEDNESDAY(\"星期三\"), THURSDAY(\"星期四\"), FRIDAY(\"星期五\"), SATURDAY(\"星期六\"), SUNDAY(\"星期日\");//记住要用分号结束 private String desc;//中文描述 /** * 私有构造,防止被外部调用 * @param desc */ private Day2(String desc){ this.desc=desc; } /** * 定义方法,返回描述,跟常规类的定义没区别 * @return */ public String getDesc(){ return desc; } public static void main(String[] args){ for (Day2 day:Day2.values()) { System.out.println(\"name:\"+day.name()+ \",desc:\"+day.getDesc()); } } /** 输出结果: name:MONDAY,desc:星期一 name:TUESDAY,desc:星期二 name:WEDNESDAY,desc:星期三 name:THURSDAY,desc:星期四 name:FRIDAY,desc:星期五 name:SATURDAY,desc:星期六 name:SUNDAY,desc:星期日 */ } 从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。但是我们必须注意到，如果打算在enum类中定义方法，务必在声明完枚举实例后使用分号分开，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过，同时即使自定义了构造函数且enum的定义结束，我们也永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。 ","date":"2022-06-05","objectID":"/java-enum-note/:5:1","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"关于覆盖enum类方法 既然enum类跟常规类的定义没什么区别（实际上enum还是有些约束的），那么覆盖父类的方法也不会是什么难说，可惜的是父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法，如下通过覆盖toString省去了getDesc方法： public enum Day2 { MONDAY(\"星期一\"), TUESDAY(\"星期二\"), WEDNESDAY(\"星期三\"), THURSDAY(\"星期四\"), FRIDAY(\"星期五\"), SATURDAY(\"星期六\"), SUNDAY(\"星期日\");//记住要用分号结束 private String desc;//中文描述 /** * 私有构造,防止被外部调用 * @param desc */ private Day2(String desc){ this.desc=desc; } /** * 覆盖 * @return */ @Override public String toString() { return desc; } public static void main(String[] args){ for (Day2 day:Day2.values()) { System.out.println(\"name:\"+day.name()+ \",desc:\"+day.toString()); } } /** 输出结果: name:MONDAY,desc:星期一 name:TUESDAY,desc:星期二 name:WEDNESDAY,desc:星期三 name:THURSDAY,desc:星期四 name:FRIDAY,desc:星期五 name:SATURDAY,desc:星期六 name:SUNDAY,desc:星期日 */ } ","date":"2022-06-05","objectID":"/java-enum-note/:5:2","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"enum类中定义抽象方法 与常规抽象类一样，enum类允许我们为其定义抽象方法，然后使每个枚举实例都实现该方法，以便产生不同的行为方式，注意abstract关键字对于枚举类来说并不是必须的如下： public enum EnumDemo3 { FIRST{ @Override public String getInfo() { return \"FIRST TIME\"; } }, SECOND{ @Override public String getInfo() { return \"SECOND TIME\"; } } ; /** * 定义抽象方法 * @return */ public abstract String getInfo(); //测试 public static void main(String[] args){ System.out.println(\"F:\"+EnumDemo3.FIRST.getInfo()); System.out.println(\"S:\"+EnumDemo3.SECOND.getInfo()); /** 输出结果: F:FIRST TIME S:SECOND TIME */ } } 通过这种方式就可以轻而易举地定义每个枚举实例的不同行为方式。我们可能注意到，enum类的实例似乎表现出了多态的特性，可惜的是枚举类型的实例终究不能作为类型传递使用，就像下面的使用方式，编译器是不可能答应的： //无法通过编译,毕竟EnumDemo3.FIRST是个实例对象 public void text(EnumDemo3.FIRST instance){ } 在枚举实例常量中定义抽象方法 ","date":"2022-06-05","objectID":"/java-enum-note/:5:3","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"enum类与接口 由于Java单继承的原因，enum类并不能再继承其它类，但并不妨碍它实现接口，因此enum类同样是可以实现多接口的，如下： interface food{ void eat(); } interface sport{ void run(); } public enum EnumDemo2 implements food ,sport{ FOOD, SPORT, ; //分号分隔 @Override public void eat() { System.out.println(\"eat.....\"); } @Override public void run() { System.out.println(\"run.....\"); } } 有时候，我们可能需要对一组数据进行分类，比如进行食物菜单分类而且希望这些菜单都属于food类型，appetizer(开胃菜)、mainCourse(主菜)、dessert(点心)、Coffee等，每种分类下有多种具体的菜式或食品，此时可以利用接口来组织，如下(代码引用自Thinking in Java)： public interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS; } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; } } public class TypeOfFood { public static void main(String[] args) { Food food = Appetizer.SALAD; food = MainCourse.LASAGNE; food = Dessert.GELATO; food = Coffee.CAPPUCCINO; } } 通过这种方式可以很方便组织上述的情景，同时确保每种具体类型的食物也属于Food，现在我们利用一个枚举嵌套枚举的方式，把前面定义的菜谱存放到一个Meal菜单中，通过这种方式就可以统一管理菜单的数据了。 public enum Meal{ APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Meal(Class\u003c? extends Food\u003e kind) { //通过class对象获取枚举实例 values = kind.getEnumConstants(); } public interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS; } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; } } } ","date":"2022-06-05","objectID":"/java-enum-note/:5:4","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举与switch 关于枚举与switch是个比较简单的话题，使用switch进行条件判断时，条件参数一般只能是整型，字符型。而枚举型确实也被switch所支持，在java 1.7后switch也对字符串进行了支持。这里我们简单看一下switch与枚举类型的使用： enum Color {GREEN,RED,BLUE} public class EnumDemo4 { public static void printName(Color color){ switch (color){ case BLUE: //无需使用Color进行引用 System.out.println(\"蓝色\"); break; case RED: System.out.println(\"红色\"); break; case GREEN: System.out.println(\"绿色\"); break; } } public static void main(String[] args){ printName(Color.BLUE); printName(Color.RED); printName(Color.GREEN); //蓝色 //红色 //绿色 } } 需要注意的是使用在于switch条件进行结合使用时，无需使用Color引用。 ","date":"2022-06-05","objectID":"/java-enum-note/:6:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举与单例模式 单例模式可以说是最常使用的设计模式了，它的作用是确保某个类只有一个实例，自行实例化并向整个系统提供这个实例。在实际应用中，线程池、缓存、日志对象、对话框对象常被设计成单例，总之，选择单例模式就是为了避免不一致状态，下面我们将会简单说明单例模式的几种主要编写方式，从而对比出使用枚举实现单例模式的优点。首先看看饿汉式的单例模式： // 饿汉式（基于classloder机制避免了多线程的同步问题） public class SingletonHungry { private static SingletonHungry instance = new SingletonHungry(); private SingletonHungry() { } public static SingletonHungry getInstance() { return instance; } } 显然这种写法比较简单，但问题是无法做到延迟创建对象，事实上如果该单例类涉及资源较多，创建比较耗时间时，我们更希望它可以尽可能地延迟加载，从而减小初始化的负载，于是便有了如下的懒汉式单例： // 懒汉式单例模式（适合多线程安全） public class SingletonLazy { private static volatile SingletonLazy instance; private SingletonLazy() { } public static synchronized SingletonLazy getInstance() { if (instance == null) { instance = new SingletonLazy(); } return instance; } } 这种写法能够在多线程中很好的工作避免同步问题，同时也具备lazy loading机制，遗憾的是，由于synchronized的存在，效率很低，在单线程的情景下，完全可以去掉synchronized，为了兼顾效率与性能问题，改进后代码如下： public class Singleton { private static volatile Singleton singleton = null; private Singleton(){} public static Singleton getSingleton(){ if(singleton == null){ synchronized (Singleton.class){ if(singleton == null){ singleton = new Singleton(); } } } return singleton; } } 这种编写方式被称为“双重检查锁”，主要在getSingleton()方法中，进行两次null检查。这样可以极大提升并发度，进而提升性能。毕竟在单例中new的情况非常少，绝大多数都是可以并行的读操作，因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，也就提高了执行效率。但是必须注意的是volatile关键字，该关键字有两层语义。第一层语义是可见性，可见性是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化，我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题，值得关注的是volatile的禁止指令重排序优化功能在Java 1.5后才得以实现，因此1.5前的版本仍然是不安全的，即使使用了volatile关键字。或许我们可以利用静态内部类来实现更安全的机制，静态内部类单例模式如下： //静态内部类 public class SingletonInner { private static class Holder { private static SingletonInner singleton = new SingletonInner(); } private SingletonInner(){} public static SingletonInner getSingleton(){ return Holder.singleton; } } 正如上述代码所展示的，我们把Singleton实例放到一个静态内部类中，这样可以避免了静态实例在Singleton类的加载阶段（类加载过程的其中一个阶段的，此时只创建了Class对象，关于Class对象可以看博主另外一篇博文，深入理解Java类型信息(Class对象)与反射机制）就创建对象，毕竟静态变量初始化是在SingletonInner类初始化时触发的，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的。从上述4种单例模式的写法中，似乎也解决了效率与懒加载的问题，但是它们都有两个共同的缺点： 序列化可能会破坏单例模式，比较每次反序列化一个序列化的对象实例时都会创建一个新的实例，解决方案如下： //测试例子(四种写解决方式雷同) public class Singleton implements java.io.Serializable { public static Singleton INSTANCE = new Singleton(); protected Singleton() { } //反序列时直接返回当前INSTANCE private Object readResolve() { return INSTANCE; } } 使用反射强行调用私有构造器，解决方式可以修改构造器，让它在创建第二个实例的时候抛异常，如下： public static Singleton INSTANCE = new Singleton(); private static volatile boolean flag = true; private Singleton(){ if(flag){ flag = false; }else{ throw new RuntimeException(\"The instance already exists ！\"); } } 如上所述，问题确实也得到了解决，但问题是我们为此付出了不少努力，即添加了不少代码，还应该注意到如果单例类维持了其他对象的状态时还需要使他们成为transient的对象，这种就更复杂了，那有没有更简单更高效的呢？当然是有的，那就是枚举单例了，先来看看如何实现： //枚举单例 public enum SingletonEnum { INSTANCE; private String name; public String getName(){ return name; } public void setName(String name){ this.name = name; } } 代码相当简洁，我们也可以像常规类一样编写enum类，为其添加变量和方法，访问方式也更简单，使用SingletonEnum.INSTANCE进行访问，这样也就避免调用getInstance方法，更重要的是使用枚举单例的写法，我们完全不用考虑序列化和反射的问题。枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性，这里我们不妨再次看看Enum类的valueOf方法： public static \u003cT extends Enum\u003cT\u003e\u003e T valueOf(Class\u003cT\u003e enumType, String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(\"Name is null\"); throw new IllegalArgumentException( \"No enum constant \" + enumType.getCanonicalName() + \".\" + name); } 实际上通过调用enumType(Class对象的引用)的enumConstantDirectory方法获取到的是一个Map集合，在该集合中存放了以枚举name为key和以枚举实例变量为value的Key\u0026Value数据，因此通过name的值就可以获取到枚举实例，看看enumConstantDirectory方法源码： Map\u003cString, T\u003e ","date":"2022-06-05","objectID":"/java-enum-note/:7:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"枚举类型相关工具类 DK5.0 中在增加 Enum 类的同时，也增加了两个工具类 EnumSet 和 EnumMap，这两个类都放在 java.util 包中。 ","date":"2022-06-05","objectID":"/java-enum-note/:8:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"EnumMap EnumMap 也是一个高性能的 Map 接口实现，用来管理使用枚举类型作为 keys 的映射表，内部是通过数组方式来实现。EnumMap 将丰富的和安全的 Map 接口与数组快速访问结合到一起，如果你希望要将一个枚举类型映射到一个值，你应该使用 EnumMap。 EnumMap基本用法 先思考这样一个问题，现在我们有一堆size大小相同而颜色不同的数据，需要统计出每种颜色的数量是多少以便将数据录入仓库，定义如下枚举用于表示颜色Color: enum Color { GREEN,RED,BLUE,YELLOW } 我们有如下解决方案，使用Map集合来统计，key值作为颜色名称，value代表衣服数量，如下： public class EnumMapDemo { public static void main(String[] args){ List\u003cClothes\u003e list = new ArrayList\u003c\u003e(); list.add(new Clothes(\"C001\",Color.BLUE)); list.add(new Clothes(\"C002\",Color.YELLOW)); list.add(new Clothes(\"C003\",Color.RED)); list.add(new Clothes(\"C004\",Color.GREEN)); list.add(new Clothes(\"C005\",Color.BLUE)); list.add(new Clothes(\"C006\",Color.BLUE)); list.add(new Clothes(\"C007\",Color.RED)); list.add(new Clothes(\"C008\",Color.YELLOW)); list.add(new Clothes(\"C009\",Color.YELLOW)); list.add(new Clothes(\"C010\",Color.GREEN)); //方案1:使用HashMap Map\u003cString,Integer\u003e map = new HashMap\u003c\u003e(); for (Clothes clothes:list){ String colorName=clothes.getColor().name(); Integer count = map.get(colorName); if(count!=null){ map.put(colorName,count+1); }else { map.put(colorName,1); } } System.out.println(map.toString()); System.out.println(\"---------------\"); //方案2:使用EnumMap Map\u003cColor,Integer\u003e enumMap=new EnumMap\u003c\u003e(Color.class); for (Clothes clothes:list){ Color color=clothes.getColor(); Integer count = enumMap.get(color); if(count!=null){ enumMap.put(color,count+1); }else { enumMap.put(color,1); } } System.out.println(enumMap.toString()); } /** 输出结果: {RED=2, BLUE=3, YELLOW=3, GREEN=2} --------------- {GREEN=2, RED=2, BLUE=3, YELLOW=3} */ } 代码比较简单，我们使用两种解决方案，一种是HashMap，一种EnumMap，虽然都统计出了正确的结果，但是EnumMap作为枚举的专属的集合，我们没有理由再去使用HashMap，毕竟EnumMap要求其Key必须为Enum类型，因而使用Color枚举实例作为key是最恰当不过了，也避免了获取name的步骤，更重要的是EnumMap效率更高，因为其内部是通过数组实现的（稍后分析），注意EnumMap的key值不能为null，虽说是枚举专属集合，但其操作与一般的Map差不多，概括性来说EnumMap是专门为枚举类型量身定做的Map实现，虽然使用其它的Map（如HashMap）也能完成相同的功能，但是使用EnumMap会更加高效，它只能接收同一枚举类型的实例作为键值且不能为null，由于枚举类型实例的数量相对固定并且有限，所以EnumMap使用数组来存放与枚举类型对应的值，毕竟数组是一段连续的内存空间，根据程序局部性原理，效率会相当高。下面我们来进一步了解EnumMap的用法，先看构造函数： //创建一个具有指定键类型的空枚举映射。 EnumMap(Class\u003cK\u003e keyType) //创建一个其键类型与指定枚举映射相同的枚举映射，最初包含相同的映射关系（如果有的话）。 EnumMap(EnumMap\u003cK,? extends V\u003e m) //创建一个枚举映射，从指定映射对其初始化。 EnumMap(Map\u003cK,? extends V\u003e m) 与HashMap不同，它需要传递一个类型信息，即Class对象，通过这个参数EnumMap就可以根据类型信息初始化其内部数据结构，另外两只是初始化时传入一个Map集合，代码演示如下： //使用第一种构造 Map\u003cColor,Integer\u003e enumMap=new EnumMap\u003c\u003e(Color.class); //使用第二种构造 Map\u003cColor,Integer\u003e enumMap2=new EnumMap\u003c\u003e(enumMap); //使用第三种构造 Map\u003cColor,Integer\u003e hashMap = new HashMap\u003c\u003e(); hashMap.put(Color.GREEN, 2); hashMap.put(Color.BLUE, 3); Map\u003cColor, Integer\u003e enumMap = new EnumMap\u003c\u003e(hashMap); enumMap.put(Color.GREEN, 2); System.out.println(enumMap.get(Color.GREEN)); //2 至于EnumMap的方法，跟普通的map几乎没有区别，注意与HashMap的主要不同在于构造方法需要传递类型参数和EnumMap保证Key顺序与枚举中的顺序一致，但请记住Key不能为null。 EnumMap实现原理剖析 EnumMap的源码有700多行，这里我们主要分析其内部存储结构，添加查找的实现，了解这几点，对应EnumMap内部实现原理也就比较清晰了，先看数据结构和构造函数 public class EnumMap\u003cK extends Enum\u003cK\u003e, V\u003e extends AbstractMap\u003cK, V\u003e implements java.io.Serializable, Cloneable { //Class对象引用 private final Class\u003cK\u003e keyType; //存储Key值的数组 private transient K[] keyUniverse; //存储Value值的数组 private transient Object[] vals; //map的size private transient int size = 0; //空map private static final Enum\u003c?\u003e[] ZERO_LENGTH_ENUM_ARRAY = new Enum\u003c?\u003e[0]; //构造函数 public EnumMap(Class\u003cK\u003e keyType) { this.keyType = keyType; keyUniverse = getKeyUniverse(keyType); vals = new Object[keyUniverse.length]; } } EnumMap继承了AbstractMap类，因此EnumMap具备一般map的使用方法，keyType表示类型信息，keyUniverse表示键数组，存储的是所有可能的枚举值，vals数组表示键对应的值，size表示键值对个数。在构造函数中通过keyUniverse = getKeyUniverse(keyType);初始化了keyUniverse数组的值，内部存储的是所有可能的枚举值，接着初始化了存在Value值得数组vals，其大小与枚举实例的个数相同，getKeyUniverse方法实现如下 //返回枚举数组 private static \u003cK extends Enum\u003cK\u003e\u003e K[] getKeyUniverse(Class\u003cK\u003e keyType) { //最终调用到枚举类型的values方法，values方法返回所有可能的枚举值 return SharedSecrets.getJavaLangAccess() .getEnumConstantsShared(keyType); } 从方法的返回值来看，返回类型是枚举数组，事实也是如此，最终返回值正是枚举类型的values方法的返回值，前面我们分析过values方法返回所有可能的枚举值，因此keyUniverse数组存储就是枚举类型的所有可能的枚举值。接着看put方法的实现 public V put(K key, V value) { typeCheck(key);//检测key的类","date":"2022-06-05","objectID":"/java-enum-note/:8:1","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"EnumSet 在其内部，是通过 来实现，。 EnumSet是与枚举类型一起使用的专用 Set 集合，是一个针对枚举类型的高性能的 Set 接口实现，EnumSet 中所有元素都必须是枚举类型。EnumSet 中装入的所有枚举对象都必须是同一种类型，EnumSet 支持在枚举类型的所有值的某个范围中进行迭代。与其他Set接口的实现类HashSet/TreeSet(内部都是用对应的HashMap/TreeMap实现的)不同的是，EnumSet在内部实现是位向量(bit-vector，也就是通过一个 long 型数)(稍后分析)，它是一种极为高效的位运算操作，由于直接存储和操作都是bit，因此EnumSet空间和时间性能都十分可观，足以媲美传统上基于 int 的“位标志”的运算，重要的是我们可像操作set集合一般来操作位运算，这样使用代码更简单易懂同时又具备类型安全的优势。注意EnumSet不允许使用 null 元素。试图插入 null 元素将抛出 NullPointerException，但试图测试判断是否存在null 元素或移除 null 元素则不会抛出异常，与大多数collection 实现一样，EnumSet不是线程安全的，因此在多线程环境下应该注意数据同步问题，ok~，下面先来简单看看EnumSet的使用方式。 EnumSet用法 创建EnumSet并不能使用new关键字，因为它是个抽象类，而应该使用其提供的静态工厂方法，EnumSet的静态工厂方法比较多，如下： //创建一个具有指定元素类型的空EnumSet。 EnumSet\u003cE\u003e noneOf(Class\u003cE\u003e elementType) //创建一个指定元素类型并包含所有枚举值的EnumSet \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e allOf(Class\u003cE\u003e elementType) // 创建一个包括枚举值中指定范围元素的EnumSet \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e range(E from, E to) // 初始集合包括指定集合的补集 \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e complementOf(EnumSet\u003cE\u003e s) // 创建一个包括参数中所有元素的EnumSet \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E e) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E e1, E e2) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E e1, E e2, E e3) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E e1, E e2, E e3, E e4) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e of(E first, E... rest) //创建一个包含参数容器中的所有元素的EnumSet \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e copyOf(EnumSet\u003cE\u003e s) \u003cE extends Enum\u003cE\u003e\u003e EnumSet\u003cE\u003e copyOf(Collection\u003cE\u003e c) 代码演示如下： enum Color { GREEN , RED , BLUE , BLACK , YELLOW } public class EnumSetDemo { public static void main(String[] args){ //空集合 EnumSet\u003cColor\u003e enumSet= EnumSet.noneOf(Color.class); System.out.println(\"添加前：\"+enumSet.toString()); enumSet.add(Color.GREEN); enumSet.add(Color.RED); enumSet.add(Color.BLACK); enumSet.add(Color.BLUE); enumSet.add(Color.YELLOW); System.out.println(\"添加后：\"+enumSet.toString()); System.out.println(\"-----------------------------------\"); //使用allOf创建包含所有枚举类型的enumSet，其内部根据Class对象初始化了所有枚举实例 EnumSet\u003cColor\u003e enumSet1= EnumSet.allOf(Color.class); System.out.println(\"allOf直接填充：\"+enumSet1.toString()); System.out.println(\"-----------------------------------\"); //初始集合包括枚举值中指定范围的元素 EnumSet\u003cColor\u003e enumSet2= EnumSet.range(Color.BLACK,Color.YELLOW); System.out.println(\"指定初始化范围：\"+enumSet2.toString()); System.out.println(\"-----------------------------------\"); //指定补集，也就是从全部枚举类型中去除参数集合中的元素，如下去掉上述enumSet2的元素 EnumSet\u003cColor\u003e enumSet3= EnumSet.complementOf(enumSet2); System.out.println(\"指定补集：\"+enumSet3.toString()); System.out.println(\"-----------------------------------\"); //初始化时直接指定元素 EnumSet\u003cColor\u003e enumSet4= EnumSet.of(Color.BLACK); System.out.println(\"指定Color.BLACK元素：\"+enumSet4.toString()); EnumSet\u003cColor\u003e enumSet5= EnumSet.of(Color.BLACK,Color.GREEN); System.out.println(\"指定Color.BLACK和Color.GREEN元素：\"+enumSet5.toString()); System.out.println(\"-----------------------------------\"); //复制enumSet5容器的数据作为初始化数据 EnumSet\u003cColor\u003e enumSet6= EnumSet.copyOf(enumSet5); System.out.println(\"enumSet6：\"+enumSet6.toString()); System.out.println(\"-----------------------------------\"); List\u003cColor\u003e list = new ArrayList\u003cColor\u003e(); list.add(Color.BLACK); list.add(Color.BLACK);//重复元素 list.add(Color.RED); list.add(Color.BLUE); System.out.println(\"list:\"+list.toString()); //使用copyOf(Collection\u003cE\u003e c) EnumSet enumSet7=EnumSet.copyOf(list); System.out.println(\"enumSet7:\"+enumSet7.toString()); /** 输出结果： 添加前：[] 添加后：[GREEN, RED, BLUE, BLACK, YELLOW] ----------------------------------- allOf直接填充：[GREEN, RED, BLUE, BLACK, YELLOW] ----------------------------------- 指定初始化范围：[BLACK, YELLOW] ----------------------------------- 指定补集：[GREEN, RED, BLUE] ----------------------------------- 指定Color.BLACK元素：[BLACK] 指定Color.BLACK和Color.GREEN元素：[GREEN, BLACK] ----------------------------------- enumSet6：[GREEN, BLACK] ----------------------------------- list:[BLACK, BLACK, RED, BLUE] enumSet7:[RED, BLUE, BLACK] */ } } noneOf(Class elementType)静态方法，主要用于创建一个空的EnumSet集合，传递参数elementType代表的是枚举类型的类型信息，即Class对象。EnumSet allOf(Class elementType)静态方法则是创建一个填充了elementType类型所代表的所有枚举实例","date":"2022-06-05","objectID":"/java-enum-note/:8:2","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"如何避免错误使用枚举类型 　不过在使用 Enum 时候有几个地方需要注意： enum 类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。也正因为如此，所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。 定义 enum 类型时候，如果是简单类型，那么最后一个枚举值后不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号';‘隔开，不能用逗号或空格。 由于 enum 类型的值实际上是通过运行期构造出对象来表示的，所以在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因而在做比较操作时候就需要注意，如果直接通过使用等号 ( ‘ == ’ ) 操作符，这些看似一样的枚举值一定不相等，因为这不是同一个对象实例。 看下面的这个例子： // 定义一个一周七天的枚举类型 package example.enumeration.codes; public enum WeekDayEnum { Mon(1), Tue(2), Wed(3), Thu(4), Fri(5), Sat(6), Sun(7); private int index; WeekDayEnum(int idx) { this.index = idx; } public int getIndex() { return index; } } // 客户端程序，将一个枚举值通过网络传递给服务器端 package example.enumeration.codes; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.InetSocketAddress; import java.net.Socket; import java.net.UnknownHostException; public class EnumerationClient { public static void main(String... args) throws UnknownHostException, IOException { Socket socket = new Socket(); // 建立到服务器端的连接 socket.connect(new InetSocketAddress(\"127.0.0.1\", 8999)); // 从连接中得到输出流 OutputStream os = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(os); // 将星期五这个枚举值传递给服务器端 oos.writeObject(WeekDayEnum.Fri); oos.close(); os.close(); socket.close(); } } // 服务器端程序，将从客户端收到的枚举值应用到逻辑处理中 package example.enumeration.codes; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class EnumerationServer { public static void main(String... args) throws IOException, ClassNotFoundException { ServerSocket server = new ServerSocket(8999); // 建立服务器端的网络连接侦听 Socket socket = server.accept(); // 从连接中获取输入流 InputStream is = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(is); // 读出客户端传递来的枚举值 WeekDayEnum day = (WeekDayEnum) ois.readObject(); // 用值比较方式来对比枚举对象 if (day == WeekDayEnum.Fri) { System.out.println(\"client Friday enum value is same as server's\"); } else if (day.equals(WeekDayEnum.Fri)) { System.out.println(\"client Friday enum value is equal to server's\"); } else { System.out.println(\"client Friday enum value is not same as server's\"); } // 用 switch 方式来比较枚举对象 switch (day) { case Mon: System.out.println(\"Do Monday work\"); break; case Tue: System.out.println(\"Do Tuesday work\"); break; case Wed: System.out.println(\"Do Wednesday work\"); break; case Thu: System.out.println(\"Do Thursday work\"); break; case Fri: System.out.println(\"Do Friday work\"); break; case Sat: System.out.println(\"Do Saturday work\"); break; case Sun: System.out.println(\"Do Sunday work\"); break; default: System.out.println(\"I don't know which is day\"); break; } ois.close(); is.close(); socket.close(); } } 运行结果如下： client Friday enum value is same as server's Do Friday work 　通过程序执行结果，我们能够发现在分布式条件下客户端和服务端的虚拟机上都生成了一个枚举对象，即使看起来一样的 Fri 枚举值，如果使用等号‘ == ’进行比较的话会出现不等的情况。而 switch 语句则是通过 equal 方法来比较枚举对象的值，因此当你的枚举对象较复杂时候，你就需要小心 override 与比较相关的方法，防止出现值比较方面的错误。 ","date":"2022-06-05","objectID":"/java-enum-note/:9:0","tags":["Java","Enum"],"title":"Java枚举笔记","uri":"/java-enum-note/"},{"categories":["Back","note"],"content":"记录多线程执行顺序问题-号称腾讯（理想汽车面试题）的笔记","date":"2022-06-05","objectID":"/java-thread-order-note/","tags":["Java","Thread"],"title":"多线程执行顺序问题-号称腾讯（理想汽车面试题）","uri":"/java-thread-order-note/"},{"categories":["Back","note"],"content":"借鉴 今天在头条上看到一道据说是腾讯的笔试题，闲来无事，准备验证一下！ 理想汽车面试出的题，怎么现在这么卷了，理想汽车面试题出现了腾讯面试题，莫非买的一个题库？只能说我太菜了 题目如下： 有一个变量int a=0；两个线程同时进行+1操作，每个线程加100次，不加锁，最后a的值是（）？ 根据我的理解答案不唯一，最大是两百，最小是2吧。直接上代码： class MyThread implements Runnable { static volatile long i = 0; public void run() { for (int m = 0; m \u003c 100; m++) { i++; } } }; public class RunnableTest { public static void main(String[] args) throws InterruptedException { MyThread mt = new MyThread(); Thread t1 = new Thread(mt); Thread t2 = new Thread(mt); t1.start(); t2.start(); Thread.sleep(500); System.out.println(MyThread.i); } } //结果一脸懵逼，每次都是两百，我都开始有点怀疑人生了。考虑之后发现可能是100太小了，样本空间不够（伪学霸），吧100改成10000，奇迹出现了果然大部分时候i的值小于20000.具体解释一下原因（复制过来的哈哈）： i++不是原子(就是只由一条指令构成的)操作，也就是说，它不是单独一条指令，而是3条指令： 1、从内存中把i的值取出来放到CPU的寄存器中 2、CPU寄存器的值+1 3、把CPU寄存器的值写回内存 假设两个线程的执行步骤如下： 线程A执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU1的寄存器中值为1，内存中为0； 线程B执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU2的寄存器中值为1，内存中为0； 线程A继续执行完成第99次i++，并把值放回内存，此时CPU1中寄存器的值为99，内存中为99； 线程B继续执行第一次i++，将其值放回内存，此时CPU2中的寄存器值为1，内存中为1； 线程A执行第100次i++，将内存中的值取回CPU1的寄存器，并执行加1，此时CPU1的寄存器中的值为2，内存中为1； 线程B执行完所有操作，并将其放回内存，此时CPU2的寄存器值为100，内存中为100； 线程A执行100次操作的最后一部分，将CPU1中的寄存器值放回内存，内存中值为2； 一共有三个线程 t1、t2、main由于指令重排，谁先执行不一定，默认是父线程优先，故无论怎么改都是0 ","date":"2022-06-05","objectID":"/java-thread-order-note/:1:0","tags":["Java","Thread"],"title":"多线程执行顺序问题-号称腾讯（理想汽车面试题）","uri":"/java-thread-order-note/"},{"categories":["Back","note"],"content":"个人思考 这里有个人测试代码 当加上sleep，让两个子线程先执行，就能得到正确结果 当循环次数增加时，会发现结果并不是循环次数的两倍，单核一倍到两倍；多核2到两倍 ","date":"2022-06-05","objectID":"/java-thread-order-note/:2:0","tags":["Java","Thread"],"title":"多线程执行顺序问题-号称腾讯（理想汽车面试题）","uri":"/java-thread-order-note/"},{"categories":["Back","note"],"content":"记录Spring 框架用到的 9 个设计模式汇总的笔记","date":"2022-06-04","objectID":"/spring-design-mode-note/","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。 Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式? ","date":"2022-06-04","objectID":"/spring-design-mode-note/:0:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"0. 控制反转(IoC)和依赖注入(DI) IoC(Inversion of Control,控制翻转) 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。 Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。 在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答 ，非常不错。 控制翻转怎么理解呢? 举个例子：“对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。 DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:1:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"1. 简单工厂（StaticFactory Method） 又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:2:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实质 由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:2:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现原理 bean容器的启动阶段： 读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。 然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。 将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。 容器中bean的实例化阶段： 实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点： 各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口 ，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口 ，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口 ，实现了BeanPostProcessor接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:2:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"设计意义 松耦合。 可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果. bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要] Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。 两者对比： BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于BeanFactory 来说会占用更少的内存，程序启动速度更快。 ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。 ApplicationContext的三个实现类： ClassPathXmlApplication：把上下文文件当成类路径资源。 FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。 XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。 Example: import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; public class App { public static void main(String[] args) { ApplicationContext context = new FileSystemXmlApplicationContext( \"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml\"); HelloApplicationContext obj = (HelloApplicationContext) context.getBean(\"helloApplicationContext\"); obj.getMsg(); } } ","date":"2022-06-04","objectID":"/spring-design-mode-note/:2:3","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"2. 工厂方法（Factory Method） 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:3:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现方式 Spring中的FactoryBean就是典型的工厂方法模式。如下图： ","date":"2022-06-04","objectID":"/spring-design-mode-note/:3:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"例子 典型的例子有spring与mybatis的结合。 代码示例： 说明： 我们看上面该bean，因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:3:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"3. 单例（Singleton） 在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。 使用单例模式的好处: 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销； 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。 Spring 中 bean 的默认作用域就是 singleton(单例)的。 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域： prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。 Spring 实现单例的方式： xml : \u003cbean id=\"userService\" class=\"top.snailclimb.UserService\" scope=\"singleton\"/\u003e 注解：@Scope(value = \"singleton\") Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下 // 通过 ConcurrentHashMap（线程安全） 实现单例注册表 private final Map\u003cString, Object\u003e singletonObjects = new ConcurrentHashMap\u003cString, Object\u003e(64); public Object getSingleton(String beanName, ObjectFactory\u003c?\u003e singletonFactory) { Assert.notNull(beanName, \"'beanName' must not be null\"); synchronized (this.singletonObjects) { // 检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { //...省略了很多代码 try { singletonObject = singletonFactory.getObject(); } //...省略了很多代码 // 如果实例对象在不存在，我们注册到单例注册表中。 addSingleton(beanName, singletonObject); } return (singletonObject != NULL_OBJECT ? singletonObject : null); } } //将对象添加到单例注册表 protected void addSingleton(String beanName, Object singletonObject) { synchronized (this.singletonObjects) { this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); } } } 分析getSingleton()方法 public Object getSingleton(String beanName){ //参数true设置标识允许早期依赖 return getSingleton(beanName,true); } protected Object getSingleton(String beanName, boolean allowEarlyReference) { //检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 isSingletonCurrentlyInCreation(beanName)) { //如果为空，则锁定全局变量并进行处理。 synchronized (this.singletonObjects) { //如果此bean正在加载，则不处理 singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory\u003c?\u003e singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { //调用预先设定的getObject方法 singletonObject = singletonFactory.getObject(); //记录在缓存中，earlysingletonObjects和singletonFactories互斥 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); } getSingleton()过程图 ps：spring依赖注入时，使用了 双重判断加锁 的单例模式 总结 单例模式定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 spring对单例的实现： spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。详解Java中的单例模式大家可以点击这里看这篇文章。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:4:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"4. 适配器（Adapter） 适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使原本由于接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:5:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"spring AOP中的适配器模式 我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是AdvisorAdapter 。Advice 常用的类型有：BeforeAdvice（目标方法调用前,前置通知）、AfterAdvice（目标方法调用后,后置通知）、AfterReturningAdvice(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:MethodBeforeAdviceInterceptor、AfterReturningAdviceAdapter、AfterReturningAdviceInterceptor。Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。 Spring中在对于AOP的处理中有Adapter模式的例子，见如下图： 由于Advisor链需要的是MethodInterceptor（拦截器）对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:5:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"spring MVC中的适配器模式 实现方式 在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。 实现过程 DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。 HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。 为什么要在 Spring MVC 中使用适配器模式？（实现意义） Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： if(mappedHandler.getHandler() instanceof MultiActionController){ ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){ ... }else if(...){ ... } 假如我们再增加一个 Controller类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。 因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:5:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"5. 包装器装饰者（Decorator） ","date":"2022-06-04","objectID":"/spring-design-mode-note/:6:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实质 可以动态地给一个对象添加一些额外的职责（属性或行为）。就增加功能来说，Decorator模式相比生成子类（使用继承）更为灵活。 简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:6:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现方式 Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 Wrapper或者 Decorator。这些类基本上都是动态地给一个对象添加一些额外的职责 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:6:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"6. 代理（Proxy） 为其他对象提供一种代理以控制对这个对象的访问。 从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。详解Java中的3种代理模式大家可以点击这里看这篇文章。 Spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:7:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"代理模式在 AOP 中的应用（实现方式） AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示： 当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:7:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现原理 切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。 织入：把切面应用到目标对象并创建新的代理对象的过程。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:7:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"动静态代理对比 动态代理 在内存中构建的，不需要手动编写代理类 静态代理 需要手工编写代理类，代理类引用被代理对象。 使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:7:3","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"Spring AOP 和 AspectJ AOP 有什么区别? Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。 Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单， 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:7:4","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"7. 观察者（Observer） 定义对象与对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新或做出反应。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:8:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现方式 Spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:8:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"Spring 事件驱动模型中的三种角色 事件角色 ApplicationEvent抽象类[事件] (org.springframework.context包下)充当事件的角色,这是一个抽象类，它继承了jdk的java.util.EventObject并实现了 java.io.Serializable接口。所有的事件都需要继承ApplicationEvent,并且通过构造器参数source得到事件源. Spring 中默认存在以下事件，他们都是对 ApplicationContextEvent 的实现(继承自ApplicationContextEvent)，表示ApplicaitonContext的容器事件： ContextStartedEvent：ApplicationContext 启动后触发的事件; ContextStoppedEvent：ApplicationContext 停止后触发的事件; ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件; ContextClosedEvent：ApplicationContext 关闭后触发的事件。 代码： publicabstractclass ApplicationEvent extends EventObject { privatestaticfinallong serialVersionUID = 7099057708183571937L; privatefinallong timestamp; public ApplicationEvent(Object source) { super(source); this.timestamp = System.currentTimeMillis(); } public final long getTimestamp() { returnthis.timestamp; } } ApplicationListener接口[事件监听器/事件监听者角色] 继承自jdk的EventListener,所有的监听器都要实现这个接口。 ApplicationListener 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent（）方法来处理ApplicationEvent或其子类对象作为参数。,可以通过不同对Event类的判断来进行相应的处理。ApplicationListener接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 ApplicationEvent就可以了。所以，在 Spring中我们只要实现 ApplicationListener 接口实现 onApplicationEvent() 方法即可完成监听事件 package org.springframework.context; import java.util.EventListener; @FunctionalInterface public interface ApplicationListener\u003cE extends ApplicationEvent\u003e extends EventListener { void onApplicationEvent(E event); } ApplicationContext接口[事件源/事件发布者角色] ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。 @FunctionalInterface public interface ApplicationEventPublisher { default void publishEvent(ApplicationEvent event) { this.publishEvent((Object)event); } void publishEvent(Object var1); } ApplicationContext是spring中的全局容器，翻译过来是”应用上下文”。 实现了ApplicationEventPublisher接口。 职责 负责读取bean的配置文档,管理bean的加载,维护bean之间的依赖关系,可以说是负责bean的整个生命周期,再通俗一点就是我们平时所说的IOC容器。 代码 publicinterface ApplicationEventPublisher { void publishEvent(ApplicationEvent event); } public void publishEvent(ApplicationEvent event) { Assert.notNull(event, \"Event must not be null\"); if (logger.isTraceEnabled()) { logger.trace(\"Publishing event in \" + getDisplayName() + \": \" + event); } getApplicationEventMulticaster().multicastEvent(event); if (this.parent != null) { this.parent.publishEvent(event); } } ApplicationEventPublisher 接口的publishEvent（）这个方法在AbstractApplicationContext类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过ApplicationEventMulticaster来广播出去的。 ApplicationEventMulticaster抽象类[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster] 属于事件广播器,它的作用是把Applicationcontext发布的Event广播给所有的监听器. 代码 publicabstractclass AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean { private ApplicationEventMulticaster applicationEventMulticaster; protected void registerListeners() { // Register statically specified listeners first. for (ApplicationListener\u003c?\u003e listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String lisName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(lisName); } } } 具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:8:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"Spring 的事件流程总结 定义一个事件: 实现一个继承自 ApplicationEvent，并且写相应的构造函数； 定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法； 使用事件发布者发布消息: 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息。 Example: // 定义一个事件,继承自ApplicationEvent并且写相应的构造函数 public class DemoEvent extends ApplicationEvent{ private static final long serialVersionUID = 1L; private String message; public DemoEvent(Object source,String message){ super(source); this.message = message; } public String getMessage() { return message; } // 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法； @Component public class DemoListener implements ApplicationListener\u003cDemoEvent\u003e{ //使用onApplicationEvent接收消息 @Override public void onApplicationEvent(DemoEvent event) { String msg = event.getMessage(); System.out.println(\"接收到的信息是：\"+msg); } } // 发布事件，可以通过ApplicationEventPublisher 的 publishEvent() 方法发布消息。 @Component public class DemoPublisher { @Autowired ApplicationContext applicationContext; public void publish(String message){ //发布事件 applicationContext.publishEvent(new DemoEvent(this, message)); } } 当调用 DemoPublisher 的 publish() 方法的时候，比如 demoPublisher.publish(\"你好\") ，控制台就会打印出:接收到的信息是：你好 。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:8:3","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"8. 策略（Strategy） 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:9:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"实现方式 Spring中在实例化对象的时候用到Strategy模式，见如下图： 在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。 Resource 接口介绍 source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。 Resource 接口主要提供了如下几个方法: getInputStream()： 定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。 exists()： 返回 Resource 所指向的资源是否存在。 isOpen()： 返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。 getDescription()： 返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。 getFile： 返回资源对应的 File 对象。 getURL： 返回资源对应的 URL 对象。 最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。 Resource 接口本身没有提供访问任何底层资源的实现逻辑，针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。 Spring 为 Resource 接口提供了如下实现类： UrlResource： 访问网络资源的实现类。 ClassPathResource： 访问类加载路径里资源的实现类。 FileSystemResource： 访问文件系统里资源的实现类。 ServletContextResource： 访问相对于 ServletContext 路径里的资源的实现类. InputStreamResource： 访问输入流资源的实现类。 ByteArrayResource： 访问字节数组资源的实现类。 这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:9:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"9. 模板方法（Template Method） 模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架（调用哪些方法及顺序），而将一些步骤延迟到子类中，某些特定方法由子类实现。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。 最大的好处 代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。 所以父类模板方法中有两类方法： 共同的方法： 所有子类都会用到的代码 不同的方法： 子类要覆盖的方法，分为两种： 抽象方法：父类中的是抽象方法，子类必须覆盖 钩子方法：父类中是一个空方法，子类继承了默认也是空的 注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！ public abstract class Template { //这是我们的模板方法 public final void TemplateMethod(){ PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); } protected void PrimitiveOperation1(){ //当前类实现 } //被子类实现的方法 protected abstract void PrimitiveOperation2(); protected abstract void PrimitiveOperation3(); } public class TemplateImpl extends Template { @Override public void PrimitiveOperation2() { //当前类实现 } @Override public void PrimitiveOperation3() { //当前类实现 } } ","date":"2022-06-04","objectID":"/spring-design-mode-note/:10:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"Spring模板方法模式实质 是模板方法模式和回调模式的结合，是模板方法模式不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:10:1","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"具体实现 Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是采用了一种理念或者处理方式，使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。 采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放 publicabstractclass JdbcTemplate { publicfinal Object execute（String sql）{ Connection con=null; Statement stmt=null; try{ con=getConnection（）; stmt=con.createStatement（）; Object retValue=executeWithStatement（stmt,sql）; return retValue; }catch（SQLException e）{ ... }finally{ closeStatement（stmt）; releaseConnection（con）; } } protectedabstract Object executeWithStatement（Statement stmt, String sql）; } 引入回调原因 JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。 回调代码 publicinterface StatementCallback{ Object doWithStatement（Statement stmt）; } 利用回调方法重写JdbcTemplate方法 publicclass JdbcTemplate { publicfinal Object execute（StatementCallback callback）{ Connection con=null; Statement stmt=null; try{ con=getConnection（）; stmt=con.createStatement（）; Object retValue=callback.doWithStatement（stmt）; return retValue; }catch（SQLException e）{ ... }finally{ closeStatement（stmt）; releaseConnection（con）; } } ...//其它方法定义 } Jdbc使用方法如下： JdbcTemplate jdbcTemplate=...; final String sql=...; StatementCallback callback=new StatementCallback(){ public Object=doWithStatement(Statement stmt){ return ...; } } jdbcTemplate.execute(callback); 为什么JdbcTemplate没有使用继承 模板方法模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？ 我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？ 那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 以下是一个具体的例子： JdbcTemplate中的execute方法： JdbcTemplate执行execute方法： ","date":"2022-06-04","objectID":"/spring-design-mode-note/:10:2","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"总结 Spring 框架中用到了哪些设计模式？ 控制反转和依赖注入 类管理 **简单工厂设计模式: **Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 **工厂方法模式: ** **代理设计模式: **Spring AOP 功能的实现。 **单例设计模式: **Spring 中的 Bean 默认都是单例的。 **模板方法模式: **Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 **包装器设计模式: **我们的项目需要连接多个数据库（Spring 中配置 DataSource），而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 **观察者模式: ** Spring 事件驱动模型就是观察者模式很经典的一个应用。 **适配器模式: **Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:11:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"参考 《Spring技术内幕》 https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/ http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/ https://www.tutorialsteacher.com/ioc/inversion-of-control https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html https://juejin.im/post/5a8eb261f265da4e9e307230 https://juejin.im/post/5ba28986f265da0abc2b6084 blog.csdn.net/caoxiaohong1005 ","date":"2022-06-04","objectID":"/spring-design-mode-note/:12:0","tags":["Java","Spring","DesignMode"],"title":"Spring 框架用到的 9 个设计模式汇总","uri":"/spring-design-mode-note/"},{"categories":["Back","note"],"content":"记录使用Winsw将Jar或Bat文件注册到Windows服务的笔记","date":"2022-06-04","objectID":"/python-note/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"使用Winsw将Jar或Bat文件注册到Windows服务","uri":"/python-note/"},{"categories":["Back","note"],"content":"与阿里巴巴的java开发手册类似的Python开发手册 动态语言确实需要规范来约束，防止项目大了以后难以维护。下边这个链接总结了之前维护项目遇到的一些问题（其实一直想和知乎的同事发起一个类似的开发手册） 编码之前碎碎念(工程实践) - python-web-guide 0.1 文档 google 的也不错： Python 风格指南 - 内容目录 ","date":"2022-06-04","objectID":"/python-note/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"使用Winsw将Jar或Bat文件注册到Windows服务","uri":"/python-note/"},{"categories":["Back","note"],"content":"参考 https://www.zhihu.com/question/269154135 ","date":"2022-06-04","objectID":"/python-note/:1:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"使用Winsw将Jar或Bat文件注册到Windows服务","uri":"/python-note/"},{"categories":["Back","note"],"content":"记录新一代垃圾回收器ZGC的探索与实践的笔记","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括： 停顿时间不超过10ms； 停顿时间不会随着堆的大小，或者活跃对象的大小而增加； 支持8MB~4TB级别的堆（未来支持16TB）。 从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。本文主要介绍ZGC在低延时场景中的应用和卓越表现，文章内容主要分为四部分： GC之痛：介绍实际业务中遇到的GC痛点，并分析CMS收集器和G1收集器停顿时间瓶颈； ZGC原理：分析ZGC停顿时间比G1或CMS更短的本质原因，以及背后的技术原理； ZGC调优实践：重点分享对ZGC调优的理解，并分析若干个实际调优案例； 升级ZGC效果：展示在生产环境应用ZGC取得的效果。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:0:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"GC之痛 很多低延迟高可用Java服务的系统可用性经常受GC停顿的困扰。GC停顿指垃圾回收期间STW（Stop The World），当STW时，所有应用线程停止活动，等待GC停顿结束。以美团风控服务为例，部分上游业务要求风控服务65ms内返回结果，并且可用性要达到99.99%。但因为GC停顿，我们未能达到上述可用性目标。当时使用的是CMS垃圾回收器，单次Young GC 40ms，一分钟10次，接口平均响应时间30ms。通过计算可知，有（40ms + 30ms) * 10次 / 60000ms = 1.12%的请求的响应时间会增加0 ~ 40ms不等，其中30ms * 10次 / 60000ms = 0.5%的请求响应时间会增加40ms。可见，GC停顿对响应时间的影响较大。为了降低GC停顿对系统可用性的影响，我们从降低单次GC时间和降低GC频率两个角度出发进行了调优，还测试过G1垃圾回收器，但这三项措施均未能降低GC对服务可用性的影响。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:1:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"CMS与G1停顿时间瓶颈 在介绍ZGC之前，首先回顾一下CMS和G1的GC过程以及停顿时间的瓶颈。CMS新生代的Young GC、G1和ZGC都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。 标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段： 标记阶段，即从GC Roots集合开始，标记活跃对象； 转移阶段，即把活跃对象复制到新的内存地址上； 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。 下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示： G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。 标记阶段停顿分析 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。 清理阶段停顿分析 清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。 复制阶段停顿分析 复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。 四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。 G1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:1:1","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"ZGC原理 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:2:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"全并发的ZGC 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。 ZGC垃圾回收周期如下图所示： ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:2:1","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"ZGC关键技术 ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。 着色指针 着色指针是一种将信息存储在指针中的技术。 ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示： 其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。 当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。 与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储元数据，第47~63位固定为0。 ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。 读屏障 读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。 读屏障示例： Object o = obj.FieldA // 从堆中读取引用，需要加入屏障 \u003cLoad barrier\u003e Object p = o // 无需加入屏障，因为不是从堆中读取引用 o.dosomething() // 无需加入屏障，因为不是从堆中读取引用 int i = obj.FieldB //无需加入屏障，因为不是对象引用 ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:2:2","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"ZGC并发处理演示 接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程： 初始化：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。 并发标记阶段：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。 并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。 其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。 着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:2:3","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"ZGC调优实践 ZGC不是“银弹”，需要根据服务的具体特点进行调优。网络上能搜索到实战经验较少，调优理论需自行摸索，我们在此阶段也耗费了不少时间，最终才达到理想的性能。本文的一个目的是列举一些使用ZGC时常见的问题，帮助大家使用ZGC提高服务可用性。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:3:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"调优基础知识 理解ZGC重要配置参数 以我们服务在生产环境中ZGC参数配置为例，说明各个参数的作用： 重要参数配置样例： -Xms10G -Xmx10G -XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:ConcGCThreads=2 -XX:ParallelGCThreads=6 -XX:ZCollectionInterval=120 -XX:ZAllocationSpikeTolerance=5 -XX:+UnlockDiagnosticVMOptions -XX:-ZProactive -Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m -Xms -Xmx：堆的最大内存和最小内存，这里都设置为10G，程序的堆内存将保持10G不变。 -XX:ReservedCodeCacheSize -XX:InitialCodeCacheSize：设置CodeCache的大小， JIT编译的代码都放在CodeCache中，一般服务64m或128m就已经足够。我们的服务因为有一定特殊性，所以设置的较大，后面会详细介绍。 -XX:+UnlockExperimentalVMOptions -XX:+UseZGC：启用ZGC的配置。 -XX:ConcGCThreads：并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。 -XX:ParallelGCThreads：STW阶段使用线程数，默认是总核数的60%。 -XX:ZCollectionInterval：ZGC发生的最小时间间隔，单位秒。 -XX:ZAllocationSpikeTolerance：ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC。 -XX:+UnlockDiagnosticVMOptions -XX:-ZProactive：是否启用主动回收，默认开启，这里的配置表示关闭。 -Xlog：设置GC日志中的内容、格式、位置以及每个日志的大小。 理解ZGC触发时机 相比于CMS和G1的GC触发机制，ZGC的GC触发机制有很大不同。ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。 ZGC有多种GC触发机制，总结如下： 阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。 基于分配速率的自适应算法：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。自适应算法的详细理论可参考彭成寒《新一代垃圾回收器ZGC设计与实现》一书中的内容。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。我们通过调整此参数解决了一些问题。日志中关键字是“Allocation Rate”。 基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。日志中关键字是“Timer”。 主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。 日志中关键字是“Proactive”。 预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。 外部触发：代码中显式调用System.gc()触发。 日志中关键字是“System.gc()”。 元数据分配触发：元数据区不足时导致，一般不需要关注。 日志中关键字是“Metadata GC Threshold”。 理解ZGC日志 一次完整的GC过程，需要注意的点已在图中标出。 注意：该日志过滤了进入安全点的信息。正常情况，在一次GC过程中还穿插着进入安全点的操作。 GC日志中每一行都注明了GC过程中的信息，关键信息如下： Start：开始GC，并标明的GC触发的原因。上图中触发原因是自适应算法。 Phase-Pause Mark Start：初始标记，会STW。 Phase-Pause Mark End：再次标记，会STW。 Phase-Pause Relocate Start：初始转移，会STW。 Heap信息：记录了GC过程中Mark、Relocate前后的堆大小变化状况。High和Low记录了其中的最大值和最小值，我们一般关注High中Used的值，如果达到100%，在GC过程中一定存在内存分配不足的情况，需要调整GC的触发时机，更早或者更快地进行GC。 GC信息统计：可以定时的打印垃圾收集信息，观察10秒内、10分钟内、10个小时内，从启动到现在的所有统计信息。利用这些统计信息，可以排查定位一些异常点。 日志中内容较多，关键点已用红线标出，含义较好理解，更详细的解释大家可以自行在网上查阅资料。 理解ZGC停顿原因 我们在实战过程中共发现了6种使程序停顿的场景，分别如下： GC时，初始标记：日志中Pause Mark Start。 GC时，再标记：日志中Pause Mark End。 GC时，初始转移：日志中Pause Relocate Start。 内存分配阻塞：当内存不足时线程会阻塞等待GC完成，关键字是”Allocation Stall”。 安全点：所有线程进入到安全点后才能进行GC，ZGC定期进入安全点判断是否需要GC。先进入安全点的线程需要等待后进入安全点的线程直到所有线程挂起。 dump线程、内存：比如jstack、jmap命令。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:3:1","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"调优案例 我们维护的服务名叫Zeus，它是美团的规则平台，常用于风控场景中的规则管理。规则运行是基于开源的表达式执行引擎Aviator。Aviator内部将每一条表达式转化成Java的一个类，通过调用该类的接口实现表达式逻辑。 Zeus服务内的规则数量超过万条，且每台机器每天的请求量几百万。这些客观条件导致Aviator生成的类和方法会产生很多的ClassLoader和CodeCache，这些在使用ZGC时都成为过GC的性能瓶颈。接下来介绍两类调优案例。 内存分配阻塞，系统停顿可达到秒级 案例一：秒杀活动中流量突增，出现性能毛刺 日志信息：对比出现性能毛刺时间点的GC日志和业务日志，发现JVM停顿了较长时间，且停顿时GC日志中有大量的“Allocation Stall”日志。 分析：这种案例多出现在“自适应算法”为主要GC触发机制的场景中。ZGC是一款并发的垃圾回收器，GC线程和应用线程同时活动，在GC过程中，还会产生新的对象。GC完成之前，新产生的对象将堆占满，那么应用线程可能因为申请内存失败而导致线程阻塞。当秒杀活动开始，大量请求打入系统，但自适应算法计算的GC触发间隔较长，导致GC触发不及时，引起了内存分配阻塞，导致停顿。 解决方法： （1）开启”基于固定时间间隔“的GC触发机制：-XX:ZCollectionInterval。比如调整为5秒，甚至更短。 （2）增大修正系数-XX:ZAllocationSpikeTolerance，更早触发GC。ZGC采用正态分布模型预测内存分配速率，模型修正系数ZAllocationSpikeTolerance默认值为2，值越大，越早的触发GC，Zeus中所有集群设置的是5。 案例二：压测时，流量逐渐增大到一定程度后，出现性能毛刺 日志信息：平均1秒GC一次，两次GC之间几乎没有间隔。 分析：GC触发及时，但内存标记和回收速度过慢，引起内存分配阻塞，导致停顿。 解决方法：增大-XX:ConcGCThreads， 加快并发标记和回收速度。ConcGCThreads默认值是核数的1/8，8核机器，默认值是1。该参数影响系统吞吐，如果GC间隔时间大于GC周期，不建议调整该参数。 GC Roots 数量大，单次GC停顿时间长 案例三： 单次GC停顿时间30ms，与预期停顿10ms左右有较大差距 日志信息：观察ZGC日志信息统计，“Pause Roots ClassLoaderDataGraph”一项耗时较长。 分析：dump内存文件，发现系统中有上万个ClassLoader实例。我们知道ClassLoader属于GC Roots一部分，且ZGC停顿时间与GC Roots成正比，GC Roots数量越大，停顿时间越久。再进一步分析，ClassLoader的类名表明，这些ClassLoader均由Aviator组件生成。分析Aviator源码，发现Aviator对每一个表达式新生成类时，会创建一个ClassLoader，这导致了ClassLoader数量巨大的问题。在更高Aviator版本中，该问题已经被修复，即仅创建一个ClassLoader为所有表达式生成类。 解决方法：升级Aviator组件版本，避免生成多余的ClassLoader。 案例四：服务启动后，运行时间越长，单次GC时间越长，重启后恢复 日志信息：观察ZGC日志信息统计，“Pause Roots CodeCache”的耗时会随着服务运行时间逐渐增长。 分析：CodeCache空间用于存放Java热点代码的JIT编译结果，而CodeCache也属于GC Roots一部分。通过添加-XX:+PrintCodeCacheOnCompilation参数，打印CodeCache中的被优化的方法，发现大量的Aviator表达式代码。定位到根本原因，每个表达式都是一个类中一个方法。随着运行时间越长，执行次数增加，这些方法会被JIT优化编译进入到Code Cache中，导致CodeCache越来越大。 解决方法：JIT有一些参数配置可以调整JIT编译的条件，但对于我们的问题都不太适用。我们最终通过业务优化解决，删除不需要执行的Aviator表达式，从而避免了大量Aviator方法进入CodeCache中。 值得一提的是，我们并不是在所有这些问题都解决后才全量部署所有集群。即使开始有各种各样的毛刺，但计算后发现，有各种问题的ZGC也比之前的CMS对服务可用性影响小。所以从开始准备使用ZGC到全量部署，大概用了2周的时间。在之后的3个月时间里，我们边做业务需求，边跟进这些问题，最终逐个解决了上述问题，从而使ZGC在各个集群上达到了一个更好表现。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:3:2","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"升级ZGC效果 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:4:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"延迟降低 TP(Top Percentile)是一项衡量系统延迟的指标：TP999表示99.9%请求都能被响应的最小耗时；TP99表示99%请求都能被响应的最小耗时。 在Zeus服务不同集群中，ZGC在低延迟（TP999 \u003c 200ms）场景中收益较大： TP999：下降12~142ms，下降幅度18%~74%。 TP99：下降5~28ms，下降幅度10%~47%。 超低延迟（TP999 \u003c 20ms）和高延迟（TP999 \u003e 200ms）服务收益不大，原因是这些服务的响应时间瓶颈不是GC，而是外部依赖的性能。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:4:1","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"吞吐下降 对吞吐量优先的场景，ZGC可能并不适合。例如，Zeus某离线集群原先使用CMS，升级ZGC后，系统吞吐量明显降低。究其原因有二：第一，ZGC是单代垃圾回收器，而CMS是分代垃圾回收器。单代垃圾回收器每次处理的对象更多，更耗费CPU资源；第二，ZGC使用读屏障，读屏障操作需耗费额外的计算资源。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:4:2","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"总结 ZGC作为下一代垃圾回收器，性能非常优秀。ZGC垃圾回收过程几乎全部是并发，实际STW停顿时间极短，不到10ms。这得益于其采用的着色指针和读屏障技术。 Zeus在升级JDK 11+ZGC中，通过将风险和问题分类，然后各个击破，最终顺利实现了升级目标，GC停顿也几乎不再影响系统可用性。 最后推荐大家升级ZGC，Zeus系统因为业务特点，遇到了较多问题，而风控其他团队在升级时都非常顺利。欢迎大家加入“ZGC使用交流”群。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:5:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"参考文献 ZGC官网 彭成寒.《新一代垃圾回收器ZGC设计与实现》. 机械工业出版社, 2019. 从实际案例聊聊Java应用的GC优化 Java Hotspot G1 GC的一些关键技术 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:6:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"附录 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:7:0","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"如何使用新技术 在生产环境升级JDK 11，使用ZGC，大家最关心的可能不是效果怎么样，而是这个新版本用的人少，网上实践也少，靠不靠谱，稳不稳定。其次是升级成本会不会很大，万一不成功岂不是白白浪费时间。所以，在使用新技术前，首先要做的是评估收益、成本和风险。 评估收益 对于JDK这种世界关注的程序，大版本升级所引入的新技术一般已经在理论上经过验证。我们要做的事情就是确定当前系统的瓶颈是否是新版本JDK可解决的问题，切忌问题未诊断清楚就采取措施。评估完收益之后再评估成本和风险，收益过大或者过小，其他两项影响权重就会小很多。 以本文开头提到的案例为例，假设GC次数不变（10次/分钟)，且单次GC时间从40ms降低10ms。通过计算，一分钟内有100/60000 = 0.17%的时间在进行GC，且期间所有请求仅停顿10ms，GC期间影响的请求数和因GC增加的延迟都有所减少。 评估成本 这里主要指升级所需要的人力成本。此项相对比较成熟，根据新技术的使用手册判断改动点。跟做其他项目区别不大，不再具体细说。 在我们的实践中，两周时间完成线上部署，达到安全稳定运行的状态。后续持续迭代3个月，根据业务场景对ZGC进行了更契合的优化适配。 评估风险 升级JDK的风险可以分为三类： 兼容性风险：Java程序JAR包依赖很多，升级JDK版本后程序是否能运行起来。例如我们的服务是从JDK 7升级到JDK 11，需要解决较多JAR包不兼容的问题。 功能风险：运行起来后，是否会有一些组件逻辑变更，影响现有功能的逻辑。 性能风险：功能如果没有问题，性能是否稳定，能稳定的在线上运行。 经过分类后，每类风险的应对转化成了常见的测试问题，不再属于未知风险。风险是指不确定的事情，如果不确定的事情都能转化成可确定的事情，意味着风险已消除。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:7:1","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"升级JDK 11 选择JDK 11，是因为在JDK 11中首次支持ZGC，而且JDK 11属于长期支持（Long Term Support，LTS）版本，至少会被维护三年，普通版本（如JDK 12、JDK 13和JDK 14）只有6个月的维护周期，不建议使用。 本地测试环境安装 从两个源OpenJDK和OracleJDK 下载JDK 11，二个版本的JDK主要区别是长时期的免费和付费，短期内都免费。注意JDK 11版本中的ZGC不支持Mac OS系统，在Mac OS系统上使用JDK 11只能用其他垃圾回收器，如G1。 生产环境安装 升级JDK 11不仅仅是升级自己项目的JDK版本，还需要编译、发布部署、运行、监控、性能内存分析工具等项目支持。美团内部的实践： 编译打包：美团发布系统支持选择JDK 11进行编译打包。 线上运行 \u0026 全量部署：要求线上机器已安装JDK11，有3种方式： 1.新申请默认安装JDK 11的虚拟机：试用JDK 11时可用这种方式；全量部署时，如果新申请机器数量过多，可能没有足够机器资源。 2.通过手写脚本给存量虚拟机安装JDK 11：不推荐，业务同学过多参与到运维当中。 3.使用容器提供的镜像部署功能，在打包镜像时安装JDK 11：推荐方式，不需要新申请资源。 监控指标：主要是GC的时间和频率，我们通过美团的CAT监控系统支持ZGC数据的收集（CAT已开源）。 性能内存分析：线上遇到性能问题时，还需要借助Profiling工具，美团的性能诊断优化平台Scalpel已支持JDK 11的性能内存分析。如果你的公司没有相关工具，推荐使用JProfier。 解决组件兼容性 我们的项目包含二十多万行代码，需要从JDK 7升级到JDK 11，依赖组件众多。虽然看起来升级会比较复杂，但实际只花了两天时间即解决了兼容性问题。具体过程如下： 1.编译，需要修改pom文件中的build配置，根据报错作修改，主要有两类： a.一些类被删除：比如“sun.misc.BASE64Encoder”，找到替换类java.util.Base64即可。 b.组件依赖版本不兼容JDK 11问题：找到对应依赖组件，搜索最新版本，一般都支持JDK 11。 2.编译成功后，启动运行，此时仍有可能组件依赖版本问题，按照编译时的方式处理即可。 升级所修改的依赖： \u003cdependency\u003e \u003cgroupId\u003ejavax.annotation\u003c/groupId\u003e \u003cartifactId\u003ejavax.annotation-api\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.validation\u003c/groupId\u003e \u003cartifactId\u003evalidation-api\u003c/artifactId\u003e \u003cversion\u003e2.0.1.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.hibernate.validator\u003c/groupId\u003e \u003cartifactId\u003ehibernate-validator-parent\u003c/artifactId\u003e \u003cversion\u003e6.0.16.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.sankuai.inf\u003c/groupId\u003e \u003cartifactId\u003epatriot-sdk\u003c/artifactId\u003e \u003cversion\u003e1.2.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang3\u003c/artifactId\u003e \u003cversion\u003e3.9\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.netty\u003c/groupId\u003e \u003cartifactId\u003enetty-all\u003c/artifactId\u003e \u003cversion\u003e4.1.39.Final\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e JDK 11已经出来两年，常见的依赖组件都有兼容性版本。但是，如果是公司内部提供的公司级组件，可能会不兼容JDK 11，需要推动相关组件进行升级。如果对方升级较为困难，可以考虑拆分功能，将依赖这些组件的功能单独部署，继续使用低版本JDK。随着JDK11的卓越性能被大家悉知，相信会有更多团队会用JDK 11解决GC问题，使用者越多，各个组件升级的动力也会越大。 验证功能正确性 通过完备的单测、集成和回归测试，保证功能正确性。 ","date":"2022-06-04","objectID":"/jvm-z-garbage-collector-note/:7:2","tags":["Java","Jvm","Garbage ","ZGC"],"title":"新一代垃圾回收器ZGC的探索与实践","uri":"/jvm-z-garbage-collector-note/"},{"categories":["Back","note"],"content":"记录使用Winsw将Jar或Bat文件注册到Windows服务的笔记","date":"2022-05-31","objectID":"/csharp-delegate-note/","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"C# 委托（Delegate） C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。 ","date":"2022-05-31","objectID":"/csharp-delegate-note/:1:0","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"声明委托（Delegate） 委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。 例如，假设有一个委托： public delegate int MyDelegate (string s); 上面的委托可被用于引用任何一个带有一个单一的 string 参数的方法，并返回一个 int 类型变量。 声明委托的语法如下： delegate \u003creturn type\u003e \u003cdelegate-name\u003e \u003cparameter list\u003e ","date":"2022-05-31","objectID":"/csharp-delegate-note/:1:1","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"实例化委托（Delegate） 一旦声明了委托类型，委托对象必须使用 new 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 new 语句的参数就像方法调用一样书写，但是不带有参数。例如： public delegate void printString(string s); ... printString ps1 = new printString(WriteToScreen); printString ps2 = new printString(WriteToFile); 下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。 实例 using System; delegate int NumberChanger(int n); namespace DelegateAppl { class TestDelegate { static int num = 10; public static int AddNum(int p) { num += p; return num; } public static int MultNum(int q) { num *= q; return num; } public static int getNum() { return num; } static void Main(string[] args) { // 创建委托实例 NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法 nc1(25); Console.WriteLine(\"Value of Num: {0}\", getNum()); nc2(5); Console.WriteLine(\"Value of Num: {0}\", getNum()); Console.ReadKey(); } } } 当上面的代码被编译和执行时，它会产生下列结果： Value of Num: 35 Value of Num: 175 ","date":"2022-05-31","objectID":"/csharp-delegate-note/:1:2","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"委托的多播（Multicasting of a Delegate） 委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。\"-\" 运算符可用于从合并的委托中移除组件委托。 使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 多播（multicasting），也叫组播。下面的程序演示了委托的多播： 实例 using System; delegate int NumberChanger(int n); namespace DelegateAppl { class TestDelegate { static int num = 10; public static int AddNum(int p) { num += p; return num; } public static int MultNum(int q) { num *= q; return num; } public static int getNum() { return num; } static void Main(string[] args) { // 创建委托实例 NumberChanger nc; NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); nc = nc1; nc += nc2; // 调用多播 nc(5); Console.WriteLine(\"Value of Num: {0}\", getNum()); Console.ReadKey(); } } } 当上面的代码被编译和执行时，它会产生下列结果： Value of Num: 75 ","date":"2022-05-31","objectID":"/csharp-delegate-note/:1:3","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"委托（Delegate）的用途 下面的实例演示了委托的用法。委托 printString 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。 我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件： 实例 using System; using System.IO; namespace DelegateAppl { class PrintString { static FileStream fs; static StreamWriter sw; // 委托声明 public delegate void printString(string s); // 该方法打印到控制台 public static void WriteToScreen(string str) { Console.WriteLine(\"The String is: {0}\", str); } // 该方法打印到文件 public static void WriteToFile(string s) { fs = new FileStream(\"c:\\\\message.txt\", FileMode.Append, FileAccess.Write); sw = new StreamWriter(fs); sw.WriteLine(s); sw.Flush(); sw.Close(); fs.Close(); } // 该方法把委托作为参数，并使用它调用方法 public static void sendString(printString ps) { ps(\"Hello World\"); } static void Main(string[] args) { printString ps1 = new printString(WriteToScreen); printString ps2 = new printString(WriteToFile); sendString(ps1); sendString(ps2); Console.ReadKey(); } } } 当上面的代码被编译和执行时，它会产生下列结果： The String is: Hello World ","date":"2022-05-31","objectID":"/csharp-delegate-note/:1:4","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back","note"],"content":"C# 调用带返回值的委托 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; //调用带返回值的委托。如果方法列表中有多个方法, //则最后一个方法的返回值就是委托的返回值，其他方法的返回值都被忽略。 namespace Examples { delegate int MyDel(); // 声明一个带返回值的委托 class MyClass { int IntValue = 0; public int Add2() { IntValue += 2; return IntValue; } public int Add3() { IntValue += 3; return IntValue; } } class Program { static void Main() { MyClass mc = new MyClass(); MyDel mDel = mc.Add2; // mDel-= mc.Add2;// 创建委托实例. Console.WriteLine(\"Value: {0}\", mDel());//2 mDel += mc.Add3; // 追加方法到列表 Console.WriteLine(\"Value: {0}\", mDel()); //先运行了一次add2 ,再运行一次add2 add3 mDel += mc.Add2; // 追加方法到列表 //mDel -= mc.Add2; Console.WriteLine(\"Value: {0}\", mDel());//14 mDel += mc.Add3; // 追加方法到列表 Console.WriteLine(\"Value: {0}\", mDel()); Console.ReadLine(); } } } ","date":"2022-05-31","objectID":"/csharp-delegate-note/:2:0","tags":["CSharp","Delegate"],"title":"C# 委托（Delegate）笔记","uri":"/csharp-delegate-note/"},{"categories":["Back"],"content":"记录Spring Cloud nested exception is java.lang.IllegalStateException: RequestParam.value() was empty on 报错的解决办法","date":"2022-05-31","objectID":"/springcloud-requestparam-value-was-empty-error/","tags":["Java","SpringCloud","SpringBoot","Controller","Feign","Error"],"title":"Spring Cloud nested exception is java.lang.IllegalStateException: RequestParam.value() was empty on 报错","uri":"/springcloud-requestparam-value-was-empty-error/"},{"categories":["Back"],"content":"记录本次出现nested exception is java.lang.IllegalStateException: RequestParam.value() was empty on 的原因，以后遇到其他原因导致的也要记录下 出现此问题原因： @RequestParam一定要有value属性，如图 ","date":"2022-05-31","objectID":"/springcloud-requestparam-value-was-empty-error/:0:0","tags":["Java","SpringCloud","SpringBoot","Controller","Feign","Error"],"title":"Spring Cloud nested exception is java.lang.IllegalStateException: RequestParam.value() was empty on 报错","uri":"/springcloud-requestparam-value-was-empty-error/"},{"categories":["Back","note"],"content":"记录SpringCloud使用Feign笔记","date":"2022-05-31","objectID":"/rpc-feign-note/","tags":["SpringCloud","RPC","Feign"],"title":"SpringCloud使用Feign笔记","uri":"/rpc-feign-note/"},{"categories":["Back","note"],"content":"SpringCloud使用Feign调用第三方接口 最近工作中需要用到第三方接口，常规解决方案有三种：1.使用HttpClient。2.使用resTemplate。3.使用Feign。毫无疑问，第三种方法代码量最少而且与项目中微服务内部远程调用编码风格统一。 ​ 第一步，引入openfrign依赖 ​ 第二步，编写接口远程调用第三方服务，这里以百度地图地理编码接口举例，ak自行申请。 注意：1.网上关于@PathVariable的使用都是复制粘贴的获取URL中参数的作用，但是其实@PathVariable可以将方法的参数填充到URL的占位符中行程完整的请求路径。2.name不可与其他微服务名称相同，否则会报错。3.FeignClient中的路径+@GetMapping中的路径拼接才是完整的请求路径：http://api.map.baidu.com/geocoding/v3/output=json\u0026ak={ak}\u0026address={address} ​ 第三步，编写接口进行测试 返回结果如下： 得到了预期的返回结果，大功告成！ 用最少的代码实现需求，精准而优雅，SpringCloud-YYDS ","date":"2022-05-31","objectID":"/rpc-feign-note/:1:0","tags":["SpringCloud","RPC","Feign"],"title":"SpringCloud使用Feign笔记","uri":"/rpc-feign-note/"},{"categories":["Back","note"],"content":"记录Springboot集成Ribbon使用RestTemplate时：java.lang.IllegalStateException: No instances available for localhost的解决办法","date":"2022-05-31","objectID":"/springboot-resttemplate-ribbon-no-instances-error/","tags":["Java","Spring","SpringCloud","RPC","Ribbon","RestTemplate","Error"],"title":"Springboot集成Ribbon使用RestTemplate时：java.lang.IllegalStateException: No instances available for localhost","uri":"/springboot-resttemplate-ribbon-no-instances-error/"},{"categories":["Back","note"],"content":"分析 在启动类中配置使用了 @LoadBalanced 再调用 @Autowired private RestTemplate restTemplate; 必须使用应用名作为代替ip:端口， http://127.0.0.1:8080/hello 改成 http://应用名/hello 不然会报错 使用RestTemplate时报错 java.lang.IllegalStateException: No instances available for 127.0.0.1 1：不要使用ip+port的方式访问，取而代之的是应用名 2：这种方式发送的请求都会被ribbon拦截，ribbon从eureka注册中心获取服务列表，然后采用均衡策略进行访问 ","date":"2022-05-31","objectID":"/springboot-resttemplate-ribbon-no-instances-error/:1:0","tags":["Java","Spring","SpringCloud","RPC","Ribbon","RestTemplate","Error"],"title":"Springboot集成Ribbon使用RestTemplate时：java.lang.IllegalStateException: No instances available for localhost","uri":"/springboot-resttemplate-ribbon-no-instances-error/"},{"categories":["Back","note"],"content":"记录RestTemplate 用法的笔记","date":"2022-05-31","objectID":"/spring-resttemplate-note/","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"引言 上篇文章带大家学习了一下基本的微服务环境搭建，由 provider 提供服务， consumer 通过 DiscoveryClient 先去 eureka 上获取 provider 的服务的地址，获取到地址之后再去调用相关的服务。在服务的调用过程中，使用到了一个工具，叫做 RestTemplate，RestTemplate 是由 Spring 提供的一个 HTTP 请求工具。在上文的案例中，开发者也可以不使用 RestTemplate ，使用 Java 自带的 HttpUrlConnection 或者经典的网络访问框架 HttpClient 也可以完成上文的案例，只是在 Spring 项目中，使用 RestTemplate 显然更方便一些。在传统的项目架构中，因为不涉及到服务之间的调用，大家对 RestTemplate 的使用可能比较少，因此，本文我们就先来带领大家来学习下 RestTemplate 的各种不同用法，只有掌握了这些用法，才能在微服务调用中随心所欲地发送请求。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:1:0","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"RestTemplate 简介 RestTemplate 是从 Spring3.0 开始支持的一个 HTTP 请求工具，它提供了常见的REST请求方案的模版，例如 GET 请求、POST 请求、PUT 请求、DELETE 请求以及一些通用的请求执行方法 exchange 以及 execute。RestTemplate 继承自 InterceptingHttpAccessor 并且实现了 RestOperations 接口，其中 RestOperations 接口定义了基本的 RESTful 操作，这些操作在 RestTemplate 中都得到了实现。接下来我们就来看看这些操作方法的使用。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:2:0","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"用法实战 在开始下面的案例之前，我们需要先创建一个工程，命名为 RestTemplate 。和上篇文章的项目结构一样，在 RestTemplate 中，我们也分别创建子项目 eureka 、provider 以及 consumer ，将 provider 和 consumer 分别注册到 eureka 上面去。这个具体的步骤大家可以参考上篇文章，本文我就不赘述了，这是我们的准备工作。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:0","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"GET 请求 做好了准备工作，先来看使用 RestTemplate 发送 GET 请求。在 RestTemplate 中，和 GET 请求相关的方法有如下几个： 这里的方法一共有两类，getForEntity 和 getForObject，每一类有三个重载方法，下面我们分别予以介绍。 getForEntity 既然 RestTemplate 发送的是 HTTP 请求，那么在响应的数据中必然也有响应头，如果开发者需要获取响应头的话，那么就需要使用 getForEntity 来发送 HTTP 请求，此时返回的对象是一个 ResponseEntity 的实例。这个实例中包含了响应数据以及响应头。例如，在 provider 中提供一个 HelloController 接口，HelloController 接口中定义一个 sayHello 的方法，如下： @RestController public class HelloController { @GetMapping(\"/hello\") public String sayHello(String name) { return \"hello \" + name + \" !\"; } } 在 consumer 中定义一个 UseHelloController 的类，再定义一个 /hello 接口，在接口中调用 provider 提供的服务，如下： @RestController public class UseHelloController { @Autowired DiscoveryClient discoveryClient; @Autowired RestTemplate restTemplate; @GetMapping(\"/hello\") public String hello(String name) { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/hello?name={1}\"; ResponseEntity\u003cString\u003e responseEntity = restTemplate.getForEntity(url, String.class, name); StringBuffer sb = new StringBuffer(); HttpStatus statusCode = responseEntity.getStatusCode(); String body = responseEntity.getBody(); sb.append(\"statusCode：\") .append(statusCode) .append(\"\u003c/br\u003e\") .append(\"body：\") .append(body) .append(\"\u003c/br\u003e\"); HttpHeaders headers = responseEntity.getHeaders(); Set\u003cString\u003e keySet = headers.keySet(); for (String s : keySet) { sb.append(s) .append(\":\") .append(headers.get(s)) .append(\"\u003c/br\u003e\"); } return sb.toString(); } } 关于 DiscoveryClient 那一段本文先不做讨论，主要来看 getForEntity 方法。第一个参数是 url ，url 中有一个占位符 {1} ,如果有多个占位符分别用 {2} 、 {3} … 去表示，第二个参数是接口返回的数据类型，最后是一个可变长度的参数，用来给占位符填值。在返回的 ResponseEntity 中，可以获取响应头中的信息，其中 getStatusCode 方法用来获取响应状态码， getBody 方法用来获取响应数据， getHeaders 方法用来获取响应头，在浏览器中访问该接口，结果如下： 当然，这里参数的传递除了这一种方式之外，还有另外两种方式，也就是 getForEntity 方法的另外两个重载方法。 第一个是占位符不使用数字，而是使用参数的 key，同时将参数放入到一个 map 中。map 中的 key 和占位符的 key 相对应，map 中的 value 就是参数的具体值，例如还是上面的请求，利用 map 来传递参数，请求方式如下： Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); String url = \"http://\" + host + \":\" + port + \"/hello?name={name}\"; map.put(\"name\", name); ResponseEntity\u003cString\u003e responseEntity = restTemplate.getForEntity(url, String.class, map); 这种方式传参可能看起来更直观一些。 第二个是使用 Uri 对象，使用 Uri 对象时，参数可以直接拼接在地址中，例如下面这样： String url = \"http://\" + host + \":\" + port + \"/hello?name=\"+ URLEncoder.encode(name,\"UTF-8\"); URI uri = URI.create(url); ResponseEntity\u003cString\u003e responseEntity = restTemplate.getForEntity(uri, String.class); 但需要注意的是，这种传参方式，参数如果是中文的话，需要对参数进行编码，使用 URLEncoder.encode 方法来实现。 getForObject getForObject 方法和 getForEntity 方法类似，getForObject 方法也有三个重载的方法，参数和 getForEntity 一样，因此这里我就不重复介绍参数了，这里主要说下 getForObject 和 getForEntity 的差异，这两个的差异主要体现在返回值的差异上， getForObject 的返回值就是服务提供者返回的数据，使用 getForObject 无法获取到响应头。例如，还是上面的请求，利用 getForObject 来发送 HTTP 请求，结果如下： String url = \"http://\" + host + \":\" + port + \"/hello?name=\" + URLEncoder.encode(name, \"UTF-8\"); URI uri = URI.create(url); String s = restTemplate.getForObject(uri, String.class); 注意，这里返回的 s 就是 provider 的返回值，如果开发者只关心 provider 的返回值，并不关系 HTTP 请求的响应头，那么可以使用该方法。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:1","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"POST 请求 和 GET 请求相比，RestTemplate 中的 POST 请求多了一个类型的方法，如下： 可以看到，post 请求的方法类型除了 postForEntity 和 postForObject 之外，还有一个 postForLocation。这里的方法类型虽然有三种，但是这三种方法重载的参数基本是一样的，因此这里我还是以 postForEntity 方法为例，来剖析三个重载方法的用法，最后再重点说下 postForLocation 方法。 postForEntity 在 POST 请求中，参数的传递可以是 key/value 的形式，也可以是 JSON 数据，分别来看： 传递 key/value 形式的参数 首先在 provider 的 HelloController 类中再添加一个 POST 请求的接口，如下： @PostMapping(\"/hello2\") public String sayHello2(String name) { return \"Hello \" + name + \" !\"; } 然后在 consumer 中添加相应的方法去访问，如下： @GetMapping(\"/hello5\") public String hello5(String name) { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/hello2\"; MultiValueMap map = new LinkedMultiValueMap(); map.add(\"name\", name); ResponseEntity\u003cString\u003e responseEntity = restTemplate.postForEntity(url, map, String.class); return responseEntity.getBody(); } 在这里， postForEntity 方法第一个参数是请求地址，第二个参数 map 对象中存放着请求参数 key/value，第三个参数则是返回的数据类型。当然这里的第一个参数 url 地址也可以换成一个 Uri 对象，效果是一样的。这种方式传递的参数是以 key/value 形式传递的，在 post 请求中，也可以按照 get 请求的方式去传递 key/value 形式的参数，传递方式和 get 请求的传参方式基本一致，例如下面这样： @GetMapping(\"/hello6\") public String hello6(String name) { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/hello2?name={1}\"; ResponseEntity\u003cString\u003e responseEntity = restTemplate.postForEntity(url, null, String.class,name); return responseEntity.getBody(); } 此时第二个参数可以直接传一个 null。 传递 JSON 数据 上面介绍的是 post 请求传递 key/value 形式的参数，post 请求也可以直接传递 json 数据，在 post 请求中，可以自动将一个对象转换成 json 进行传输，数据到达 provider 之后，再被转换为一个对象。具体操作步骤如下： 首先在 RestTemplate 项目中创建一个新的maven项目，叫做 commons ，然后在 commons 中创建一个 User 对象，如下： public class User { private String username; private String address; //省略getter/setter } 然后分别在 provider 和 consumer 的 pom.xml 文件中添加对 commons 模块的依赖，如下： \u003cdependency\u003e \u003cgroupId\u003ecom.justdojava\u003c/groupId\u003e \u003cartifactId\u003ecommons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 这样，在 provider 和 consumer 中就都能使用 User 对象了。首先在 provider 中创建一个添加用户的接口，如下： @Controller @ResponseBody public class UserController { @PostMapping(\"/user\") public User hello(@RequestBody User user) { return user; } } 这里的接口很简单，只需要将用户传来的 User 对象再原封不动地返回去就行了，然后在 consumer 中添加一个接口来测试这个接口，如下： @GetMapping(\"/hello7\") public User hello7() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/user\"; User u1 = new User(); u1.setUsername(\"牧码小子\"); u1.setAddress(\"深圳\"); ResponseEntity\u003cUser\u003e responseEntity = restTemplate.postForEntity(url, u1, User.class); return responseEntity.getBody(); } 看到这段代码有人要问了，这不和前面的一样吗？是的，唯一的区别就是第二个参数的类型不同，这个参数如果是一个 MultiValueMap 的实例，则以 key/value 的形式发送，如果是一个普通对象，则会被转成 json 发送。 postForObject postForObject 和 postForEntity 基本一致，就是返回类型不同而已，这里不再赘述。 postForLocation postForLocation 方法的返回值是一个 Uri 对象，因为 POST 请求一般用来添加数据，有的时候需要将刚刚添加成功的数据的 URL 返回来，此时就可以使用这个方法，一个常见的使用场景如用户注册功能，用户注册成功之后，可能就自动跳转到登录页面了，此时就可以使用该方法。例如在 provider 中提供一个用户注册接口，再提供一个用户登录接口，如下： @RequestMapping(\"/register\") public String register(User user) throws UnsupportedEncodingException { return \"redirect:/loginPage?username=\" + URLEncoder.encode(user.getUsername(),\"UTF-8\") + \"\u0026address=\" + URLEncoder.encode(user.getAddress(),\"UTF-8\"); } @GetMapping(\"/loginPage\") @ResponseBody public String loginPage(User user) { return \"loginPage:\" + user.getUsername() + \":\" + user.getAddress(); } 这里一个注册接口，一个是登录页面，不过这里的登录页面我就简单用一个字符串代替了。然后在 consumer 中来调用注册接口，如下： @GetMapping(\"/hello8\") public String hello8() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\"","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:2","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"PUT 请求 只要将 GET 请求和 POST 请求搞定了，接下来 PUT 请求就会容易很多了，PUT 请求本身方法也比较少，只有三个，如下： 这三个重载的方法其参数其实和 POST 是一样的，可以用 key/value 的形式传参，也可以用 JSON 的形式传参，无论哪种方式，都是没有返回值的，我这里就举两个例子给大家参考下： 首先在 provider 的 UserController 中添加如下两个数据更新接口： @PutMapping(\"/user/name\") @ResponseBody public void updateUserByUsername(User User) { System.out.println(User); } @PutMapping(\"/user/address\") @ResponseBody public void updateUserByAddress(@RequestBody User User) { System.out.println(User); } 这里两个接口，一个接收 key/value 形式的参数，另一个接收 JSON 参数。因为这里没有返回值，我直接把数据打印出来就行了。接下来在 consumer 中添加接口调用这里的服务，如下： @GetMapping(\"/hello9\") public void hello9() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url1 = \"http://\" + host + \":\" + port + \"/user/name\"; String url2 = \"http://\" + host + \":\" + port + \"/user/address\"; MultiValueMap map = new LinkedMultiValueMap(); map.add(\"username\", \"牧码小子\"); map.add(\"address\", \"深圳\"); restTemplate.put(url1, map); User u1 = new User(); u1.setAddress(\"广州\"); u1.setUsername(\"江南一点雨\"); restTemplate.put(url2, u1); } 访问 /hello9 接口，即可看到 provider 上有日志打印出来，这里比较简单，我就不再演示。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:3","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"DELETE 请求 和 PUT 请求一样，DELETE 请求也是比较简单的，只有三个方法，如下： 不同于 POST 和 PUT ，DELETE 请求的参数只能在地址栏传送，可以是直接放在路径中，也可以用 key/value 的形式传递，当然，这里也是没有返回值的。我也举两个例子： 首先在 provider 的 UserController 中添加两个接口，如下： @DeleteMapping(\"/user/{id}\") @ResponseBody public void deleteUserById(@PathVariable Integer id) { System.out.println(id); } @DeleteMapping(\"/user/\") @ResponseBody public void deleteUserByUsername(String username) { System.out.println(username); } 两个接口，一个的参数在路径中，另一个的参数以 key/value 的形式传递，然后在 consumer 中，添加一个方法调用这两个接口，如下： @GetMapping(\"/hello10\") public void hello10() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url1 = \"http://\" + host + \":\" + port + \"/user/{1}\"; String url2 = \"http://\" + host + \":\" + port + \"/user/?username={username}\"; Map\u003cString,String\u003e map = new HashMap\u003c\u003e(); map.put(\"username\", \"牧码小子\"); restTemplate.delete(url1, 99); restTemplate.delete(url2, map); } 这里参数的传递和 GET 请求基本一致，我就不再赘述了。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:4","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"其他 设置请求头 有的时候我们会有一些特殊的需求，例如模拟 cookie ，此时就需要我们自定义请求头了。自定义请求头可以通过拦截器的方式来实现（下篇文章我们会详细的说这个拦截器）。定义拦截器、自动修改请求数据、一些身份认证信息等，都可以在拦截器中来统一处理。具体操作步骤如下： 首先在 provider 中定义一个接口，在接口中获取客户端传来的 cookie 数据，如下： @GetMapping(\"/customheader\") public String customHeader(HttpServletRequest req) { return req.getHeader(\"cookie\"); } 这里简单处理，将客户端传来的 cookie 拿出来后再返回给客户端，然后在 consumer 中添加如下接口来测试： @GetMapping(\"/hello11\") public void hello11() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/customheader\"; restTemplate.setInterceptors(Collections.singletonList(new ClientHttpRequestInterceptor() { @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { HttpHeaders headers = request.getHeaders(); headers.add(\"cookie\",\"justdojava\"); return execution.execute(request,body); } })); String s = restTemplate.getForObject(url, String.class); System.out.println(s); } 这里通过调用 RestTemplate 的 setInterceptors 方法来给它设置拦截器，拦截器也可以有多个，我这里只有一个。在拦截器中，将请求拿出来，给它设置 cookie ，然后调用 execute 方法让请求继续执行。此时，在 /customheader 接口中，就能获取到 cookie了。 通用方法 exchange 在 RestTemplate 中还有一个通用的方法 exchange。为什么说它通用呢？因为这个方法需要你在调用的时候去指定请求类型，即它既能做 GET 请求，也能做 POST 请求，也能做其它各种类型的请求。如果开发者需要对请求进行封装，使用它再合适不过了，举个简单例子： @GetMapping(\"/hello12\") public void hello12() { List\u003cServiceInstance\u003e list = discoveryClient.getInstances(\"provider\"); ServiceInstance instance = list.get(0); String host = instance.getHost(); int port = instance.getPort(); String url = \"http://\" + host + \":\" + port + \"/customheader\"; HttpHeaders headers = new HttpHeaders(); headers.add(\"cookie\",\"justdojava\"); HttpEntity\u003cMultiValueMap\u003cString,String\u003e\u003e request = new HttpEntity\u003c\u003e(null,headers); ResponseEntity\u003cString\u003e responseEntity = restTemplate.exchange(url, HttpMethod.GET, request, String.class); System.out.println(responseEntity.getBody()); } 这里的参数和前面的也都差不多，注意就是多了一个请求类型的参数，然后创建一个 HttpEntity 作为参数来传递。 HttpEntity 在创建时候需要传递两个参数，第一个上文给了一个 null ，这个参数实际上就相当于 POST/PUT 请求中的第二个参数，有需要可以自行定义。HttpEntity 创建时的第二个参数就是请求头了，也就是说，如果使用 exchange 来发送请求，可以直接定义请求头，而不需要使用拦截器。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:3:5","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back","note"],"content":"小结 本文主要向大家介绍了 RestTemplate 这样一个 HTTP 请求工具类的常见用法，一些比较冷门的用法本文并未涉及，读者有兴趣可以自行查找资料学习。由于 Spring、SpringMVC、Spring Boot、Spring Cloud 这些家族成员一脉相承，因此在 SpringMVC 中支持良好的 RESTful 风格的接口在后续的各个组件中都继续支持，在微服务接口设计时，大部分接口也都满足 RESTful 风格，使用 RestTemplate 则可以非常方便地发送 RESTful 风格的请求，因此这个工具的使用是我们后面学习的基础，常见的用法一定要熟练掌握。 ","date":"2022-05-31","objectID":"/spring-resttemplate-note/:4:0","tags":["Java","Spring","RestTemplate"],"title":"RestTemplate 用法详解","uri":"/spring-resttemplate-note/"},{"categories":["Back"],"content":"记录Feign：No fallbackFactory instance of type报错的解决办法","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"背景 我在:ruoyi-api-system这个模块,这个模块仅仅是放了一些类,没有启动类 src/main/java/com.ruoyi.system.api 下面添加了自己的远程调用类: 这个类是在:ruoyi-auth模块中用到的. ","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/:1:0","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"报错 但是当我启动ruoyi-auth的时候,发现报错了: No fallbackFactory instance of type class com.jnhc.system.api.factory.RemotexxxxFallbackFactory found for feign client remoteTeUserService ","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/:2:0","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"最后解决方案 在:RuoyiAuthApplication 这个类上面,添加 @ComponentScan({\"com.ruoyi.system.api\"}) 这样就可以了. \u003e»»»»»»»»»»»»警告»»»上面的方法不管用»»»»»\u003e ","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/:3:0","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"最后解决方案2 最后是这样弄的,一定要注意: 在ruoyi-api 下面的 ruoyi-api-system 中有个 src/main/java 然后有个src/main/resources 这里面有个META-INF里面有个 spring.factories文件,在这个文件中配置的 org.springframework.boot.autoconfigure.EnableAutoConfiguration= ","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/:4:0","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"分析 由于此项目工程种没有添加Spring/SpringBoot/SpringCloud等任何包，故无法使用注解将其注入，需要直接使用spring.factories文件注入Bean ","date":"2022-05-31","objectID":"/rpc-feign-no-fallbackfactory-error/:5:0","tags":["Microservices","SrpingCloud","RPC","Feign","FallbackFactory","Error"],"title":"Feign：No fallbackFactory instance of type报错","uri":"/rpc-feign-no-fallbackfactory-error/"},{"categories":["Back"],"content":"记录事务注解 @Transactional 失效的场景及6种解决办法","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"Transactional失效场景介绍 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:0","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第一种 Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用。例如以下代码。 定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法 /** * @author zhoujy **/ @Component public class TestServiceImpl { @Resource TestMapper testMapper; @Transactional void insertTestWrongModifier() { int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); } } 在同一个包内，新建调用对象，进行访问。 @Component public class InvokcationService { @Resource private TestServiceImpl testService; public void invokeInsertTestWrongModifier(){ //调用@Transactional标注的默认访问符方法 testService.insertTestWrongModifier(); } } 测试用例 @RunWith(SpringRunner.class) @SpringBootTest public class DemoApplicationTests { @Resource InvokcationService invokcationService; @Test public void testInvoke(){ invokcationService.invokeInsertTestWrongModifier(); } } 以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果TestServiceImpl#insertTestWrongModifier方法改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:1","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第二种 在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。示例代码如下。 设置一个内部调用 /** * @author zhoujy **/ @Component public class TestServiceImpl implements TestService { @Resource TestMapper testMapper; @Transactional public void insertTestInnerInvoke() { //正常public修饰符的事务方法 int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); } public void testInnerInvoke(){ //类内部调用@Transactional标注的方法。 insertTestInnerInvoke(); } } 测试用例。 @RunWith(SpringRunner.class) @SpringBootTest public class DemoApplicationTests { @Resource TestServiceImpl testService; /** * 测试内部调用@Transactional标注方法 */ @Test public void testInnerInvoke(){ //测试外部调用事务方法是否正常 //testService.insertTestInnerInvoke(); //测试内部调用事务方法是否正常 testService.testInnerInvoke(); } } 上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚； 然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:2","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第三种 事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下。 /** * @author zhoujy **/ @Component public class TestServiceImpl implements TestService { @Resource TestMapper testMapper; @Transactional public void insertTestCatchException() { try { int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { //运行期间抛异常 throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); }catch (Exception e){ System.out.println(\"i catch exception\"); } } } 测试用例代码如下。 @RunWith(SpringRunner.class) @SpringBootTest public class DemoApplicationTests { @Resource TestServiceImpl testService; @Test public void testCatchException(){ testService.insertTestCatchException(); } } 运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。 以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。 在这个工程中，定义一个名为User的实体： @Entity @Data @NoArgsConstructor public class User { @Id @GeneratedValue private Long id; @Size(max = 5) private String name; @Max(50) private Integer age; public User(String name, Integer age) { this.name = name; this.age = age; } } 这里name设置了长度为5，这样可以通过insert语句中的name超长，让其抛出异常，从而可以测试事务的触发。 另外工程中还包含了Spring Data Jpa的数据访问对象UserRepository，用来实现对User实体的数据操作，这里就不放具体代码了。 问题来了 这里数据库采用MySQL 5.7，存储引擎为InnoDB，使用默认事务级别。 下面来调整下这三个问题吧： 问题一：test1会不会回滚？ @Transactional public void test1() { userRepository.save(new User(\"AAA\", 10)); throw new RuntimeException(); } 问题二：test2会不会回滚？（第二句插入name超长） @Transactional public void test3() { userRepository.save(new User(\"BBB\", 10)); userRepository.save(new User(\"123456\", 20)); } 问题三：test3会不会回滚？（第二句插入name超长） @Transactional public void test4() { userRepository.save(new User(\"BBB\", 10)); try { userRepository.save(new User(\"123456\", 20)); } catch (Exception e) { log.error(\"异常捕获：\", e); } } 答案是这三种都会回滚。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:3","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第四种 旧版本MyISAM引擎导致不支持事务，故无法正确回滚 所以，如果你的事务没有生效，那么可以看看创建的表，是不是使用了MyISAM存储引擎，如果是的话，那就是这个原因了！ ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:4","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第五种 数据源没有配置事务管理器 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:5","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第六种 异常类型错误，如果有通过rollbackFor指定回滚的异常类型，那么抛出的异常与指定的是否一致。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:1:6","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"@Transactional注解不起作用原理分析 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:0","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第一种 @Transactional注解标注方法修饰符为非public时，@Transactional注解将会不起作用。这里分析 的原因是，@Transactional是基于动态代理实现的，@Transactional注解实现原理中分析了实现方法，在bean初始化过程中，对含有@Transactional标注的bean实例创建代理对象，这里就存在一个spring扫描@Transactional注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的@Transactional信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用 @Transactional注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是。根据spring创建好一个aop切点BeanFactoryTransactionAttributeSourceAdvisor实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含@Transactional，如果bean任何一个方法包含@Transactional注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。 spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中， AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class\u003c?\u003e, boolean) public static boolean canApply(Pointcut pc, Class\u003c?\u003e targetClass, boolean hasIntroductions) { Assert.notNull(pc, \"Pointcut must not be null\"); if (!pc.getClassFilter().matches(targetClass)) { return false; } MethodMatcher methodMatcher = pc.getMethodMatcher(); if (methodMatcher == MethodMatcher.TRUE) { // No need to iterate the methods if we're matching any method anyway... return true; } IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) { introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; } //遍历class的方法对象 Set\u003cClass\u003c?\u003e\u003e classes = new LinkedHashSet\u003cClass\u003c?\u003e\u003e(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); classes.add(targetClass); for (Class\u003c?\u003e clazz : classes) { Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) { if ((introductionAwareMethodMatcher != null \u0026\u0026 introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) || //适配查询方法上的@Transactional注解信息 methodMatcher.matches(method, targetClass)) { return true; } } } return false; } 我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。推荐：Java面试练题宝典 AbstractFallbackTransactionAttributeSource#getTransactionAttribute AbstractFallbackTransactionAttributeSource#computeTransactionAttribute protected TransactionAttribute computeTransactionAttribute(Method method, Class\u003c?\u003e targetClass) { // Don't allow no-public methods as required. //非public 方法，返回@Transactional信息一律是null if (allowPublicMethodsOnly() \u0026\u0026 !Modifier.isPublic(method.getModifiers())) { return null; } //后面省略....... } 不创建代理对象 所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。 如果class中的方法都是非public的那么将不是代理对象。 不进行代理调用 考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。 创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。 /** * @author zhoujy **/ @Component public class TestServiceImpl implements TestService { @Resource TestMapper testMapper; @Override @Transactional public void insertTest() { int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); } @Transactional void insertTestWrongModifier() { int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); } } 原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中CglibAopProxy.DynamicAdvisedInterceptor#intercept，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。 List\u003cObject\u003e chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次 AbstractFallbackTransactionAttributeSource#getTransactionAttribute AbstractFallbackTransactionAttributeSource#computeTransactionAttribute 也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:1","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第二种 在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。 经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到； 既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。 其实我们可以这样玩，内部调用也能实现开启事务，代码如下。 /** * @author zhoujy **/ @Component public class TestServiceImpl implements TestService { @Resource TestMapper testMapper; @Resource TestServiceImpl testServiceImpl; @Transactional public void insertTestInnerInvoke() { int re = testMapper.insert(new Test(10,20,30)); if (re \u003e 0) { throw new NeedToInterceptException(\"need intercept\"); } testMapper.insert(new Test(210,20,30)); } public void testInnerInvoke(){ //内部调用事务方法 testServiceImpl.insertTestInnerInvoke(); } } 上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩~ 实在碰到业务需要，建议分开写，互相调用。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:2","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第三种 事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。 这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里卖弄动态代理逻辑是如何为我们管理事务的。 TransactionAspectSupport#invokeWithinTransaction 代码如下。 protected Object invokeWithinTransaction(Method method, Class\u003c?\u003e targetClass, final InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional. final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass); final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { // Standard transaction demarcation with getTransaction and commit/rollback calls. //开启事务 TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. //反射调用业务方法 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // target invocation exception //异常时，在catch逻辑中回滚事务 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } //提交事务 commitTransactionAfterReturning(txInfo); return retVal; } else { //.................... } } 所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。 解释三种情况异常会回滚 一二不难理解，由于没有被Catch，故捕捉不到，案例三有些特殊 为什么没回滚 先来说说，那些写了代码验证\"不会回滚“的情况，把这些错误答案的原因先说清楚，然后再细说test4会回滚的情况。 根据这两天读者给我的案例或者描述清楚的一些情况，归结了一下，大家写的验证代码之所以不会回滚，主要有以下三个原因： 没有按照我题目开头说的，采用InnoDB存储引擎，用了MyISAM，不支持事务，自然不会复现。 没用按照我题目开头说的，采用JPA和JSR 303校验注解，比如：用了MyBaits，所以自然也不会复现。 定义事务的函数不是public类型，这个基础用法就不对了，事务本身就没生效 归家一下出现这些疑问的原因：没审题和事务基础掌握不牢导致。关于事务基础使用的一些常见注意点，之前写过一篇文章，如果觉得这方面知识还不扎实的，建议读一读：《为什么加了@Transactional注解，事务没有回滚？》(https://blog.didispace.com/transactional-not-rollback/) 为什么写了catch，还会回滚 先来看看执行时候报的异常： javax.validation.ConstraintViolationException: Validation failed for classes [com.didispace.chapter310.User] during persist time for groups [javax.validation.groups.Default, ] List of constraint violations:[ ConstraintViolationImpl{interpolatedMessage='个数必须在0和5之间', propertyPath=name, rootBeanClass=class com.didispace.chapter310.User, messageTemplate='{javax.validation.constraints.Size.message}'} ] at org.hibernate.cfg.beanvalidation.BeanValidationEventListener.validate(BeanValidationEventListener.java:140) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.cfg.beanvalidation.BeanValidationEventListener.onPreInsert(BeanValidationEventListener.java:80) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.action.internal.EntityInsertAction.preInsert(EntityInsertAction.java:209) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.action.internal.EntityInsertAction.execute(EntityInsertAction.java:83) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:604) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:478) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:356) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:39) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.internal.SessionImpl.doFlush(SessionImpl.java:1454) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:511) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.internal.SessionImpl.flushBeforeTransactionCompletion(SessionImpl.java:3283) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final] at org.hibernate.internal.SessionImpl.beforeTransactionCompletion(SessionImpl.java:2479) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Fi","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:3","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第四种 在前文的描述中，我漏了一个细节，其实在示例代码中，与之前拿的基础例子在配置中有一个关键属性没有提到，就是下面这个配置： spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect 这里的spring.jpa.database-platform配置主要用来设置hibernate使用的方言。这里特地采用了MySQL5InnoDBDialect，主要为了保障在使用Spring Data JPA时候，Hibernate自动创建表的时候使用InnoDB存储引擎，不然就会以默认存储引擎MyISAM来建表，而MyISAM存储引擎是没有事务的。 修改数据库引擎即可 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:4","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第五种 正确配置事务管理器 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:5","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back"],"content":"第六种 修改异常类型一致即可 总结了以上几种情况。 ","date":"2022-05-31","objectID":"/spring-transactional-invalid-error/:2:6","tags":["Java","Srping","Transactional","Error"],"title":"事务注解 @Transactional 失效的场景及6种解决办法","uri":"/spring-transactional-invalid-error/"},{"categories":["Back","note"],"content":"记录Java即时编译器原理解析及实践的笔记","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"一、导读 常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。 为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。 即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:1:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"二、Java的执行过程 Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。 怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示： ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:2:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"1. JVM中的编译器 JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。 Client Compiler HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事： 局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。 将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。 最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。 Server Compiler Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。 C2 Compiler 在Hotspot VM中，默认的Server Compiler是C2编译器。 C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。 Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。 无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示： Graal Compiler 从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性： 前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。 使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。 更深层次的优化，比如虚函数的内联、部分逃逸分析等。 Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:2:1","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"2. 分层编译 在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是： 解释执行。 执行不带profiling的C1代码。 执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。 执行带所有profiling的C1代码。 执行C2代码。 profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。 通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层\u003e2层\u003e3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径： 图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。 如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。 在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。 前文提到C1中的执行效率是1层\u003e2层\u003e3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。 如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。 总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:2:2","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"3. 即时编译的触发 Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码： 循环回边 public void nlp(Object obj) { int sum = 0; for (int i = 0; i \u003c 200; i++) { sum += i; } } 上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。 字节码 public void nlp(java.lang.Object); Code: 0: iconst_0 1: istore_1 2: iconst_0 3: istore_2 4: iload_2 5: sipush 200 8: if_icmpge 21 11: iload_1 12: iload_2 13: iadd 14: istore_1 15: iinc 2, 1 18: goto 4 21: return 在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。 当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。 开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断： 方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。 方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。 分层编译触发条件公式 i \u003e TierXInvocationThreshold * s || (i \u003e TierXMinInvocationThreshold * s \u0026\u0026 i + b \u003e TierXCompileThreshold * s) i为调用次数，b是循环回边次数 上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:2:3","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"三、编译优化 即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"1. 中间表达形式（Intermediate Representation） 在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。 Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子： SSA IR Plain Text { a = 1; a = 2; b = a; } 上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。 上面代码的SSA IR形式的伪代码可以表示为： SSA IR Plain Text { a_1 = 1; a_2 = 2; b_1 = a_2; } 由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。 除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子： DeadCodeElimination public void DeadCodeElimination{ int a = 2; int b = 0 if(2 \u003e 1){ a = 1; } else{ b = 2; } add(a,b) } 可以得到SSA IR伪代码： DeadCodeElimination a_1 = 2; b_1 = 0 if true: a_2 = 1; else b_2 = 2; add(a,b) 编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码： DeadCodeElimination public void DeadCodeElimination{ int a = 1; int b = 0; add(a,b) } 我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。 C1中的中间表达形式 前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。 HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示： 其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。 从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示： 字节码构造HIR 字节码 Local Value operand stack HIR 5: iload_1 [i1,i2] [i1] 6: iload_2 [i1,i2] [i1,i2] ................................................ i3: i1 * i2 7: imul 8: istore_3 [i1,i2，i3] [i3] 可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。 C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。 Sea-of-Nodes IR C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码： example public static int foo(int count) { int sum = 0; for (int i = 0; i \u003c count; i++) { sum += i; } return sum; } 对应的IR图如下所示： 图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。 这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。 依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。 Phi And Region Nodes Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。 example int test(int x) { int a = 0; if(x == 1) { a = 5; } else { a = 6; } return a; } 为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图： Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下： Phi Nodes int test(int x) { a_1 = 0; if(x == 1){ a_2 = 5; }else { a_3 = 6; } a_4 = Phi(a_2,a_3); return a_4; } Global Value Numbering Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。 GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码： GVN a = 1; b = 2; c = a + b; d = a + b; e = d; GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。 可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:1","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"2.方法内联 方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。 Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）： 方法内联的过程 public static boolean flag = true; public static int value0 = 0; public static int value1 = 1; public static int foo(int value) { int result = bar(flag); if (result != 0) { return result; } else { return value; } } public static int bar(boolean flag) { return flag ? value0 : value1; } bar方法的IR图： 内联后的IR图： 内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。 被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。 调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。 方法内联的条件 编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。 可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示： 虚函数内联 内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。 C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子： virtual call public class SimpleInliningTest { public static void main(String[] args) throws InterruptedException { VirtualInvokeTest obj = new VirtualInvokeTest(); VirtualInvoke1 obj1 = new VirtualInvoke1(); for (int i = 0; i \u003c 100000; i++) { invokeMethod(obj); invokeMethod(obj1); } Thread.sleep(1000); } public static void invokeMethod(VirtualInvokeTest obj) { obj.methodCall(); } private static class VirtualInvokeTest { public void methodCall() { System.out.println(\"virtual call\"); } } private static class VirtualInvoke1 extends VirtualInvokeTest { @Override public void methodCall() { super.methodCall(); } } } 经过JIT编译器优化后，进行反汇编得到下面这段汇编代码： 0x0000000113369d37: callq 0x00000001132950a0 ; OopMap{off=476} ;*invokevirtual methodCall //代表虚调用 ; - SimpleInliningTest::invokeMethod@1 (line 18) ; {optimized virtual_call} //虚调用已经被优化 可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。 比如下面这段代码，我们增加一个实现： 多实现的虚调用 public class SimpleInliningTest { public static void main(String[] args) throws InterruptedException { VirtualInvokeTest obj = new VirtualInvokeTest(); VirtualInvoke1 obj1 = new VirtualInvoke1(); VirtualInvoke2 obj2 = new VirtualInvoke2(); for (int i = 0; i \u003c 100000; i++) { invokeMethod(obj); invokeMethod(obj1); invokeMethod(obj2); } Thread.sleep(1000); } public static void invokeMethod(VirtualInvokeTest obj) { obj.methodCall(); } private static class VirtualInvokeTest { public void methodCall() { System.out.println(\"virtual call\"); } } private static class VirtualInvoke1 extends VirtualInvokeTest { @Override public void methodCall() { super.methodCall(); } } private static class VirtualInvoke2 extends VirtualInvokeTest { @Override public void methodCall() { super.methodCall(); } } } 经过反编译得到下面的汇编代码： 代码块 0x000000011f5f0a37: callq 0x000000011f4fd2e0 ; OopMap{off=28} ;*invokevirtual methodCall //代表虚调用 ; - SimpleInliningTest::invokeMethod@1 (line 20) ; {virtual_call} //虚调用未被优化 可以看到多个实现的虚调用未被优化，依然是virtual_call。 Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:2","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"3. 逃逸分析 逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种： 对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。 对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。 逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子： pulbic class Example{ public static void main(String[] args) { example(); } public static void example() { Foo foo = new Foo(); Bar bar = new Bar(); bar.setFoo(foo); } } class Foo {} class Bar { private Foo foo; public void setFoo(Foo foo) { this.foo = foo; } } } 在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。 锁消除 在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。 如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。 栈上分配 我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子： 标量替换 public class Example{ @AllArgsConstructor class Cat{ int age; int weight; } public static void example(){ Cat cat = new Cat(1,10); addAgeAndWeight(cat.age,Cat.weight); } } 经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码： public class Example{ @AllArgsConstructor class Cat{ int age; int weight; } public static void example(){ int age = 1; int weight = 10; addAgeAndWeight(age,weight); } } 部分逃逸分析 部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:3","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"4. Loop Transformations 在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。 循环展开 循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。 循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环： 循环展开 public void loopRolling(){ for(int i = 0;i\u003c200;i++){ delete(i); } } 上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码： 循环展开 public void loopRolling(){ for(int i = 0;i\u003c200;i+=5){ delete(i); delete(i+1); delete(i+2); delete(i+3); delete(i+4); } } 这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。 循环分离 循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码： 循环分离 int a = 10; for(int i = 0;i\u003c10;i++){ b[i] = x[i] + x[a]; a = i; } 可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码： 循环分离 b[0] = x[0] + 10; for(int i = 1;i\u003c10;i++){ b[i] = x[i] + x[i-1]; } 这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:4","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"5. 窥孔优化与寄存器分配 前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子： 强度削减 y1=x1*3 经过强度削减后得到 y1=(x1\u003c\u003c1)+x1 编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。 寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。 寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:3:5","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"四、实践 即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:4:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"1. 编译相关的重* 要参数 -XX:+TieredCompilation：开启分层编译，JDK8之后默认开启 -XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2 -XX:TierXBackEdgeThreshold：OSR编译的阈值 -XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值 -XX:TierXCompileThreshold：开启分层编译后的编译阈值 -XX:ReservedCodeCacheSize：codeCache最大大小 -XX:InitialCodeCacheSize：codeCache初始大小 -XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。 由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:4:1","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"2. 通过JITwatch分析编译日志 通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。 如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中： 我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。 区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:4:2","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"3. 使用Graal编译器 由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。 为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。 前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。 前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。 这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。 使用Graal编译器后性能表现 在我们的线上服务中，启用Graal编译后，TP9999从60ms -\u003e 50ms ，下降10ms，下降幅度达16.7%。 运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。 Graal编译器的问题 Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。 考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:4:3","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"五、总结 本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:5:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"六、参考文献 《深入理解Java虚拟机》 《Proceedings of the Java™ Virtual Machine Research and Technology Symposium》Monterey, California, USA April 23–24, 2001 《Visualization of Program Dependence Graphs》 Thomas Würthinger 《深入拆解Java虚拟机》 郑宇迪 JIT的Profile神器JITWatch ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:6:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"作者简介 珩智，昊天，薛超，均来自美团AI平台/搜索与NLP部。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:7:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"招聘信息 美团搜索与NLP部，长期招聘搜索、对话、NLP算法工程师，坐标北京/上海，感兴趣的同学可投递简历至：tech@meituan.com（邮件标题请注明：搜索与NLP部）。 ","date":"2022-05-31","objectID":"/jvm-compiler-in-time-note/:8:0","tags":["Java","Jvm","Compiler"],"title":"Java即时编译器原理解析及实践","uri":"/jvm-compiler-in-time-note/"},{"categories":["Back","note"],"content":"记录JUnit笔记","date":"2022-05-30","objectID":"/junit-note/","tags":["Java","JUnit"],"title":"JUnit笔记","uri":"/junit-note/"},{"categories":["Back","note"],"content":"JUnit的Rule的使用 我们在使用JUnit的时候，为了使测试结果更加清晰明确，会有以下的需求： 一个类有多个测试方法，想知道日志是哪个测试方法 想在所有测试方法的前后加上一些语句，用于初始化和销毁一些资源 如果一个测试方法可能抛出多个异常，想知道运行时到底抛出哪些异常 … 以上的需求可以通过为每个方法加上相似的语句来实现，但这样未免有点麻烦和冗余，好在JUnit4为我们提供了一劳永逸的方法，使用Rule。 ","date":"2022-05-30","objectID":"/junit-note/:1:0","tags":["Java","JUnit"],"title":"JUnit笔记","uri":"/junit-note/"},{"categories":["Back","note"],"content":"Rule简介 Rule是JUnit4.7加入的新特性，有点类似于拦截器，用于在测试方法执行前后添加额外的处理。实际上是@Before，@After的另一种实现。使用时需要放在实现了TestRule的成员变量上或者返回TestRule的方法上，且修饰符为public。Rule会应用于该类每个测试方法。 ","date":"2022-05-30","objectID":"/junit-note/:1:1","tags":["Java","JUnit"],"title":"JUnit笔记","uri":"/junit-note/"},{"categories":["Back","note"],"content":"内置Rule JUnit提供了很多内置的TestRule的实现满足日常使用，具体有如下: Verifier：所有测试结束后对测试执行结果添加额外的逻辑验证测试最终成功与否。该抽象类为子类提供一个接口方法verify()供扩展 String result = \"success\"; /** * Verifier:用于在测试方法执行结束后，进行一些结果校验 */ @Rule public Verifier verifier = new Verifier() { @Override protected void verify() throws Throwable { if (result.equals(\"fail\")) { throw new Exception(\"failed\"); } } }; @Test public void verifierTest() { result = \"fail\"; } 运行结果： java.lang.Exception: failed ... ErrorCollector：是Verifier类的一个子类实现，用于在测试执行过程中收集错误信息，不会中断测试，最后调用verify()方法处理。 /** * ErrorCollector:可以收集多个多个异常，并在方法结束后一起打印出来 */ @Rule public ErrorCollector errorCollector = new ErrorCollector(); @Test public void errorCollectorTest() { errorCollector.addError(new RuntimeException(\"error 1\")); System.out.println(\"==================================\"); errorCollector.addError(new RuntimeException(\"error 2\")); } 运行结果： ================================== java.lang.RuntimeException: error 1 ... java.lang.RuntimeException: error 2 ... TemporaryFolder：是抽象类ExternalResource的一个子类实现，用于在JUnit测试执行前后，创建和删除临时目录 /** * TemporaryFolder：创建临时目录/文件，测试方法执行结束后自动删除 * 可以在构造方法中传入使用的父目录，否则默认使用系统临时目录 */ @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder(new File(\"C:\\\\Users\\\\test\")); @Test public void temporaryFolderTest() throws IOException, InterruptedException { temporaryFolder.newFolder(\"test\"); temporaryFolder.newFile(\"hello.txt\"); Thread.sleep(10 * 1000); } TestName：是抽象类TestWatcher的一个子类实现，用于在测试执行过程中获取测试方法名称。在starting()中记录测试方法名，在getMethodName()中返回 /** * TestName:获取当前测试方法的方法名 */ @Rule public TestName testName = new TestName(); @Test public void testNameTest() { System.out.println(\"method is \" + testName.getMethodName()); } 运行结果： method is testNameTest TestWatcher：监视测试方法生命周期的各个阶段。该抽象类为子类提供了五个接口方法succeeded(), failed(), skipped(), starting()及finished()供扩展 /** * TestWatcher:在测试方法开始，结束，成功，失败，跳过这些时间点调用相应方法 */ @Rule public TestWatcher testWatcher = new TestWatcher() { @Override protected void succeeded(Description description) { System.out.println(\"success\"); } @Override protected void failed(Throwable e, Description description) { System.out.println(\"failed\"); } @Override protected void starting(Description description) { System.out.println(\"starting\"); } @Override protected void finished(Description description) { System.out.println(\"finished\"); } @Override protected void skipped(AssumptionViolatedException e, Description description) { System.out.println(\"skipped\"); } }; @Test public void testWatcherTest() { System.out.println(\"testWatcher\"); } 运行结果： starting testWatcher success finished Timeout：与@Test中的timeout相对应，@Test只能修饰待测试方法，Timeout可以修饰待测试类 /** * Timeout:超时时间,方法运行超时则抛出TestTimedOutException异常 */ @Rule public Timeout timeout = new Timeout(5, TimeUnit.SECONDS); @Test public void timeoutTest() throws InterruptedException { System.out.println(\"timeout\"); Thread.sleep(6*1000); } 运行结果： org.junit.runners.model.TestTimedOutException: test timed out after 5 seconds ... ExpectedException：与@Test中的expected相对应，提供更强大灵活的异常验证功能，@Test只能修饰待测试方法，ExpectedException可以修饰待测试类 /** * ExpectedException:指定测试方法出现的异常，未出现或者出现其他类型的异常测试不通过 */ @Rule public ExpectedException expectedException=ExpectedException.none(); @Test public void expectedExceptionTest(){ expectedException.expect(NullPointerException.class); throw new RuntimeException(); } 运行结果： java.lang.AssertionError: Expected: an instance of java.lang.NullPointerException but: is a java.lang.RuntimeException ","date":"2022-05-30","objectID":"/junit-note/:1:2","tags":["Java","JUnit"],"title":"JUnit笔记","uri":"/junit-note/"},{"categories":["Back","note"],"content":"自定义Rule 当内置的Rule无法满足你的需求的时候，你还可以通过实现TestRule来自定义Rule。 自定义RuleTest实现类 /** * 自己实现TestRule */ public class MyTestRule implements TestRule { /** * @param base 基础行为,要进行封装的行为 * @param description test方法的描述,包括方法名，类名等 * @return 可以使在基础行为上添加新动作，也可以是一个全新的动作 */ @Override public Statement apply(Statement base, Description description) { return new Statement() { @Override public void evaluate() throws Throwable { String name = description.getMethodName(); System.out.println(\"开始调用\" + name); base.evaluate(); System.out.println(\"结束调用\" + name); } }; } } 使用自定义的Rlue类： @Rule public MyTestRule myTestRule=new MyTestRule(); @Test public void myTestRuleTest(){ System.out.println(\"myTestRuleTest\"); } 运行结果： 开始调用myTestRuleTest myTestRuleTest 结束调用myTestRuleTest 使用匿名类自定义Rule @Rule public TestRule myRule(){ TestRule rule = (base, description) -\u003e new Statement() { @Override public void evaluate() throws Throwable { String name = description.getMethodName(); System.out.println(\"start invoke \" + name); base.evaluate(); System.out.println(\"finished invoke \" + name); } }; return rule; } @Test public void myRuleTest(){ System.out.println(\"myRule\"); } 运行结果： start invoke myRuleTest myRule finished invoke myRuleTest ","date":"2022-05-30","objectID":"/junit-note/:1:3","tags":["Java","JUnit"],"title":"JUnit笔记","uri":"/junit-note/"},{"categories":["Back","note"],"content":"记录Nacos使用笔记","date":"2022-05-30","objectID":"/nacos-note/","tags":["MicroServices","Alibaba","SpringCloud","Nacos"],"title":"Nacos使用笔记","uri":"/nacos-note/"},{"categories":["Back","note"],"content":"Nacos 权限控制介绍及实战 ","date":"2022-05-30","objectID":"/nacos-note/:1:0","tags":["MicroServices","Alibaba","SpringCloud","Nacos"],"title":"Nacos使用笔记","uri":"/nacos-note/"},{"categories":["Back","note"],"content":"Nacos权限控制设计方案 方案背景 Nacos 自开源依赖，权限控制一直需求比较强烈，这也反应了用户需求将 Nacos 部署到生产环境的需求。最新发布的 Nacos 1.2.0版本已经支持了服务发现和配置管理的权限控制，保障用户安全上生产。本文主要介绍 Nacos 权限控制的设计方案和使用指南。 什么是权限控制？ 在分布式服务调用时，需要对未知的或者不受信任的请求来源的请求进行识别和拒绝。权限控制一般分为两个阶段：身份识别（Authentication）和权限识别（Authorization）。身份认证主要确定访问者的身份，权限识别则判断这个访问者是否有对应资源的权限。 在 Nacos 的场景中，配置管理的权限控制指的是设置某个配置能否被某个用户读写，这个比较好理解，没有权限的用户旧无法读取或者写入对应的配置。服务发现的权限控制指的是用户是否有权限进行某个服务的注册或者订阅，这里需要注意的是服务发现的权限控制只能够控制用户是否可以从 Nacos 获取到服务的地址或者在 Nacos 上修改服务的地址。但是如果已经获取到了服务的地址， Nacos 无法在服务真正调用时进行权限控制，这个时候的权限控制需要由服务框架来完成。 常见实现方式： 认证（Authentication） 用户名+密码 Cookie（只适用于浏览器） Session Token（JWT，Oauth，LDAP，SAML，OpenID） AK/SK 鉴权（Authorization） ACL：规定资源可以被哪些主体进行哪些操作； DAC：规定资源可以被哪些主体进行哪些操作 同时，主体可以将资源的权限，授予其他主体； MAC：a. 规定资源可以被哪些类别的主体进行哪些操作 。b. 规定主体可以对哪些等级的资源进行哪些操作 当一个操作，同时满足a与b时，允许操作； RBAC：a. 规定角色可以对哪些资源进行哪些操作 。b. 规定主体拥有哪些角色当一个操作，同时满足a与b时，允许操作； ABAC：规定哪些属性的主体可以对哪些属性的资源在哪些属性的情况下进行哪些操作。 方案详情 Nacos 的权限控制，目标是能够满足用户基本的鉴权需求，同时能够保持扩展性，可以支持去对接用户自带的用户管理系统或者鉴权系统，包括后面和 K8s 生态以及 Service Mesh 生态能够无缝的融合。基于这样的考虑，目前 Nacos 权限控制的设计是自带一个基本的实现，然后可以支持用户扩展。具体的设计如下。 模块设计 整体的模块设计是尽量将鉴权的逻辑抽象出来，不在服务发现模块或者配置管理模块添加相关的逻辑。通过配置文件可以选择当前使用的鉴权系统。Nacos 自带的认证系统使用 JWT Token ，自带的鉴权系统使用的是 RBAC 。 认证算法 对于用户来说，不管是在控制台还是在客户端，都是上传用户名和密码来获取一个 token ，然后后续的每一次到 Nacos 的请求都会带上这个 token 来表明身份。这个 token 会有一个失效时间，对于控制台来说，只需要直接提示用户重新登录即可，对于客户端则需要有一个定期到 Nacos 刷新 token 的逻辑。 鉴权算法 Nacos 自带的鉴权系统使用的是 RBAC 模型，可以在网上查询相关的资料。 数据模型 鉴权的数据模型也是基于标准的 RBAC 来设计的，分为用户、角色和权限三部分。用户就是由用户名和密码组成的用户信息，角色则是一个逻辑上的用户组， Nacos 启动时会自带一个全局管理员的角色，只有这个全局管理员的角色可以进行添加用户、添加角色、添加授权等操作，保证安全性。而权限则是由资源+动作来组成。 接口设计 以下接口涉及到登录和鉴权的所有逻辑，这些接口除了登录接口，其他接口都只能由全局管理员来调用。 用户管理 创建用户：POST /nacos/v1/auth/users?username=xx\u0026password=yy 删除用户：DELETE /nacos/v1/auth/users?username=xx\u0026password=yy 更新用户：PUT /nacos/v1/auth/users?username=xx\u0026oldPassword=yy\u0026newPassword=zz 登录：POST /nacos/v1/auth/users/login?username=xxx\u0026password=yyy 角色管理 创建角色/绑定用户到角色：POST /nacos/v1/auth/roles?role=xx\u0026username=yy 删除某个用户的角色：DELETE /nacos/v1/auth/roles?role=xx\u0026username=yy 获取用户的所有角色：GET /nacos/v1/auth/roles?username=xxx 权限管理 给角色添加权限：POST /nacos/v1/auth/permissions?role=xxx\u0026resource=yyy\u0026action=zzz 从角色删除权限：DELETE /nacos/v1/auth/permissions?role=xxx\u0026resource=yyy\u0026action=zzz 获取某个角色的权限：GET /nacos/v1/auth/permissions?role=xxx ","date":"2022-05-30","objectID":"/nacos-note/:1:1","tags":["MicroServices","Alibaba","SpringCloud","Nacos"],"title":"Nacos使用笔记","uri":"/nacos-note/"},{"categories":["Back","note"],"content":"Nacos权限控制实战 安装 Nacos 1.2.0 1、部署包准备。可以直接下载安装包： https://github.com/alibaba/nacos/releases/tag/1.2.0， 也可以将 Nacos master 分支 clone 下来进行源码编译： mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U 2、安装包解压，然后使用 distribution/nacos-mysql.sql 进行数据库初始化，主要是新增了 users, roles , permissions三张表， standalone模式使用 distribution/schema.sql 进行初始化。 3、Server 端打开权限控制开关。修改 con/application.properties 内容： nacos.core.auth.enabled=true 这个开关采用了热加载模式，无需重启 Server 即可生效。因此当权限控制功能使用有异常时，可以直接回滚到不鉴权的模式。 使用权限控制 1、使用管理员账号登录 Nacos 控制台（如果页面提示错误，可以情况浏览器缓存刷新页面）： 可以看到，左侧边栏增加了一个父菜单和三个子菜单，分别用于权限控制里的用户创建、角色创建以及权限管理。这个菜单栏只会在管理员登录的时候显示，也就意味着只有管理员才能进行权限的管理和分配。 2、管理用户。点击“用户列表”，进入用户管理页面，可以进行用户的创建、修改和删除： 3、管理角色。因为 Nacos 的自带的权限是基于角色来进行分配的，因此需要给创建好的用户绑定一些角色： 4、管理权限。角色创建好以后，就可以给这个角色赋予特定的权限了： 在“添加资源”对话框里，可以选择绑定的角色，命名空间资源以及对应的动作类型，例如在上图中，我们给角色 role1 绑定命名空间test的读写权限。然后又因为刚刚我们是将 user1 绑定到了 role1 上，那么 user1 这个用户就可以对 test 这个命名空间的资源进行读写操作了。 5、使用 user1 登录控制台。点击控制台右上角，退出 admin 账号，然后用刚才创建的 user1 进行登录： 如上图所示，首先是左侧的权限管理菜单消失了，因为当前用户不是管理员。其次是会弹出一个鉴权失败的提示框。不用担心，这个提示框意思是 user1 没有 public 命名空间的读权限，所以会弹出，但是不影响我们将命名空间切换到 test ： 如上图所示，我们可以看到 test 命名空间的配置数据了，下面我们再来介绍客户端的使用。 6、先依赖最新的 nacos 1.2.0 客户端，然后在初始化时添加如下代码： Properties properties = new Properties(); properties.put(PropertyKeyConst.NAMESPACE, \"99a791cf-41c4-4535-9e93-b0141652bad0\"); properties.put(PropertyKeyConst.SERVER_ADDR, \"127.0.0.1:8848\"); // 配置用户名： properties.put(PropertyKeyConst.USERNAME, \"user1\"); // 配置密码： properties.put(PropertyKeyConst.PASSWORD, \"pwd1\"); ConfigService iconfig = NacosFactory.createConfigService(properties); 7、使用客户端进行正常的读写配置操作。 ","date":"2022-05-30","objectID":"/nacos-note/:1:2","tags":["MicroServices","Alibaba","SpringCloud","Nacos"],"title":"Nacos使用笔记","uri":"/nacos-note/"},{"categories":["Back","note"],"content":"他们在招人 阿里巴巴云原生基础技术中台是隶属于阿里云基础产品事业部的核心研发团队，致力于打造稳定、标准、先进的云原生应用基础平台，推动行业面向云原生技术升级与革命。目前在招聘技术专家岗位，详情可参考： http://www.posterhr.com/html/CkgpBwD6f?from=timeline\u0026isappinstalled=0 （可以直接投递，也可以将简历直接发送到 water.lyl@alibaba-inc.com） 作者信息： 朱鹏飞，GitHub ID：@nkorange，Nacos Maintainer，Nacos 开源负责人。阿里巴巴技术专家，阿里云 EDAS 注册中心 ANS 负责人，目前主要专注于服务发现、服务管理等领域。 ","date":"2022-05-30","objectID":"/nacos-note/:1:3","tags":["MicroServices","Alibaba","SpringCloud","Nacos"],"title":"Nacos使用笔记","uri":"/nacos-note/"},{"categories":["Back","note"],"content":"记录RabbitMQ 使用笔记","date":"2022-05-30","objectID":"/rabbitmq-note/","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"Windows安装RabbitMQ详细教程 ","date":"2022-05-30","objectID":"/rabbitmq-note/:1:0","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"前言 下面我将分享下RabbitMQ最新版本在Windows上的详细安装教程。 笔者在这里使用的系统环境如下： windows系统：Windows 11 专业版 21H2 Erlang：24.1.7 RabbitMQ：3.9.11 ","date":"2022-05-30","objectID":"/rabbitmq-note/:1:1","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"一、RabbitMQ是什么？ RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 具体特点包括： 1.可靠性（Reliability） RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 **2.灵活的路由（Flexible Routing） ** 在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 3.消息集群（Clustering） 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 4.高可用（Highly Available Queues） 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 5.多种协议（Multi-protocol） RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 7.管理界面（Management UI） RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 8.跟踪机制（Tracing） 如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 9.插件机制（Plugin System） RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 ","date":"2022-05-30","objectID":"/rabbitmq-note/:1:2","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"二、安装步骤 1.安装准备工作 这里通过官网下载需要的版本：RabbitMQ官方网址 鉴于官网访问下载比较慢，贴一个云盘地址：百度云盘地址 进入官网向下拉，找到 Download + Installation 下载+安装，点击进入。 在新页面找到右侧，Install Windows 安装windows版本 然后页面下拉，找到 Dependencies 依赖关系 选择otp_win64_24.1.7.exe 我的系统是64位的，所以下载win64 这里笔者强调一下。我安装的是最新版本。如果你们觉得最新版可能存在未知bug或不兼容问题，可以选择自己想要下载的对应版本即可。 这里我截图一部分版本参照表，其他的可以自行查看 2.开始安装 第一步：找到我们下载的软件位置。 第二步：先安装otp_win64_24.1.7.exe 第三步：鼠标右键以管理员方式运行 第四步：接着选取要安装的路径，然后一路傻瓜式安装 next 下一步，安装即可。 【注意】不要安装在中文或带空格的文件路径下 第五步：配置系统环境变量 右键此电脑 - 属性 - 高级系统设置 - 环境变量 接着打开 - 此电脑（文件资源管理器） 找到刚刚我们安装的 erl - 24.1.7 文件 bin 目录下，复制路径 ctrl+c 切换窗口到环境变量，找到系统变量 path - 编辑 新建 - ctrl + v 粘贴刚才我们复制的路径，然后三次确定，关闭环境变量窗口 第六步：安装 RabbitMQ 右键管理员运行，然后选择安装路径，接着一路 next 下一步，遇到弹窗点允许，没有弹窗则无视。 【注意】不要安装在中文或带空格的文件路径下 第七步：安装完成后找到安装文件路径，找到 sbin 目录下，全选路径 输入 cmd 打开cmd命令窗口。 运行下面命令，回车运行。 rabbitmq-plugins enable rabbitmq_management 由于我已经安装过了，所以贴一张。运行成功的图片 第八步：打开任务资源管理器。win11 快捷键 Ctrl+Shift+Esc，找到rabbitmq服务右键重新启动。 3.结束安装 打开浏览器。访问 http://127.0.0.1:15672 出现管理页面： 账号：guest 密码：guest 登录成功后。进入下面页面即代表安装成功。至此大功告成。是不是很简单！ 如果不小心安装到中文或带空格路径文件路径下，这个链接可以解决： https://blog.csdn.net/leoma2012/article/details/97636859 如果想要彻底卸载RabbitMQ，则访问这个链接： https://blog.csdn.net/qq_41463655/article/details/86747917 总结 以上就是今天要讲的内容，本文详细的介绍了RabbitMQ的安装步骤。有需要的请收藏，转发让更多的朋友知道。 ","date":"2022-05-30","objectID":"/rabbitmq-note/:1:3","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"RabbitMQ 清除全部队列及消息 安装RabbitMQ后可访问：http://{rabbitmq安装IP}:15672使用(默认的是帐号guest，密码guest。此账号只能在安装RabbitMQ的机器上登录，无法远程访问登录。） 远程访问登录，可以使用自己创建的帐号，给与对应的管理员权限即可。 ","date":"2022-05-30","objectID":"/rabbitmq-note/:2:0","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"直接在管理页面删除 访问http://{rabbitmq安装IP}:15672，登录。 点击queues，这里可以看到你创建的所有的Queue， 选中某一个Queue，下方有个Delete Queue删除队列/Purge Message清除消息。 但是这样只能一个队列一个队列的删除，如果队列中的消息过多就会特别慢。 ","date":"2022-05-30","objectID":"/rabbitmq-note/:2:1","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"命令行批量删除 首先定位到 rabbitMQ 安装目录的sbin 目录下。打开cmd窗口。 关闭应用的命令为： rabbitmqctl stop_app 清除的命令为： rabbitmqctl reset 重新启动命令为： rabbitmqctl start_app ps 查看所有队列命令： rabbitmqctl list_queues ","date":"2022-05-30","objectID":"/rabbitmq-note/:2:2","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["Back","note"],"content":"注意 命令行批量删除相当于重置RabbitMQ，请谨慎操作，配置和队列都会被清除。 操作完成，记得添加远程访问账号。 ","date":"2022-05-30","objectID":"/rabbitmq-note/:2:3","tags":["RabbitMq"],"title":"RabbitMQ 使用笔记","uri":"/rabbitmq-note/"},{"categories":["SoftwareDesign","note"],"content":"记录领域模型之失血、贫血、充血、胀血模型的笔记","date":"2022-05-30","objectID":"/java-domain-model-note/","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["SoftwareDesign","note"],"content":"前言 领域模型分为4大类：失血模型、贫血模型、充血模型、胀血模型。这类理论都是些软件设计领域的大牛（如Martin Fowler）提出来的，有其背景和原因，这里第一步先了解它们是什么，以后再深挖。 想要理解这几个分类，先要知道“血”指的是domain object的model层内容。 ","date":"2022-05-30","objectID":"/java-domain-model-note/:1:0","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["SoftwareDesign","note"],"content":"1、失血模型 失血模型中，domain object只有属性的get set方法的纯数据类，所有的业务逻辑完全由Service层来完成的，由于没有dao，Service直接操作数据库，进行数据持久化。 service: 肿胀的服务逻辑 model：只包含get set方法 显然失血模型service层负担太重，一般不会有这种设计。 ","date":"2022-05-30","objectID":"/java-domain-model-note/:2:0","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["SoftwareDesign","note"],"content":"2、贫血模型 贫血模型中，domain ojbect包含了不依赖于持久化的原子领域逻辑，而组合逻辑在Service层。 service ：组合服务，也叫事务服务 model：除包含get set方法，还包含原子服务（如获得关联model的id） dao：数据持久化 贫血模型比较常见，其问题在于原子服务往往不能直接拿到关联model，因此可以把这个原子服务变成直接用关联modelRepo拿到关联model，这就是充血模型。 ","date":"2022-05-30","objectID":"/java-domain-model-note/:3:0","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["SoftwareDesign","note"],"content":"3、充血模型 充血模型中，绝大多业务逻辑都应该被放在domain object里面，包括持久化逻辑，而Service层是很薄的一层，仅仅封装事务和少量逻辑，不和DAO层打交道。 service ：组合服务 也叫事务服务 model：除包含get set方法，还包含原子服务和数据持久化的逻辑 充血模型的问题也很明显，当model中包含了数据持久化的逻辑，实例化的时候可能会有很大麻烦，拿到了太多不一定需要的关联model。 ","date":"2022-05-30","objectID":"/java-domain-model-note/:4:0","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["SoftwareDesign","note"],"content":"4、胀血模型 胀血模型取消了Service层，只剩下domain object和DAO两层，在domain object的domain logic上面封装事务。 一般来说失血模型和胀血模型不常见，多采用贫血模型。 贫血模型和充血模型的差别在于，领域模型是否要依赖持久层，贫血模型是不依赖的，而充血模型是依赖的。 参考资料： https://blog.csdn.net/chenxiang0207/article/details/6423086 https://blog.csdn.net/bxl_1986/article/details/79097493 ","date":"2022-05-30","objectID":"/java-domain-model-note/:5:0","tags":["Java","Domain","JavaBean"],"title":"领域模型之失血、贫血、充血、胀血模型","uri":"/java-domain-model-note/"},{"categories":["Back"],"content":"记录数据转JSONString异常，Write javaBean error的解决办法","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"起因 一位同事在接收RocketMQ消息后，为了方便以后排查问题，顺便就用fastjson将消息转成JSONString来打log。模拟代码如下 public ConsumeConcurrentlyStatus consumeMessage(List\u003cMessageExt\u003e msgs, ConsumeConcurrentlyContext consumeConcurrentlyContext) { MessageExt msg = msgs.get(0); logger.info(\"收到MQ消息，msg={}\", JSON.toJSONString(msg)); ... 然后就报错了，JSON.toJSONString(msg)异常后，代码就不往下走了，关键是业务逻辑也不能执行了。 本人也喜欢在一些场景下将对象转JSONString打log来作为日后快速排查问题的依据，有时候因为业务需要，甚至将对象转JSONString后存储数据库，而且用的都是fastjson。 所以菊花一紧，觉得有必要排查下这个问题。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:1:0","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"猜测 刚开始猜测是不是消息内容有序列化的问题，但是消息能够正常解析和使用，所以排除这种可能。 转而猜测会不会是fastjson的bug，当前使用的fastjson版本是1.2.7，果断升到官方最新版本1.2.44试了下，还是报一样的错。 改用google的gson来解析，成功解析并输出。所以fastjson被打上重点嫌疑人便签。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:2:0","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"Do 最后直接分析fastjson源码，最终fastjson表示这个锅它不背。那为什么fastjson不行，而gson可以呢？ 这是由于它们各自的解析方式不一样的导致的，fastjson解析的数据是来自对象的get方法，而gson的则来自于对象的属性。 之前的报错恰恰是由于MessageExt对象的get方法引起的。 MessageExt对象中有两个有趣的get方法，getBornHostBytes()和getStoreHostBytes()。 两个方法差不多，就拿getBornHostBytes()来说事吧。 public ByteBuffer getBornHostBytes() { return socketAddress2ByteBuffer(this.bornHost); } public static ByteBuffer socketAddress2ByteBuffer(SocketAddress socketAddress) { ByteBuffer byteBuffer = ByteBuffer.allocate(8); return socketAddress2ByteBuffer(socketAddress, byteBuffer); } private static ByteBuffer socketAddress2ByteBuffer(SocketAddress socketAddress, ByteBuffer byteBuffer) { InetSocketAddress inetSocketAddress = (InetSocketAddress)socketAddress; byteBuffer.put(inetSocketAddress.getAddress().getAddress(), 0, 4); byteBuffer.putInt(inetSocketAddress.getPort()); byteBuffer.flip(); return byteBuffer; } 具体方法功能就不多说了，问题就出在方法的返回类型ByteBuffer。fastjson会继续解析这个方法的实际返回类型HeapByteBuffer。 具体方法功能就不多说了，问题就出在方法的返回类型ByteBuffer。fastjson会继续解析这个方法的实际返回类型HeapByteBuffer。 最终的问题就出在HeapByteBuffer的get方法上（ps：fastjson解析的都是无参的get方法） public char getChar() { return Bits.getChar(this, ix(nextGetIndex(2)), bigEndian); } public int getInt() { return Bits.getInt(this, ix(nextGetIndex(4)), bigEndian); } public double getDouble() { return Bits.getDouble(this, ix(nextGetIndex(8)), bigEndian); } ... 每解析一个get方法，都会从ByteBuffer中读取相应数量的字节数据，当ByteBuffer的remaining长度小于要获取的字节数时就会抛BufferUnderflowException， 是不是有点眼熟呢，没错，在最开始贴出的异常日志就出现了它的身影 举个更直观的例子，假设你的ByteBuffer字节长度就是8，第一次你用getInt()获取到了4个字节的数据，第二次你用getDouble()想获取8个字节的数据时就会抛这个异常了，因为remaining这个时候的值是4，小于想获取的长度。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:3:0","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"More fastjson实际上是可以通过设置SerializerFeature规避这个问题的 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:4:0","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"方法一 JSON.toJSONString(msg, SerializerFeature.IgnoreNonFieldGetter); getBornHostBytes()方法在MessageExt并没有对应的属性bornHostBytes, 设置后，fastjson就会跳过getBornHostBytes()的解析。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:4:1","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"方法二 JSON.toJSONString(msg, SerializerFeature.IgnoreErrorGetter); fastjson会忽略有问题的get异常解析，返回其它正常的解析数据。 SerializerFeature.IgnoreErrorGetter 在fastjson 1.2.7版本中没有，1.2.44版本中有。 另外，JSONObject.toJSONString和JSON.toJSONString本质上是相同的。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:4:2","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back"],"content":"总结 吃一堑长一智，在我们实际开发中，DTO对象尽量使用失血模型，不要在get方法中做些不必要的操作。还有不要将DTO的get方法返回类型设为ByteBuffer哦。 如果没有特殊情况，RocketMQ的消息就打印body部分(真正的消息内容)就够看了，不要打印MessageExt对象。 ","date":"2022-05-30","objectID":"/fastjson-write-javabean-error/:5:0","tags":["Java","J2EE","FastJson","Error"],"title":"数据转JSONString异常，Write javaBean error","uri":"/fastjson-write-javabean-error/"},{"categories":["Back","note"],"content":"记录Java 基础类型属性笔记","date":"2022-05-30","objectID":"/java-basicclass-note/","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"Java代码实现double类型数字格式化为百分数 public class PercentTest { public static void main(String[] args) { double rate = 0.26535; NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留位数 nf.setMaximumFractionDigits(2);//小数点前保留位数 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 String percent = nf.format(rate); System.out.println(percent); } } 舍入模式 UP：远离零方向舍入的舍入模式。始终对非零舍弃部分前面的数字加 1。注意，此舍入模式始终不会减少计算值的绝对值。 示例： 输入数字 使用 UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 DOWN：向零方向舍入的舍入模式。从不对舍弃部分前面的数字加 1（即截尾）。注意，此舍入模式始终不会增加计算值的绝对值。 示例： 输入数字 使用 DOWN 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 CEILING：向正无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.UP；如果结果为负，则舍入行为类似于 RoundingMode.DOWN。注意，此舍入模式始终不会减少计算值。 示例： 输入数字 使用 CEILING 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 FLOOR：向负无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.DOWN；如果结果为负，则舍入行为类似于RoundingMode.UP。注意，此舍入模式始终不会增加计算值。 示例： 输入数字 使用 FLOOR 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 HALF_UP： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。如果被舍弃部分 \u003e= 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。注意，此舍入模式就是通常学校里讲的四舍五入。 示例： 输入数字 使用 HALF_UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -3 -5.5 -6 HALF_DOWN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。如果被舍弃部分 \u003e 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。 示例： 输入数字 使用 HALF_DOWN 舍入模式 5.5 5 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -5 HALF_EVEN： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为同 RoundingMode.HALF_UP；如果为偶数，则舍入行为同RoundingMode.HALF_DOWN。注意，在重复进行一系列计算时，此舍入模式可以在统计上将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。此舍入模式类似于 Java 中对float 和double 算法使用的舍入策略。 示例： 输入数字 使用 HALF_EVEN 舍入模式 5.5 6 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -6 UNNECESSARY：用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。如果对生成精确结果的操作指定此舍入模式，则抛出 ArithmeticException。 示例： 输入数字 使用 UNNECESSARY 舍入模式 5.5 抛出 ArithmeticException 2.5 抛出 ArithmeticException 1.6 抛出 ArithmeticException 1.1 抛出 ArithmeticException 1.0 1 -1.0 -1 -1.1 抛出 ArithmeticException -1.6 抛出 ArithmeticException -2.5 抛出 ArithmeticException -5.5 抛出 ArithmeticException ","date":"2022-05-30","objectID":"/java-basicclass-note/:1:0","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"BigDecimal ","date":"2022-05-30","objectID":"/java-basicclass-note/:2:0","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"几种舍弃精度的算法 测试代码 double i = 2, j = 2.4, k = 2.5, l = 2.6, m = 2.9; System.out.println(\"五舍六入取整:Math.rint(2)=\" + (int) Math.rint(i)); System.out.println(\"五舍六入取整:Math.rint(2.4=\" + (int) Math.rint(j)); System.out.println(\"五舍六入取整:Math.rint(2.5)=\" + (int) Math.rint(k)); System.out.println(\"五舍六入取整:Math.rint(2.6)=\" + (int) Math.rint(l)); System.out.println(\"五舍六入取整:Math.rint(2.9)=\" + (int) Math.rint(m)); System.out.println(\"五舍六入取整: new DecimalFormat(2)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.4)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.5)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.6)=\" + new DecimalFormat(\"0\").format(l)); System.out.println(\"五舍六入取整: new DecimalFormat(2.9)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整:Math.rint(-2)=\" + (int) Math.rint(-i)); System.out.println(\"五舍六入取整:Math.rint(-2.4=\" + (int) Math.rint(-j)); System.out.println(\"五舍六入取整:Math.rint(-2.5)=\" + (int) Math.rint(-k)); System.out.println(\"五舍六入取整:Math.rint(-2.6)=\" + (int) Math.rint(-l)); System.out.println(\"五舍六入取整:Math.rint(-2.9)=\" + (int) Math.rint(-m)); System.out.println(\"五舍六入取整: new DecimalFormat(-2)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.4)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.5)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.6)=\" + new DecimalFormat(\"0\").format(-l)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.9)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"舍掉小数取整:Math.floor(2)=\" + (int) Math.floor(i)); System.out.println(\"舍掉小数取整:Math.floor(2.4)=\" + (int) Math.floor(j)); System.out.println(\"舍掉小数取整:Math.floor(2.5)=\" + (int) Math.floor(k)); System.out.println(\"舍掉小数取整:Math.floor(2.6)=\" + (int) Math.floor(l)); System.out.println(\"舍掉小数取整:Math.floor(2.9)=\" + (int) Math.floor(m)); System.out.println(\"四舍五入取整:new BigDecimal(2).setScale=\" + new BigDecimal(\"2\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.4).setScale=\" + new BigDecimal(\"2.1\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.5).setScale=\" + new BigDecimal(\"2.5\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.6).setScale=\" + new BigDecimal(\"2.6\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.9).setScale=\" + new BigDecimal(\"2.9\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"凑整:Math.ceil(2)=\" + (int) Math.ceil(i)); System.out.println(\"凑整:Math.ceil(2.4)=\" + (int) Math.ceil(j)); System.out.println(\"凑整:Math.ceil(2.5)=\" + (int) Math.ceil(k)); System.out.println(\"凑整:Math.ceil(2.6)=\" + (int) Math.ceil(l)); System.out.println(\"凑整:Math.ceil(2.9)=\" + (int) Math.ceil(m)); System.out.println(\"舍掉小数取整:Math.floor(-2)=\" + (int) Math.floor(-i)); System.out.println(\"舍掉小数取整:Math.floor(-2.4)=\" + (int) Math.floor(-j)); System.out.println(\"舍掉小数取整:Math.floor(-2.5)=\" + (int) Math.floor(-k)); System.out.println(\"舍掉小数取整:Math.floor(-2.6)=\" + (int) Math.floor(-l)); System.out.println(\"舍掉小数取整:Math.floor(-2.9)=\" + (int) Math.floor(-m)); System.out.println(\"四舍五入取整:new BigDecimal(-2).setScale=\" + new BigDecimal(\"-2\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.4).setScale=\" + new BigDecimal(\"-2.1\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.5).setScale=\" + new BigDecimal(\"-2.5\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.6).setScale=\" + new BigDecimal(\"-2.6\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.9).setScale=\" + new BigDecimal(\"-2.9\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"凑整:Math.ceil(-2)=\" + (int) Math.ceil(-i)); System.out.println(\"凑整:Math.ceil(-2.4)=\" + (int) Math.ceil(-j","date":"2022-05-30","objectID":"/java-basicclass-note/:2:1","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"特殊的情况 将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式。返回的 BigDecimal 的标度是使 $ (10^{scale} × val) $为整数的最小值。 ","date":"2022-05-30","objectID":"/java-basicclass-note/:2:2","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"Java中如何将int 类型转换为 Long类型 Long l = (Long)3; 很多同学可能会用上面的方法将int类型转换为Long类型，但事实上这样是不可行的。因为Long是包装类，而int是值类型数据，两者是不能这样强转的。 long l = (long)3; int和long都是基本类型的数据，是可以强转的，那么我就可以以此作为桥梁，强转成long后，再生成Long类型的数据。 Long l = new Long((long)3); 这样就可以将int类型顺利转换为Long类型。 还有这种 Long waitTime = Long.valueOf(String.valueOf((10 * 60 * 1000) / 5)); ","date":"2022-05-30","objectID":"/java-basicclass-note/:3:0","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"java的三种随机数生成方式 随机数的产生在一些代码中很常用，也是我们必须要掌握的。而java中产生随机数的方法主要有三种： 第一种：new Random() 第二种：Math.random() 第三种：currentTimeMillis() ","date":"2022-05-30","objectID":"/java-basicclass-note/:4:0","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"第一种 第一种需要借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关。以代码为例。 public static void main(String[] args) { Random r = new Random(1); for (int i = 0; i \u003c 5; i++) { int ran1 = r.nextInt(100); System.out.println(ran1); } } 在我的编译器下产生的五个数均为85,88,47,13,54，如果采用Random r = new Random()，产生的随机数就不同，这就是确定种子导致的结果。 ","date":"2022-05-30","objectID":"/java-basicclass-note/:4:1","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"第二种 而第二种方法返回的数值是[0.0,1.0）的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了，代码如下。 public static void main(String[] args){ int max=100,min=1; int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); } ","date":"2022-05-30","objectID":"/java-basicclass-note/:4:2","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back","note"],"content":"第三种 至于第三种方法虽然不常用，但是也是一种思路。方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。 public static void main(String[] args){ int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } ","date":"2022-05-30","objectID":"/java-basicclass-note/:4:3","tags":["Java","BasicClass"],"title":"Java 基础类型属性笔记","uri":"/java-basicclass-note/"},{"categories":["Back"],"content":"记录Win10美化：任务栏右下角时间设置显示秒钟的笔记","date":"2022-05-30","objectID":"/win-taskdock-time-add-second-note/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10美化：任务栏右下角时间设置显示秒钟","uri":"/win-taskdock-time-add-second-note/"},{"categories":["Back"],"content":"在win10系统任务栏右下角有显示时间的区域，默认情况下我们只能看到小时与分钟的显示，而看不到秒钟。如何才能显示秒钟呢？我们可以通过以下方式开启。 按win+E组合键，在地址栏中输入 控制面板\\时钟和区域 回车，打开“时钟和区域”控制面板 在弹出的“时钟和区域”控制面板中找到“更改日期、时间或数字格式”，点击进入 在弹出的“区域”设置对话框中，点击最底下的“其他设置(D)…” ​ 在打开的“自定义格式”对话框中，定位到“时间”选项卡，在展开的“时间”选项卡中，找到“时间格式”-“短时间”，并将短时间内容输入为 HH:mm:ss 注意符号 一定要在英文状态下输入（下拉菜单中没有该选项，只能手动输入） 点击应用-确定，退出所有对话框。 按win键+R组合键，打开运行对话框，并在其中输入 regedit 回车，打开注册表编辑器。（或者右键点击开始菜单，在弹出菜单中选择运行） 在注册表编辑器中，定位到： HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced 在右侧空白处点击右键，选择 新建-DWORD(32位)值 将新建的DWORD值名称修改为 ShowSecondsInSystemClock 双击刚刚建立的ShowSecondsInSystemClock值，在弹出的窗口中把其中的数值修改为 1 最后重启电脑就可以在任务栏右下角时间区域显示秒钟了。 效果如下： 秒钟是实时更新的哦~ 喜欢这个功能的朋友可以看看。 ","date":"2022-05-30","objectID":"/win-taskdock-time-add-second-note/:0:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10美化：任务栏右下角时间设置显示秒钟","uri":"/win-taskdock-time-add-second-note/"},{"categories":["Software","note"],"content":"记录WinRAR如何进行分卷压缩的笔记","date":"2022-05-30","objectID":"/winrar-sub-volume-compression-note/","tags":["Wintar","Volume","Compression"],"title":"WinRAR如何进行分卷压缩","uri":"/winrar-sub-volume-compression-note/"},{"categories":["Software","note"],"content":"前言 有些地方需要把一个大文件分割成几个小文件进行上传或者存放，如何方便快捷的把一个大文件分割成为N个小文件呢？请看教程！ ","date":"2022-05-30","objectID":"/winrar-sub-volume-compression-note/:1:0","tags":["Wintar","Volume","Compression"],"title":"WinRAR如何进行分卷压缩","uri":"/winrar-sub-volume-compression-note/"},{"categories":["Software","note"],"content":"步骤 右击要分卷压缩的文件，从弹出的快捷菜单中选择添加到压缩文件。 在“压缩文件夹名和参数”窗口中设置压缩分卷的大小，以字节为单位，如我的压缩分卷大小为500KB，则1024×500=512000字节 后单击确定，开始分卷压缩 这就是分卷压缩后的文件，以数字为后缀名，如.part01，.001 下载完这些分卷压缩包以后，把它们放到同一个文件夹里，双击后缀名中数字最小的压缩包，解压，WinRAR就会自动解出所有分卷压缩包中的内容，把它合并成一个。 ","date":"2022-05-30","objectID":"/winrar-sub-volume-compression-note/:2:0","tags":["Wintar","Volume","Compression"],"title":"WinRAR如何进行分卷压缩","uri":"/winrar-sub-volume-compression-note/"},{"categories":["Learning"],"content":"记录阿里巴巴为什么不用 ZooKeeper 做服务发现的笔记","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"简介 站在未来的路口，回望历史的迷途，常常会很有意思，因为我们会不经意地兴起疯狂的念头，例如如果当年某事提前发生了，而另外一件事又没有发生会怎样？一如当年的奥匈帝国皇位继承人斐迪南大公夫妇如果没有被塞尔维亚族热血青年普林西普枪杀会怎样，又如若当年的丘老道没有经过牛家村会怎样？ 2008 年底，淘宝开启一个叫做“五彩石”的内部重构项目，这个项目后来成为了淘宝服务化、面向分布式走自研之路，走出了互联网中间件体系之始，而淘宝服务注册中心 ConfigServer 于同年诞生。 2008 年前后，Yahoo 这个曾经的互联网巨头开始逐渐在公开场合宣讲自己的大数据分布式协调产品 ZooKeeper，这个产品参考了 Google 发表的关于 Chubby 以及 Paxos 的论文。 2010 年 11 月，ZooKeeper 从 Apache Hadoop 的子项目发展为 Apache 的顶级项目，正式宣告 ZooKeeper 成为一个工业级的成熟稳定的产品。 2011 年，阿里巴巴开源 Dubbo，为了更好开源，需要剥离与阿里内部系统的关系，Dubbo 支持了开源的 ZooKeeper 作为其注册中心，后来在国内，在业界诸君的努力实践下，Dubbo + ZooKeeper 的典型的服务化方案成就了 ZooKeeper 作为注册中心的声名。 2015 年双 11，ConfigServer 服务内部近 8 个年头过去了，阿里巴巴内部“服务规模”超几百万 ，以及推进“千里之外”的 IDC 容灾技术战略等，共同促使阿里巴巴内部开启了 ConfigServer 2.0 到 ConfigServer 3.0 的架构升级之路。 时间走向 2018 年，站在 10 年的时间路口上，有多少人愿意在追逐日新月异的新潮技术概念的时候，稍微慢一下脚步，仔细凝视一下服务发现这个领域，有多少人想到过或者思考过一个问题： ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:1:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"服务发现，ZooKeeper 真的是最佳选择么？ 而回望历史，我们也偶有迷思，在服务发现这个场景下，如果当年 ZooKeeper 的诞生之日比我们 HSF 的注册中心 ConfigServer 早一点会怎样？ 我们会不会走向先使用 ZooKeeper 然后疯狂改造与修补 ZooKeeper 以适应阿里巴巴的服务化场景与需求的弯路？ 但是，站在今天和前人的肩膀上，我们从未如今天这样坚定的认知到，在服务发现领域，ZooKeeper 根本就不能算是最佳的选择，一如这些年一直与我们同行的 Eureka 以及这篇文章 《Eureka! Why You Shouldn’t Use ZooKeeper for Service Discovery》那坚定的阐述一样，为什么你不应该用 ZooKeeper 做服务发现！ 吾道不孤矣。 注册中心需求分析及关键设计考量 接下来，让我们回归对服务发现的需求分析，结合阿里巴巴在关键场景上的实践，来一一分析，一起探讨为何说 ZooKeeper 并不是最合适的注册中心解决方案。 注册中心是 CP 还是 AP 系统? CAP 和 BASE 理论相信读者都已经耳熟能详，其业已成了指导分布式系统及互联网应用构建的关键原则之一，在此不再赘述其理论，我们直接进入对注册中心的数据一致性和可用性需求的分析: 数据一致性需求分析 注册中心最本质的功能可以看成是一个 Query 函数 Si = F(service-name)，以 service-name 为查询参数，service-name 对应的服务的可用的 endpoints (ip:port)列表为返回值. 注: 后文将 service 简写为 svc。 先来看看关键数据 endpoints (ip:port) 不一致性带来的影响，即 CAP 中的 C 不满足带来的后果 : 如上图所示，如果一个 svcB 部署了 10 个节点 (副本 /Replica），如果对于同一个服务名 svcB, 调用者 svcA 的 2 个节点的 2 次查询返回了不一致的数据，例如: S1 = { ip1,ip2,ip3…,ip9 }, S2 = { ip2,ip3,….ip10 }, 那么这次不一致带来的影响是什么？相信你一定已经看出来了，svcB 的各个节点流量会有一点不均衡。 ip1 和 ip10 相对其它 8 个节点{ip2…ip9}，请求流量小了一点，但很明显，在分布式系统中，即使是对等部署的服务，因为请求到达的时间，硬件的状态，操作系统的调度，虚拟机的 GC 等，任何一个时间点，这些对等部署的节点状态也不可能完全一致，而流量不一致的情况下，只要注册中心在 SLA 承诺的时间内（例如 1s 内）将数据收敛到一致状态（即满足最终一致），流量将很快趋于统计学意义上的一致，所以注册中心以最终一致的模型设计在生产实践中完全可以接受。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:2:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"分区容忍及可用性需求分析 接下来我们看一下网络分区（Network Partition）情况下注册中心不可用对服务调用产生的影响，即 CAP 中的 A 不满足时带来的影响。 考虑一个典型的 ZooKeeper 三机房容灾 5 节点部署结构 (即 2-2-1 结构)，如下图: 当机房 3 出现网络分区 (Network Partitioned) 的时候，即机房 3 在网络上成了孤岛，我们知道虽然整体 ZooKeeper 服务是可用的，但是节点 ZK5 是不可写的，因为联系不上 Leader。 也就是说，这时候机房 3 的应用服务 svcB 是不可以新部署，重新启动，扩容或者缩容的，但是站在网络和服务调用的角度看，机房 3 的 svcA 虽然无法调用机房 1 和机房 2 的 svcB, 但是与机房 3 的 svcB 之间的网络明明是 OK 的啊，为什么不让我调用本机房的服务？ 现在因为注册中心自身为了保脑裂 (P) 下的数据一致性（C）而放弃了可用性，导致了同机房的服务之间出现了无法调用，这是绝对不允许的！可以说在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，这是注册中心设计应该遵循的铁律！ 后面在注册中心客户端灾容上我们还会继续讨论。 同时我们再考虑一下这种情况下的数据不一致性，如果机房 1，2，3 之间都成了孤岛，那么如果每个机房的 svcA 都只拿到本机房的 svcB 的 ip 列表，也即在各机房 svcB 的 ip 列表数据完全不一致，影响是什么？ 其实没啥大影响，只是这种情况下，全都变成了同机房调用，我们在设计注册中心的时候，有时候甚至会主动利用这种注册中心的数据可以不一致性，来帮助应用主动做到同机房调用，从而优化服务调用链路 RT 的效果！ 通过以上我们的阐述可以看到，在 CAP 的权衡中，注册中心的可用性比数据强一致性更宝贵，所以整体设计更应该偏向 AP，而非 CP，数据不一致在可接受范围，而 P 下舍弃 A 却完全违反了注册中心不能因为自身的任何原因破坏服务本身的可连通性的原则。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:3:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"服务规模、容量、服务联通性 你所在公司的“微服务”规模有多大？数百微服务？部署了上百个节点？那么 3 年后呢？互联网是产生奇迹的地方，也许你的“服务”一夜之间就家喻户晓，流量倍增，规模翻番！ 当数据中心服务规模超过一定数量 (服务规模 =F{服务 pub 数, 服务 sub 数})，作为注册中心的 ZooKeeper 很快就会像下图的驴子一样不堪重负 其实当 ZooKeeper 用对地方时，即用在粗粒度分布式锁，分布式协调场景下，ZooKeeper 能支持的 tps 和支撑的连接数是足够用的，因为这些场景对于 ZooKeeper 的扩展性和容量诉求不是很强烈。 但在服务发现和健康监测场景下，随着服务规模的增大，无论是应用频繁发布时的服务注册带来的写请求，还是刷毫秒级的服务健康状态带来的写请求，还是恨不能整个数据中心的机器或者容器皆与注册中心有长连接带来的连接压力上，ZooKeeper 很快就会力不从心，而 ZooKeeper 的写并不是可扩展的，不可以通过加节点解决水平扩展性问题。 要想在 ZooKeeper 基础上硬着头皮解决服务规模的增长问题，一个实践中可以考虑的方法是想办法梳理业务，垂直划分业务域，将其划分到多个 ZooKeeper 注册中心，但是作为提供通用服务的平台机构组，因自己提供的服务能力不足要业务按照技术的指挥棒配合划分治理业务，真的可行么？ 而且这又违反了因为注册中心自身的原因（能力不足）破坏了服务的可连通性，举个简单的例子，1 个搜索业务，1 个地图业务，1 个大文娱业务，1 个游戏业务，他们之间的服务就应该老死不相往来么？也许今天是肯定的，那么明天呢，1 年后呢，10 年后呢？谁知道未来会要打通几个业务域去做什么奇葩的业务创新？注册中心作为基础服务，无法预料未来的时候当然不能妨碍业务服务对未来固有联通性的需求。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:4:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"注册中心需要持久存储和事务日志么？ 需要，也不需要。 我们知道 ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，以及宕机之后的数据可恢复，这是非常好的特性，但是我们要问，在服务发现场景中，其最核心的数据 - 实时的健康的服务的地址列表真的需要数据持久化么？ 对于这份数据，答案是否定的。 如上图所示，如果 svcB 经历了注册服务 (ip1) 到扩容到 2 个节点（ip1，ip2）到因宕机缩容 (ip1 宕机），这个过程中，产生了 3 次针对 ZooKeeper 的写操作。 但是仔细分析，通过事务日志，持久化连续记录这个变化过程其实意义不大，因为在服务发现中，服务调用发起方更关注的是其要调用的服务的实时的地址列表和实时健康状态，每次发起调用时，并不关心要调用的服务的历史服务地址列表、过去的健康状态。 但是为什么又说需要呢，因为一个完整的生产可用的注册中心，除了服务的实时地址列表以及实时的健康状态之外，还会存储一些服务的元数据信息，例如服务的版本，分组，所在的数据中心，权重，鉴权策略信息，service label 等元信息，这些数据需要持久化存储，并且注册中心应该提供对这些元信息的检索的能力。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:5:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"Service Health Check 使用 ZooKeeper 作为服务注册中心时，服务的健康检测常利用 ZooKeeper 的 Session 活性 Track 机制 以及结合 Ephemeral ZNode 的机制，简单而言，就是将服务的健康监测绑定在了 ZooKeeper 对于 Session 的健康监测上，或者说绑定在 TCP 长链接活性探测上了。 这在很多时候也会造成致命的问题，ZK 与服务提供者机器之间的 TCP 长链接活性探测正常的时候，该服务就是健康的么？答案当然是否定的！注册中心应该提供更丰富的健康监测方案，服务的健康与否的逻辑应该开放给服务提供方自己定义，而不是一刀切搞成了 TCP 活性检测！ 健康检测的一大基本设计原则就是尽可能真实的反馈服务本身的真实健康状态，否则一个不敢被服务调用者相信的健康状态判定结果还不如没有健康检测。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:6:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"注册中心的容灾考虑 前文提过，在实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，那么在可用性上，一个本质的问题，如果注册中心（Registry）本身完全宕机了，svcA 调用 svcB 链路应该受到影响么？ 是的，不应该受到影响。 服务调用（请求响应流）链路应该是弱依赖注册中心，必须仅在服务发布，机器上下线，服务扩缩容等必要时才依赖注册中心。 这需要注册中心仔细的设计自己提供的客户端，客户端中应该有针对注册中心服务完全不可用时做容灾的手段，例如设计客户端缓存数据机制（我们称之为 client snapshot）就是行之有效的手段。另外，注册中心的 health check 机制也要仔细设计以便在这种情况不会出现诸如推空等情况的出现。 ZooKeeper 的原生客户端并没有这种能力，所以利用 ZooKeeper 实现注册中心的时候我们一定要问自己，如果把 ZooKeeper 所有节点全干掉，你生产上的所有服务调用链路能不受任何影响么？而且应该定期就这一点做故障演练。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:7:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"你有没有 ZooKeeper 的专家可依靠？ ZooKeeper 看似很简单的一个产品，但在生产上大规模使用并且用好，并不是那么理所当然的事情。如果你决定在生产中引入 ZooKeeper，你最好做好随时向 ZooKeeper 技术专家寻求帮助的心理预期，最典型的表现是在两个方面: 难以掌握的 Client/Session 状态机 ZooKeeper 的原生客户端绝对称不上好用，Curator 会好一点，但其实也好的有限，要完全理解 ZooKeeper 客户端与 Server 之间的交互协议也并不简单，完全理解并掌握 ZooKeeper Client/Session 的状态机（下图）也并不是那么简单明了: 但基于 ZooKeeper 的服务发现方案却是依赖 ZooKeeper 提供的长连接 /Session 管理，Ephemeral ZNode，Event\u0026Notification, ping 机制上，所以要用好 ZooKeeper 做服务发现，恰恰要理解这些 ZooKeeper 核心的机制原理，这有时候会让你陷入暴躁，我只是想要个服务发现而已，怎么要知道这么多？而如果这些你都理解了并且不踩坑，恭喜你，你已经成为 ZooKeeper 的技术专家了。 难以承受的异常处理 我们在阿里巴巴内部应用接入 ZooKeeper 时，有一个《ZooKeeper 应用接入必知必会》的 WIKI，其中关于异常处理有过如下的论述: 如果说要选出应用开发者在使用 ZooKeeper 的过程中，最需要了解清楚的事情？那么根据我们之前的支持经验，一定是异常处理。 当所有一切（宿主机，磁盘，网络等等）都很幸运的正常工作的时候，应用与 ZooKeeper 可能也会运行的很好，但不幸的是，我们整天会面对各种意外，而且这遵循墨菲定律，意料之外的坏事情总是在你最担心的时候发生。 所以务必仔细了解 ZooKeeper 在一些场景下会出现的异常和错误，确保您正确的理解了这些异常和错误，以及知道您的应用如何正确的处理这些情况。 ConnectionLossException 和 Disconnected 事件 简单来说，这是个可以在同一个 ZooKeeper Session 恢复的异常 (Recoverable), 但是应用开发者需要负责将应用恢复到正确的状态。 发生这个异常的原因有很多，例如应用机器与 ZooKeeper 节点之间网络闪断，ZooKeeper 节点宕机，服务端 Full GC 时间超长，甚至你的应用进程 Hang 死，应用进程 Full GC 时间超长之后恢复都有可能。 要理解这个异常，需要了解分布式应用中的一个典型的问题，如下图： 在一个典型的客户端请求、服务端响应中，当它们之间的长连接闪断的时候，客户端感知到这个闪断事件的时候，会处在一个比较尴尬的境地，那就是无法确定该事件发生时附近的那个请求到底处在什么状态，Server 端到底收到这个请求了么？已经处理了么？因为无法确定这一点，所以当客户端重新连接上 Server 之后，这个请求是否应该重试（Retry）就也要打一个问号。 所以在处理连接断开事件中，应用开发者必须清楚处于闪断附近的那个请求是什么（这常常难以判断），该请求是否是幂等的，对于业务请求在 Server 端服务处理上对于\"仅处理一次\" “最多处理一次” “最少处理一次\"语义要有选择和预期。 举个例子，如果应用在收到 ConnectionLossException 时，之前的请求是 Create 操作，那么应用的 catch 到这个异常，应用一个可能的恢复逻辑就是，判断之前请求创建的节点的是否已经存在了，如果存在就不要再创建了，否则就创建。 再比如，如果应用使用了 exists Watch 去监听一个不存在的节点的创建的事件，那么在 ConnectionLossException 的期间，有可能遇到的情况是，在这个闪断期间，其它的客户端进程可能已经创建了节点，并且又已经删除了，那么对于当前应用来说，就 miss 了一次关心的节点的创建事件，这种 miss 对应用的影响是什么？是可以忍受的还是不可接受？需要应用开发者自己根据业务语义去评估和处理。 SessionExpiredException 和 SessionExpired 事件 Session 超时是一个不可恢复的异常，这是指应用 Catch 到这个异常的时候，应用不可能在同一个 Session 中恢复应用状态，必须要重新建立新 Session，老 Session 关联的临时节点也可能已经失效，拥有的锁可能已经失效。… 我们阿里巴巴的小伙伴在自行尝试使用 ZooKeeper 做服务发现的过程中，曾经在我们的内网技术论坛上总结过一篇自己踩坑的经验分享 在该文中中肯的提到: … 在编码过程中发现很多可能存在的陷阱，毛估估，第一次使用 zk 来实现集群管理的人应该有 80% 以上会掉坑，有些坑比较隐蔽，在网络问题或者异常的场景时才会出现，可能很长一段时间才会暴露出来 … 这篇文章已经分享到云栖社区, 你可以点击 这里 详细阅读。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:8:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"向左走，向右走 阿里巴巴是不是完全没有使用 ZooKeeper？并不是！ 熟悉阿里巴巴技术体系的都知道，其实阿里巴巴维护了目前国内乃至世界上最大规模的 ZooKeeper 集群，整体规模有近千台的 ZooKeeper 服务节点。 同时阿里巴巴中间件内部也维护了一个面向大规模生产的、高可用、更易监控和运维的 ZooKeeper 的代码分支 TaoKeeper，如果以我们近 10 年在各个业务线和生产上使用 ZooKeeper 的实践，给 ZooKeeper 用一个短语评价的话，那么我们认为 ZooKeeper 应该是 “The King Of Coordination for Big Data”！ 在粗粒度分布式锁，分布式选主，主备高可用切换等不需要高 TPS 支持的场景下有不可替代的作用，而这些需求往往多集中在大数据、离线任务等相关的业务领域，因为大数据领域，讲究分割数据集，并且大部分时间分任务多进程 / 线程并行处理这些数据集，但是总是有一些点上需要将这些任务和进程统一协调，这时候就是 ZooKeeper 发挥巨大作用的用武之地。 但是在交易场景交易链路上，在主业务数据存取，大规模服务发现、大规模健康监测等方面有天然的短板，应该竭力避免在这些场景下引入 ZooKeeper，在阿里巴巴的生产实践中，应用对 ZooKeeper 申请使用的时候要进行严格的场景、容量、SLA 需求的评估。 所以可以使用 ZooKeeper，但是大数据请向左，而交易则向右，分布式协调向左，服务发现向右。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:9:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Learning"],"content":"结语 感谢你耐心的阅读到这里，至此，我相信你已经理解，我们写这篇文章并不是全盘否定 ZooKeeper，而只是根据我们阿里巴巴近 10 年来在大规模服务化上的生产实践，对我们在服务发现和注册中心设计及使用上的经验教训进行一个总结，希望对业界就如何更好的使用 ZooKeeper，如何更好的设计自己的服务注册中心有所启发和帮助。 最后，条条大路通罗马，衷心祝愿你的注册中心直接就诞生在罗马。 ","date":"2022-05-30","objectID":"/microservices-ali-zk-or-other-note/:10:0","tags":["Microservices","Alibaba","ZooKeeper"],"title":"阿里巴巴为什么不用 ZooKeeper 做服务发现？","uri":"/microservices-ali-zk-or-other-note/"},{"categories":["Back","note"],"content":"记录Java注解笔记","date":"2022-05-30","objectID":"/java-annotation-note/","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"Java注解使用、Java获取注解的属性、获取注解的字段值 ","date":"2022-05-30","objectID":"/java-annotation-note/:1:0","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"一、前言 1、前面一直讲注解的基础知识，注解的定义，对于注解的使用几乎是一笔略过，本篇将着重讲讲注解的使用。 获取注解的属性，通过反射获取注解的属性值。 ","date":"2022-05-30","objectID":"/java-annotation-note/:1:1","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"二、示例代码 1、定义一个注解，用于给 全局变量 field 字段 赋值 package com.haha.study.annotation.value; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** \\* description: 定义一个注解，用于给 全局变量 field 字段 赋值,并使用反射取值。 \u003cbr\u003e \\* 特别提醒： @Rentention(RetentionPolicy.RUNTIME) 时，注解才会被jvm加载，才能使用反射获取。 \\* @version v1.0 \\* @author w \\* @date 2018年8月1日下午2:37:40 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value=ElementType.FIELD) public @interface Fields { int sort() default 0 ; String value() ; } 2、定义一个注解 。 package com.haha.study.annotation.value; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** \\* description: 定义一个注解。 \\* @version v1.0 \\* @author w \\* @date 2018年8月1日下午2:41:45 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface ConsAnnotation { String[] request(); } 3、创建一个普通的类，使用 @ConsAnnotation、@Fields 注解 package com.haha.study.annotation.value; /** \\* description: 创建一个普通的类，使用 @ConsAnnotation、@Fields 注解。 \\* @version v1.0 \\* @author w \\* @date 2018年8月1日下午2:50:23 */ @ConsAnnotation(request = { \"hello\",\"world\",\"annotation!\" }) public class User { @Fields(\"中华人民共和国\") private String userName; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } } 4、针对 com.haha.study.annotation.value.User 类使用注解的测试 package com.haha.study.annotation.value; import java.lang.reflect.Field; import java.util.Arrays; /** \\* description: 针对 com.haha.study.annotation.value.User 类使用注解的测试 \\* @version v1.0 \\* @author w \\* @date 2018年8月1日下午2:37:13 */ public class ValueTest { public static void main(String[] args) throws Exception { User user = new User(); // 1、 获取 User类上的注解 @ConsAnnotation ConsAnnotation anno = user.getClass().getAnnotation(ConsAnnotation.class); String[] arr = anno.request(); System.out.println(Arrays.toString(arr)); // [hello, world, annotation!] // 2、 获取User类中 private String userName; 变量上的注解 @Field Field f = user.getClass().getDeclaredField(\"userName\"); Fields anno2 = f.getAnnotation(Fields.class); user.setUserName(anno2.value()); System.out.println(user.getUserName()); // 中华人民共和国 } } ","date":"2022-05-30","objectID":"/java-annotation-note/:1:2","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"Java的自定义注解及通过反射获取注解 ","date":"2022-05-30","objectID":"/java-annotation-note/:2:0","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"一、注解基本知识 　1、元注解：@Retention @Target @Document @Inherited 　2、Annotation型定义为**@interface**, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口。 　3、参数成员只能用public或默认(default)这两个访问权修饰 　4、参数成员只能用基本类型byte，short，char，int，long，float，double，boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组。 　5、要获取类、方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,除此之外没有别的获取注解对象的方法 　6、注解也可以没有定义成员, 不过这样注解就没啥用了，只起到标识作用 自定义注解类时, 可以指定目标 (类、方法、字段, 构造函数等) , 注解的生命周期(运行时,class文件或者源码中有效), 是否将注解包含在javadoc中及是否允许子类继承父类中的注解, 具体如下： 　1、@Target 表示该注解目标,可能的 ElemenetType 参数包括： 　ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明(包括 enum 实例) ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口(包括注解类型)或enum声明 　2、@Retention 表示该注解的生命周期,可选的 RetentionPolicy 参数包括 　RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被JVM丢弃 RetentionPolicy.RUNTIME JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息 　3、@Documented 指示将此注解包含在 javadoc 中 　4、@Inherited 指示允许子类继承父类中的注解 ","date":"2022-05-30","objectID":"/java-annotation-note/:2:1","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"二、在java中的使用 　2.1、定义注解 package annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class MyAnnotation { /** * 注解类 * * @author suguoliang * */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyClassAnnotation { String uri(); String desc(); } /** * 构造方法注解 * * @author suguoliang * */ @Target(ElementType.CONSTRUCTOR) @Retention(RetentionPolicy.RUNTIME) public @interface MyConstructorAnnotation { String uri(); String desc(); } /** * 方法注解 * * @author suguoliang * */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyMethodAnnotation { String uri(); String desc(); } /** * 字段注解 * * @author suguoliang * */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface MyFieldAnnotation { String uri(); String desc(); } /** * 可以同时应用到类和方法上 * * @author 尐蘇 * */ @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) public @interface MyClassAndMethodAnnotation { // 定义枚举 public enum EnumType { util, entity, service, model } // 设置默认值 public EnumType classType() default EnumType.util; // 数组 int[] arr() default { 3, 7, 5 }; String color() default \"blue\"; } } 　2.2基本测试 package annotation; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import annotation.MyAnnotation.MyClassAndMethodAnnotation; import annotation.MyAnnotation.MyClassAndMethodAnnotation.EnumType; import annotation.MyAnnotation.MyClassAnnotation; import annotation.MyAnnotation.MyConstructorAnnotation; import annotation.MyAnnotation.MyFieldAnnotation; import annotation.MyAnnotation.MyMethodAnnotation; @MyClassAnnotation(desc = \"The Class\", uri = \"com.sgl.annotation\") @MyClassAndMethodAnnotation(classType = EnumType.util) public class TestAnnotation { @MyFieldAnnotation(desc = \"The Class Field\", uri = \"com.sgl.annotation#id\") private String id; @MyConstructorAnnotation(desc = \"The Class Constructor\", uri = \"com.sgl.annotation#constructor\") public TestAnnotation() { } public String getId() { return id; } @MyMethodAnnotation(desc = \"The Class Method\", uri = \"com.sgl.annotation#setId\") public void setId(String id) { this.id = id; } @MyMethodAnnotation(desc = \"The Class Method sayHello\", uri = \"com.sgl.annotation#sayHello\") public void sayHello(String name) { if (name == null || name.equals(\"\")) { System.out.println(\"hello world!\"); } else { System.out.println(name + \"\\t:say hello world\"); } } public static void main(String[] args) throws Exception { Class\u003cTestAnnotation\u003e clazz = TestAnnotation.class; // 获取类注解 MyClassAnnotation myClassAnnotation = clazz.getAnnotation(MyClassAnnotation.class); System.out.println(myClassAnnotation.desc() + \"+\" + myClassAnnotation.uri()); // 获得构造方法注解 Constructor\u003cTestAnnotation\u003e constructors = clazz.getConstructor(new Class[] {});// 先获得构造方法对象 MyConstructorAnnotation myConstructorAnnotation = constructors.getAnnotation(MyConstructorAnnotation.class);// 拿到构造方法上面的注解实例 System.out.println(myConstructorAnnotation.desc() + \"+\" + myConstructorAnnotation.uri()); // 获得方法注解 Method method = clazz.getMethod(\"setId\", new Class[] { String.class });// 获得方法对象 MyMethodAnnotation myMethodAnnotation = method.getAnnotation(MyMethodAnnotation.class); System.out.println(myMethodAnnotation.desc() + \"+\" + myMethodAnnotation.uri()); // 获得字段注解 Field field = clazz.getDeclaredField(\"id\");// 暴力获取private修饰的成员变量 MyFieldAnnotation myFieldAnnotation = field.getAnnotation(MyFieldAnnotation.class); System.out.println(myFieldAnnotation.desc() + \"+\" + myFieldAnnotation.uri()); } } 　2.3通过反射解析 package annotation; import java.lang.reflect.Method; import java.util.Arrays; import annotation.MyAnnotation.MyClassAndMethodAnnotation; import annotation.MyAnnotation.MyClassAndMethodAnnotation.EnumType; import annotation.MyAnnotation.MyClassAnnotation; import annotation.MyAnnotation.MyMethodAnnotation; public class Par","date":"2022-05-30","objectID":"/java-annotation-note/:2:2","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"Java获取类、方法、属性上的注解 ","date":"2022-05-30","objectID":"/java-annotation-note/:3:0","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"一、获取类上的注解 Java获取类上的注解有下面3个方法： Class.getAnnotations() 获取所有的注解，包括自己声明的以及继承的 Class.getAnnotation(Class\u003c A \u003e annotationClass) 获取指定的注解，该注解可以是自己声明的，也可以是继承的 Class.getDeclaredAnnotations() 获取自己声明的注解 下面，我们来演示一下3个方法的使用。 首先，我们定义两个注解ParentAnnotation、SubAnnotation @Retention(RetentionPolicy.RUNTIME) @Target(value={ElementType.TYPE}) @Documented @Inherited //可以继承 public @interface ParentAnnotation { } @Target(value={ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SubAnnotation { } 接下来，我们定义两个类，Parent、Sub，分别标注ParentAnnotation 注解和SubAnnotation注解 @ParentAnnotation public class Parent { } @SubAnnotation public class Sub extends Parent{ } 一切准备OK后，就开始测试了。 public class AnnotationTest { public static void main(String[] args) { Annotation[] allAnnos = Sub.class.getAnnotations(); Annotation[] deAnnos = Sub.class.getDeclaredAnnotations(); Annotation subAnnotation = Sub.class.getAnnotation(SubAnnotation.class); Annotation parentAnnotation = Sub.class.getAnnotation(ParentAnnotation.class); printAnnotation(\"all\",allAnnos); printAnnotation(\"declare\",deAnnos); printAnnotation(\"sub\",subAnnotation); printAnnotation(\"parent\",parentAnnotation); } private static void printAnnotation(String msg,Annotation... annotations){ System.out.println(\"==============\"+msg+\"======================\"); if(annotations == null){ System.out.println(\"Annotation is null\"); } for (Annotation annotation : annotations) { System.out.println(annotation); } System.out.println(); } } 执行结果： ==============all====================== @com.ghs.test.annotation.ParentAnnotation() @com.ghs.test.annotation.SubAnnotation() ==============declare====================== @com.ghs.test.annotation.SubAnnotation() ==============sub====================== @com.ghs.test.annotation.SubAnnotation() ==============parent====================== @com.ghs.test.annotation.ParentAnnotation() 尝试着将ParentAnnotation中的@Inherited去掉，结果如下： ==============all====================== @com.ghs.test.annotation.SubAnnotation() ==============declare====================== @com.ghs.test.annotation.SubAnnotation() ==============sub====================== @com.ghs.test.annotation.SubAnnotation() ==============parent====================== null 再试着将Sub类中的SubAnnotation去掉，结果如下： ==============all====================== ==============declare====================== ==============sub====================== null ==============parent====================== null 经过几番小小的测试，我们基本上可以得出下面几条结论： 注解只有标注了@Inherited才能被子类继承 当某个类没有标注任何注解时，getAnnotations()和getDeclaredAnnotations()返回空数组 当某个注解查询不到时，getAnnotation(Class\u003c A \u003e annotationType)方法返回null ","date":"2022-05-30","objectID":"/java-annotation-note/:3:1","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"二、获取方法上的注解 修改上面的ParentAnnotation与SubAnnotation，使其可以标注在方法上 @Target(value={ElementType.TYPE, ElementType.METHOD}) 在Sub、Parent中分别添加一个test()方法，如下： @ParentAnnotation public class Parent { @ParentAnnotation public void test(){ } } @SubAnnotation public class Sub extends Parent{ @SubAnnotation public void test(){ } } 一切准备就绪，就可以进行测试了。 private static void testMethodAnnotation() { Method[] methods = Sub.class.getMethods(); for (Method method : methods) { if(method.getName().equals(\"test\")){ Annotation[] allMAnnos = method.getAnnotations(); Annotation[] deMAnnos = method.getDeclaredAnnotations(); Annotation subMAnno = method.getAnnotation(SubAnnotation.class); Annotation parentMAnno = method.getAnnotation(ParentAnnotation.class); printAnnotation(\"allMAnnos\",allMAnnos); printAnnotation(\"deMAnnos\",deMAnnos); printAnnotation(\"subMAnno\",subMAnno); printAnnotation(\"parentMAnno\",parentMAnno); } } } 执行结果如下： ==============allMAnnos====================== @com.ghs.test.annotation.SubAnnotation() ==============deMAnnos====================== @com.ghs.test.annotation.SubAnnotation() ==============subMAnno====================== @com.ghs.test.annotation.SubAnnotation() ==============parentMAnno====================== null 尝试着删除Sub中的test方法，再次进行测试，结果如下： ==============allMAnnos====================== @com.ghs.test.annotation.ParentAnnotation() ==============deMAnnos====================== @com.ghs.test.annotation.ParentAnnotation() ==============subMAnno====================== null ==============parentMAnno====================== @com.ghs.test.annotation.ParentAnnotation() 经过两轮测试，可以得出以下结论： 子类重写的方法，注解无法被继承 针对方法而言，getAnnotations()与getDeclaredAnnotations()返回的结果似乎永远都是一样的。 附：针对此结论，如有不同的想法，还望不吝赐教 ","date":"2022-05-30","objectID":"/java-annotation-note/:3:2","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"三、获取属性上的注解 修改上面的ParentAnnotation与SubAnnotation，使其可以标注在属性上 @Target(value={ElementType.TYPE, ElementType.METHOD,ElementTypeFIELD}) 在Sub、Parent中分别添加一个name属性，如下： @ParentAnnotation public class Parent { @ParentAnnotation public String name; @ParentAnnotation public void test(){ } } @SubAnnotation public class Sub extends Parent{ @SubAnnotation public String name; @SubAnnotation public void test(){ } } 下面开始测试： private static void testFieldAnnotation() { Field[] fields = Sub.class.getFields(); for (Field field : fields) { Annotation[] allFAnnos= field.getAnnotations(); Annotation[] deFAnnos = field.getDeclaredAnnotations(); Annotation subFAnno = field.getAnnotation(SubAnnotation.class); Annotation parentFAnno = field.getAnnotation(ParentAnnotation.class); printAnnotation(\"allFAnnos\",allFAnnos); printAnnotation(\"deFAnnos\",deFAnnos); printAnnotation(\"subFAnno\",subFAnno); printAnnotation(\"parentFAnno\",parentFAnno); System.out.println(\"**************************************************\\n\"); } } 执行结果如下： ==============allFAnnos====================== @com.ghs.test.annotation.SubAnnotation() ==============deFAnnos====================== @com.ghs.test.annotation.SubAnnotation() ==============subFAnno====================== @com.ghs.test.annotation.SubAnnotation() ==============parentFAnno====================== null ************************************************** ==============allFAnnos====================== @com.ghs.test.annotation.ParentAnnotation() ==============deFAnnos====================== @com.ghs.test.annotation.ParentAnnotation() ==============subFAnno====================== null ==============parentFAnno====================== @com.ghs.test.annotation.ParentAnnotation() ************************************************** 经过测试，我们可以得出下面的几个结论： 父类的属性和子类的属性互补干涉 针对属性而言，getAnnotations()与getDeclaredAnnotations()方法返回的结果似乎都是一样的 附：针对此结论，如有不同的想法，还望不吝赐教 ","date":"2022-05-30","objectID":"/java-annotation-note/:3:3","tags":["Java","Annotation"],"title":"Java注解笔记","uri":"/java-annotation-note/"},{"categories":["Back","note"],"content":"记录Java线程Thread笔记","date":"2022-05-30","objectID":"/java-thread-note/","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"Java 获取正在执行的方法名 //获取调用该方法的方法名.... String method = Thread.currentThread().getStackTrace()[2].getMethodName(); //获取正在执行方法的方法名.... String method = Thread.currentThread().getStackTrace()[1].getMethodName(); ","date":"2022-05-30","objectID":"/java-thread-note/:1:0","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"什么是CAS机制，通俗易懂大白话版 ","date":"2022-05-30","objectID":"/java-thread-note/:2:0","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"我们先看一段代码： 启动两个线程，每个线程中让静态变量count循环累加100次。 最终输出的count结果一定是200吗？因为这段代码是非线程安全的，所以最终的自增结果很可能会小于200。我们再加上synchronized同步锁，再来看一下。 加了同步锁之后，count自增的操作变成了原子性操作，所以最终输出一定是count=200，代码实现了线程安全。虽然synchronized确保了线程安全，但是在某些情况下，这并不是一个最有的选择。 关键在于性能问题。 synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。 尽管JAVA 1.6为synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过过度，但是在最终转变为重量级锁之后，性能仍然比较低。所以面对这种情况，我们就可以使用java中的“原子操作类”。 所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicUInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。 现在我们尝试使用AtomicInteger类： 使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比synchronized更好。 ","date":"2022-05-30","objectID":"/java-thread-note/:2:1","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"而Atomic操作类的底层正是用到了“CAS机制”。 CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换。 CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。 我们看一个例子： 1. 在内存地址V当中，存储着值为10的变量。 2. 此时线程1想把变量的值增加1.对线程1来说，旧的预期值A=10，要修改的新值B=11. 3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。 4. 线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。 5. 线程1 重新获取内存地址V的当前值，并重新计算想要修改的值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。 6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行比较，发现A和地址V的实际值是相等的。 7. 线程1进行交换，把地址V的值替换为B，也就是12. 从思想上来说，synchronized属于悲观锁，悲观的认为程序中的并发情况严重，所以严防死守，CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。 在java中除了上面提到的Atomic系列类，以及Lock系列类夺得底层实现，甚至在JAVA1.6以上版本，synchronized转变为重量级锁之前，也会采用CAS机制。 ","date":"2022-05-30","objectID":"/java-thread-note/:2:2","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"CAS的缺点： 1） CPU开销过大 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。 2） 不能保证代码块的原子性 CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。 3） ABA问题 这是CAS机制最大的问题所在。（后面有介绍） ","date":"2022-05-30","objectID":"/java-thread-note/:2:3","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"我们下面来介绍一下两个问题： 1. JAVA中CAS的底层实现 2. CAS的ABA问题和解决办法。 我们看一下AtomicInteger当中常用的自增方法incrementAndGet： public final int incrementAndGet () { for (; ; ) { int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; } } private volatile int value; public final int get () { return value; } 这段代码是一个无限循环，也就是CAS的自旋，循环体中做了三件事： 获取当前值 当前值+1，计算出目标值 进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤 这里需要注意的重点是get方法，这个方法的作用是获取变量的当前值。 如何保证获取的当前值是内存中的最新值？很简单，用volatile关键字来保证（保证线程间的可见性）。我们接下来看一下compareAndSet方法的实现： compareAndSet方法的实现很简单，只有一行代码。这里涉及到两个重要的对象，一个是unsafe，一个是valueOffset。 **什么是unsafe呢？**Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。unsafe为我们提供了硬件级别的原子操作。 至于valueOffset对象，是通过unsafe.objectFiledOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单的把valueOffset理解为value变量的内存地址。 我们上面说过，CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 而unsafe的compareAndSwapInt方法的参数包括了这三个基本元素：valueOffset参数代表了V，expect参数代表了A，update参数代表了B。 正是unsafe的compareAndSwapInt方法保证了Compare和Swap操作之间的原子性操作。 ","date":"2022-05-30","objectID":"/java-thread-note/:2:4","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Back","note"],"content":"我们现在来说什么是ABA问题。 假设内存中有一个值为A的变量，存储在地址V中。 此时有三个线程想使用CAS的方式更新这个变量的值，每个线程的执行时间有略微偏差。线程1和线程2已经获取当前值，线程3还未获取当前值。 接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获取了当前值B。 在之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。 最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值A”，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。 看起来这个例子没啥问题，但如果结合实际，就可以发现它的问题所在。 我们假设一个提款机的例子。假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。 由于提款机硬件出了点问题，小灰的提款操作被同时提交了两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。 理想情况下，应该一个线程更新成功，一个线程更新失败，小灰的存款值被扣一次。 线程1首先执行成功，把余额从100改成50.线程2因为某种原因阻塞。这时，小灰的妈妈刚好给小灰汇款50元。 线程2仍然是阻塞状态，线程3执行成功，把余额从50改成了100。 线程2恢复运行，由于阻塞之前获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以会成功把变量值100更新成50。 原本线程2应当提交失败，小灰的正确余额应该保持100元，结果由于ABA问题提交成功了。 怎么解决呢？加个版本号就可以了。 真正要做到严谨的CAS机制，我们在compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。 我们仍然以刚才的例子来说明，假设地址V中存储着变量值A，当前版本号是01。线程1获取了当前值A和版本号01，想要更新为B，但是被阻塞了。 这时候，内存地址V中变量发生了多次改变，版本号提升为03，但是变量值仍然是A。 随后线程1恢复运行，进行compare操作。经过比较，线程1所获得的值和地址的实际值都是A，但是版本号不相等，所以这一次更新失败。 在Java中，AtomicStampedReference类就实现了用版本号作比较额CAS机制。 1. java语言CAS底层如何实现？ 利用unsafe提供的原子性操作方法。 2.什么事ABA问题？怎么解决？ 当一个值从A变成B，又更新回A，普通CAS机制会误判通过检测。 利用版本号比较可以有效解决ABA问题。 ","date":"2022-05-30","objectID":"/java-thread-note/:2:5","tags":["Java","Thread"],"title":"Java线程Thread笔记","uri":"/java-thread-note/"},{"categories":["Software"],"content":"记录使用Winsw将Jar或Bat文件注册到Windows服务的笔记","date":"2022-05-29","objectID":"/win-ftp-unable-allocate-handles-error/","tags":["Windows","Ftp","Error"],"title":"打开Ftp服务器地址，提示无法分配更多的Internet句柄","uri":"/win-ftp-unable-allocate-handles-error/"},{"categories":["Software"],"content":" 报错如上图 ","date":"2022-05-29","objectID":"/win-ftp-unable-allocate-handles-error/:0:0","tags":["Windows","Ftp","Error"],"title":"打开Ftp服务器地址，提示无法分配更多的Internet句柄","uri":"/win-ftp-unable-allocate-handles-error/"},{"categories":["Software"],"content":"解决办法 任务管理器-\u003e进程，杀掉explorer.exe，任务管理器-\u003e文件-\u003e运行新任务 explorer ","date":"2022-05-29","objectID":"/win-ftp-unable-allocate-handles-error/:1:0","tags":["Windows","Ftp","Error"],"title":"打开Ftp服务器地址，提示无法分配更多的Internet句柄","uri":"/win-ftp-unable-allocate-handles-error/"},{"categories":["Software","note"],"content":"记录在Windows下Ftp使用的笔记","date":"2022-05-29","objectID":"/win-ftp-note/","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"在Windows下Ftp命令行的使用 本篇记录了如何在Windows自带的命令行（cmd）下使用Ftp进行文件的上传、下载、查找等操作。 环境： 客户端：Windows10 家庭版，管理员权限命令行 服务器端：Windows 7，端口21（控制连接端口）和20（数据连接端口） ","date":"2022-05-29","objectID":"/win-ftp-note/:1:0","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"建立连接 win+r键打开cmd，在命令行中输入ftp xxx.xxx.xxx.xxx，或者输入ftp进入Ftp模式，然后在这个模式下输入open xxx.xxx.xxx.xxx，其中xxx.xxx.xxx.xxx就是Ftp服务器的地址。连接上服务器之后，服务器会让你输入用户和密码，输入你的用户和密码即可登陆成功，如下图所示： ","date":"2022-05-29","objectID":"/win-ftp-note/:1:1","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"操作文件及文件目录 1.使用dir（如果是linux服务器的话应该使用ls）来查看当前Ftp目录的文件，dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件local-file。 2.使用cd来切换Ftp系统目录。 3.使用mkdir来新建一个目录（文件夹）。 4.使用delete 路径+文件名来删除文件。 5.使用mdelete remote-file批量删除远程主机文件。 5.使用rm 路径名来删除文件夹。 6.使用lcd设置当前用户工作路径，也就是要把资源下载到本地哪个文件夹。 7.!xx是跳出Ftp模式，在命令行中执行xx命令，比如说使用lcd切换到本地另外一个文件夹之后，你想看当前文件夹下有什么文件，就可以使用!dir来实现。 8.使用pwd命令查看当前路径。 ","date":"2022-05-29","objectID":"/win-ftp-note/:1:2","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"上传文件 使用put(或者send，如果想上传多个文件的话使用mput) 路径+文件名。比如说： put E:\\test.txt send E:\\test.txt mput E:\\test.txt E:\\test1.txt 以mget为例： ","date":"2022-05-29","objectID":"/win-ftp-note/:1:3","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"下载文件 使用get（下载多个文件用mget）路径+文件名来下载文件。 get ./test.txt mget ./test.txt ./test1.txt 以mget为例： ","date":"2022-05-29","objectID":"/win-ftp-note/:1:4","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software","note"],"content":"断开连接 输入bye就可以了。 ","date":"2022-05-29","objectID":"/win-ftp-note/:1:5","tags":["Windows","Ftp","Command"],"title":"在Windows下Ftp使用笔记","uri":"/win-ftp-note/"},{"categories":["Software"],"content":"记录Beyond Compare 4 This license key has been revoked 报错的解决办法","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Software"],"content":"错误提示 This license key has been revoked xxxxx ","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/:1:0","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Software"],"content":"Windows 系统 ","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/:2:0","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Software"],"content":"解决方法 删除以下目录中的所有文件即可。 C:\\Users\\Administrator\\AppData\\Roaming\\ScooterSoftware\\Beyond [Compare](https://so.csdn.net/so/search?q=Compare\u0026spm=1001.2101.3001.7020) 4 ","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/:2:1","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Software"],"content":"Linux系统 ","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/:3:0","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Software"],"content":"解决方法 1.删除下面目录中的所有文件： /home/xxx/.config/bcompare 2.重新破解 $cd /usr/lib/beyondcompare/ $sudo sed -i \"s/keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH+/N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR+/g\" BCompare 3.此时BCompare文件已被破解，打开软件会提示“Trial Mode Error！”表示成功，输入下面TEAM ZWT生成的密钥即可注册成功 --- BEGIN LICENSE KEY --- GXN1eh9FbDiX1ACdd7XKMV7hL7x0ClBJLUJ-zFfKofjaj2yxE53xauIfkqZ8FoLpcZ0Ux6McTyNmODDSvSIHLYhg1QkTxjCeSCk6ARz0ABJcnUmd3dZYJNWFyJun14rmGByRnVPL49QH+Rs0kjRGKCB-cb8IT4Gf0Ue9WMQ1A6t31MO9jmjoYUeoUmbeAQSofvuK8GN1rLRv7WXfUJ0uyvYlGLqzq1ZoJAJDyo0Kdr4ThF-IXcv2cxVyWVW1SaMq8GFosDEGThnY7C-SgNXW30jqAOgiRjKKRX9RuNeDMFqgP2cuf0NMvyMrMScnM1ZyiAaJJtzbxqN5hZOMClUTE+++ --- END LICENSE KEY ----- \\--------------------- mv1nPlXAywBDCdhxFc9QOVv6TBcQHLAXBQUAKTh3ie4fqSEOnWrPsnVkF yt0wAkJHweoExRJWWVwwCniKNROSdJzJXE6YVapYW7f+tRRXRFI4yn4Nj jZ0RiiqGRCTVzwComUcXB-eiFWRBY6JpSsCNkmIxL5KsRCo442djHhTZE ","date":"2022-05-29","objectID":"/beyond-compare-4-license-revoked-error/:3:1","tags":["BeyondCompare","BeyondCompare4","License","Editer","CompareEditer","Error"],"title":"Beyond Compare 4 This license key has been revoked 解决办法","uri":"/beyond-compare-4-license-revoked-error/"},{"categories":["Back"],"content":"记录Gradle项目在IDEA中运行时提示:Unnecessarily replacing a task that does not exist is not supported. Use create的报错","date":"2022-05-29","objectID":"/gradle-could-not-create-task-error/","tags":["Gradle","Idea","Error"],"title":"Gradle项目在IDEA中运行时提示:Unnecessarily replacing a task that does not exist is not supported. Use create","uri":"/gradle-could-not-create-task-error/"},{"categories":["Back"],"content":"场景 在IDEA中新建Gradle项目后，使用Java语言。 新建类后添加main方法，然后运行main方法释提示： could not create task ':HelloWorldServer.main()'. \\\u003e Unnecessarily replacing a task that does not exist is not supported. Use create() or register() directly instead. ","date":"2022-05-29","objectID":"/gradle-could-not-create-task-error/:1:0","tags":["Gradle","Idea","Error"],"title":"Gradle项目在IDEA中运行时提示:Unnecessarily replacing a task that does not exist is not supported. Use create","uri":"/gradle-could-not-create-task-error/"},{"categories":["Back"],"content":"实现 这是因为在运行main方法时，gradle并没有识别，将其认为是一个task。 来到项目下的.idea下的gradle.xml文件 将下面的设置改为false \u003coption name=\"delegatedBuild\" value=\"false\" /\u003e 如果没有则添加该配置。 ","date":"2022-05-29","objectID":"/gradle-could-not-create-task-error/:2:0","tags":["Gradle","Idea","Error"],"title":"Gradle项目在IDEA中运行时提示:Unnecessarily replacing a task that does not exist is not supported. Use create","uri":"/gradle-could-not-create-task-error/"},{"categories":["Back","note"],"content":"记录Java jar包指令笔记","date":"2022-05-29","objectID":"/java-jar-cmd-note/","tags":["Java","Jar","Operation","Command"],"title":"Java jar包指令笔记","uri":"/java-jar-cmd-note/"},{"categories":["Back","note"],"content":"Java中Jar包运行之-jar和-cp命令 或多或少，我们都会见到用这两种命令启动java程序，最基本的用法如： java [options] -jar xxx.jar [args] java [options] -cp xxx.jar classname [args] 那这两种用法有什么区别呢？ 我们先写一个简单的测试类（为了方便说明问题，不借助开发工具）： 1）在本机随便找个目录，创建com.test目录，并编写HelloTest.java文件： package com.test; public class HelloTest { public static void main(String[] args) { String name = args[0]; System.out.println(\"hello:\"+name); } } 2）编译： 3）打jar包： 4）我们尝试用最开始说的两种命令来执行 发现-jar命令执行的结果提示：没有主清单属性，什么意思呢？ 首先说下jar包，jar包跟我们通常认知的.zip压缩文件，是一样一样的，我们甚至完全可以用普通zip压缩工具来压缩com目录，然后用java -cp com.zip com.test.HelloTest everybody照样能运行，不同的是，用jar命令打出的jar包会多出来一个东西： 看到没，一个META-INF目录，里面有一个文件：MANIFEST.MF，其内容如下： Manifest-Version: 1.0 Created-By: 1.8.0_171 (Oracle Corporation) 这个文件就是jar的清单文件，可以理解成一个标识配置文件，上面说的java -jar执行结果提示：没有主清单属性，就是因为我们的清单文件中少了一样属性，这个属性是：Main-Class，它声明了jar包的默认入口类，也是java -jar运行时开始执行的类，其格式为： Main-Class: com.test.HelloTest 我们把test.jar解压后，在MANIFEST.MF文件中加入该属性： 然后用.zip格式直接再次压缩后（命名为test2.jar），执行java -jar test2.jar 注意：清单属性配置格式问题，冒号后面需要一个空格，否则会报Error: Invalid or corrupt jarfile错误，属性结束必须换行，否则仍然找不到属性 当然，实际上也不需要如此麻烦，我们在打jar包时可以通过-e参数指定默认入口，会自动生成Main-Class属性，此时jar包就是一个可执行jar文件： 用java -jar运行jar包时，虚拟机忽略系统中的classpath配置，如果有依赖jar，需要在清单属性中指定，格式为： Class-Path： servlet.jar infobus.jar acme/beans.jar 多个jar包之间用空格隔开，其位置是相对于当前运行的jar包所在的目录； 用java -cp运行时，其cp本身就是classpath的意思，对于多个依赖的jar格式为： java -cp test.jar;test1.jar;test2.jar com.test.HelloTest 注意：jar包之间的分隔符在windows上是分号\";\"，而在linux中是冒号\":\"。 综上所述： java -jar用来执行可执行jar包，其可执行的特性，由jar包中的清单属性Main-Class决定； java -cp命令是纯粹的java命令，在指定的classpath中查找java类文件并执行，使用更灵活； ","date":"2022-05-29","objectID":"/java-jar-cmd-note/:1:0","tags":["Java","Jar","Operation","Command"],"title":"Java jar包指令笔记","uri":"/java-jar-cmd-note/"},{"categories":["Back","note"],"content":"记录Idea中java程序打Jar包的两种方式（超详细）的笔记","date":"2022-05-29","objectID":"/maven-idea-jar-note/","tags":["Java","Jar","Maven","Idea"],"title":"Idea中java程序打Jar包的两种方式（超详细）","uri":"/maven-idea-jar-note/"},{"categories":["Back","note"],"content":"Java程序打成的Jar包有两种类型，一种是可直接执行的Runnable Jar文件，另一种是包含多个主类，运行时需要指定主类全类名的Jar包，下面我们细说在Idea中两种Jar包的打包方法及执行Jar包时的命令。 ","date":"2022-05-29","objectID":"/maven-idea-jar-note/:0:0","tags":["Java","Jar","Maven","Idea"],"title":"Idea中java程序打Jar包的两种方式（超详细）","uri":"/maven-idea-jar-note/"},{"categories":["Back","note"],"content":"第一种： 含多个主类的Jar包打包方法及运行命令 在写好我们要打Jar包的Java程序后，点击Idea右上角如图所示位置 先选择Artifacts，再点击加号 点击Empty新建一个新的Jar包 如图，设置Jar包名称，Jar包打好后所在的路径，以及添加工程编译文件 点击OK后，会回到Idea界面 然后按照图示依次点击选项 最后选择你的jar包名，点击build，jar包便打包成功，进入你在第4步时设置好的路径下就可以看到你的jar包了 运行Jar包程序， 命令：java -cp jar包路径 主类全类名 ","date":"2022-05-29","objectID":"/maven-idea-jar-note/:1:0","tags":["Java","Jar","Maven","Idea"],"title":"Idea中java程序打Jar包的两种方式（超详细）","uri":"/maven-idea-jar-note/"},{"categories":["Back","note"],"content":"第二种：可直接执行的runnable jar打包方法及运行命令 前4步操作与上面的一样，然后继续以下操作 点击Create Manifest选项，选择你的工程名称，然后点击OK 如图选择jar文件，会有以下Main Class选项，点击对应文件夹图标 选择你要执行的main方法所在的类，点击OK，再点击下一个OK，就回到了idea主界面，接着上面第6-7步进行操作即可 运行jar包程序 因为此runnable jar在打jar包的时候已经选择好了主类，所以可以直接运行，命令也有所不同 命令：java -jar jar包路径 ","date":"2022-05-29","objectID":"/maven-idea-jar-note/:2:0","tags":["Java","Jar","Maven","Idea"],"title":"Idea中java程序打Jar包的两种方式（超详细）","uri":"/maven-idea-jar-note/"},{"categories":["Back","note"],"content":"结语： 好了，以上就是idea中java程序的两种jar包的打包方式及运行命令，需要注意的就是千万别把jar包和对应的运行命令搞混了！ ","date":"2022-05-29","objectID":"/maven-idea-jar-note/:3:0","tags":["Java","Jar","Maven","Idea"],"title":"Idea中java程序打Jar包的两种方式（超详细）","uri":"/maven-idea-jar-note/"},{"categories":["Operation","note"],"content":"记录Windows Cmd指令笔记","date":"2022-05-29","objectID":"/win-cmd-note/","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"Cmd怎么杀死进程 ","date":"2022-05-29","objectID":"/win-cmd-note/:1:0","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"方法一 Windows + R，输入cmd，按下Enter，打开DOS窗口 输入命令tasklist，查看运行中的进程 输入命令taskkill /pid xxx -f 终止相应进程即可 END ","date":"2022-05-29","objectID":"/win-cmd-note/:1:1","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"方法二 Windows + R，输入cmd，按下Enter，打开DOS窗口 输入命令netstat -ano，查看相应运行中的线程 输入命令taskkill /pid xxx -f 终止相应进程即可 ","date":"2022-05-29","objectID":"/win-cmd-note/:1:2","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"方法三 taskkill /F /im chrome.exe 或者用 taskkill -f -PID chrome.exe 参数说明： /F 强制终止 /IM 进程映像名 frontpg.exe 进程名 ","date":"2022-05-29","objectID":"/win-cmd-note/:1:3","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"Windows cmd命令行findstr 类似linux中的grep 使用截图 简介 findstr是Window系统自带的命令，用途是查找指定的一个或多个文件文件中包含（或通过参数 /V来控制不包含)某些特定字符串的行，并将该行完整的信息打印出来，或者打印查询字符串所在的文件名。 ","date":"2022-05-29","objectID":"/win-cmd-note/:2:0","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"通过命令行启动uwp应用 ","date":"2022-05-29","objectID":"/win-cmd-note/:3:0","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"1. 命令行格式 explorer.exe shell:AppsFolder{PackageFamilyName}\\!{PackageId} 以uwp版的windbg为例 ","date":"2022-05-29","objectID":"/win-cmd-note/:3:1","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"2. 获取PackageFamilyName 在powershell中运行命令 get-appxpackage | select PackageFamilyName,InstallLocation 输出结果 PackageFamilyName InstallLocation ----------------- --------------- Microsoft.NET.Native.Framework.1.3_8wekyb3d8bbwe C:\\Program Files\\WindowsApps\\Microsoft.NET.Native.Framework.1.3_1.3.24201.0_x64__8wekyb3... Microsoft.NET.Native.Framework.1.6_8wekyb3d8bbwe C:\\Program Files\\WindowsApps\\Microsoft.NET.Native.Framework.1.6_1.6.24903.0_x64__8wekyb3... Microsoft.WinDbg_8wekyb3d8bbwe C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2103.1004.0_neutral__8wekyb3d8bbwe 得到windbg的PackageFamilyName Microsoft.WinDbg_8wekyb3d8bbwe ","date":"2022-05-29","objectID":"/win-cmd-note/:3:2","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"3. 获取PackageId 打开appxmanifest.xml文件 notepad \"C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2103.1004.0_neutral__8wekyb3d8bbwe\\appxmanifest.xml\" 得到PackageId Microsoft.WinDbg ","date":"2022-05-29","objectID":"/win-cmd-note/:3:3","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"4. 通过命令行打开windbg explorer.exe shell:AppsFolder\\Microsoft.WinDbg_8wekyb3d8bbwe!Microsoft.WinDbg ","date":"2022-05-29","objectID":"/win-cmd-note/:3:4","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"CMD/BAT 命令行中的 sleep 方法 ","date":"2022-05-29","objectID":"/win-cmd-note/:4:0","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"timout命令 cmd\u003e timeout /? TIMEOUT [/T] timeout [/NOBREAK] 描述: 这个工具接受超时参数，等候一段指定的时间(秒)或等按任意键。它还接受 一个参数，忽视按键。 参数列表: /T timeout 指定等候的秒数。有效范围从 -1 到 99999 秒。 /NOBREAK 忽略按键并等待指定的时间。 /? 显示此帮助消息。 注意: 超时值 -1 表示无限期地等待按键。 示例: TIMEOUT /? TIMEOUT /T 10 TIMEOUT /T 300 /NOBREAK TIMEOUT /T -1 ","date":"2022-05-29","objectID":"/win-cmd-note/:4:1","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"CMD中延时10秒 cmd\u003e TIMEOUT /T 10 等待 10 秒，按一个键继续 ... 按任意键打断上面的代码 ","date":"2022-05-29","objectID":"/win-cmd-note/:4:2","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"CMD中延时10秒，且不被打断 cmd\u003e TIMEOUT /T 10 /NOBREAK 等待 10 秒，按 CTRL+C 退出 ... 只有 CTRL+C 可以打断上面的代码 ","date":"2022-05-29","objectID":"/win-cmd-note/:4:3","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"CMD中一直等待 cmd\u003e TIMEOUT /T -1 请按任意键继续 ... 相当于 pause ","date":"2022-05-29","objectID":"/win-cmd-note/:4:4","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"CMD中一直等待，且不被打断 cmd\u003e TIMEOUT /T -1 /NOBREAK 请按 CTRL+C 退出 ... ","date":"2022-05-29","objectID":"/win-cmd-note/:4:5","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Operation","note"],"content":"batch echo换行 @echo. ","date":"2022-05-29","objectID":"/win-cmd-note/:5:0","tags":["Windows","Command"],"title":"Windows Cmd指令笔记","uri":"/win-cmd-note/"},{"categories":["Back","note"],"content":"记录ElasticSearch使用Http方式访问数据的笔记","date":"2022-05-29","objectID":"/es-http-note/","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"ES删除索引中的所有数据（不删除索引结构）含Curl删除方式 ","date":"2022-05-29","objectID":"/es-http-note/:1:0","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"场景 想只删除索引下的数据，不删除索引结构，(Windows环境)服务器中没有Postman工具 ","date":"2022-05-29","objectID":"/es-http-note/:1:1","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"直接发请求方式删除 第一种：只删除索引中的所有数据，不删除索引结构 POST 192.168.100.88:9200/my_index/_delete_by_query 请求体： { \"query\": { \"match_all\": {} } } 注释： 其中 my_index是索引名称 第二种：删除索引中的指定的数据，不删除索引结构 请求头 DELETE 192.168.100.88:9200/log_index/log_type/D8D1D480190945C2A50B32D2255AA3D3 注释： 其中 log_index是索引名称，log_type是索引类型，D8D1D480190945C2A50B32D2255AA3D3是文档id 第三种：删除所有数据，删除索引结构 DELETE 192.168.100.88:9200/my_index 注释： 其中 my_index是索引名称 ","date":"2022-05-29","objectID":"/es-http-note/:1:2","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"Windows环境中Curl方式删除 第一种：删除所有数据，含索引结构 curl -X DELETE \"http://192.168.100.88:9200/my_index\" 第二种：删除所有数据，不删除索引结构 curl -XPOST \"http://192.168.100.88:9200/log_index/_delete_by_query?pretty=true\" -d \"{\"\"\"query\"\"\":{\"\"\"match_all\"\"\": {}}}\" 其中：curl使用时注意（windows环境必须是双引号），单引号会报错如下 'http\" not supported or disabled in libcurl C:\\Users\\admin\u003ecurl -X DELETE 'http://192.168.100.88:9200/my_index' curl: (1) Protocol \"'http\" not supported or disabled in libcurl ","date":"2022-05-29","objectID":"/es-http-note/:1:3","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"ES 使用_cat命令查看帮助命令信息 #使用_cat 查看帮助命令： get _cat =^.^= /_cat/allocation /_cat/shards /_cat/shards/{index} /_cat/master /_cat/nodes /_cat/tasks /_cat/indices /_cat/indices/{index} /_cat/segments /_cat/segments/{index} /_cat/count /_cat/count/{index} /_cat/recovery /_cat/recovery/{index} /_cat/health /_cat/pending_tasks /_cat/aliases /_cat/aliases/{alias} /_cat/thread_pool /_cat/thread_pool/{thread_pools} /_cat/plugins /_cat/fielddata /_cat/fielddata/{fields} /_cat/nodeattrs /_cat/repositories /_cat/snapshots/{repository} /_cat/templates ","date":"2022-05-29","objectID":"/es-http-note/:2:0","tags":["ElasticSearch","Http","Curl"],"title":"ElasticSearch使用Http方式访问数据","uri":"/es-http-note/"},{"categories":["Back","note"],"content":"记录Logstash 配置 Mysql 数据准实时同步到 ES 中的笔记","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"题记 一次同步多张表是开发中的一般需求。之前研究了很久找到方法，但没有详细总结。 博友前天在线提问，说明这块理解的还不够透彻。 我整理下， 一是为了尽快解决博友问题， 二是加深记忆，便于未来产品开发中快速上手。 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:1:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"同步原理 以下是通过ES5.4.0， logstash5.4.1 验证成功。 可以确认的是2.X版本同样可以验证成功。 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:2:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"下载插件 ./bin/logstash-plugin install logstash-input-jdbc ./bin/logstash-plugin install logstash-output-elasticsearch 12 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:3:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"修改配置 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:4:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"配置作业文件 创建一个Logstash作业配置文件，文件命名为logstash-mysql-es.conf ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:4:1","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"配置文件内容 这里 mysql 驱动文件需要自己手动下载，并复制到 logstash 目录下，默认路径为 /usr/share/logstash/logstash-core/lib/jars , 如果另外目录需要在配置中配置绝对路径 input { jdbc { jdbc_driver_library =\u003e \"mysql-connector-java-5.1.44-bin.jar\" jdbc_driver_class =\u003e \"com.mysql.jdbc.Driver\" jdbc_connection_string =\u003e \"jdbc:mysql://localhost.com:3306/db_name?useUnicode=true\u0026characterEncoding=UTF-8\u0026autoReconnect=true\u0026useSSL=false\u0026zeroDateTimeBehavior=convertToNull\u0026serverTimezone=Asia/Shanghai\" jdbc_user =\u003e \"db_user\" jdbc_password =\u003e \"db_password\"# 开启分页 jdbc_paging_enabled =\u003e \"true\"# 每页数量 jdbc_page_size =\u003e \"1000\" jdbc_default_timezone =\u003e \"Asia/Shanghai\"# 配置数据刷新频率， 如果所有都为 '*', 表示每分钟刷新一次， 这也是 Mysql 数据同步的最小频率。 schedule =\u003e \"* * * * *\"# 数据同步查询接口, 注意 sql 语句不需要带‘;’ 号结尾 statement =\u003e \"select * from test where updatetime \u003e :sql_last_value\"## 除了上面这种直接执行sql语句的， 还有指定sql文件， 当然只能二选一 statement_filepath =\u003e \"/home/test/test.sql\"# 启用追踪， 如果为 true, 则需要指定 tracking_column use_column_value =\u003e true# 指定递增字段 tracking_column =\u003e \"updatetime\"# 递增字段类型， 目前只有数字（ numeric） 和时间类型（ timestamp）， 默认是数字类型 tracking_column_type =\u003e \"timestamp\"# 记录最后一次运行的结果 record_last_run =\u003e true# 上面运行结果保存的位置 last_run_metadata_path =\u003e \"./logstash_jdbc_last_run\" } } output { elasticsearch { hosts =\u003e \"localhost:9200\" user =\u003e \"elastic\" password =\u003e \"es_password\" index =\u003e \"employee\" document_id =\u003e \"%{id}\" } stdout { codec =\u003e json_lines } } ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:4:2","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"配置同步多张数据表 input { stdin {} jdbc { type =\u003e \"cxx_article_info\"# mysql jdbc connection string to our backup databse 后面的test对应mysql中的test数据库 jdbc_connection_string =\u003e \"jdbc:mysql://110.10.15.37:3306/cxxwb\"# the user we wish to excute our statement as jdbc_user =\u003e \"root\" jdbc_password =\u003e \"xxxxx\" record_last_run =\u003e \"true\" use_column_value =\u003e \"true\" tracking_column =\u003e \"id\" last_run_metadata_path =\u003e \"/opt/logstash/bin/logstash_xxy/cxx_info\" clean_run =\u003e \"false\" # the path to our downloaded jdbc driver jdbc_driver_library =\u003e \"/opt/elasticsearch/lib/mysql-connector-java-5.1.38.jar\"# the name of the driver class for mysql jdbc_driver_class =\u003e \"com.mysql.jdbc.Driver\" jdbc_paging_enabled =\u003e \"true\" jdbc_page_size =\u003e \"500\" statement =\u003e \"select * from cxx_article_info where id \u003e :sql_last_value\"# 定时字段 各字段含义（ 由左至右） 分、 时、 天、 月、 年， 全部为 * 默认含义为每分钟都更新 schedule =\u003e \"* * * * *\"# 设定ES索引类型 } jdbc { type =\u003e \"cxx_user\"# mysql jdbc connection string to our backup databse 后面的test对应mysql中的test数据库 jdbc_connection_string =\u003e \"jdbc:mysql://110.10.15.37:3306/cxxwb\"# the user we wish to excute our statement as jdbc_user =\u003e \"root\" jdbc_password =\u003e \"xxxxxx\" record_last_run =\u003e \"true\" use_column_value =\u003e \"true\" tracking_column =\u003e \"id\" last_run_metadata_path =\u003e \"/opt/logstash/bin/logstash_xxy/cxx_user_info\" clean_run =\u003e \"false\" # the path to our downloaded jdbc driver jdbc_driver_library =\u003e \"/opt/elasticsearch/lib/mysql-connector-java-5.1.38.jar\"# the name of the driver class for mysql jdbc_driver_class =\u003e \"com.mysql.jdbc.Driver\" jdbc_paging_enabled =\u003e \"true\" jdbc_page_size =\u003e \"500\" statement =\u003e \"select * from cxx_user_info where id \u003e :sql_last_value\"# 以下对应着要执行的sql的绝对路径。# statement_filepath =\u003e \"/opt/logstash/bin/logstash_mysql2es/department.sql\"# 定时字段 各字段含义（ 由左至右） 分、 时、 天、 月、 年， 全部为 * 默认含义为每分钟都更新 schedule =\u003e \"* * * * *\"# 设定ES索引类型 } } filter { mutate { convert =\u003e [\"publish_time\", \"string\"] } date { timezone =\u003e \"Europe/Berlin\" match =\u003e [\"publish_time\", \"ISO8601\", \"yyyy-MM-dd HH:mm:ss\"] }# date {# match =\u003e [\"publish_time\", \"yyyy-MM-dd HH:mm:ss,SSS\"]# remove_field =\u003e [\"publish_time\"]# } json { source =\u003e \"message\" remove_field =\u003e [\"message\"] } } output { if [type] == \"cxxarticle_info\" { elasticsearch {# ESIP地址与端口 hosts =\u003e \"10.100.11.231:9200\"# ES索引名称（ 自己定义的） index =\u003e \"cxx_info_index\"# 自增ID编号# document_id =\u003e \"%{id}\" } } if [type] == \"cxx_user\" { elasticsearch {# ESIP地址与端口 hosts =\u003e \"10.100.11.231:9200\"# ES索引名称（ 自己定义的） index =\u003e \"cxx_user_index\"# 自增ID编号# document_id =\u003e \"%{id}\" } } } ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:4:3","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"启动 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:5:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"启动运行 /usr/share/logstash/bin/logstash --path.settings /etc/logstash -f /home/elk/logstash/conf/logstash-mysql-es.conf ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:5:1","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"后台启动 nohup /usr/share/logstash/bin/logstash --path.settings /etc/logstash -f /home/elk/logstash/conf/logstash-mysql-es.conf \u0026 3、同步成功结果 [2017-07-19T15:08:05,438][INFO ][logstash.pipeline ] Pipeline main started The stdin plugin is now waiting for input: [2017-07-19T15:08:05,491][INFO ][logstash.agent ] Successfully started Logstash API endpoint {:port=\u003e9600} [2017-07-19T15:09:00,721][INFO ][logstash.inputs.jdbc ] (0.007000s) SELECT count(*) AS `count` FROM (select * from cxx_article_info where id \u003e 0) AS `t1` LIMIT 1 [2017-07-19T15:09:00,721][INFO ][logstash.inputs.jdbc ] (0.008000s) SELECT count(*) AS `count` FROM (select * from cxx_user_info where id \u003e 0) AS `t1` LIMIT 1 [2017-07-19T15:09:00,730][INFO ][logstash.inputs.jdbc ] (0.004000s) SELECT * FROM (select * from cxx_user_info where id \u003e 0) AS `t1` LIMIT 500 OFFSET 0 [2017-07-19T15:09:00,731][INFO ][logstash.inputs.jdbc ] (0.007000s) SELECT * FROM (select * from cxx_article_info where id \u003e 0) AS `t1` LIMIT 500 OFFSET 0 [2017-07-19T15:10:00,173][INFO ][logstash.inputs.jdbc ] (0.002000s) SELECT count(*) AS `count` FROM (select * from cxx_article_info where id \u003e 3) AS `t1` LIMIT 1 [2017-07-19T15:10:00,174][INFO ][logstash.inputs.jdbc ] (0.003000s) SELECT count(*) AS `count` FROM (select * from cxx_user_info where id \u003e 2) AS `t1` LIMIT 1 [2017-07-19T15:11:00,225][INFO ][logstash.inputs.jdbc ] (0.001000s) SELECT count(*) AS `count` FROM (select * from cxx_article_info where id \u003e 3) AS `t1` LIMIT 1 [2017-07-19T15:11:00,225][INFO ][logstash.inputs.jdbc ] (0.002000s) SELECT count(*) AS `count` FROM (select * from cxx_user_info where id \u003e 2) AS `t1` LIMIT 1 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:5:2","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"扩展 1）多个表无非就是在input里面多加几个类型，在output中多加基础 类型判定。 举例： if [type]==\"cxx_user\" 1 2）input里的type和output if判定的type保持一致，该type对应ES中的type。 ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:6:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"Logstash 配置多个conf和配置增量更新 参考：https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html Logstash可以配置多个pipeline，每一个pipeline设置不同的参数，包括读取的conf； 也可以配置一个pipeline,读取多个conf，其读取多个conf，实际上是把它们合并一起，所以，conf里面需要写上type，通过type来判断写入那个索引。 logstash.yml的配置修改如下： logstash.yml的设置：# pipeline.id: mainpipeline.id:d_bzdz## path.config:path.config:\"/map/es/soft/logstash-7.6.2/config/myconfig/*.conf\" 运行的时候就不需要 -f conf参数。 运行 ./bin/logstash # Sample Logstash configuration for creating a simple # Beats -\u003e Logstash -\u003e Elasticsearch pipeline. input{ # stdin{} jdbc{ jdbc_connection_string =\u003e \"jdbc:oracle:thin:@//:1521/GIS\" jdbc_user =\u003e \"\" jdbc_password =\u003e \"\" jdbc_driver_library =\u003e \"/es/soft/logstash-7.6.2/lib/ojdbc7.jar\" jdbc_driver_class =\u003e \"Java::oracle.jdbc.driver.OracleDriver\" # jdbc_default_timezone =\u003e \"Asia/Shanghai\" # 统一用一个时间标准即可，不需要设置。oracle本来的时区也是+00。 # plugin_timezone =\u003e \"local\" # 228万条记录 12分钟完成同步 jdbc_paging_enabled =\u003e \"true\" # 每批传输数量 jdbc_page_size =\u003e \"100000\" # sql_last_value 是最后查询的值（时间或者id）,未执行查询之前，它的值是1970.1.1，应该是时间戳的值； # 如果设置 use_column_value =\u003e \"true\" #和tracking_column ，sql_last_value 的默认值是0，之后是这个字段的最新值。 # 如果use_column_value =\u003e \"false\", #后续每次查询，都会记录执行查询的logstash时间 作为sql_last_value statement =\u003e \"select t.systemid .... and t.lastupdatedtime \u003e :sql_last_value order by t.lastupdatedtime asc\" # 设置为true时，sql_last_value的值是tracking_column的值； #设置为false是，sql_last_value的值是上次执行的值。 use_column_value =\u003e \"true\" # 是否保存状态 record_last_run =\u003e \"true\" # 记录最后一条数据的时间戳，所以，sql语句里面需要 有 #order by t.lastupdatedtime asc tracking_column =\u003e \"lastupdatedtime\" # 只有两种类型numberic 和timestamp tracking_column_type =\u003e \"timestamp\" # 记录 sql_last_value的文件 last_run_metadata_path =\u003e \"/es/soft/logstash-7.6.2/config/myconfig/mlp_parameter.txt\" #设置监听间隔，各字段（分、时、天、月、年），全部*代表每分钟都更新 # \"0 * * * *\" 在每小时每天的第0分钟运行 # 设置每天12点0分运行 corn表达式 schedule =\u003e \"47 12 * * *\" # 这个类型可以判断输入到哪个索引，因为我设置了一个pipeline读取多个conf， #它实际是把多个conf合并成一个。 type =\u003e \"mlp_jdbc\" } } filter { if[type] == \"mlp_jdbc\" { mutate { add_field =\u003e [\"[location][lat]\",\"%{zxwd}\"] add_field =\u003e [\"[location][lon]\",\"%{zxjd}\"] } ruby { code =\u003e \"event.set('timestamp',event.get('@timestamp').time.localtime )\" } ruby { code =\u003e \"event.set('@timestamp',event.get('timestamp'))\" } mutate { remove_field =\u003e [\"timestamp\"] } } } output{ if[type] == \"mlp_jdbc\" { elasticsearch{ hosts =\u003e \"localhost:9200\" index =\u003e \"d_bzdz_mlp\" document_id =\u003e \"%{systemid}\" } stdout{ codec =\u003e \"json_lines\" # codec =\u003e \"rubydebug\" } } } ","date":"2022-05-29","objectID":"/es-mysql-sync-logstash-note/:7:0","tags":["ElasticSearch","Mysql ","Sync","Logstash"],"title":"Logstash 配置 Mysql 数据准实时同步到 ES 中","uri":"/es-mysql-sync-logstash-note/"},{"categories":["Back","note"],"content":"记录Mysql数据同步ES的笔记","date":"2022-05-29","objectID":"/es-mysql-sync-note/","tags":["ElasticSearch","Mysql","Sync"],"title":"Mysql数据同步ES","uri":"/es-mysql-sync-note/"},{"categories":["Back","note"],"content":"一、前言 随着业务发展，数据量的增长，对数据全文检索或模糊查询显得普遍而重要。 这个时候Mysql就无法应对海量数据下各种复杂条件的查询。有人说加索引，加索引确实可以提升查询速度，但是索引也是成本，Mysql中加多个索引最终在执行 SQL 的时候它只会选择成本最低的那个索引，如果没有索引满足搜索条件，就会触发全表扫描，出现慢sql等性能低下，而有些场景是加索引也解决不了的。 这样的话，我们可以借助搜索引擎，将数据发送到搜索引擎（如ES）上，由搜索引擎来提供专业的服务。而ES是搜索引擎中佼佼者，选用ES无疑是Mysql的一个有效补充。 ","date":"2022-05-29","objectID":"/es-mysql-sync-note/:1:0","tags":["ElasticSearch","Mysql","Sync"],"title":"Mysql数据同步ES","uri":"/es-mysql-sync-note/"},{"categories":["Back","note"],"content":"二、ES数据同步方案 ","date":"2022-05-29","objectID":"/es-mysql-sync-note/:2:0","tags":["ElasticSearch","Mysql","Sync"],"title":"Mysql数据同步ES","uri":"/es-mysql-sync-note/"},{"categories":["Back","note"],"content":"1、方案一:应用程序双写 1）（同步双写，代码侵入性比较高） 这是一种最为简单的方式，在将数据写到Mysql时，同时将数据写到ES，实现数据的双写。 优点： 1）业务逻辑简单。 缺点： 1）硬编码：有需要写入Mysql的地方都需要添加写入ES的代码；业务强耦合； 2）存在双写失败丢数据风险；ES系统不可用；应用系统和ES之间的网络故障；应用系统重启，导致系统来不及写入ES等； 3）性能较差：本来Mysql的性能就不是很高，再加写一个ES，有数据强一致性要求的，就必须双写放到事物中来处理，系统的性能必然会下降。 2）（异步双写，MQ方式） 针对第一种同步双写的性能和数据丢失问题，可以考虑引入MQ中间件： 优点： 1）性能高，MQ的性能基本比Mysql高出一个数量级；解决数据一致性问题； 2）把同步变为异步，做了部分解耦 缺点： 1）会增加延迟性，由于MQ的消费可能由于网络或其它原因导致用户写入的数据不一定可以马上看到，造成延时； 2）硬编码问题：依然存在业务强耦合，业务系统增加MQ代码； 3）复杂度增加：多一个MQ中间件要维护 3）（异步双写，定时任务方式） 上面两种方案中都存在硬编码问题，也就是有任何对Mysql进行增删改查的地方要么植入ES代码，要么替换为MQ代码，代码的侵入性太强。 如果对实时性要求不高的情况下，可以考虑用定时器来处理，在 Mysql的表结构里设置特殊的字段，增加一个字段为timestamp的字段，如 updated_at（数据的更新时间），任何CRUD操作都会导致该字段的时间发生变化。起一个定时任务，在用户低峰的时候，执行定时任务，去查询实际变更的数据，从而实现数据的增量更新到MQ中。这种方式可以使用开源的 Logstash 去完成。当然缺点也很明显，就是无法同步数据的物理删除操作。 优点： 不改变原来代码，没有侵入性、没有硬编码； 没有业务强耦合；不改变原来程序的性能； 定时代码编写简单不需要考虑增删改查。 缺点： 时效性较差，由于定时器工作周期不可能设在秒级，所以实时性没有上面几种好； 对数据库有一定的轮询压力，一种改进方法是将轮询放到压力不大的重库上。 ","date":"2022-05-29","objectID":"/es-mysql-sync-note/:2:1","tags":["ElasticSearch","Mysql","Sync"],"title":"Mysql数据同步ES","uri":"/es-mysql-sync-note/"},{"categories":["Back","note"],"content":"2、方案二：基于Binlog 同步（业界比较成熟的方案） 上面三种方案要么有代码侵入，要么有硬编码，要么有时延，所以通常我们利用mysql的binlog方式来进行同步。 1) 限制条件： （1）Mysql Binlog必须是ROW模式； Mysql 的 Binlog三种格式： •ROW 模式，Binlog按行的方式去记录数据的变更； •statement 模式，Binlog记录的是 SQL 语句； •mixed 模式时，混合以上两种，记录的可能是 SQL 语句或者 ROW 模式的每行变更； show variables like 'log_bin'; 查看Binlog开启状态。 show variables like 'binlog-format'; 查看Binlog格式。 （2）要同步的mysql数据表必须包含主键，否则直接忽略，这是因为如果数据表没有主键，UPDATE和DELETE操作就会因为在ES中找不到对应的document而无法进行同步 （3）不支持程序运行过程中修改表结构 （4）要赋予用于连接Mysql的账户RELOAD权限以及REPLICATION权限, SUPER权限： GRANT REPLICATION SLAVE ON . TO ‘elastic’@‘172.16.32.44’; GRANT RELOAD ON . TO ‘elastic’@‘172.16.32.44’; UPDATE mysql.user SET Super_Priv=‘Y’ WHERE user=‘elastic’ AND host=‘172.16.32.44’; 2) 具体步骤如下： 1） 读取Mysql的Binlog日志，获取指定表的日志信息； 2） 将读取的信息转为MQ； 3） 编写一个MQ消费程序； 4） 不断消费MQ，每消费完一条消息，将消息写入到ES中。 3）优缺点 优点： 没有代码侵入、没有硬编码；原有系统不需要任何变化，没有感知； 性能高； 业务解耦，不需要关注原来系统的业务逻辑。 缺点： 构建Binlog系统复杂； 存在MQ延时的风险 Binlog其他详细解释参考博文：https://blog.csdn.net/weixin_47061482/article/details/115163442 ","date":"2022-05-29","objectID":"/es-mysql-sync-note/:2:2","tags":["ElasticSearch","Mysql","Sync"],"title":"Mysql数据同步ES","uri":"/es-mysql-sync-note/"},{"categories":["Operation","note"],"content":"记录使用Winsw将Jar或Bat文件注册到Windows服务的笔记","date":"2022-05-29","objectID":"/win-winsv-winsw-note/","tags":["Windows","WindowsService","WinSW"],"title":"使用WinSW将Jar或Bat文件注册到Windows服务","uri":"/win-winsv-winsw-note/"},{"categories":["Operation","note"],"content":"步骤 **1.**下载 winsw.exe文件，地址：https://github.com/winsw/winsw Windiws 上的 .NET framework 版本 要 是4.6或以上。 2. 注册 jar 将下载下来的 winsw.exe 修改成 jar文件同名。并在同目录创建一个 同名的xml text.xml文件配置: \u003cservice\u003e \u003cid\u003etest\u003c/id\u003e \u003c!-- 服务id,必须唯一 --\u003e \u003cname\u003etest\u003c/name\u003e \u003c!-- 服务名称 --\u003e \u003cdescription\u003e测试\u003c/description\u003e \u003c!-- 服务描述 --\u003e \u003cexecutable\u003ejava\u003c/executable\u003e \u003carguments\u003e-jar D:\\test.jar\u003c/arguments\u003e \u003c!-- 指定jar包的路径 ，启动命令 --\u003e \u003clogpath\u003e.\\log\u003c/logpath\u003e \u003c!-- 日志路径 --\u003e \u003cstartmode\u003eAutomatic\u003c/startmode\u003e \u003c!-- 设置服务自动启动 --\u003e \u003clogmode\u003ereset\u003c/logmode\u003e \u003c/service\u003e 3. 在 test.exe 目录下 启动 cmd 执行: test.exe install 执行成功，会生成一个log 文件夹，到windows 服务中查看，test 服务已经创建成功。 4.注册bat文件 xml文件配置，启动方式同上 \u003cservice\u003e \u003cid\u003eminio\u003c/id\u003e \u003cname\u003eminio\u003c/name\u003e \u003cdescription\u003eminio服务端\u003c/description\u003e \u003cexecutable\u003ed:\\minio\\start.bat\u003c/executable\u003e \u003c!-- 指定bat文件的路径 --\u003e \u003clogpath\u003e.\\log\u003c/logpath\u003e \u003cstartmode\u003eAutomatic\u003c/startmode\u003e \u003clogmode\u003ereset\u003c/logmode\u003e \u003c/service\u003e ","date":"2022-05-29","objectID":"/win-winsv-winsw-note/:1:0","tags":["Windows","WindowsService","WinSW"],"title":"使用WinSW将Jar或Bat文件注册到Windows服务","uri":"/win-winsv-winsw-note/"},{"categories":["Operation","note"],"content":"运维指令 删除服务命令 sc delete 服务名称 启动服务命令 net start 服务名称 停止服务命令 net stop 服务名称 ","date":"2022-05-29","objectID":"/win-winsv-winsw-note/:2:0","tags":["Windows","WindowsService","WinSW"],"title":"使用WinSW将Jar或Bat文件注册到Windows服务","uri":"/win-winsv-winsw-note/"},{"categories":["Operation","note"],"content":"记录Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包的笔记","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"后台运⾏的原因 在 Windows 上，在 Cmd 命令窗⼝，使⽤ java -jar 的⽅式启动，Cmd 窗⼝会⼀直存在，若关闭，程序也就停⽌运⾏了，所以需要后台运⾏ ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:1:0","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"说明 Windows 通过 Bat 脚本后台启动 Jar 包，通过 Jps 找到 PId，然后停⽌指定 Jar 包，附 linux shell 脚本启停脚本 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:1:1","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"参考 Springboot 程序，lib 下是依赖 Jar ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:1:2","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"Windows 端启停脚本 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:2:0","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"启动脚本 Bat 启动⽆法输出⽇志到⽂件，但是拷贝命令到 Cmd 就可以输出到⽂件，不懂为什么。若启动多个 Jar 包，须保证 Jar 包名称不同。 @echo off echo find analog-access-1.0.jar to kill before start process. call stop.bat echo \"------ begin start analog-access-1.0.jar, see: ./logs/analog-access.log.------\" start javaw -Xms1024m -Xmx2048m -Dsun.lang.ClassLoader.allowArraySyntax=true -Duser.timezone=GMT+08 -cp analog-access-1.0.jar;lib/*; indi.tudan. analogaccess.AnalogAccessApplication 1\u003e\u003e.\\logs\\analog-access.log 2\u003e\u00261 \u0026 exit ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:2:1","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"停⽌脚本 解析：通过 Jps -l 命令，找到程序对应的进程 Id，即 PId，然后终⽌ PId 即可。其中，indi.tudan.analogaccess.AnalogAccessApplication 为程序⼊⼝类包路径。 @echo off set program=indi.tudan.analogaccess.AnalogAccessApplication echo program: %program% for/f \"usebackq tokens=1-2\" %% a in (`jps -l ^| findstr %program%`)do( set PId = %% a set image_name = %% b ) if not defined PId (echo process %program% does not exists) else ( echo prepare to kill %image_name% echo start kill %PId%... rem 根据进程Id，kill进程 taskkill /f /pid %PId% ) ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:2:2","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"Linux 端启停脚本 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:3:0","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"启动脚本 echo \"find analog-access-1.0.jar to kill before start process.\" sh stop.sh echo \"------ begin start analog-access-1.0.jar, see: ./logs/analog-access.log. ------\" lib_names = `ls -l ./lib |awk'{if($NF~/jar/) print $NF}'` import_libs = \"\" for lib_name in $lib_names do import_libs = $import_libs\":./lib/\"$lib_name done nohup java -Xms1024m -Xmx2048m -Dsun.lang.ClassLoader.allowArraySyntax=true -Duser.timezone = GMT+08 -cp \"./analog-access-1.0.jar$import_libs\" i ndi.tudan.analogaccess.AnalogAccessApplication \u003e ./logs/analog-access.log 2\u003e\u00261 \u0026 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:3:1","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"停⽌脚本 #!/bin/sh PROCESS = `ps auxww |grep'analog-access-1.0.Jar'|grep'indi.tudan.analogaccess.AnalogAccessApplication'|grep -v grep` if[\"$PROCESS\"=\"\"];then echo \"process analog-access-1.0.jar not exists\" else SId = `echo $PROCESS |awk'{print $2 }'` echo \"prepare to kill \"$PROCESS echo \"begin kill \"$SId\" ...\" kill -9 $SId echo \"kill successfully\" fi; ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:3:2","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"jvm.dll、java.exe、javaw.exe ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:4:0","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"jvm.dll jvm.dll 是⼀个 Java 虚拟机在 Windows 平台环境上的实现，也是 JRE 的⼀部分，⼀个 C 程序能够使⽤ jvm.dll 直接运⾏在 Jvm上。 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:4:1","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"java.exe java.exe 是 win32 控制台应⽤，它提供了⼀种帮助，代替使⽤ Jvm.dll 执⾏ java classes ⽂件，作为⼀个 Win32 控制台应⽤，显然他是和⼀个控制台相关联，当执⾏ java classes 的时候，它运⾏。 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:4:2","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"javaw.exe javaw.exe 是相似的和 java.exe 是⼀个 Win32 的 GUI 应⽤，应⽤提供⾃⼰的 GUI 窗⼝，不启⽤控制台。 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:4:3","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"区别 java 运⾏ Jar 以后，会阻塞在那⾥直到窗⼝关闭。 javaw 运⾏ Jar 后，不会阻塞，直接就可以进⾏下⼀条命令的运⾏了。 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:4:4","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Operation","note"],"content":"Jps Jps 的英⽂名称是 JVM Process Status Tool, 功能和 ps 命令类似。可以列出正在运⾏的虚拟机进程、显⽰虚拟机执⾏主类（main () 函数所在的类）的名称、这些进程的本地虚拟机的唯⼀ Id（LVMId, Local Virtual Machine Identifier,LVMId 和 PId 是⼀致的）。 选项 作⽤ -q 只输出 LVMId (PId) -m 输出虚拟机进程启动时传递给主类 main () 函数的参数 -l 输出主类的全名，如果进程执⾏时是 Jar 包，输出 Jar 路径 -v 输出虚拟机进程启动时 JVM 参数 ","date":"2022-05-29","objectID":"/win-jps-kill-progress-note/:5:0","tags":["Java","Windows","Linux","Jps","Kill"],"title":"Windows通过Bat脚本后台启动Jar包，通过Jps找到PId，然后停⽌指定Jar包","uri":"/win-jps-kill-progress-note/"},{"categories":["Back","note"],"content":"记录Mysql怎么去掉重复的数据的笔记","date":"2022-05-28","objectID":"/mysql-filte-duplicate-date-note/","tags":["Mysql","DataBase","MysqlNote"],"title":"Mysql怎么去掉重复的数据","uri":"/mysql-filte-duplicate-date-note/"},{"categories":["Back","note"],"content":"方法 在mysql中，可以利用“SELECT”语句和“DISTINCT”关键字来进行去重查询，过滤掉重复的数据，语法“SELECT DISTINCT 字段名 FROM 数据表名;”。 本教程操作环境：windows7系统、mysql8版本、Dell G3电脑。 在 MySQL 中使用 SELECT 语句执行简单的数据查询时，返回的是所有匹配的记录。如果表中的某些字段没有唯一性约束，那么这些字段就可能存在重复值。为了实现查询不重复的数据，MySQL 提供了 DISTINCT 关键字。 DISTINCT 关键字的主要作用就是对数据表中一个或多个字段重复的数据进行过滤，只返回其中的一条数据给用户。 DISTINCT 关键字的语法格式为： SELECTDISTINCT\u003c字段名\u003eFROM\u003c表名\u003e; 其中，“字段名”为需要消除重复记录的字段名称，多个字段时用逗号隔开。 使用 DISTINCT 关键字时需要注意以下几点： DISTINCT 关键字只能在 SELECT 语句中使用。 在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。 如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。 ","date":"2022-05-28","objectID":"/mysql-filte-duplicate-date-note/:1:0","tags":["Mysql","DataBase","MysqlNote"],"title":"Mysql怎么去掉重复的数据","uri":"/mysql-filte-duplicate-date-note/"},{"categories":["Back","note"],"content":"示例 下面通过一个具体的实例来说明如何实现查询不重复数据。 test 数据库中 student 表的表结构和数据如下所示： mysql\u003eSELECT*FROMtest.student;+----+----------+------+-------+ |id|name|age|stuno|+----+----------+------+-------+ |1|zhangsan|18|23||2|lisi|19|24||3|wangwu|18|25||4|zhaoliu|18|26||5|zhangsan|18|27||6|wangwu|20|28|+----+----------+------+-------+ 6rowsinset(0.00sec) 结果显示，student 表中存在 6 条记录。 下面对 student 表的 age 字段进行去重，SQL 语句和运行结果如下： mysql\u003eSELECTDISTINCTageFROMstudent;+------+ |age|+------+ |18||19||20|+------+ 3rowsinset(0.00sec) 对 student 表的 name 和 age 字段进行去重，SQL 语句和运行结果如下： mysql\u003eSELECTDISTINCTname,ageFROMstudent;+----------+------+ |name|age|+----------+------+ |zhangsan|18||lisi|19||wangwu|18||zhaoliu|18||wangwu|20|+----------+------+ 5rowsinset(0.00sec) 对 student 表中的所有字段进行去重，SQL 语句和运行结果如下： mysql\u003eSELECTDISTINCT*FROMstudent;+----+----------+------+-------+ |id|name|age|stuno|+----+----------+------+-------+ |1|zhangsan|18|23||2|lisi|19|24||3|wangwu|18|25||4|zhaoliu|18|26||5|zhangsan|18|27||6|wangwu|20|28|+----+----------+------+-------+ 6rowsinset(0.00sec) 因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。 查询 student 表中对 name 和 age 字段去重之后记录的条数，SQL 语句和运行结果如下： mysql\u003eSELECTCOUNT(DISTINCTname,age)FROMstudent;+--------------------------+ |COUNT(DISTINCTname,age)|+--------------------------+ |5|+--------------------------+ 1rowinset(0.01sec) 结果显示，student 表中对 name 和 age 字段去重之后有 5 条记录。 ","date":"2022-05-28","objectID":"/mysql-filte-duplicate-date-note/:2:0","tags":["Mysql","DataBase","MysqlNote"],"title":"Mysql怎么去掉重复的数据","uri":"/mysql-filte-duplicate-date-note/"},{"categories":["Back"],"content":"记录Java反射笔记","date":"2022-02-07","objectID":"/java-reflect-note/","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"Java通过反射获给Java对象赋值为null /** * *java通过反射获给java对象赋值为null * @param obj 对象 * @param propertyName 字段 * @return java.lang.Object */ public static Object setPropertyNull(Object obj, String propertyName) { //利用反射获取类属性 Field[] field = obj.getClass().getDeclaredFields(); for (int i = 0; i \u003c field.length; i++) { Field f = field[i]; f.setAccessible(true); //获取属性名 String name = field[i].getName(); name = name.substring(0, 1).toUpperCase() + name.substring(1); Method method = null; //获取属性类型 String type = field[i].getGenericType().toString(); try { // if (type.equals(\"class java.lang.String\") \u0026\u0026 propertyName.equalsIgnoreCase(name)) { method = obj.getClass().getMethod(\"set\" + name, String.class); method.invoke(obj, (Object)null); } if (type.equals(\"class java.lang.Integer\") \u0026\u0026 propertyName.equalsIgnoreCase(name)) { method = obj.getClass().getMethod(\"set\" + name, Integer.class); method.invoke(obj, (Object)null); } if (type.equals(\"int\") \u0026\u0026 propertyName.equalsIgnoreCase(name)) { method = obj.getClass().getMethod(\"set\" + name, int.class); method.invoke(obj, (Object)null); } if (type.equals(\"class java.lang.Long\") \u0026\u0026 propertyName.equalsIgnoreCase(name)) { method = obj.getClass().getMethod(\"set\" + name, Long.class); method.invoke(obj, (Object)null); } if (type.equals(\"class java.math.BigDecimal\") \u0026\u0026 propertyName.equalsIgnoreCase(name)) { method = obj.getClass().getMethod(\"set\" + name, BigDecimal.class); method.invoke(obj, (Object)null); } } catch (Exception e) { e.printStackTrace(); } } return obj; }``` ","date":"2022-02-07","objectID":"/java-reflect-note/:1:0","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"使用PropertyDescriptor反射调用setter/getter方法 有时候我们只知道一个对象的字段，我们想通过反射的方式将此字段赋值，可直接写反射又太浪费时间，还需要自己手动拼接方法名，而java为我们提供了一个很方便的类(PropertyDescriptor)来操作这一过程。使用很简单，直接看代码： ","date":"2022-02-07","objectID":"/java-reflect-note/:2:0","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"代码 import com.pibgstar.demo.bean.User; import java.beans.IntrospectionException; import java.beans.PropertyDescriptor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @author pibigstar * @create 2018-12-03 18:36 * @desc **/ public class TestPropertyDescriptor { public static void main(String[] args){ TestPropertyDescriptor test = new TestPropertyDescriptor(); User user = new User(); user.setId(\"123\"); Object id = test.getAttribute(\"id\", user); System.out.println(\"id:\"+id.toString()); test.setAttribute(\"name\",user,\"pibigstar\"); System.out.println(user); } /** * @Author:pibigstar * @Description: 根据字段获取属性值 */ private Object getAttribute(String filed,Object obj) { try { PropertyDescriptor pd = new PropertyDescriptor(filed,obj.getClass()); // 获取getter方法 Method method = pd.getReadMethod(); Object result = method.invoke(obj); return result; } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } return null; } /** * @Author:pibigstar * @Description: 设置属性字段值 */ private void setAttribute(String filed,Object obj,Object value) { try { PropertyDescriptor pd = new PropertyDescriptor(filed,obj.getClass()); // 获取setter方法 Method method = pd.getWriteMethod(); method.invoke(obj, value); } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } } ","date":"2022-02-07","objectID":"/java-reflect-note/:2:1","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"运行结果 id:123 User{id='123', name='pibigstar'} ","date":"2022-02-07","objectID":"/java-reflect-note/:2:2","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"反射中Method类的invoke() 和getMethod() 就是调用类中的方法，最简单的用法是可以把方法参数化。 invoke(class, method)； Method Class.getMethod(String name, Class\u003c?\u003e... parameterTypes)的作用是获得对象所声明的公开方法 该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。 person.getClass().getMethod(\"Speak\", null); //获得person对象的Speak方法，因为Speak方法没有形参，所以parameterTypes为null person.getClass().getMethod(\"run\", String.class); //获得person对象的run方法，因为run方法的形参是String类型的，所以parameterTypes为String.class 如果对象内的方法的形参是int类型的，则parameterTypes是int.class //getMethod第一个参数是方法名，第二个参数是该方法的参数类型， //因为存在同方法名不同参数这种情况，所以只有同时指定方法名和参数类型才能唯一确定一个方法 Method method = XXX.getClass().getMethod(methodName,new Class[0]); //第一个参数是具体调用该方法的对象 //第二个参数是执行该方法的具体参数 如一个函数 int Test(int a, String str); 对应的getMethod方法： getMethod(“Test”,int.class,String.class); getMethod(“Test”,new Class[]{int.class,String.class}); //Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象，返回值总是对象。 //如果参数为基本类型数据，必须转换为相应的包装类型的对象。 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException InvokeObj.java: public class InvokeObj { public void show() { System.out.println(\"无参show()方法\"); } public void show(String name) { System.out.println(\"show方法：\" + name); } public String[] arrayShow(String[] arr) { return arr; } public String stringShow(String str) { return str; } public int intShow(int sum) { return sum; } } MethodInvokeTest.java: import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class MethodInvokeTest { public static void main(String[] args) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException { Class\u003cInvokeObj\u003e clazz = InvokeObj.class; Method[] methods = clazz.getMethods(); //输出了Class类型的所有方法。 System.out.println(\"以下输出InvokeObj类的方法\"); for (Method method : methods) { System.out.println(method); } System.out.println(); System.out.println(\"InvokeObj类的无参show()方法：\"); Method method1 = clazz.getMethod(\"show\", null); //会执行无参show()方法 Object obj = method1.invoke(new InvokeObj(), null); System.out.print(\"输出无参show()方法的返回值：\" + obj); System.out.println(); System.out.println(); System.out.println(\"InvokeObj类的show()方法： \"); Method method2 = clazz.getMethod(\"show\", String.class); Object obj1 = method2.invoke(new InvokeObj(), \"hello,world\"); // System.out.println(\"输出有参show()方法： \"); System.out.println(); System.out.println(\"InvokeObj类的arrayShow()方法： \"); Method method3 = clazz.getMethod(\"arrayShow\", String[].class); String[] strs = new String[]{\"hello\", \"world\", \"!\"}; //数组类型的参数必须包含在new Object[]{}中，否则会报IllegalArgumentException String[] strings = (String[]) method3.invoke(new InvokeObj(), new Object[]{strs}); for (String str : strings) { System.out.println(\"arrayShow的数组元素：\" + str); } System.out.println(); System.out.println(\"InvokeObj类的StringShow()方法： \"); Method method4 = clazz.getMethod(\"stringShow\", String.class); String string = (String) method4.invoke(new InvokeObj(), \"Thinking in java\"); System.out.println(\"stringShow()方法的返回值： \" + string); System.out.println(); System.out.println(\"InvokeObj类的intShow()方法： \"); Method method5 = clazz.getMethod(\"intShow\", int.class); int num = (Integer) method5.invoke(new InvokeObj(), 89); System.out.println(\"intShow()方法的返回值： \" + num); } } ","date":"2022-02-07","objectID":"/java-reflect-note/:3:0","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"Java反射通过class获取父类泛型类型 在Java的反射技术中，通过Method和Field对象很容易就可以取出泛型类型的具体类型。但是普通类的泛型参数在编译期会被擦除，比如定义了一个List对象，在运行期我们可以拿到的信息就只剩下List，并不知道List中的元素类型是什么。这也说明了，为什么fun(List list)和 fun(List)会被编译器认为是相同的函数。 但是，对于获取父类的泛型类型，还是会有办法的。在Class类中，有这样一个方法： /** * Returns the {@code Type} representing the direct superclass of * the entity (class, interface, primitive type or void) represented by * this {@code Class}. * * \u003cp\u003eIf the superclass is a parameterized type, the {@code Type} * object returned must accurately reflect the actual type * parameters used in the source code. The parameterized type * representing the superclass is created if it had not been * created before. See the declaration of {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the * semantics of the creation process for parameterized types. If * this {@code Class} represents either the {@code Object} * class, an interface, a primitive type, or void, then null is * returned. If this object represents an array class then the * {@code Class} object representing the {@code Object} class is * returned. * * @throws java.lang.reflect.GenericSignatureFormatError if the generic * class signature does not conform to the format specified in * \u003ccite\u003eThe Java™ Virtual Machine Specification\u003c/cite\u003e * @throws TypeNotPresentException if the generic superclass * refers to a non-existent type declaration * @throws java.lang.reflect.MalformedParameterizedTypeException if the * generic superclass refers to a parameterized type that cannot be * instantiated for any reason * @return the superclass of the class represented by this object * @since 1.5 */ public Type getGenericSuperclass() { if (getGenericSignature() != null) { // Historical irregularity: // Generic signature marks interfaces with superclass = Object // but this API returns null for interfaces if (isInterface()) return null; return getGenericInfo().getSuperclass(); } else return getSuperclass(); } 此方法返回的是具有泛型信息的父类，如果没有则返回Object对象。具体什么样的类都返回什么样的结果，来看测试代码 public void printGenericType(){ Class clazz1 = new ArrayList\u003cInteger\u003e().getClass(); Class clazz2 = new String[0].getClass(); Class clazz3 = String.class; Class clazz4 = Object.class; Class clazz5 = new IntList().getClass(); System.out.println(clazz1.getGenericSuperclass()); System.out.println(clazz2.getGenericSuperclass()); System.out.println(clazz3.getGenericSuperclass()); System.out.println(clazz4.getGenericSuperclass()); System.out.println(clazz5.getGenericSuperclass()); } 结果： java.util.AbstractList\u003cE\u003e class java.lang.Object class java.lang.Object null java.util.ArrayList\u003cjava.lang.Integer\u003e 上面的测试代码中分别打印出了ArrayList，数组，普通类，Object类和自定义的一个类通过getGenericSuperclass()方法获取到的结果。普通类以及数组的父类都是Object，所以打印出的结果是Object。Object没有父类，打印出的是null。普通的ArrayList打印出的结果是java.util.AbstractList，第五个class打印出了带有泛型信息的java.util.ArrayList\u003cjava.lang.Integer\u003e。IntList的定义是这样的 public class IntList extends ArrayList\u003cInteger\u003e { } ArrayList的定义是这样的 public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable ​ 两处的不同在于继承父类的时候有没有知道父类泛型的具体类型，如果指定了，则可以通过上面的方法得到这个具体的类型。否则不能得到，这两者一定还存在 其他的区别联系，下面打印出获得的具体类型是什么 public void getGenericType(){ Class clazz1 = new ArrayList\u003cInteger\u003e().getClass(); Type type = clazz1.getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) type; System.out.println(parameterizedType); System.out.println(parameterizedType.getActualTypeArguments()[0].getClass()); Class clazz2 = new IntList().getClass(); Type type2 = clazz2.getGenericSuperclass(); ParameterizedType parameterizedType2 = (ParameterizedType) type2; System.out.println(parameterizedType2); System.out.println(parameterizedType2.getActualTypeArguments()[0].getClass()); } 结果 java.util.AbstractList\u003cE\u003e class sun.reflect.generics.reflectiveObjects.TypeVariableImpl java.util.ArrayList\u003cjava.lang.Integer\u003e class java.lang.Class ​ 原来如此，如果在继承父类的时候没有指定父类的泛型类型，则这时候获取到的类型是TypeVariableImpl；而指定了父类的泛型类型则这时候就能获取到对应的Class ","date":"2022-02-07","objectID":"/java-reflect-note/:4:0","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Back"],"content":"反射应用–通用的toString方法，泛型数组代码 反射应用 - toString方法/泛型数组代码  我们常用的toString方法都是显式地调用其域，当需要时，要在类中重写toString方法（基本上一个类一个），而通用toString方法什么都不需要知道，直接调用即可。  泛型数组代码不需要记，是java.util.Arrays类中copyOf(T[] original, int newLength) 方法实现底层中使用了反射机制，这里介绍了一下而已。 import java.lang.reflect.AccessibleObject; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; public class ObjectAnalyzer{ private ArrayList\u003cObject\u003e vistied =new ArrayList\u003c\u003e(); public String toString(Object obj) { if (obj == null) return \"null\"; //对象为null，返回“null” if (vistied.contains(obj)) return \"...\"; // vistied.add(obj); Class\u003c? extends Object\u003e c1 = obj.getClass(); if(c1 == String.class) return (String) obj; //对象类型为字符串，直接打印 //对象类型为数组 if(c1.isArray()) { String r = c1.getComponentType() + \"[]{\"; //getComponentType返回数组类型 for(int i=0;i\u003cArray.getLength(obj);i++) { //getLength返回数组长度 if(i\u003e0) r +=\",\"; //逗号分隔元素 Object val =Array.get(obj, i); //返回数组中指定索引的值 if(c1.getComponentType().isPrimitive()) //若数组中类型为基本类型，直接添加于字符串r中 r += val; else r += toString(val); //递归,执行本方法中‘对象类型非数组’部分 } return r+\"}\"; } //对象类型为非数组 String r = c1.getName(); //获取对象所属的类 do { r += \"[\"; Field[] fields = c1.getDeclaredFields(); //获取本类所有域 AccessibleObject.setAccessible(fields, true); //开放域的访问限制 for(Field f: fields) { if(!Modifier.isStatic(f.getModifiers())) { //非静态域 if(!r.endsWith(\"[\")) r += \",\"; r += f.getName() + \"=\"; try { //处理异常 Class\u003c?\u003e t = f.getType(); //获取域的类型 Object val = f.get(obj); //获取域值 if(t.isPrimitive()) r+= val; //若域类型为基本数据类型,直接加入域值 else r += toString(val); //若域类型为对象，调用本方法 }catch(Exception e){ e.printStackTrace(); } } } r += \"]\"; c1 = c1.getSuperclass(); //开始获取超类的域 }while(c1 != null); return r; } //泛型数组代码 public static Object copyOf(Object a,int newLength) { //参数类型定义为Object，而不可以是Object[],是因为基本类型数组不可转换为Object[],但可以是Object Class\u003c? extends Object\u003e c1 = a.getClass(); if(!c1.isArray()) return null; //不是数组，返回null Class\u003c?\u003e componentType = c1.getComponentType(); //获取数组类型 int length = Array.getLength(a); //获取数组长度 Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length,newLength)); return newArray; } } 调用 //调用toString方法 Employee em = new Employee(2,3,4,5); System.out.println(new ObjectAnalyzer().toString(em)); java.lang.reflect.Array 相关API 表 返回类型 方法名和参数 解释 static Object get(Object array, int index) 返回存储在指定index上给定数组的内容 static xxxx getXxxx(Object array, int index) 若index索引处的类型为基本类型，可直接调用相关方法，那样得到的结果就不用强转了 static void set(Object array, int index, Object value) 将新值存储到给定位置上的给定数组中 static void setXxxx(Object array, int index, Object value) 若index索引处的类型为基本类型，可直接调用相关方法 static int getLength(Object array) 返回指定数组对象的长度 static Object newInstance(Class\u003c?\u003e componentType, int length) 返回具有给定类型，给定长度的新数组 ","date":"2022-02-07","objectID":"/java-reflect-note/:5:0","tags":["Java","JavaNote","Reflect"],"title":"Java反射笔记","uri":"/java-reflect-note/"},{"categories":["Operation"],"content":"记录Gradle中compile，provided，compile files，compile project有何区别？","date":"2022-02-07","objectID":"/gradle-compiles-diff/","tags":["Gradle","Compile","Difference"],"title":"Gradle中compile，provided，compile files，compile project有何区别？","uri":"/gradle-compiles-diff/"},{"categories":["Operation"],"content":"在一个Android项目的build.gradle中，dependencies闭包中有以下四种形式的声明： compile 'com.android.support:appcompat-v7:22.2.1' provided 'com.squareup.dagger:dagger-compiler:1.2.1' compile files('libs/picasso-2.4.0.jar') compile project(':androidPullToRefresh') 1，3，4本质上是一样的，区别在于： 1 是从repository（默认是jCenter())里下载一个依赖包进行编译并打包 3 是从本地的libs目录下寻找picasso-2.4.0.jar这个文件进行编译并打包。类似的命令有compile fileTree(dir: 'libs', include: '*.jar')——将libs目录下所有jar文件进行编译并打包。 4 是将另一个module（等同eclipse中的library)进行编译并打包 至于provided，是提供给那些只编译不打包场景的命令。就是，我在编译的时候对某一个jar文件有依赖，但是最终打包apk文件时，我不想把这个jar文件放进去，可以用这个命令。生成jar文件的时候,也不会打包provided的模块。 推荐一本书 《gradle for android》 ","date":"2022-02-07","objectID":"/gradle-compiles-diff/:0:0","tags":["Gradle","Compile","Difference"],"title":"Gradle中compile，provided，compile files，compile project有何区别？","uri":"/gradle-compiles-diff/"},{"categories":["Operation"],"content":"记录启动 WSL 2时警告“参考的对象类型不支持尝试的操作”的解决办法","date":"2022-02-07","objectID":"/docker-wsl2-waring-error/","tags":["Docker","WSL","Error"],"title":"基于WSL2 的 Docker Desktop 启动时 Failed to set version to docker-desktop: exit code: -1的解决方法...","uri":"/docker-wsl2-waring-error/"},{"categories":["Operation"],"content":"报错 在Windows 10 的 2004 版本 中， 启用 使用Docker Desktop 时 发现 根本无法启动， 偶尔 或者频繁的出错: System.InvalidOperationException: Failed to set version to docker-desktop: exit code: -1 各种百度谷歌始终无法解决， 这时打算到命令行去看看。 在cmd中输入 bash 或者 wsl 都报错， 提示 如下图: ","date":"2022-02-07","objectID":"/docker-wsl2-waring-error/:1:0","tags":["Docker","WSL","Error"],"title":"基于WSL2 的 Docker Desktop 启动时 Failed to set version to docker-desktop: exit code: -1的解决方法...","uri":"/docker-wsl2-waring-error/"},{"categories":["Operation"],"content":"方法 启动 WSL 2时警告“参考的对象类型不支持尝试的操作” 出现图中所示错误的原因是 代理软件与 wsl2 的端口冲突。 在管理员身份模式下执行 netsh winsock reset ,可以重新启动 WSL。 此操作会导致代理软件（proxifier）无法使用，请谨慎操作。 Github Issue1 Github Issue2 使用 NoLsp.exe 下载链接 备用下载链接 使用管理员身份运行以下命令: NoLsp.exe C:\\Windows\\system32\\wsl.exe 参数为 wsl 的绝对路径（默认为 C:\\Windows\\system32\\wsl.exe） 问题原因及解决方案的讨论见 Gihub Issue ","date":"2022-02-07","objectID":"/docker-wsl2-waring-error/:2:0","tags":["Docker","WSL","Error"],"title":"基于WSL2 的 Docker Desktop 启动时 Failed to set version to docker-desktop: exit code: -1的解决方法...","uri":"/docker-wsl2-waring-error/"},{"categories":["Operation"],"content":"解决 然后启动 docker-desktop 就解决了 ","date":"2022-02-07","objectID":"/docker-wsl2-waring-error/:3:0","tags":["Docker","WSL","Error"],"title":"基于WSL2 的 Docker Desktop 启动时 Failed to set version to docker-desktop: exit code: -1的解决方法...","uri":"/docker-wsl2-waring-error/"},{"categories":["Software","Note"],"content":"记录PowerShellGet笔记","date":"2022-02-07","objectID":"/win-powershellget-note/","tags":["PowerShell","Windows"],"title":"PowerShellGet笔记","uri":"/win-powershellget-note/"},{"categories":["Software","Note"],"content":"PowerShell的最佳管理能手 如果你看了上一篇关于微软的新一代Windows套件包管理器(OneGet)的文章的话，应该对PowerShell如何操作Windows的套件包管理器有了一定的了解。而这篇内容我会着重要谈谈管理PowerShell的PowerShellGet套件包，他与Windows套件包管理器(OneGet)有着密不可分的关系。PowerShellGet的内容还是比较多的，考虑到篇幅我打算拆分几篇文章分别以介绍，使用等角度来分享下这个PowerShell管理能手。 什么是PowerShellGet 首先，PowerShellGet是可以用来查找，安装，更新，管理等操作PowerShell模块与脚本的一个套件包，也就是所谓的管理PowerShell的包管理器。PowerShellGet里内置了一系列用于管理PowerShell模块与脚本的相关命令。用户可以使用PowerShellGet内的相关命令获取在线的PowerShell模块和脚本。 而PowerShellGet作为与用户的交互接口会默认连接PowerShell Gallery站点并从那获取在线资源。 让我们来看看上一篇我们在OneGet文章中提到的架构图，PowerShellGet作为PackageManagementProviders提供给用户各类相关功能命令使用，而他的Package Source数据源来自于PowerShell Gallery。 还记得我们文章开头提到PowerShellGet与OneGet有着密不可分的关系吗，我们知道OneGet是用来统一管理Windows平台上各种各样的套件包的组件，而OneGet还支持各种Provider扩展他把各种套件提供者Provider组合在一起供用户使用。而PowerShellGet作为一个Provider扩展套件被集成在OneGet中，可以被用于管理PowerShell。 我们用命令查看下PackageManagement的Provider，发现是PowerShellGet。这下你应该明白了，PowerShellGet作为一个Provider扩展套件被集成在OneGet中。 PS C:\\Users\\Administrator\u003e Get-Package -Name PackageManagement | Format-List PropertyOfSoftwareIdentity : PropertyOfSoftwareIdentity FastPackageReference : NuGet|PackageManagement|1.1.3.0|https://www.powershellgallery.com/api/v2/|Module ProviderName : PowerShellGet Source : https://www.powershellgallery.com/api/v2/ Status : Installed ","date":"2022-02-07","objectID":"/win-powershellget-note/:1:0","tags":["PowerShell","Windows"],"title":"PowerShellGet笔记","uri":"/win-powershellget-note/"},{"categories":["Software","Note"],"content":"用PowerShellGet管理你的模块包 上一篇在PowerShellGet系列中【PowerShellGet系列(一)：PowerShell的最佳管理能手】文章中，我们介绍了有关什么是PowerShellGet，今天这篇我们就来看看如何操作PowerShellGet模块里的命令。 不过在正式介绍里面的相关命令操作时，先让我们来简单回顾一下什么是PowerShellGet。 PowerShellGet是可以用来查找，安装，更新，管理等操作PowerShell模块与脚本的一个套件包，也就是所谓的管理PowerShell的包管理器。PowerShellGet里内置了一系列用于管理PowerShell模块与脚本的相关命令。用户可以使用PowerShellGet内的相关命令获取在线的PowerShell模块和脚本。 大家知道了什么是PowerShellGet，按照上面解释的说法，那是不是说明它里面所包含的Cmdlets就是各种操作的相关命令。让我使用Get-Command -Module PowerShellGet命令行来查看下里面包含的命令。 友好提示：文章里的一些代码片段单行内容比较长，如果排版有些拥挤，建议手机切换成横屏模式游览会舒服很多。 PS C:\\Users\\Administrator\u003e Get-Command -Module PowerShellGet CommandType Name Version Source ----------- ---- ------- ------ Function Find-Command 1.0.0.1 PowerShellGet Function Find-DscResource 1.0.0.1 PowerShellGet Function Find-Module 1.0.0.1 PowerShellGet Function Find-RoleCapability 1.0.0.1 PowerShellGet Function Find-Script 1.0.0.1 PowerShellGet Function Get-InstalledModule 1.0.0.1 PowerShellGet Function Get-InstalledScript 1.0.0.1 PowerShellGet Function Get-PSRepository 1.0.0.1 PowerShellGet Function Install-Module 1.0.0.1 PowerShellGet Function Install-Script 1.0.0.1 PowerShellGet Function New-ScriptFileInfo 1.0.0.1 PowerShellGet Function Publish-Module 1.0.0.1 PowerShellGet Function Publish-Script 1.0.0.1 PowerShellGet Function Register-PSRepository 1.0.0.1 PowerShellGet Function Save-Module 1.0.0.1 PowerShellGet Function Save-Script 1.0.0.1 PowerShellGet Function Set-PSRepository 1.0.0.1 PowerShellGet Function Test-ScriptFileInfo 1.0.0.1 PowerShellGet Function Uninstall-Module 1.0.0.1 PowerShellGet Function Uninstall-Script 1.0.0.1 PowerShellGet Function Unregister-PSRepository 1.0.0.1 PowerShellGet Function Update-Module 1.0.0.1 PowerShellGet Function Update-ModuleManifest 1.0.0.1 PowerShellGet Function Update-Script 1.0.0.1 PowerShellGet Function Update-ScriptFileInfo 1.0.0.1 PowerShellGet 我们获得了各类用于管理的相关命令，为了方便查看我们用下面的命令做些编排以方便梳理。 PS C:\\Users\\Administrator\u003e Get-Command -Module PowerShellGet | Group-Object -Property Verb Count Name Group ----- ---- ----- 5 Find {Find-Command, Find-DscResource, Find-Module, Find-RoleCapability...} 3 Get {Get-InstalledModule, Get-InstalledScript, Get-PSRepository} 2 Install {Install-Module, Install-Script} 1 New {New-ScriptFileInfo} 2 Publish {Publish-Module, Publish-Script} 1 Register {Register-PSRepository} 2 Save {Save-Module, Save-Script} 1 Set {Set-PSRepository} 1 Test {Test-ScriptFileInfo} 2 Uninstall {Uninstall-Module, Uninstall-Script} 1 Unregister {Unregister-PSRepository} 4 Update {Update-Module, Update-ModuleManifest, Update-Script, Update-ScriptFileInfo} 大家可以看到，有Find(查找), Get(获取), Install(安装), New(新建), Publish(发布), Register(注册), Save(保存), Set(设置), Test(检查), Uninstall(卸载), Unregister(注销), Update(更新)一共包含了12大类的功能管理，几乎你可以用PowerShellGet来管理你整个PowerShell了。因为里面涵盖的内容非常多，所以我打算抽其中部分方面来介绍下。 好吧，我突然想到想用Find-Module查看PowerShellGet的所有包含版本号，因为PowerShellGet的数据源是PSGallery在线站点，所以它会连接PSGallery在线站点去获取我们的数据包，下面列出了目前站点上收录的可用版本号。 PS C:\\Users\\Administrator\u003e Find-Module -Name PowerShellGet -AllVersions Version Name Repository Description ------- ---- ---------- ----------- 1.1.2.0 PowerShellGet PSGallery PowerShell module with commands for discovering,.. 1.1.1.0 PowerShellGet PSGallery PowerShell module with commands for discovering,.. 1.1.0.0 PowerShellGet PSGallery PowerShell module with commands for discovering,.. 我好像记得我当前电脑里的PowerShellGet不是最新的呢，让我用Get-Module查看下PowerShellGet版本号确认下吧。 PS C:\\Users\\Administrator\u003e Get-Module -Name PowerShellGet ModuleType Version Name ExportedCommands ---------- ------- ---- ---------------- Script 1.0.0.1 PowerShellGet {Find-Command, Find-DscResource, Find-Module, Find-RoleCap.. 果然不是最新的，我电脑里的版本还是1.0.0.1，而之前我用Find-Module列出的在线版本号最新的已经到1.1.2.0了，赶紧升级下看看是不是又多了什么新功能。怎么升级呢？我想到了Update-Module的命令 PS C:\\Users\\Administrator\u003e Update-Module -Name PowerShellGet -RequiredVersion 1.1.2.0 Update-Module : Module 'PowerShellGet' was not installed by using Install-Module, so it cannot be updated. At line:1 char:1 + Update-Module -Name PowerShellGet -RequiredVersion 1.1.","date":"2022-02-07","objectID":"/win-powershellget-note/:2:0","tags":["PowerShell","Windows"],"title":"PowerShellGet笔记","uri":"/win-powershellget-note/"},{"categories":["Software","Note"],"content":"总结 大致的介绍说完了，虽然只是一个安装升级模块的过程出现了点小插曲，但在这过程中我们却用到了许多相关命令。让我们总结下，我们用Find-Module来查找在线仓库里可用的模块版本。然后用Get-Module获得当前的版本信息号以此来比较是否需要更新。接着我们用Update-Module来更新模块，但知道了一个重要的点一旦能用Update-Module更新的模块包前提必须都是要用Install-Module方式来安装的。在安装的过程中我们用Set-PSRepository设置可信任的安装源，最后终于可以顺利安装了。 ","date":"2022-02-07","objectID":"/win-powershellget-note/:2:1","tags":["PowerShell","Windows"],"title":"PowerShellGet笔记","uri":"/win-powershellget-note/"},{"categories":["Software","Note"],"content":"PackageSource 大家一定还发现还有其它三个有关于“PackageSource”相关的命令，我们就来探讨下这些命令。 首先你可以用Get-PackageSource命令查看下你当前配置中具备哪些PackageSource资源，如下： PS C:\\Users\\Administrator\u003e Get-PackageSource Name Location Provider IsTrusted ---- -------- -------- --------- chocolatey http://chocolatey.org/api/v2/ Chocolatey False 我们可以从上面的输出信息中看到，我们当前只有名为chocolatey的PackageSource资源。聪明的你一定已经发现了，剩下的3个PackageSource命令中，有一个Add-PackageSource的命令，它一定是可以用来帮我们添加额外的PackageSource，如下我们使用了Add-PackageSource命令来添加了一个名为AndersGet的资源池： PS C:\\Users\\Administrator\u003e Add-PackageSource -Name AndersGet -Provider chocolatey -Location http://chocolatey.org/api/v2 / -Trusted 创建完毕后，我们再次使用Get-PackageSource命令查看会得到： PS C:\\Users\\Administrator\u003e Get-PackageSource Name Location Provider IsTrusted ---- -------- -------- --------- chocolatey http://chocolatey.org/api/v2/ Chocolatey False andersget http://chocolatey.org/api/v2/ Chocolatey True 那么添加好后自己的资源池后如何去使用里面的程序包呢？其实方法很简单和之前我们使用Find、Get以及Install来查找，查看以及安装程序包类似，我们依然使用Find-Package命令去查找程序包，只是这次我们需要使用Source参数去指定从我们指定的资源池中查找，方法如下： PS C:\\Users\\Administrator\u003e Find-Package -Source andersget -Name sysinternals Name Version Status Source Summary ---- ------- ------ ------ ------- sysinternals 2014.05.13 Available chocolatey Sysinternals - utilities to help y... 最后你可以用Remove-PackageSource命令删除你不想用的资源池，如下： PS C:\\Users\\Administrator\u003e Remove-PackageSource -Name andersget PS C:\\Users\\Administrator\u003e Get-PackageSource Name Location Provider IsTrusted ---- -------- -------- --------- chocolatey http://chocolatey.org/api/v2/ Chocolatey False 很简单吧，下次我们将继续探讨关于，如何创建自定义的OneGet。 ","date":"2022-02-07","objectID":"/win-powershellget-note/:3:0","tags":["PowerShell","Windows"],"title":"PowerShellGet笔记","uri":"/win-powershellget-note/"},{"categories":["Software"],"content":"记录Win10 邮件0x80004005报错的解决办法","date":"2022-01-30","objectID":"/win10-mail-0x80004005-error/","tags":["Mail","Windows","Error"],"title":"Win10 邮件0x80004005报错","uri":"/win10-mail-0x80004005-error/"},{"categories":["Software"],"content":"处理方法 使用cmd处理一小时之后，猛然想起之前在隐私设置里关闭了邮件。 在设置-\u003e隐私-\u003e电子邮箱-\u003e允许访问电子邮箱-\u003e开，再勾选邮件与日历即可 ","date":"2022-01-30","objectID":"/win10-mail-0x80004005-error/:0:0","tags":["Mail","Windows","Error"],"title":"Win10 邮件0x80004005报错","uri":"/win10-mail-0x80004005-error/"},{"categories":["Software","note"],"content":"记录Windows PowerShell 笔记","date":"2022-01-30","objectID":"/win-powshell-note/","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"PowerShell创建 Profile profile主要用于个性化常用的函数、别名等等。每次加载powershell的时候，都会执行profile中的内容。 查看是否有profile： $profile 如果结果是false说明没有。则创建一个。 New-Item –Path $Profile –Type File –Force -Force 是强制创建，即使你有了，也创建。 使用记事本编辑你自己的profile： notepad $Profile 这个里面，可以输入任何你在ps中输入的命令、函数。 比如，个性化自己的ps界面、常用的自己用的函数等等。 function Test-BaiduConnection{ Test-Connection www.baidu.com } 比如以上就定义了一个函数，重新打开一个ps，你就可以用``Test-BaiduConnection`命令，来执行了。 ","date":"2022-01-30","objectID":"/win-powshell-note/:1:0","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"Powershell控制台字体改为Consolas ","date":"2022-01-30","objectID":"/win-powshell-note/:2:0","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"方法 ","date":"2022-01-30","objectID":"/win-powshell-note/:3:0","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"一 一开始查了一些博客修改注册表 用了一些比较麻烦的方法 结论是不能永久改动，当修改如透明度等属性的时候，字体将还原为默认 修改注册表项的方法不赘述了 链接 ","date":"2022-01-30","objectID":"/win-powshell-note/:3:1","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"二 数日之后，发现了相对简单快速的办法： 1.控制台下，输入 chcp 437 后，你会发现字体有所变化 2.此时打开属性，可选consolas字体，重启shell界面也将保留字体 3.输入chcp 936切换成简体中文以支持中文输入 改好了之后大致是这个效果： ","date":"2022-01-30","objectID":"/win-powshell-note/:3:2","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"所以chcp指令究竟是什么？ 以下来自百度百科： 功能：显示或设置活动 代码页编号 CHCP [nnn] nnn 指定代码页编号。 不加参数键入 CHCP 显示活动代码页编号。 nnn指定一已有的系统字符集，该字符集在 CONFIG.SYS文件中由COUNTRY命令定义。 在DOS下可以通过mode命令来设置代码页。 选定代码页:　MODE CON[:] CP SELECT=yyy 代码页状态:　MODE CON[:] CP [/STATUS] 按Windows+R组合键，然后输入cmd或者command打开 命令提示符。 比如输入：mode con cp select=936，则表示显示简体中文。如果输入mode con cp select=437，则表示显示MS-DOS 美国英语，而中文显示将会是? ","date":"2022-01-30","objectID":"/win-powshell-note/:3:3","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Software","note"],"content":"总结 写的比较乱，总结一下： consolas支持中文显示，但不支持中文输入 所以想要使用consolas或者其他不在可选字体中的字体， 需要切换成美国英语模式 » chcp 437 ，然后修改字体 字体修改完毕后，为了支持中文输入再次切换成简体中文模式 » chcp 936 大概就是这个思路 ","date":"2022-01-30","objectID":"/win-powshell-note/:4:0","tags":["PowerShell","Windows"],"title":"Windows PowerShell 笔记","uri":"/win-powshell-note/"},{"categories":["Back"],"content":"记录Docker基础容器中bash: vi: command not found问题解决办法","date":"2022-01-30","objectID":"/docker-vi-not-find-error/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Docker容器中bash: vi: command not found","uri":"/docker-vi-not-find-error/"},{"categories":["Back"],"content":"问题 我们在创建基础容器之后，进入容器，进行编辑配置文件的时候，需要使用vim或者vi命令，但是会出现： root@700af56070dl:/# vi bash: vi: command not found ","date":"2022-01-30","objectID":"/docker-vi-not-find-error/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Docker容器中bash: vi: command not found","uri":"/docker-vi-not-find-error/"},{"categories":["Back"],"content":"解决 使用如下命令安装： apt-get update apt-get install vim featured-image featured-image.jpg ","date":"2022-01-30","objectID":"/docker-vi-not-find-error/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Docker容器中bash: vi: command not found","uri":"/docker-vi-not-find-error/"},{"categories":["Software","note"],"content":"记录Visual Studio 笔记","date":"2022-01-30","objectID":"/vs-note/","tags":["VisualStudio"],"title":"Visual Studio 笔记","uri":"/vs-note/"},{"categories":["Software","note"],"content":"Visual Studio安装时共享组件、工具和 SDK安装位置不能更改 ","date":"2022-01-30","objectID":"/vs-note/:1:0","tags":["VisualStudio"],"title":"Visual Studio 笔记","uri":"/vs-note/"},{"categories":["Software","note"],"content":"解决办法 更改注册表 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\Setup下的SharedInstallationPath项为所要的路径 ","date":"2022-01-30","objectID":"/vs-note/:1:1","tags":["VisualStudio"],"title":"Visual Studio 笔记","uri":"/vs-note/"},{"categories":["Back"],"content":"记录Chocolatey : 无法将“choco”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正 确，然后再试一次。解决办法","date":"2022-01-30","objectID":"/chocolatey-install-others-error/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Chocolatey : 无法将“choco”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。","uri":"/chocolatey-install-others-error/"},{"categories":["Back"],"content":"报错 PS C:\\WINDOWS\\system32\u003e choco install mkcert choco : 无法将“choco”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正 确，然后再试一次。 所在位置 行:1 字符: 1 +choco install mkcert + +CategoryInfo : ObjectNotFound: (choco:String) [], CommandNotFoundException +FullyQualifiedErrorId : CommandNotFoundException ","date":"2022-01-30","objectID":"/chocolatey-install-others-error/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Chocolatey : 无法将“choco”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。","uri":"/chocolatey-install-others-error/"},{"categories":["Back"],"content":"解决 使用命令 并输入 y set-executionpolicy remotesigned 继续执行 iwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex 我们发现就可以正常下载了 ","date":"2022-01-30","objectID":"/chocolatey-install-others-error/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Chocolatey : 无法将“choco”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。","uri":"/chocolatey-install-others-error/"},{"categories":["Software"],"content":"记录Window10安装Chocolatey 'An existing Chocolatey installation was detected'解决办法","date":"2022-01-30","objectID":"/chocolatey-install-error/","tags":["Chocolatey","Window10","Error"],"title":"Window10安装Chocolatey 'An existing Chocolatey installation was detected'","uri":"/chocolatey-install-error/"},{"categories":["Software"],"content":"情景 安装Node.js时安装额外组件时安装Chocolatey，安装失败，反馈以下信息： An existing Chocolatey installation was detected. Installation will not continue. For security reasons, this script will not overwrite existing installations. Please use choco upgrade chocolatey to handle upgrades of Chocolatey itself. ","date":"2022-01-30","objectID":"/chocolatey-install-error/:1:0","tags":["Chocolatey","Window10","Error"],"title":"Window10安装Chocolatey 'An existing Chocolatey installation was detected'","uri":"/chocolatey-install-error/"},{"categories":["Software"],"content":"解决方案 Remove-Item C:\\ProgramData\\chocolatey -Recurse 重新执行安装脚本即可 ","date":"2022-01-30","objectID":"/chocolatey-install-error/:2:0","tags":["Chocolatey","Window10","Error"],"title":"Window10安装Chocolatey 'An existing Chocolatey installation was detected'","uri":"/chocolatey-install-error/"},{"categories":["Back","note"],"content":"记录Java泛型相关笔记","date":"2021-12-14","objectID":"/java-generic-note/","tags":["Java","Generic","JavaNote"],"title":"Java泛型笔记","uri":"/java-generic-note/"},{"categories":["Back","note"],"content":"泛型通配符及上下边界 ","date":"2021-12-14","objectID":"/java-generic-note/:1:0","tags":["Java","Generic","JavaNote"],"title":"Java泛型笔记","uri":"/java-generic-note/"},{"categories":["Back","note"],"content":"引言 思考这种情形 　我们先定义一个水果类： public class Fruit { private String name; public Fruit(String name){ this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 　然后再定义一个苹果类： public class Apple extends Fruit{ public Apple(String name) { super(name); } } 　接下来定义一个泛型容器： public class GenericHolder\u003cT\u003e { private T obj; public GenericHolder(){} public GenericHolder(T obj){ this.obj = obj; } public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; } } 　接下来开始我们的测试： public class Test { /** * 吃水果 * @param fruitHolder */ public static void eatFruit(GenericHolder\u003cFruit\u003e fruitHolder){ System.out.println(\"我正在吃 \" + fruitHolder.getObj().getName()); } public static void main(String args[]){ //这是一个贴了水果标签的袋子 GenericHolder\u003cFruit\u003e fruitHolder = new GenericHolder\u003cFruit\u003e(); //这是一个贴了苹果标签的袋子 GenericHolder\u003cApple\u003e appHolder = new GenericHolder\u003cApple\u003e(); //这是一个水果 Fruit fruit = new Fruit(\"水果\"); //这是一个苹果 Apple apple = new Apple(\"苹果\"); //现在我们把水果放进去 fruitHolder.setObj(fruit); //调用一下吃水果的方法 eatFruit(fruitHolder); //贴了水果标签的袋子放水果当然没有问题 //现在我们把水果的子类——苹果放到这个袋子里看看 fruitHolder.setObj(apple); //同样是可以的，其实这时候会发生自动向上转型，apple向上转型为Fruit类型后再传入fruitHolder中 //但不能再将取出来的对象赋值给redApple了 //因为袋子的标签是水果，所以取出来的对象只能赋值给水果类的变量 //无法通过编译检测 redApple = fruitHolder.getObj(); eatFruit(fruitHolder); //放苹果的标签，自然只能放苹果 appHolder.setObj(apple); // 这时候无法把appHolder 传入eatFruit // 因为GenericHolder\u003cFruit\u003e 和 GenericHolder\u003cApple\u003e是两种不同的类型 // eatFruit(appHolder); } } 　运行结果： 我正在吃 水果 我正在吃 苹果 ","date":"2021-12-14","objectID":"/java-generic-note/:1:1","tags":["Java","Generic","JavaNote"],"title":"Java泛型笔记","uri":"/java-generic-note/"},{"categories":["Back","note"],"content":"原理 　在这里，我们往eatFruit方法里传入fuitHolder的时候，是可以正常编译的，但是如果将appHolder传入，就无法通过编译了，因为作为参数时，GenericHolder\u003cFruit\u003e 和 GenericHolder\u003cApple\u003e是两种不同的类型，所以无法通过编译，那么问题来了，如果我想让eatFruit方法能同时处理GenericHolder\u003cFruit\u003e 和 GenericHolder\u003cApple\u003e两种类型怎么办？而且这也是很合理的需求，毕竟Apple是Fruit的子类，能吃水果，为啥不能吃苹果？？？如果要把这个方法重载一次，未免也有些小题大做了（而且事实上也无法通过编译，具体原因之后会有说明）。 　在代码的逻辑里： 苹果 IS-A 水果 装苹果的盘子 NOT-IS-A 装水果的盘子 　这个时候，泛型的边界符就有它的用武之地了。我们先来看效果： public class Test { /** * 吃水果 * @param fruitHolder */ public static void eatFruit(GenericHolder\u003c? extends Fruit\u003e fruitHolder){ System.out.println(\"我正在吃 \" + fruitHolder.getObj().getName()); } public static void main(String args[]){ //这是一个贴了水果标签的袋子 GenericHolder\u003cFruit\u003e fruitHolder = new GenericHolder\u003cFruit\u003e(); //这是一个贴了苹果标签的袋子 GenericHolder\u003cApple\u003e appHolder = new GenericHolder\u003cApple\u003e(); //这是一个水果 Fruit fruit = new Fruit(\"水果\"); //这是一个苹果 Apple apple = new Apple(\"苹果\"); //现在我们把水果放进去 fruitHolder.setObj(fruit); //调用一下吃水果的方法 eatFruit(fruitHolder); //放苹果的标签，自然只能放苹果 appHolder.setObj(apple); // 这时候可以顺利把appHolder 传入eatFruit eatFruit(appHolder); } } 　运行结果： 我正在吃 水果 我正在吃 苹果 　这里我们只是使用了一点小小的魔法，把参数类型改成了GenericHolder\u003c? extends Fruit\u003e，这样就能将 GenericHolder\u003cApple\u003e类型的参数顺利传入了，怎么样？很好用吧，这就是泛型的边界符，用\u003c? extends Fruit\u003e的形式表示。边界符的意思，自然就是定义一个边界，这里用？表示传入的泛型类型不是固定类型，而是符合规则范围的所有类型，用extends关键字定义了一个上边界，也就是说这里的？可以代表任何继承于Fruit的类型，你也许会问，为什么是上边界，好问题，一图胜千言： 　从这个图可以很好的看出这个“上边界”的概念了吧。有上边界，自然有下边界，泛型里使用形如\u003c? super Fruit\u003e的方式使用下边界，此时，？只能代表Fruit及其父类。 　这两种方式基本上解决了我们之前的问题，但是同时，也有一定的限制。 　1.上界\u003c? extends T\u003e不能往里存，只能往外取 　不要太疑惑，其实很好理解，因为编译器只知道容器里的是Fruit或者Fruit的子类，但不知道它具体是什么类型，所以存的时候，无法判断是否要存入的数据的类型与容器种的类型一致，所以会拒绝set操作。 　2.下界\u003c? super T\u003e往外取只能赋值给Object变量，不影响往里存 　因为编译器只知道它是Fruit或者它的父类，这样实际上是放松了类型限制，Fruit的父类一直到Object类型的对象都可以往里存，但是取的时候，就只能当成Object对象使用了。 　所以如果需要经常往外读，则使用\u003c? extends T\u003e，如果需要经常往外取，则使用\u003c? super T\u003e。 ","date":"2021-12-14","objectID":"/java-generic-note/:1:2","tags":["Java","Generic","JavaNote"],"title":"Java泛型笔记","uri":"/java-generic-note/"},{"categories":["Operation","note"],"content":"记录Docker使用相关的笔记","date":"2021-12-13","objectID":"/docker-note/","tags":["Docker"],"title":"Docker笔记","uri":"/docker-note/"},{"categories":["Operation","note"],"content":"列出镜像 (1)指令介绍 列出所有docker中已有的镜像指令： docker iamges [OPTIONS] [REPOSITORY] 其中[OPTIONS]为相关操作选项，一种有4种： -a –all=false 显示所有镜像，默认不显示中间层的镜像。 -f –filter=[] 显示镜像时的过滤条件 –no-trunc=false 是指定不使用“截断”的形式来显示数据(默认情况下，使用image命令查到镜像的唯一ID是会被截断的) -q –quiet=false 只显示镜像的唯一ID ","date":"2021-12-13","objectID":"/docker-note/:1:0","tags":["Docker"],"title":"Docker笔记","uri":"/docker-note/"},{"categories":["Operation","note"],"content":"打开2375端口 ","date":"2021-12-13","objectID":"/docker-note/:2:0","tags":["Docker"],"title":"Docker笔记","uri":"/docker-note/"},{"categories":["Operation","note"],"content":"Windows 设置-\u003eGeneral-\u003e勾选如图-\u003eApply \u0026 Restart ","date":"2021-12-13","objectID":"/docker-note/:2:1","tags":["Docker"],"title":"Docker笔记","uri":"/docker-note/"},{"categories":["Back","note"],"content":"记录J2EE相关笔记","date":"2021-12-10","objectID":"/java-j2ee-note/","tags":["Java","J2EE"],"title":"J2EE相关笔记","uri":"/java-j2ee-note/"},{"categories":["Back","note"],"content":"Java Bean ","date":"2021-12-10","objectID":"/java-j2ee-note/:1:0","tags":["Java","J2EE"],"title":"J2EE相关笔记","uri":"/java-j2ee-note/"},{"categories":["Back","note"],"content":"历史 在java1996年发布,当年12月即发布了java bean1.00-A,有什么用呢?通过统一的规范可以设置对象的值(get,set方法),这是最初的java bean; 在实际企业开发中,需要实现事务,安全,分布式,javabean就不好用了.sun公司就开始往上面堆功能,这里java bean就复杂为EJB; EJB功能强大,但是太重了.此时出现DI(依赖注入),AOP(面向切面)技术,通过简单的java bean也能完成EJB的事情,这里的java bean简化为POJO; Spring诞生了. ","date":"2021-12-10","objectID":"/java-j2ee-note/:1:1","tags":["Java","J2EE"],"title":"J2EE相关笔记","uri":"/java-j2ee-note/"},{"categories":["Back","note"],"content":"补充名词 PO(persistence object):用于持久化时(例如保存到数据库或者缓存); VO(value object):用于前端展示使用(例如放置到JSP中解析或者给前端传递数据) DTO(data transfer object):用于接口互相调用返回,数据传输(例如很多接口调用返回值或消息队列内容); 特别地,由于class不同,复制时一般推荐 Dozer · springside/springside4 Wiki · GitHub 注意 这里规范有一个小坑:属性名ICar是合法的,但iCar是非法的..有一个要求(属性前两个字母大小写必须一致)主要是get和set方法无法区分.上面两个属性set方法都是SetICar() ","date":"2021-12-10","objectID":"/java-j2ee-note/:1:2","tags":["Java","J2EE"],"title":"J2EE相关笔记","uri":"/java-j2ee-note/"},{"categories":["Back","note"],"content":"其他主流观点和补充 主要区分三个：JavaBean，EJB，POJO。 JavaBean JavaBean是公共Java类，但是为了编辑工具识别，需要满足至少三个条件： 有一个public默认构造器（例如无参构造器,） 属性使用public 的get，set方法访问，也就是说设置成private，同时get，set方法与属性名的大小也需要对应。例如属性name，get方法就要写成，public String getName(){},N大写。 需要序列化。这个是框架，工具跨平台反映状态必须的 《Think in Java》,里面讲到JavaBean最初是为Java GUI的可视化编程实现的.你拖动IDE构建工具创建一个GUI 组件（如多选框）,其实是工具给你创建Java类,并提供将类的属性暴露出来给你修改调整,将事件监听器暴露出来.《Java 编程思想（第四版）》p823-p824 EJB 在企业开发中，需要可伸缩的性能和事务、安全机制，这样能保证企业系统平滑发展，而不是发展到一种规模重新更换一套软件系统。 然后有提高了协议要求，就出现了Enterprise Bean。 EJB在javabean基础上又提了一些要求，当然更复杂了。 POJO 有个叫Josh MacKenzie人觉得，EJB太复杂了，完全没必要每次都用，所以发明了个POJO，POJO是普通的javabean，什么是普通，就是和EJB对应的。 ​ 总之，区别就是，你先判断是否满足javabean的条件，然后如果再实现一些要求，满足EJB条件就是EJB，否则就是POJO。 原文链接： java - Difference between DTO, VO, POJO, JavaBeans? ","date":"2021-12-10","objectID":"/java-j2ee-note/:1:3","tags":["Java","J2EE"],"title":"J2EE相关笔记","uri":"/java-j2ee-note/"},{"categories":["Back"],"content":"记录JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX的解决办法","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"报错 如上图 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:1:0","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"自行测试 使用lombok注解测试Xml和实体类互相转化得出结论 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:2:0","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"知识储备 Spring 注解加载的流程 注解管理器APT JAXB源码 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:3:0","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"原因分析 JavaBean 属性名称与字段名称之间的名称冲突。Jaxb框架将getter或setter在java容器中注册为同名对象，导致同时使用getter和setter时出现冲突 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:4:0","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"解决 如果不使用Get和Set 选择性创建一个即可，注解加到属性上或者Get和Set上都可以 若必须同时存在Get和Set 需要使用@XmlTransient禁止绑定或者使用 或者是设置对应类 @XmlAccessorType(XmlAccessType.FIELD) （特殊注意）在解析XML时，可以将注解加到Get和Set上，不能加到属性上，构造XML时不行 TODO从源码角度解决\r","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:5:0","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"思路 自定义Getter或者Setter注解（在生成的get或set代码中加上注解） 找到Jaxb框架中绑定部分或者使用绑定创建get或set注入的位置 找到Jaxb框架中设置绑定默认属性的位置 动态代理 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:5:1","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back"],"content":"知识 lombok源码讲解 注解处理器 ","date":"2021-11-29","objectID":"/java-xml-jaxb-class-same-attr-error/:5:2","tags":["Java","Xml","Jaxb","Error"],"title":"JAXB报错：有两个名为XX的属性,类的两个属性具有相同名称XX","uri":"/java-xml-jaxb-class-same-attr-error/"},{"categories":["Back","note"],"content":"记录JAXB将Xml和实体类相互转化的笔记","date":"2021-11-29","objectID":"/java-xml-jaxb-note/","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"JAXB是什么？ JAXB（即Java Architecturefor XML Binding）是一个业界的标准，即是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。 ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:1:0","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"使用举例 ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:2:0","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"实体类 父节点 @Data @AllArgsConstructor @NoArgsConstructor @Component @XmlRootElement(name = \"Xml\") @ApiModel(\"XML对象\") public class XMLEty { @XmlElement(name = \"Header\") private Header header; @XmlElement(name = \"Body\") private Body body; @XmlTransient public Header getHeader() { return header; } @XmlTransient public Body getBody() { return body; } } 头节点 @Data @AllArgsConstructor @NoArgsConstructor public class Header { @XmlElement(name = \"b\") String b; @XmlTransient public String getB() { return b; } } 身体节点 @Data @AllArgsConstructor @NoArgsConstructor public class Body { @XmlElement(name = \"a\") String a; @XmlTransient public String getA() { return a; } } ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:2:1","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"业务逻辑（Controller） ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:3:0","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"实体类到XML @PostMapping(\"/re\") public String reIndex() { String result = \"null\"; StringWriter writer = new StringWriter(); Header header = new Header(\"B-Header\"); Body body = new Body(\"A-Body\"); XMLEtyReq xml = new XMLEtyReq(header,body); Marshaller m = null; try { JAXBContext context = JAXBContext.newInstance(XMLEtyReq.class); m = context.createMarshaller(); m.marshal(xml, writer); result = writer.toString(); } catch (JAXBException ex) { ex.printStackTrace(); } return result; } ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:3:1","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"XML到实体类 @PostMapping(\"/\") public String index(@RequestBody JSONObject jsonObj) { Unmarshaller uma = null; Object obj = null; try { JAXBContext jc = JAXBContext.newInstance(XMLEty.class); uma = jc.createUnmarshaller(); String param = jsonObj.getString(\"param\"); obj = uma.unmarshal(new StringReader(param)); } catch (JAXBException e) { e.printStackTrace(); } return ((XMLEty) obj).toString(); } 注： 多层通过类的嵌套实现 内部类需要定义为static 使用@XmlTransient注解它会为它的target阻止绑定操作，这个target可以是一个class或者一个field或者一个method。否则会报错：JAXB 有两个名为XX的属性，类的两个属性具有相同名称XX详情点我 ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:3:2","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"其他注解 XmlTransient 设置getter/setter不和xml绑定，类似ORM框架中Transient注解， XmlAccessorType Controls whether fields or Javabean properties are serialized by default. 控制是否默认序列化字段或者Javabean 的属性（四种情况如下） /** * Every getter/setter pair in a JAXB-bound class will be automatically * bound to XML, unless annotated by {@link XmlTransient}. * * Fields are bound to XML only when they are explicitly annotated * by some of the JAXB annotations. */ PROPERTY, /** * Every non static, non transient field in a JAXB-bound class will be automatically * bound to XML, unless annotated by {@link XmlTransient}. * * Getter/setter pairs are bound to XML only when they are explicitly annotated * by some of the JAXB annotations. */ FIELD, /** * Every public getter/setter pair and every public field will be * automatically bound to XML, unless annotated by {@link XmlTransient}. * * Fields or getter/setter pairs that are private, protected, or * defaulted to package-only access are bound to XML only when they are * explicitly annotated by the appropriate JAXB annotations. */ PUBLIC_MEMBER, /** * None of the fields or properties is bound to XML unless they * are specifically annotated with some of the JAXB annotations. */ NONE XmlAttribute 可以绑定属性到对应的标签 Java代码 @XmlRootElement @SuppressWarnings(\"serial\") public class TVenueEntity implements java.io.Serializable { private long venueId; @XmlAttribute(name = \"venueId\") public long getVenueId() { return venueId; } } 生成的xml \u003ctVenueEntity venueId=\"1132\"\u003e \u003c/tVenueEntity\u003e XmlElementWrpper 当属性是集合时如List、Set、Map等，需要在外层对多个内部对象进行包装，否则序列化报错 报错 [javax.xml.bind.JAXBException: class java.util.HashSet nor any of its super class is known to this context.] Java代码 @XmlRootElement @SuppressWarnings(\"serial\") public class TVenueEntity implements java.io.Serializable { private List\u003clong\u003e venueIds; @XmlElementWrpper(name=\"venueIds\") @XmlElement(name = \"venueId\") public long getVenueId() { return venueId; } } 生成的XML \u003ctVenueEntity\u003e \u003cvenueIds\u003e \u003cvenueId\u003e1\u003c/venueId\u003e \u003cvenueId\u003e2\u003c/venueId\u003e \u003cvenueId\u003e3\u003c/venueId\u003e \u003c/venueIds\u003e \u003c/tVenueEntity\u003e ","date":"2021-11-29","objectID":"/java-xml-jaxb-note/:4:0","tags":["Java","Xml","Jaxb"],"title":"JAXB将Xml和实体类相互转化的笔记","uri":"/java-xml-jaxb-note/"},{"categories":["Back","note"],"content":"记录Spring使用@Async注解异步调用的笔记","date":"2021-11-29","objectID":"/spring-async-note/","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["Back","note"],"content":"1. 何为异步调用？ 在解释异步调用之前，我们先来看同步调用的定义；同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。 异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。例如， 在某个调用中，需要顺序调用 A, B, C三个过程方法；如他们都是同步调用，则需要将他们都顺序执行完毕之后，方算作过程执行完毕； 如B为一个异步的调用方法，则在执行完A之后，调用B，并不等待B完成，而是执行开始调用C，待C执行完毕之后，就意味着这个过程执行完毕了。 ","date":"2021-11-29","objectID":"/spring-async-note/:1:0","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["Back","note"],"content":"2. 常规的异步调用处理方式 在Java中，一般在处理类似的场景之时，都是基于创建独立的线程去完成相应的异步调用逻辑，通过主线程和不同的线程之间的执行流程，从而在启动独立的线程之后，主线程继续执行而不会产生停滞等待的情况。 ","date":"2021-11-29","objectID":"/spring-async-note/:2:0","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["Back","note"],"content":"3. @Async介绍 在Spring中，基于@Async标注的方法，称之为异步方法；这些方法将在执行的时候，将会在独立的线程中被执行，调用者无需等待它的完成，即可继续其他的操作。 分为不带参数的异步调用；带参数的异步调用；调用返回Future的异步线程 ","date":"2021-11-29","objectID":"/spring-async-note/:3:0","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["Back","note"],"content":"4. @Async调用中的事务处理机制 在@Async标注的方法，同时也适用了@Transactional进行了标注；在其调用数据库操作之时，将无法产生事务管理的控制，原因就在于其是基于异步处理的操作。 那该如何给这些操作添加事务管理呢？可以将需要事务管理操作的方法放置到异步方法内部，在内部被调用的方法上添加@Transactional. 例如： 方法A，使用了@Async/@Transactional来标注，但是无法产生事务控制的目的。 方法B，使用了@Async来标注， B中调用了C、D，C/D分别使用@Transactional做了标注，则可实现事务控制的目的。 ","date":"2021-11-29","objectID":"/spring-async-note/:4:0","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["Back","note"],"content":"5. 配合使用@EnableAsync @EnableAsync 在启动类或者Control类加上 @EnableAsync 注解 @EnableAsync注解的意思是可以异步执行，就是开启多线程的意思。可以标注在方法、类上。@Async所修饰的函数不要定义为static类型，这样异步调用不会生效 如下： @SpringBootApplication @EnableAsync public class Application { public static void main( String[] args ) { SpringApplication.run(Application.class, args); } } 或者： @EnableAsync @RestController public class HelloController { @Autowired TestAsyncService testAsyncService; } 6. 举例： 两张表：user_info和order_table 插入user_info数据时候用同步，插入order_table用异步。 在controller类中创建一个方法 同时保存user_info和order_table表。保存order_table用异步（对应service方法中用**@Async标注**） （1）domain文件夹中创建Entity类 package com.cfj.ceshi.async.domain; import java.io.Serializable; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"order_table\") public class OrderTable implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; @Column(name = \"order_name\") private String orderName; @Column(name = \"user_id\") private Integer userId; @Column(name = \"create_date\") private Date createDate; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getOrderName() { return orderName; } public void setOrderName(String orderName) { this.orderName = orderName; } public Integer getUserId() { return userId; } public void setUserId(Integer userId) { this.userId = userId; } public Date getCreateDate() { return createDate; } public void setCreateDate(Date createDate) { this.createDate = createDate; } } package com.cfj.ceshi.async.domain; import java.io.Serializable; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"user_info\") public class UserInfo implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String userName; private String age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString() { return \"UserInfo [id=\" + id + \", userName=\" + userName + \", age=\" + age + \"]\"; } } （2）创建repository层操作数据库。如果是普通保存方法，只需要接口继承JpaRepository，不需要写具体方法 package com.cfj.ceshi.async.repository; import org.springframework.data.jpa.repository.JpaRepository; import com.cfj.ceshi.async.domain.OrderTable; public interface OrderRepository extends JpaRepository\u003cOrderTable, Integer\u003e { } package com.cfj.ceshi.async.repository; import org.springframework.data.jpa.repository.JpaRepository; import com.cfj.ceshi.async.domain.UserInfo; public interface UserRepository extends JpaRepository\u003cUserInfo, Integer\u003e { } （3）service层 其中order的实现层保存方法加上@Async package com.cfj.ceshi.async.service; public interface OrderService { public void saveOrder(Integer UserId,String name); } package com.cfj.ceshi.async.service; import java.util.List; import com.cfj.ceshi.async.domain.UserInfo; public interface UserService { public Integer save(UserInfo user); } package com.cfj.ceshi.async.service.impl; import java.util.Date; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; import com.cfj.ceshi.async.domain.OrderTable; import com.cfj.ceshi.async.repository.OrderRepository; import com.cfj.ceshi.async.service.OrderService; @Service public class OrderServiceImpl implements OrderService { @Autowired OrderRepository orderRepository; /** * 异步保存 */ @Async @Override public v","date":"2021-11-29","objectID":"/spring-async-note/:5:0","tags":["Java","J2EE","Spring","Async"],"title":"Spring使用@Async注解异步调用","uri":"/spring-async-note/"},{"categories":["SoftWare","note"],"content":"记录Office中Excel的单独使用笔记","date":"2021-11-29","objectID":"/office-excel-note/","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"Excel字符串连接的5种方式 如图，我们可能要将下面的字符单元格进行串联，拼接成新的字符串。 ","date":"2021-11-29","objectID":"/office-excel-note/:1:0","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"1、连接符\u0026 =B4\u0026C4：\u0026作用是将两个单元格内容连接起来；如果中间需要添加其他内容，在因为状态下用“”括起来即可。 ","date":"2021-11-29","objectID":"/office-excel-note/:1:1","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"2、PHONETIC函数文本连接 函数的语法为： PHONETIC(reference),reference为需连接的区域。连接顺序为从左到右，从上到下。注：该函数只对文本起作用。 =phonetic(B4:B6) ","date":"2021-11-29","objectID":"/office-excel-note/:1:2","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"3、CONCATENATE 函数 可将最多 255 个文本字符串合并为一个文本字符串。联接项可以是文本、数字、单元格引用或这些项的组合。 =CONCATENATE(text1, [text2], …)，text指的是需要连接的字符。作用同：=text1\u0026text2 =CONCATENATE(B4,C4) 新版EXCEL2016可以合并区域的文本连接函数：CONCAT和TEXTJOIN ","date":"2021-11-29","objectID":"/office-excel-note/:1:3","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"4、CONCAT 将区域文本（或单个文本）联接为一个字符串。 语法： CONCAT （文本 1，[文本 2]，…) 普通区域合并：=CONCAT(A1:F1) 加分隔符合并区域：=CONCAT(A1:F1\u0026\" “)，注：此公式是数组公式，需要按\u003cCtrl+Shift+Enter\u003e组合键结束。 ","date":"2021-11-29","objectID":"/office-excel-note/:1:4","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"5、TEXTJOIN 将从多个区域和/或字符串文本结合在一起，包括您指定将结合每个文本值之间的分隔符。 语法： TEXTJOIN （分隔符， 是否忽略空白单元格，文本 1，[文本 2]，…） 分隔符：每个文本之间的分隔，需用英文状态的双引号引起来。 是否忽略空白单元格：true（忽略空白单元格）；false（反之）； =TEXTJOIN(\"、\",1,A1:F1)：将A1到F1区域的单元格内容（忽略空白）连接起来，用、间隔。 ","date":"2021-11-29","objectID":"/office-excel-note/:1:5","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"Excel中怎么设置有永久显示行列标题 在实际工作中我们做的表格可能会很长或者很宽，当我们下拉的时候我们的标题就会看不到，为了解决这种情况我们可以冻结行列标题来实现，下面来看。 首先我们打开一个工作表，我们可看到在工作表中，当我们往下拉动的时候就会看不到工作表的表头。 现在我们来设置。 首先我们点击要设置要永久显示工作表的行。 如图我们选择的D9单元格表示1-8行以及A-C列永久显示。 选择要显示的单元格后我们点击菜单栏中的冻结窗口，选择下拉菜单中的第一个。 这是我们设置后的效果。 如果只需要设置首行或首列永久显示我们可以之际点击菜单栏中的冻结窗格中的冻结首行或冻结首列。 如果要取消冻结首行我们可以再次点击该按钮来实现。 ","date":"2021-11-29","objectID":"/office-excel-note/:2:0","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"快速在Excel中筛选奇数或偶数行 在旁边的辅助列第一个和第二个输入a和b然后填充。 点击排序和筛选下的筛选。 点击小三角，选择a或者b然后确定就可以了。 ","date":"2021-11-29","objectID":"/office-excel-note/:3:0","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"公式 Excel 等于号作为字符串显示和其他字符串拼接，要给其它字符串添加双引号，否则会报#NAME? ","date":"2021-11-29","objectID":"/office-excel-note/:4:0","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["SoftWare","note"],"content":"Excel为什么明明有数值，求和结果总是0 有这样一个Excel文件，有两列明明有数值，但是用sum公式求和，结果总是0，如下图所示： 提成和合计两列有数值 一般我们求和遇到结果为0的情况是求和区域的数字是文本格式的数字，类似于下图这样： 文本储存的数字 注意数字前面有个英文的单引号。 但是在本例中，数字并不是以文本存储的。 所以，无论怎样修改这两列的格式，或者无论怎样检查求和公式，都是没用的，计算结果始终为0。 这是为什么，为什么，为什么？我简直愁白了少年头。 当我无意中发狠显示所有公式时（通过【公式】选项卡-【显示公式】），终于发现了玄机： 原来是两个单元格的公式在dao’gui 红圈里两个单元格数值都是0，只是公式不一样。实际上这是个什么鬼公式，怎么钻出来的，我也不知道（因为Excel文件不是我做的），把公式修正一下，要么变成实际的数值，要么改为正确的公式，计算结果就出来了。 为什么合计列也计算不出结果来呢？这是因为合计列公式引用都是提成列的值，提成列算不出来结果，引用它的合计列也就自然算不出来结果了。 顺便提一下： 如果是文本储存的数字计算不出结果，直接把文本型数字转换成真正的数字就可以了。 方法是在任意一个空白单元格中输入0，然后复制，选中要转换成数字的区域，选择性粘贴，在【运算】区域选择【加】或【减】，即可。 也可以在任意单元格输入1，复制，然后选中要转换的区域，选择性粘贴为【乘】或【除】。 原理也就是小学学过的四则运算规律——一个数加或减0，值不变，一个数乘以或除以1，值不变。 选择性粘贴转换数字格式 ","date":"2021-11-29","objectID":"/office-excel-note/:5:0","tags":["Office","Excel"],"title":"Office中Excel的单独使用笔记","uri":"/office-excel-note/"},{"categories":["Software","note"],"content":"记录Office中Word的单独使用笔记","date":"2021-11-29","objectID":"/office-word-note/","tags":["Office","Word"],"title":"Office中Word的单独使用笔记","uri":"/office-word-note/"},{"categories":["Software","note"],"content":"Word最后一页空白页为什么总是删不掉 可能是由于您的Word空白页有一个分页符，只需要将Word视图模式设置为【普通视图】，2010和2013版命名为【草稿】，即可在页面中看到一条横虚线的分页符，将其删除之后，回到默认的【页面视图】中就能够将空白页删除； 将光标置于倒数第二页的最后，点击菜单栏字体选项右下角，效果选择【隐藏】，点击确定，就可以删除最后一页了； 菜单栏选择页面布局，点击页边距下拉标志，选择自定义边距，将页边距的上下值调小一点，就可以删除最后一页了； 也可以将光标置于倒数第二页的最后，点击菜单栏段落选项右下角，行距选择固定值，设置值为1磅，点击确定，就删掉了最后一页。 ","date":"2021-11-29","objectID":"/office-word-note/:1:0","tags":["Office","Word"],"title":"Office中Word的单独使用笔记","uri":"/office-word-note/"},{"categories":["Software","note"],"content":"Word文档不同页面设置不同页码 通常，在写论文或报告的时候会涉及封面、目录、正文、参考文献等多个方面的内容，当然页码也是必不可少的。在插入页码的时候，默认是从前往后按顺序排列，而我们的封面是不需要页码的，目录的页码也希望独立设置，这个该怎么操作呢？今天就让我们一起来学习一下吧！ 首先我们需要了解的是，默认情况下，一个文档是一个整节，如果页码也是按照这个逻辑排列的。如果要设置不同页码就需要将文档分成若干个节，这就是分节符帮我们实现的。因此我们需要在目录前插入分节符（下一页），然后双击目录所在的页脚，将上方的“链接到前一节”取消选中，然后删除封面所在的页码，然后设置目录所在页码格式，将页码编号的“续前节”改为“起始页码”，顺便可以修改一下目录页码的格式哦，比如用罗马数字显示。这样就设置好了。 如果正文部分要重新设置，跟刚才的操作类似，正文之前插入分节符，然后取消链接并重新设置页码格式及起始页就可以了。 ","date":"2021-11-29","objectID":"/office-word-note/:2:0","tags":["Office","Word"],"title":"Office中Word的单独使用笔记","uri":"/office-word-note/"},{"categories":["Operation","note"],"content":"记录Win10操作笔记","date":"2021-11-29","objectID":"/win-opt-note/","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"Win10桌面图标 还原方法如下 ","date":"2021-11-29","objectID":"/win-opt-note/:1:0","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"方法一 1、右键单击Win10系统桌面上的空白，将鼠标移到视图顶部，选择中号图标，选择之后，桌面图标将变得更加适中 2、选择中号图标后，整个Win10系统的桌面图标的大小会变得中等，看起来非常舒适。 ","date":"2021-11-29","objectID":"/win-opt-note/:1:1","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"方法二 1、按住键盘上的Ctrl键， 2、然后滚动鼠标滚轮以调整桌面图标的大小。 ","date":"2021-11-29","objectID":"/win-opt-note/:1:2","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"Windows获取文件的hash值 ","date":"2021-11-29","objectID":"/win-opt-note/:2:0","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"命令 certutil -hashfile F:\\code\\1.jpg ","date":"2021-11-29","objectID":"/win-opt-note/:2:1","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Operation","note"],"content":"结果 ","date":"2021-11-29","objectID":"/win-opt-note/:2:2","tags":["Win10","MD5","Windows"],"title":"Win10操作笔记","uri":"/win-opt-note/"},{"categories":["Software"],"content":"记录新版PostMan(9.1.5)离线不能使用得解决办法","date":"2021-11-26","objectID":"/postman-offline-note/","tags":["Http","PostMan","Error"],"title":"新版PostMan(9.1.5)离线不能使用","uri":"/postman-offline-note/"},{"categories":["Software"],"content":"原因 由于某项目属于内网环境，导致开发也是内网，新版本PostMan找不到原来跳过登录的地方了，所以不能用了 ","date":"2021-11-26","objectID":"/postman-offline-note/:1:0","tags":["Http","PostMan","Error"],"title":"新版PostMan(9.1.5)离线不能使用","uri":"/postman-offline-note/"},{"categories":["Software"],"content":"解决 查阅资料得选择Settings-Scratch Pad即可离线使用，或者登出账户应该也可以但是本人没验证 ","date":"2021-11-26","objectID":"/postman-offline-note/:2:0","tags":["Http","PostMan","Error"],"title":"新版PostMan(9.1.5)离线不能使用","uri":"/postman-offline-note/"},{"categories":["Learning"],"content":"记录Sublime卡死的解决办法","date":"2021-11-23","objectID":"/sublime-down-error/","tags":["Editer","Sublime","Error"],"title":"Sublime卡死的解决办法","uri":"/sublime-down-error/"},{"categories":["Learning"],"content":"原因 sublime打开卡死，需要进行结束程序 ","date":"2021-11-23","objectID":"/sublime-down-error/:1:0","tags":["Editer","Sublime","Error"],"title":"Sublime卡死的解决办法","uri":"/sublime-down-error/"},{"categories":["Learning"],"content":"解决办法 sublime临时文件存储路径 C:\\Users\\KKK-PJS-KEY\\AppData\\Roaming\\Sublime Text 3\\Local ","date":"2021-11-23","objectID":"/sublime-down-error/:2:0","tags":["Editer","Sublime","Error"],"title":"Sublime卡死的解决办法","uri":"/sublime-down-error/"},{"categories":["Back"],"content":"记录Spring注入接口实现错误得解决办法","date":"2021-11-23","objectID":"/spring-wire-impl-error/","tags":["Java","Spring","Error"],"title":"Spring注入接口实现错误","uri":"/spring-wire-impl-error/"},{"categories":["Back"],"content":"现象 Service下有接口 @Service public interface Common { String a = \"a\"; void sout(String s); } 和实现关系 @Service public class AImpl implements Common{ @Override public void sout(String s) { System.out.println(a); System.out.println(s); } } 在Controller下进行自动注入 @Autowired/@Resource AImpl aImpl; 启动Spring时报错 ","date":"2021-11-23","objectID":"/spring-wire-impl-error/:1:0","tags":["Java","Spring","Error"],"title":"Spring注入接口实现错误","uri":"/spring-wire-impl-error/"},{"categories":["Back"],"content":"解决 ","date":"2021-11-23","objectID":"/spring-wire-impl-error/:2:0","tags":["Java","Spring","Error"],"title":"Spring注入接口实现错误","uri":"/spring-wire-impl-error/"},{"categories":["Back"],"content":"方案一 我的，在Service实现类注入时自定义名字 @Service(\"AImpl\") public class AImpl implements Common{ @Override public void sout(String s) { System.out.println(a); System.out.println(s); } } 在Controller注入接口时给对应名字注入 @Autoired/@Reource(name = \"AImpl\") Common common; ","date":"2021-11-23","objectID":"/spring-wire-impl-error/:2:1","tags":["Java","Spring","Error"],"title":"Spring注入接口实现错误","uri":"/spring-wire-impl-error/"},{"categories":["Back"],"content":"方案二 项目组长写了一个接口ACommon继承于接口Common @Service public interface ACommon extends Common{ } Controller注入子类接口 @Autoired/@Reource ACommon aCommon; 完美解决！ ","date":"2021-11-23","objectID":"/spring-wire-impl-error/:2:2","tags":["Java","Spring","Error"],"title":"Spring注入接口实现错误","uri":"/spring-wire-impl-error/"},{"categories":["Learning"],"content":"记录解决XShell启动报错要继续使用此程序,您必须应用最新的更新的办法","date":"2021-11-23","objectID":"/xshell-open-error/","tags":["SSH","XShell","Error"],"title":"XShell启动报错要继续使用此程序,您必须应用最新的更新","uri":"/xshell-open-error/"},{"categories":["Learning"],"content":"起因 某些内部环境，Xshell版本十分落后，并且报错要继续使用此程序,您必须应用最新的更新 ","date":"2021-11-23","objectID":"/xshell-open-error/:1:0","tags":["SSH","XShell","Error"],"title":"XShell启动报错要继续使用此程序,您必须应用最新的更新","uri":"/xshell-open-error/"},{"categories":["Learning"],"content":"查询解决 xshell 老版本会造成这个错误，新版本更是直接不让使用，那我们来解决这个问题。 更改安装目录下的nslicense.dll文件，可以使用UE等 16进制软件打开此文件 查找 字符串 7F 0C 81 F9 80 33 E1 01 0F 86 80 替换 86为 83即可： 7F 0C 81 F9 80 33 E1 01 0F 83 80 如图： ","date":"2021-11-23","objectID":"/xshell-open-error/:2:0","tags":["SSH","XShell","Error"],"title":"XShell启动报错要继续使用此程序,您必须应用最新的更新","uri":"/xshell-open-error/"},{"categories":["Learning"],"content":"后续 内部环境也没有UE或者Winhex等工具，妥协使用其他版本Xshell ","date":"2021-11-23","objectID":"/xshell-open-error/:3:0","tags":["SSH","XShell","Error"],"title":"XShell启动报错要继续使用此程序,您必须应用最新的更新","uri":"/xshell-open-error/"},{"categories":["Back"],"content":"记录SpringCloud RPC Read timed out报错的解决办法","date":"2021-11-23","objectID":"/springcloud-rpc-readtimeout-error/","tags":["Java","J2EE","SpringCloud","RPC","Feign","ribbon"],"title":"SpringCloud RPC Read timed out","uri":"/springcloud-rpc-readtimeout-error/"},{"categories":["Back"],"content":"起因 在使用SpringCloud进行服务间调用时出现连接超时的错误，错误信息：Read timed out executing GET http://service-batch/batchmanagement/datatransfer/querybyplanid?planid=PL00000102。 报错日志 消费端报错 feign.RetryableException: Read timed out executing GET http://localhost:8080/UserApi/exportFormalUserHotline at feign.FeignException.errorExecuting(FeignException.java:67) at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:104) at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:76) at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:103) at com.sun.proxy.$Proxy125.exportFormalUserHotline(Unknown Source) at com.tinet.bigboss.web.controller.UserController.exportFormalUserHotline(UserController.java:396) at com.tinet.bigboss.web.controller.UserController$$FastClassBySpringCGLIB$$2fbde74b.invoke(\u003cgenerated\u003e) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:100) at com.tinet.bigboss.web.operatelog.OperateLogAspect.operateLogAdvice(OperateLogAspect.java:96) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:174) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.tinet.bigboss.web.controller.UserController$$EnhancerBySpringCGLIB$$954ef189.exportFormalUserHotline(\u003cgenerated\u003e) at com.tinet.bigboss.web.controller.UserController$$FastClassBySpringCGLIB$$2fbde74b.invoke(\u003cgenerated\u003e) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(Re","date":"2021-11-23","objectID":"/springcloud-rpc-readtimeout-error/:1:0","tags":["Java","J2EE","SpringCloud","RPC","Feign","ribbon"],"title":"SpringCloud RPC Read timed out","uri":"/springcloud-rpc-readtimeout-error/"},{"categories":["Back"],"content":"原因 用idea开发debug模式调试代码时，在处理服务间调用时，由于debug模式调试代码花费一些时间，或者是数据量过大，或者是网络波动，结果出现Fegin连接超时问题， ","date":"2021-11-23","objectID":"/springcloud-rpc-readtimeout-error/:2:0","tags":["Java","J2EE","SpringCloud","RPC","Feign","ribbon"],"title":"SpringCloud RPC Read timed out","uri":"/springcloud-rpc-readtimeout-error/"},{"categories":["Back"],"content":"解决方案 在配置文件中添加 ribbon:ReadTimeout:60000ConnectTimeout:60000# 以下三个不知道干嘛，Todo查资料MaxAutoRetries:0MaxAutoRetriesNextServer:1eureka: 服务间调用其实走的是http请求，debug了一下默认的ReadTimeout时间为5s，ConnectTimeout时间为2s。用Fegin进行服务间调用，底层用的还是Ribbon 也可以直接用feign的配置 # feign调用超时时间配置feign:client:config:default:connectTimeout:600000readTimeout:600000 ","date":"2021-11-23","objectID":"/springcloud-rpc-readtimeout-error/:3:0","tags":["Java","J2EE","SpringCloud","RPC","Feign","ribbon"],"title":"SpringCloud RPC Read timed out","uri":"/springcloud-rpc-readtimeout-error/"},{"categories":["Back","Note"],"content":"记录Java文件操作笔记","date":"2021-11-22","objectID":"/java-file-note/","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Back","Note"],"content":"递归计算文件夹下所有文件的总大小 ","date":"2021-11-22","objectID":"/java-file-note/:1:0","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Back","Note"],"content":"需求 需求描述:从键盘接收一个文件夹路径,获得该文件夹大小并输出到控制台。 ","date":"2021-11-22","objectID":"/java-file-note/:1:1","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Back","Note"],"content":"代码实现 import java.io.File; import java.util.Scanner; public class Demo934 { public static void main(String[] args) { //创建扫描器 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要查询的文件夹的绝对路径(格式为: 盘符:\\\\文件夹名\\\\子文件夹名...)\"); //定义变量保存用户输入的文件夹路径 String path = sc.next(); //调用方法 long fileSize = getFileSize(path); System.out.println(\"您查询的\"+path+\"文件夹下的文件大小为\"+(fileSize/1024/1024)+\"MB\"); } //创建方法获取指定文件夹下的文件大小并将其打印出来,参数为文件夹绝对路径,返回值文件的大小 public static long getFileSize(String file) { //创建文件对象 File f = new File(file); if (f.exists() \u0026\u0026 f.isDirectory()) {//文件夹存在 //获取文件夹的文件的集合 File[] files = f.listFiles(); long count =0;//用来保存文件的长度 for (File file1 : files) {//遍历文件集合 if (file1.isFile()) {//如果是文件 count += file1.length();//计算文件的长度 } else { count += getFileSize(file1.toString());//递归调用 } } return count; }else { System.out.println(\"您查询的文件夹有误\"); return 0; } } } ","date":"2021-11-22","objectID":"/java-file-note/:1:2","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Back","Note"],"content":"控制台运行效果 ","date":"2021-11-22","objectID":"/java-file-note/:1:3","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Back","Note"],"content":"递归删除文件 /** * @author yzh * @date 2018年4月26日 14:52:12 * @description 递归删除文件夹下所有目录和文件 */ public static void delDir(File f) { if(f.isDirectory()) {// 判断是否是一个目录, 不是的话跳过, 直接删除; 如果是一个目录, 先将其内容清空. File[] subFiles = f.listFiles();// 获取子文件/目录 for (File subFile : subFiles) {// 遍历该目录 // 递归调用删除该文件: 如果这是一个空目录或文件, 一次递归就可删除. 如果这是一个非空目录, 多次 // 递归清空其内容后再删除 delDir(subFile); } } f.delete();// 删除空目录或文件 } ","date":"2021-11-22","objectID":"/java-file-note/:2:0","tags":["Java","File"],"title":"Java文件操作笔记","uri":"/java-file-note/"},{"categories":["Operation","Note"],"content":"记录Linux网络笔记","date":"2021-11-22","objectID":"/linux-net-note/","tags":["Linux","Net"],"title":"Linux网络笔记","uri":"/linux-net-note/"},{"categories":["Operation","Note"],"content":"CURL 发送POST请求 curl -H \"Content-Type: application/json\" -X POST -d '{\"user_id\": \"123\", \"coin\":100, \"success\":1, \"msg\":\"OK!\" }' \"http://192.168.0.1:8001/test\" 参数 内容 -H 请求头 -d POST内容 -X 请求协议 ","date":"2021-11-22","objectID":"/linux-net-note/:1:0","tags":["Linux","Net"],"title":"Linux网络笔记","uri":"/linux-net-note/"},{"categories":["Back"],"content":"记录PG Sql报错 null value in column 'id' violates not-null constraintDetail: Failing row contains (11110, 1, null)的解决办法","date":"2021-11-22","objectID":"/sql-pg-column-notnull-error/","tags":["Database","Sql","PostgreSql","Error"],"title":"PG Sql报错 null value in column 'id' violates not-null constraintDetail: Failing row contains (11110, 1, null)","uri":"/sql-pg-column-notnull-error/"},{"categories":["Back"],"content":"报错 null value in column “id” violates not-null constraintDetail: Failing row contains (11110, 1, null) ","date":"2021-11-22","objectID":"/sql-pg-column-notnull-error/:1:0","tags":["Database","Sql","PostgreSql","Error"],"title":"PG Sql报错 null value in column 'id' violates not-null constraintDetail: Failing row contains (11110, 1, null)","uri":"/sql-pg-column-notnull-error/"},{"categories":["Back"],"content":"解决 这个错误很简单，一般来说，是因为插入的主键Id为空引起的，检查一下 插入语句就好了 我的是列名使用Excel填值得时候多了Tab或者空格导致orm持久层框架找不到列，修改了就没事了 ","date":"2021-11-22","objectID":"/sql-pg-column-notnull-error/:2:0","tags":["Database","Sql","PostgreSql","Error"],"title":"PG Sql报错 null value in column 'id' violates not-null constraintDetail: Failing row contains (11110, 1, null)","uri":"/sql-pg-column-notnull-error/"},{"categories":["Operation"],"content":"记录Git Merge 冲突报错的解决办法","date":"2021-11-22","objectID":"/git-unmerge-error/","tags":["Git","Merge","Error"],"title":"Git Merge 冲突报错","uri":"/git-unmerge-error/"},{"categories":["Operation"],"content":"报错 git合并分支错误，git融合分支错误，git merge错误，git冲突 git合并分支冲突，git ，git merge conflict error，git冲突，git如何融合分支 git合并冲突解决，git错误解决，git merge 冲突，git如何合并分支，git怎样融合分支 在做项目工作的时候，同事修改了代码一个cpp代码，我同样也修改了代码，两人代码冲突了，提交之后，他代码git自动合并，并提示: [master| MERGEING] $ git merge my_new_branch error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm \u003cfile\u003e' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. 又或者提示如下错误： Auto-merging src/ui/menu/wizardGroup.c Auto-merging src/ui/menu/drawmenu5.c Auto-merging src/ui/menu/drawmenu3.c Auto-merging src/ui/menu/drawmenu2.c Auto-merging src/ui/menu/drawmenu1.c Auto-merging src/ui/menu/drawmenu0.c Auto-merging src/string/language_d.h CONFLICT (content): Merge conflict in src/string/language_d.h Auto-merging src/string/languageDict.h CONFLICT (content): Merge conflict in src/string/languageDict.h Auto-merging src/drawui.c Auto-merging src/dev/dev_phascan.c Auto-merging src/dev/dev_flexscan.c Auto-merging src/callback.c Automatic merge failed; fix conflicts and then commit the result. ","date":"2021-11-22","objectID":"/git-unmerge-error/:1:0","tags":["Git","Merge","Error"],"title":"Git Merge 冲突报错","uri":"/git-unmerge-error/"},{"categories":["Operation"],"content":"解决方法 If you have fixed the conflicts you need to add the files to the stage with git add [filename], then commit as normal. 就是你手动修改git提示有错误的文件，修改之后，添加有冲突的文件： git add [被修改的冲突文件]， 最后，按照普通提交那样，提交有冲突的问题： git commit [修改后的冲突文件] -m “注释内容” 用git diff或者git status 查看哪些文件冲突，有冲突的会提示： ++\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD ++\u003c\u003c\u003c\u003c\u003c\u003c\u003c new_branch 修改你的冲突的文件，修改完之后，保存。 用git add xxx，把你修改的文件全部都添加进去。 最后，用git commit -a -m ” 备注信息 ” 提交，完成。 ","date":"2021-11-22","objectID":"/git-unmerge-error/:2:0","tags":["Git","Merge","Error"],"title":"Git Merge 冲突报错","uri":"/git-unmerge-error/"},{"categories":["Back","Note"],"content":"记录JAVA使用Dom4j工具解析XML，获取指定节点下的所有元素的笔记","date":"2021-11-22","objectID":"/java-xml-dom4j-note/","tags":["Java","XML"],"title":"JAVA使用Dom4j工具解析XML","uri":"/java-xml-dom4j-note/"},{"categories":["Back","Note"],"content":"一、获取指定节点下的所有元素，首先给一段示例报文： \u003cBody\u003e \u003cBnkInfArrys\u003e \u003cBnkInfArry\u003e \u003cBank_name\u003e1.1\u003c/Bank_name\u003e \u003cBank_no\u003e1.2\u003c/Bank_no\u003e \u003cBank_name\u003e2.1\u003c/Bank_name\u003e \u003cBank_no\u003e2.2\u003c/Bank_no\u003e \u003cBnkInfArry\u003e \u003c/BnkInfArrys\u003e \u003c/Body\u003e ","date":"2021-11-22","objectID":"/java-xml-dom4j-note/:1:0","tags":["Java","XML"],"title":"JAVA使用Dom4j工具解析XML","uri":"/java-xml-dom4j-note/"},{"categories":["Back","Note"],"content":"二、代码示例： //1、通过解析文本内容获得文档对象。 Document document = DocumentHelper.parseText(str); //2、获取元素根节点。 Element root = document.getRootElement(); //3、获取BnkInfArry阶段的的第一可操作元素 Element element1 = (Element) root.selectNodes(\"Body/BnkInfArrys/BnkInfArry\").get(0); //4、获取第一可操作元素下的所有元素 List\u003cElement\u003e elements = element1.elements(); //5、获得标签的具体内容。 for(int i = 0,len = elements.size(); i \u003c len;i++){ System.out.println((elements.get(i)).getText()); System.out.println(elements.get(i+1).getText()); i = i + +; } ","date":"2021-11-22","objectID":"/java-xml-dom4j-note/:2:0","tags":["Java","XML"],"title":"JAVA使用Dom4j工具解析XML","uri":"/java-xml-dom4j-note/"},{"categories":["Back"],"content":"记录SpringBoot报错 There is already 'xxxController' bean method的解决办法","date":"2021-11-07","objectID":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/","tags":["Java","J2EE","SpringBoot","Controller","Error"],"title":"SpringBoot报错 There is already 'xxxController' bean method","uri":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/"},{"categories":["Back"],"content":"原因分析 报这个错的原因是因为你controller里的@RequestMapping中的路径有重复！ 如： ","date":"2021-11-07","objectID":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/:1:0","tags":["Java","J2EE","SpringBoot","Controller","Error"],"title":"SpringBoot报错 There is already 'xxxController' bean method","uri":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/"},{"categories":["Back"],"content":"解决 去掉重复就完事了 ","date":"2021-11-07","objectID":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/:2:0","tags":["Java","J2EE","SpringBoot","Controller","Error"],"title":"SpringBoot报错 There is already 'xxxController' bean method","uri":"/springboot-thr-is-ard-cntrlr-bin-mthd-error/"},{"categories":["Operation"],"content":"记录GitHub的Pull Request和GitLab的Merge Request的区别","date":"2021-11-07","objectID":"/git-mr-pr-diff/","tags":["Git","GitHub","GitLab","Difference"],"title":"GitHub的Pull Request和GitLab的Merge Request","uri":"/git-mr-pr-diff/"},{"categories":["Operation"],"content":"起因 在 GitHub 上混久了，对 Pull Request 就…… 在 GitLab 上混久了，对 Merge Request 就…… 然而它们之间有不同吗？为什么要用两个不同的名称？ ","date":"2021-11-07","objectID":"/git-mr-pr-diff/:1:0","tags":["Git","GitHub","GitLab","Difference"],"title":"GitHub的Pull Request和GitLab的Merge Request","uri":"/git-mr-pr-diff/"},{"categories":["Operation"],"content":"分析 要追溯这两个名称，需要追溯 GitHub 和 GitLab 引以为傲的 git 工作流。这也是本文参考链接中一定要附上 GitLab 工作流的重要原因。 众所周知 git 是一个分布式的版本管理系统，但为了团队成员之间能够高效地协作，必须有至少一个服务器用于给团队所有成员之间同步代码。而这一点又有点类似于集中式的版本管理。 对于项目的核心成员，集中式版本管理和分布式版本管理贡献代码的方式并没有多大差异（这里不要纠结个人使用层面的差异，只谈论为仓库贡献代码的方式）。但对于非项目核心成员来说，集中式的版本管理就非常痛苦了，因为他们找不到方式来提交自己的代码（请忽略低效的发邮件补丁吧……）。然而分布式版本管理则解决了这个问题：非项目核心成员可以克隆仓库，这样就得到了一个自己具有完全读写权限的仓库，贡献的代码可以完全同步到这个具有完全读写权限的仓库中。 为了让非核心成员提交的代码被核心成员接纳，非核心成员会向核心成员提出“申请（Request）”去自己的仓库指定分支中“拉取(pull)”最新的修改，这便是 Pull Request 的来源。 ","date":"2021-11-07","objectID":"/git-mr-pr-diff/:2:0","tags":["Git","GitHub","GitLab","Difference"],"title":"GitHub的Pull Request和GitLab的Merge Request","uri":"/git-mr-pr-diff/"},{"categories":["Operation"],"content":"结果 那么 Merge Request 又是什么呢？GitLab 对此的解释是——一样的，没有区别。Merge 只是在强调最后的那个动作“合并（Merge）”。 GitHub、Bitbucket 和码云（Gitee.com）选择 Pull Request 作为这项功能的名称。 GitLab 和 Gitorious 选择 Merge Request 作为这项功能的名称。 参考：StackOverflow - Pull request vs Merge request ","date":"2021-11-07","objectID":"/git-mr-pr-diff/:3:0","tags":["Git","GitHub","GitLab","Difference"],"title":"GitHub的Pull Request和GitLab的Merge Request","uri":"/git-mr-pr-diff/"},{"categories":["Operation","note"],"content":"记录Linux系统设置指令的笔记","date":"2021-11-02","objectID":"/linux-system-set-note/","tags":["Linux","SystemSettings"],"title":"Linux系统设置指令","uri":"/linux-system-set-note/"},{"categories":["Operation","note"],"content":"Linux export 命令 Linux export 命令用于设置或显示环境变量。 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。 ","date":"2021-11-02","objectID":"/linux-system-set-note/:1:0","tags":["Linux","SystemSettings"],"title":"Linux系统设置指令","uri":"/linux-system-set-note/"},{"categories":["Operation","note"],"content":"语法 export [-fnp][变量名称]=[变量设置值] 参数说明： -f 代表[变量名称]中为函数名称。 -n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 -p 列出所有的shell赋予程序的环境变量。 ","date":"2021-11-02","objectID":"/linux-system-set-note/:1:1","tags":["Linux","SystemSettings"],"title":"Linux系统设置指令","uri":"/linux-system-set-note/"},{"categories":["Operation","note"],"content":"实例 列出当前所有的环境变量 # export -p //列出当前的环境变量值 declare -x HOME=“/root“ declare -x LANG=“zh_CN.UTF-8“ declare -x LANGUAGE=“zh_CN:zh“ declare -x LESSCLOSE=“/usr/bin/lesspipe %s %s“ declare -x LESSOPEN=“| /usr/bin/lesspipe %s“ declare -x LOGNAME=“root“ declare -x LS_COLORS=““ declare -x MAIL=“/var/mail/root“ declare -x OLDPWD declare -x PATH=“/opt/toolchains/arm920t-eabi/bin:/opt/toolchains/arm920t-eabi/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games“ declare -x PWD=“/root“ declare -x SHELL=“/bin/bash“ declare -x SHLVL=“1“ declare -x SPEECHD_PORT=“6560“ declare -x SSH_CLIENT=“192.168.1.65 1674 22“ declare -x SSH_CONNECTION=“192.168.1.65 1674 192.168.1.3 22“ declare -x SSH_TTY=“/dev/pts/2“ declare -x TERM=“XTERM“ declare -x USER=“root“ declare -x XDG_SESSION_COOKIE=“93b5d3d03e032c0cf892a4474bebda9f-1273864738.954257-340206484“ 定义环境变量 # export MYENV //定义环境变量 # export -p //列出当前的环境变量 declare -x HOME=“/root“ declare -x LANG=“zh_CN.UTF-8“ declare -x LANGUAGE=“zh_CN:zh“ declare -x LESSCLOSE=“/usr/bin/lesspipe %s %s“ declare -x LESSOPEN=“| /usr/bin/lesspipe %s“ declare -x LOGNAME=“root“ declare -x LS_COLORS=““ declare -x MAIL=“/var/mail/root“ declare -x MYENV declare -x OLDPWD declare -x PATH=“/opt/toolchains/arm920t-eabi/bin:/opt/toolchains/arm920t-eabi/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games“ declare -x PWD=“/root“ declare -x SHELL=“/bin/bash“ declare -x SHLVL=“1“ declare -x SPEECHD_PORT=“6560“ declare -x SSH_CLIENT=“192.168.1.65 1674 22“ declare -x SSH_CONNECTION=“192.168.1.65 1674 192.168.1.3 22“ declare -x SSH_TTY=“/dev/pts/2“ declare -x TERM=“XTERM“ declare -x USER=“root“ declare -x XDG_SESSION_COOKIE=“93b5d3d03e032c0cf892a4474bebda9f-1273864738.954257-340206484“ 定义环境变量赋值 # export MYENV=7 //定义环境变量并赋值 # export -p declare -x HOME=“/root“ declare -x LANG=“zh_CN.UTF-8“ declare -x LANGUAGE=“zh_CN:zh“ declare -x LESSCLOSE=“/usr/bin/lesspipe %s %s“ declare -x LESSOPEN=“| /usr/bin/lesspipe %s“ declare -x LOGNAME=“root“ declare -x LS_COLORS=““ declare -x MAIL=“/var/mail/root“ declare -x MYENV=“7“ declare -x OLDPWD declare -x PATH=“/opt/toolchains/arm920t-eabi/bin:/opt/toolchains/arm920t-eabi/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games“ declare -x PWD=“/root“ declare -x SHELL=“/bin/bash“ declare -x SHLVL=“1“ declare -x SPEECHD_PORT=“6560“ declare -x SSH_CLIENT=“192.168.1.65 1674 22“ declare -x SSH_CONNECTION=“192.168.1.65 1674 192.168.1.3 22“ declare -x SSH_TTY=“/dev/pts/2“ declare -x TERM=“XTERM“ declare -x USER=“root“ declare -x XDG_SESSION_COOKIE=“93b5d3d03e032c0cf892a4474bebda9f-1273864738.954257-340206484“ ","date":"2021-11-02","objectID":"/linux-system-set-note/:1:2","tags":["Linux","SystemSettings"],"title":"Linux系统设置指令","uri":"/linux-system-set-note/"},{"categories":["Back"],"content":"记录Win10下 Redis启动 错误1067导致进程意外终止的解决方法","date":"2021-11-02","objectID":"/redis-start-error/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10下 Redis启动 错误1067导致进程意外终止","uri":"/redis-start-error/"},{"categories":["Back"],"content":"一、系统环境 操作系统：Windows10专业版 64位 Redis版本：redis-64.3.0.503 ","date":"2021-11-02","objectID":"/redis-start-error/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10下 Redis启动 错误1067导致进程意外终止","uri":"/redis-start-error/"},{"categories":["Back"],"content":"二、问题描述 1.命令行启动： redis-server redis.windows.conf 可以启动成功； 2.将Redis安装为Windows系统服务： redis-server --service-``install` `redis.windows-service.conf --loglevel verbose 3.进入系统服务页面： Win + r打开运行命令框，services.msc打开系统服务页面 4.启动redis服务 启动报错，错误信息如下： ","date":"2021-11-02","objectID":"/redis-start-error/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10下 Redis启动 错误1067导致进程意外终止","uri":"/redis-start-error/"},{"categories":["Back"],"content":"三、解决方案 在redis-64.3.0.503文件夹下新建一个空文件夹，命名为logs，如下图所示： 重新启动redis服务，可以启动成功,如下图: ","date":"2021-11-02","objectID":"/redis-start-error/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10下 Redis启动 错误1067导致进程意外终止","uri":"/redis-start-error/"},{"categories":["Back"],"content":"四、反思 由于C盘没地方了，迁移了一下Redis，估计导致Redis对数据库文件识别或者持久化文件识别除了问题，重启就解决了 ","date":"2021-11-02","objectID":"/redis-start-error/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Win10下 Redis启动 错误1067导致进程意外终止","uri":"/redis-start-error/"},{"categories":["Software"],"content":"记录Sublime隐藏菜单栏后无法显示的解决办法","date":"2021-11-02","objectID":"/sublime-menubar-hide-error/","tags":["Sublime","Error"],"title":"Sublime隐藏菜单栏后无法显示","uri":"/sublime-menubar-hide-error/"},{"categories":["Software"],"content":"原因 尝试点击视图下的显示/隐藏菜单栏按钮时菜单栏消失，并且也无直接快捷键回复显示。 ","date":"2021-11-02","objectID":"/sublime-menubar-hide-error/:1:0","tags":["Sublime","Error"],"title":"Sublime隐藏菜单栏后无法显示","uri":"/sublime-menubar-hide-error/"},{"categories":["Software"],"content":"步骤 先看看隐藏后的界面，没了菜单项，怎么设置也不行了 ","date":"2021-11-02","objectID":"/sublime-menubar-hide-error/:2:0","tags":["Sublime","Error"],"title":"Sublime隐藏菜单栏后无法显示","uri":"/sublime-menubar-hide-error/"},{"categories":["Software"],"content":"Win特性方法 其实这个时候按住alt键，就可以暂时显示菜单栏了，再次点击“显示/隐藏菜单栏”就能恢复了。 另外，这个方法适用于绝大部分win软件。 ","date":"2021-11-02","objectID":"/sublime-menubar-hide-error/:2:1","tags":["Sublime","Error"],"title":"Sublime隐藏菜单栏后无法显示","uri":"/sublime-menubar-hide-error/"},{"categories":["Software"],"content":"看一下网络盛行的方法 按下键盘的ctrl+shift+P组合键，输入view 然后点击view:Toggle Menu即可。 ","date":"2021-11-02","objectID":"/sublime-menubar-hide-error/:2:2","tags":["Sublime","Error"],"title":"Sublime隐藏菜单栏后无法显示","uri":"/sublime-menubar-hide-error/"},{"categories":["Back","note"],"content":"记录Spring Boot 可执行 Jar 包运行原理的笔记","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"简介 Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。 ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:1:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"打可执行 Jar 包 将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可。 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e **注意：**参数 \u003cbuild\u003e \u003cfinalName\u003eprojectByMyself\u003c/finalName\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.0.1.RELEASE\u003c/version\u003e \u003cconfiguration\u003e \u003cmainClass\u003e${start-class}\u003c/mainClass\u003e \u003clayout\u003eZIP\u003c/layout\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e finalName 1、设置了就会按照自己设定的名字作为包名 2、如果没有设置，打包后的包名为：artifactId与version拼接的结果 如下图： mainClass ${start-class} 其实就是项目的启动类，例如：com.myproject.PortalutilApplication layout 1、JAR，即通常的可执行jar ​ Main-Class: org.springframework.boot.loader.JarLauncher 2、WAR，即通常的可执行war，需要的servlet容器依赖位于WEB-INF/lib-provided ​ Main-Class: org.springframework.boot.loader.warLauncher 3、ZIP，即DIR，类似于JAR ​ Main-Class: org.springframework.boot.loader.PropertiesLauncher 4、MODULE，将所有的依赖库打包（scope为provided的除外），但是不打包Spring Boot的任何Launcher 5、NONE，将所有的依赖库打包，但是不打包Spring Boot的任何Launcher goals 如果你的项目没有继承spring-boot-starter-parent这个POM，你需要做如下配置，将目标绑定到repackage。 运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。 关于这个插件的详细使用，可以参考官网 ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:2:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"可执行 Jar 包内部结构 将打出来的可执行 Jar 解压开我们能看到下面的结构： 可执行 jar 目录结构 ├─BOOT-INF │ ├─classes │ └─lib ├─META-INF │ ├─maven │ ├─app.properties │ ├─MANIFEST.MF └─org └─springframework └─boot └─loader ├─archive ├─data ├─jar └─util 我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。 Manifest-Version: 1.0 Archiver-Version: Plexus Archiver Built-By: xxxx Start-Class: com.xxxx.AppServer Spring-Boot-Classes: BOOT-INF/classes/ Spring-Boot-Lib: BOOT-INF/lib/ Spring-Boot-Version: 2.1.6.RELEASE Created-By: Apache Maven 3.3.9 Build-Jdk: 1.8.0_73 Main-Class: org.springframework.boot.loader.JarLauncher 在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。 再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。 ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:3:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"JarLauncher public class JarLauncher extends ExecutableArchiveLauncher { static final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\"; static final String BOOT_INF_LIB = \"BOOT-INF/lib/\"; public JarLauncher() { } protected JarLauncher(Archive archive) { super(archive); } @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } public static void main(String[] args) throws Exception { //项目入口，重点在launch这个方法中 new JarLauncher().launch(args); } } //launch方法 protected void launch(String[] args) throws Exception { JarFile.registerUrlProtocolHandler(); //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。 ClassLoader classLoader = createClassLoader(getClassPathArchives()); //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。 launch(args, getMainClass(), classLoader); } ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:4:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"简单总结 Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法； 这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载； 读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。 ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:5:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"远程调试 这边介绍个调试 JarLauncher 启动的小技巧：IDEA 远程调试。 step1：我们以下面的方式启动我们的 Spring Boot 应用 java -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -jar App.jar step2：在 idea 中进行如下配置 然后点击下面的执行按钮执行即可： ","date":"2021-10-26","objectID":"/maven-idea-springboot-jar-note/:6:0","tags":["Java","SpringBoot","Maven","Jar"],"title":"Spring Boot 可执行 Jar 包运行原理","uri":"/maven-idea-springboot-jar-note/"},{"categories":["Back","note"],"content":"记录SpringCloud/SpringBoot分离依赖打包的笔记","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"需求 由于公司Gitlab服务器和部署服务器之间似乎无法内网访问，找了IT部门好几次没有什么结果。但是紧急的需求增加或者变更需要使用公司提供连接方式手动上传jar包，一个jar包有个几十到几百M不等，重新部署一次各个微服务需要很久时间。于是项目组下定决心搭一下CI/CD，我由于学校有事情，就远程完成开发。技术组长就将这个不是那么着急的事情给我了，并提了一个开头的需求，及分离jar包中的依赖部分。因为依赖部分所占内存很大，并且更新并不会很频繁，于是打算“懒更新”。 说做就做，技术组长提供的技术参考是Maven下的assembly插件，于是开始学习插件。 ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:1:0","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"打包步骤 完事开头难，其实也还行。查阅相关资料，网上关于SpringCloud和assembly二者的笔记寥寥无几。于是转战单独assembly插件研究和SpringBoot和assembly插件组合的研究，毕竟每个微服务其实还是SpringBoot。跟据相关的笔记自己创建了一个SpringBoot项目进行测试(Assembly官方文档) Pom \u003cplugins\u003e \u003c!-- \u003cplugin\u003e--\u003e \u003c!-- \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e--\u003e \u003c!-- \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e--\u003e \u003c!-- \u003c/plugin\u003e--\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-jar-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003carchive\u003e \u003cmanifest\u003e \u003c!-- 项目启动类，这里需要替换成启动类 --\u003e \u003cmainClass\u003ecn.edu.hubu.lhy.assembly_test.AssemblyTestApplication\u003c/mainClass\u003e \u003c!-- 依赖的jar的目录前缀 --\u003e \u003cclasspathPrefix\u003e../lib\u003c/classpathPrefix\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003cexcludes\u003e \u003cexclude\u003eassembly.xml\u003c/exclude\u003e \u003cexclude\u003eapplication.properties\u003c/exclude\u003e \u003cexclude\u003eapplication.yml\u003c/exclude\u003e \u003c/excludes\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-assembly-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cappendAssemblyId\u003etrue\u003c/appendAssemblyId\u003e \u003cdescriptors\u003e \u003cdescriptor\u003esrc/main/resources/assembly.xml\u003c/descriptor\u003e \u003c/descriptors\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003c!-- 配置执行器 --\u003e \u003cexecution\u003e \u003cid\u003emake-assembly\u003c/id\u003e \u003c!-- 绑定到 package 生命周期阶段上 --\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003c!-- 只运行一次 --\u003e \u003cgoal\u003esingle\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cfinalName\u003eskywalking\u003c/finalName\u003e \u003cdescriptors\u003e \u003c!-- 配置描述文件路径 --\u003e \u003cdescriptor\u003esrc/main/resources/assembly.xml\u003c/descriptor\u003e \u003c/descriptors\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c!-- 以下是多环境中的配置 --\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003elocal\u003c/id\u003e \u003cproperties\u003e \u003cenv\u003elocal\u003c/env\u003e \u003c/properties\u003e \u003c!-- 如果不指定ID，默认是本地环境--\u003e \u003cactivation\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003etest\u003c/id\u003e \u003cproperties\u003e \u003cenv\u003etest\u003c/env\u003e \u003c/properties\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003eproduct\u003c/id\u003e \u003cproperties\u003e \u003cenv\u003eproduct\u003c/env\u003e \u003c/properties\u003e \u003c/profile\u003e \u003c/profiles\u003e assembly配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cassembly\u003e \u003c!-- 可自定义--\u003e \u003cid\u003eassembly-${project.version}\u003c/id\u003e \u003c!-- 打包的类型，如果有N个，将会打N个类型的包 --\u003e \u003cformats\u003e \u003cformat\u003ezip\u003c/format\u003e \u003c!-- \u003cformat\u003etar.gz\u003c/format\u003e --\u003e \u003c/formats\u003e \u003c!-- tar.gz 压缩包下是否生成和项目名相同的根目录，有需要请设置成 true --\u003e \u003cincludeBaseDirectory\u003efalse\u003c/includeBaseDirectory\u003e \u003c!-- 将依赖jar打包到lib文件夹中 --\u003e \u003cdependencySets\u003e \u003cdependencySet\u003e \u003c!-- 是否把本项目添加到依赖文件夹下，有需要请设置成 true --\u003e \u003cuseProjectArtifact\u003efalse\u003c/useProjectArtifact\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003c!-- 将 scope 为 runtime 的依赖包打包 --\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003cexcludes\u003e \u003cexclude\u003e${groupId}:${artifactId}\u003c/exclude\u003e \u003c/excludes\u003e \u003c/dependencySet\u003e \u003c!-- 也可以配置在下面--\u003e \u003c!-- \u003cfileSets\u003e--\u003e \u003c!-- \u003cfileSet\u003e--\u003e \u003c!-- \u0026lt;!\u0026ndash; 设置需要打包的文件路径 \u0026ndash;\u0026gt;--\u003e \u003c!-- \u003cdirectory\u003eagent\u003c/directory\u003e--\u003e \u003c!-- \u0026lt;!\u0026ndash; 打包后的输出路径 \u0026ndash;\u0026gt;--\u003e \u003c!-- \u003coutputDirectory\u003e\u003c/outputDirectory\u003e--\u003e \u003c!-- \u003c/fileSet\u003e--\u003e \u003c!-- \u003c/fileSets\u003e--\u003e \u003c/dependencySets\u003e \u003cfileSets\u003e \u003c!-- 0755-\u003e即用户具有读/写/执行权限，组用户和其它用户具有读写权限； 0644-\u003e即用户具有读写权限，组用户和其它用户具有只读权限； --\u003e \u003c!-- 将src/bin目录下的所有文件输出到打包后的bin目录中 --\u003e \u003cfileSet\u003e \u003cdirectory\u003e${basedir}/bin\u003c/directory\u003e \u003coutputDirectory\u003ebin\u003c/outputDirectory\u003e \u003cfileMode\u003e0755\u003c/fileMode\u003e \u003cincludes\u003e \u003cinclude\u003e**.sh\u003c/include\u003e \u003cinclude\u003e**.bat\u003c/include\u003e \u003c/includes\u003e \u003c/fileSet\u003e \u003c!-- 指定输出target/classes中的配置文件到config目录中 --\u003e \u003cfileSet\u003e \u003cdirectory\u003e${basedir}/target/classes\u003c/directory\u003e \u003coutputDirectory\u003ebin\u003c/outputDirectory\u003e \u003cfileMode\u003e0644\u003c/fileMode\u003e \u003cincludes\u003e \u003cinclude\u003eapplication.properties\u003c/include\u003e \u003cinclude\u003eapplication.yml\u003c/include\u003e \u003c/includes\u003e \u003c/fileSet\u003e \u003c!-- 将第三方依赖打包到lib目录中 --\u003e \u003cfileSet\u003e \u003cdirectory\u003e${basedir}/target/lib\u003c/directory\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003cfileMode\u003e0755\u003c/fileMode\u003e \u003c/fileSet\u003e \u003c!-- 将项目启动jar打包到bin目录中 --\u003e \u003cfileSet\u003e \u003cdirectory\u003e${basedir}/target\u003c/directory\u003e \u003coutputDirectory\u003ebin\u003c/outputDirectory\u003e \u003cfileMode\u003e0755\u003c/fileMode\u003e \u003cincludes\u003e \u003cinclude\u003e${project.build.finalName}.jar\u003c/include\u003e \u003c/includes\u003e \u003c/fileSet\u003e \u003c!-- 包含根目录下的文件 --\u003e \u003c!-- \u003cfileSet\u003e--\u003e \u003c!-- \u003cdirectory\u003e${basedir}\u003c/directory\u003e--\u003e \u003c!-- \u003cincludes\u003e--\u003e \u003c!-- \u003cinclude\u003eNOTICE\u003c/include\u003e--\u003e \u003c!-- \u003cinclude\u003eLICENSE\u003c/include\u003e--\u003e \u003c!-- \u003cinclude\u003e*.md\u003c/include\u003e--\u003e \u003c!-- \u003c/includes\u003e--\u003e \u003c!-- \u003c","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:2:0","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"启动指令 # Windows平台 ## -Dloader.path ### 绝对路径 java -Dloader.path=D:/tmp/target/libs -jar xxx.jar ### 相对路径 java -Dloader.path=libs -jar xxx.jar # Windows平台 ## -Djava.ext.dirs ### 绝对路径 java -Djava.ext.dirs=D:/tmp/target/libs -jar xxx.jar ### 相对路径 java -Djava.ext.dirs=libs -jar xxx.jar # Linux平台 TODO 注意：spring-boot-maven-plugin下没有这句话，经测试无法使用-Dloader.path指定外部依赖进行运行 \u003c!--拷贝资源文件 copy-resources--\u003e \u003cplugin\u003e \u003cartifactId\u003emaven-resources-plugin\u003c/artifactId\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003ecopy-resources\u003c/id\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-resources\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003c/resource\u003e \u003c/resources\u003e \u003coutputDirectory\u003e${mzservice.path}/config\u003c/outputDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c!--copy 脚本，把bin目录下的文件复制到，打包目录下--\u003e \u003cexecution\u003e \u003cid\u003ecopy-bin\u003c/id\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-resources\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003ebin/\u003c/directory\u003e \u003c/resource\u003e \u003c/resources\u003e \u003coutputDirectory\u003e${mzservice.path}\u003c/outputDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:3:0","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"一些说明 1、通常，一个工程项目架构确定后，引入的jar包基本上不会变，改变的大部分是业务逻辑； 2、后面如果需要变更业务逻辑，只需要轻量地编译工程，大大提高项目部署的效率。 3、之前都是直接在idea里改好再打包了，所以没有直接引用外部文件过，通过查看SpringBoot官网，得知有下面的几种方法： 24.3 Application Property Files SpringApplication loads properties from application.properties files in the following locations and adds them to the Spring Environment: 1、A /config subdirectory of the current directory // 大概意思是：放在jar包同级目录下的子目录config 2、The current directory //大概意思是：放在jar包目录同级 3、A classpath /config package // 大概意思是在classpath下的config目录 4、The classpath root // classpath中 引用的优先级和上面的顺序是一样的。 其中springboot对于配置文件读取中文解释有如下方式： 1、读取jar包同级目录下的config目录中的properties文件，优先级最高； 2、读取jar包同级目录下的properties文件，优先级次之； 3、读取classpath下的config文件夹中的properties文件，优先级第三； 4、在classpath下直接放配置文件，优先级最低。 还有一种是用命令行 java -jar bootdemo-0.0.1-SNAPSHOT.jar --spring.config.location=./test.properties //此时test.properties和jar是同级目录 ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:4:0","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"未验证知识 ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:0","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"将项目resources下的文件，复制到config下。将bin下的启动脚本复制到打包目录，可根据自己的需求修改。 ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:1","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"配置清理插件，每次打包前，清理之前生成的打包目录。 \u003cplugin\u003e \u003cartifactId\u003emaven-clean-plugin\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003eauto-clean\u003c/id\u003e \u003cphase\u003einitialize\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003eclean\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cskip\u003efalse\u003c/skip\u003e \u003cfilesets\u003e \u003cfileset\u003e \u003cdirectory\u003e${mzservice.path}\u003c/directory\u003e \u003c/fileset\u003e \u003c/filesets\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:2","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"跳过测试 \u003c!--maven打包时，跳过测试--\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cskip\u003etrue\u003c/skip\u003e \u003c/configuration\u003e \u003c/plugin\u003e ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:3","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"其它说明 网上有些其它文章会使用spring-boot-maven-plugin 这个插件打包项目jar，个人觉得这个插件是对其它插件的一些封装，打包的jar会包含spring boot的一些东西,测试之后觉得和maven-jar-plugin打包的jar，使用上没什么区别。 ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:4","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"启动时省略-Dloader.path 另外一种启动方案是可以不加-Dloader.path=“D:develop/shared/fjar\"来指定路径，直接使用如下指令启动 java -jar mytest.jar 使用上述启动的话需要添加maven-jar-plugin插件，配置\u003cclasspathPrefix\u003e属性，另外在处理一些读取可执行jar中的文件时，可以使用maven-jar-plugin插件替换spring-boot-maven-plugin进行打包操作 \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-jar-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003carchive\u003e \u003cmanifest\u003e \u003c!--addClasspath表示需要加入到类构建路径--\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003c!--classpathPrefix指定生成的Manifest文件中Class-Path依赖lib前面都加上路径,构建出lib/xx.jar--\u003e \u003cclasspathPrefix\u003elib/\u003c/classpathPrefix\u003e \u003cmainClass\u003ecom.common.util.CommonUtilsApplication\u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003c/configuration\u003e \u003c/plugin\u003e 上述插件效果就是在打成的包里META_INF目录下的MANIFEST.MF文件里增加Class-path对应jar,这样在后面应用刚启动时就会根据Class-Path的只去加载需要的版本依赖（解决在共享目录里存在多版本加载引用冲突问题），这个效果就等效加参数-classpath xxx（具体的jar）。此时就是将需要的jar目录lib放在和要运行的xxx.jar同级目录即可，启动时就可以不加-Dloader.path参数了，如果lib目录和要运行的xxx.jar不在同级目录的话，则需要使用-Dloader.path来启动 如下：在同一级目录启动 不在同一级目录启动： 其中**-Dloader.path可以指定多个目录**，这样在存在多个微服务情况下可将一些公共用到的jar放在一个共享目录中，每个微服务独有的jar可以放在微服务私有的目录下（解决jar版本冲突问题）,示例如下： 注意： 1、使用-Dloader.path需要在打包的时候增加\u003clayout\u003eZIP\u003c/layout\u003e，不指定的话-Dloader.path不生效。对于多个微服务瘦身打包建议使用maven-jar-plugin打包，避免因为spring-boot-maven-plugin打包机制导致的一些应用启动问题（已踩坑） 2、若存在不同版本依赖：比如项目A依赖Y库的1.0版本，项目B依赖Y库的2.0版本，那么可能会出现版本依赖冲突（两个版本不兼容的情况下），解决方案： 　2.1、能做到版本一致就保持使用同一个版本，保证版本一致。可以使用maven的版本依赖管理进行处理，即在父pom文件使用\u003cdependencyManagement\u003e统一管理依赖版本 　2.2、让项目各自依赖所需的版本并打进war包中，把其他同版本的jar包放在同一个共享包下 测试发现依赖在查找时从上往下找，匹配到就用第一个，如下图会使用comm-0.0.1.jar版本的 附注： 使用spring-boot-maven-plugin插件，会将依赖的jar包全部打包进去，这样就可以直接运行生成的 JAR 包，简化了我们开发操作。 使用spring-boot-maven-plugin插件如果不指定程序主运行入口类的话默认为Main-Class: org.springframework.boot.loader.JarLauncher 这个可以自定义执行主入口类，有以下几种方式： 1.POM继承spring-boot-starter-parent \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.1.9.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003cproperties\u003e \u003c!-- The main class to start by executing java -jar --\u003e \u003cstart-class\u003eccom.notes.JavaNotesApplication\u003c/start-class\u003e \u003c/properties\u003e 2.POM不是继承spring-boot-starter-parent时需指定 \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.1.9.RELEASE\u003c/version\u003e \u003cconfiguration\u003e \u003cmainClass\u003ecom.notes.JavaNotesApplication\u003c/mainClass\u003e \u003clayout\u003eZIP\u003c/layout\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 3.POM不是继承spring-boot-starter-paren，且使用maven-jar-plugin插件来指定执行的类 \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-jar-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003carchive\u003e \u003cmanifest\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003cuseUniqueVersions\u003efalse\u003c/useUniqueVersions\u003e \u003cclasspathPrefix\u003elib/\u003c/classpathPrefix\u003e \u003cmainClass\u003ecom.notes.JavaNotesApplication\u003c/mainClass\u003e \u003c/manifest\u003e \u003cmanifestEntries\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/manifestEntries\u003e \u003c/archive\u003e \u003c/configuration\u003e \u003c/plugin\u003e ","date":"2021-10-26","objectID":"/springserver-maven-exclude-lib-note/:5:5","tags":["Maven","SpringCloud","SpringBoot"],"title":"SpringCloud/SpringBoot分离依赖打包","uri":"/springserver-maven-exclude-lib-note/"},{"categories":["Back","note"],"content":"记录maven-dependency-plugin插件使用笔记","date":"2021-10-26","objectID":"/maven-dep-note/","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"简介 maven-dependency-plugin是处理与依赖相关的插件。它有很多可用的goal，大部分是和依赖构建、分析和解决相关的goal，这部分goal可以直接用maven的命令操作，例如：mvn dependency:tree、mvn dependency:analyze；这类操作在平时的maven应用中很少会用到。这里主要介绍除此之外的、用得最多的几个操作：copy, copy-dependencies和它们对应的unpack, unpack-dependencies ","date":"2021-10-26","objectID":"/maven-dep-note/:1:0","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"使用 首先声明插件： Xml代码 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e ","date":"2021-10-26","objectID":"/maven-dep-note/:2:0","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"copy 和 unpack copy操作可以用来将某个（些）maven artifact(s)拷贝到某个目录下。添加phase和goal如下： Xml代码 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 比如把junit拷到libs目录下 \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003coutputDirectory\u003e${project.build.directory}/libs\u003c/outputDirectory\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 执行mvn package打包命令之后，会多出libs目录 然后就是配置，copy可以的配置的项比较多，详细的请参考：copy配置。下面是一些常用项说明： Name Type Since Description artifactItems List 1.0 Collection of ArtifactItems to work on. (ArtifactItem contains groupId, artifactId, version, type, classifier, outputDirectory, destFileName and overWrite.) See Usage for details. outputDirectory File 1.0 Default output location used for mojo, unless overridden in ArtifactItem. Default value is: ${project.build.directory}/dependency. User property is: outputDirectory. prependGroupId boolean 2.7 Prepend artifact groupId during copy Default value is: false. User property is: mdep.prependGroupId. prependGroupId: 用来指示拷出来的library名字需要不需要加上groupId，默认是不加 outputDirectory: 用来指定拷出后Libraries的存放地 这里除了artifactItems没有默认值，需要指定外，所有其他的选项都可以被忽略： Xml代码 \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003c/configuration\u003e 以上配置会将junit包拷到target/dependency目录下，文件名为：junit-4.11.jar。 如果想把它拷到lib目录下，可以如下配置： Xml代码 \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003c/configuration\u003e 或者： Xml代码 \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003c/configuration\u003e 根据上面的说明，artifactItem里可以有以下几个参数： groupId artifactId version type classifier outputDirectory destFileName overWrite 同样的参数，artifactItem里的优先级更高，例如： Xml代码 \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003c/artifactItem\u003e \u003cartifactItem\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.7\u003c/version\u003e \u003coutputDirectory\u003elib2\u003c/outputDirectory\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003c/configuration\u003e 其中junit会拷到lib目录下，因为它没有定义自己的outputDirectory；slf4j-log4j12会拷到lib2下，因为它定义了自己的outputDirectory。 unpack和copy类似，只不过它会把拷来的包解开，例如： Xml代码 \u003cexecutions\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003eunpack\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003cconfiguration\u003e \u003cartifactItems\u003e \u003cartifactItem\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003c/artifactItem\u003e \u003cartifactItem\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.7\u003c/version\u003e \u003coutputDirectory\u003elib2\u003c/outputDirectory\u003e \u003c/artifactItem\u003e \u003c/artifactItems\u003e \u003coutputDirectory\u003elib\u003c/outputDirectory\u003e \u003c/configuration\u003e 执行mvn package打包命令之后,slf4j复制到lib目录下,junit复制到libs目录下 则junit和slf4j-log4j12拷完以后，放到lib和lib2下的不再是Jar包，还是Jar包里的内容。 ","date":"2021-10-26","objectID":"/maven-dep-note/:2:1","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"copy-dependencies 和 unpack-dependencies 上面介绍的copy 和 unpack操作是由要拷某个包，这个包需要具体指定要拷哪个包，与当前工程的依赖没有关系。copy-dependencies和它有点类似，但是它是用来拷当前工程的依赖包的，典型的，例如我们有一个web应用，当打成war包的时候，它所有的依赖也需要被打到应用中。 copy-dependencies的参数有很多，详细的可以参考：copy-dependencies Doc，但是几乎所有都有默认值。所以一个最简单的定义如下： Xml代码 \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-dependencies\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 这里没有指定任何配置，所有的参数都用默认值，则当前工程的所有依赖（直接、间接的）都会被拷到target/dependency目录下。 也可以使用outputDirectory指定存放在。另外，以下几个参数可以控制哪些依赖将被拷出（或排除）： Name Type Since Description excludeArtifactIds String 2.0 Comma separated list of Artifact names to exclude. User property is: excludeArtifactIds. excludeClassifiers String 2.0 Comma Separated list of Classifiers to exclude. Empty String indicates don’t exclude anything (default). User property is: excludeClassifiers. excludeGroupIds String 2.0 Comma separated list of GroupId Names to exclude. User property is: excludeGroupIds. excludeScope String 2.0 Scope to exclude. An Empty string indicates no scopes (default). User property is: excludeScope. excludeTransitive boolean 2.0 If we should exclude transitive dependencies Default value is: false. User property is: excludeTransitive. excludeTypes String 2.0 Comma Separated list of Types to exclude. Empty String indicates don’t exclude anything (default). User property is: excludeTypes. includeArtifactIds String 2.0 Comma separated list of Artifact names to include. User property is: includeArtifactIds. includeClassifiers String 2.0 Comma Separated list of Classifiers to include. Empty String indicates include everything (default). User property is: includeClassifiers. includeGroupIds String 2.0 Comma separated list of GroupIds to include. User property is: includeGroupIds. includeScope String 2.0 Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:runtime scope gives runtime and compile dependencies,compile scope gives compile, provided, and system dependencies,test (default) scope gives all dependencies,provided scope just gives provided dependencies,system scope just gives system dependencies. User property is: includeScope. includeTypes String 2.0 Comma Separated list of Types to include. Empty String indicates include everything (default). User property is: includeTypes. 例如当前工程有以下依赖： Xml代码 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.11\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.7\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.camel\u003c/groupId\u003e \u003cartifactId\u003ecamel-script\u003c/artifactId\u003e \u003cversion\u003e2.13.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.camel\u003c/groupId\u003e \u003cartifactId\u003ecamel-spring\u003c/artifactId\u003e \u003cversion\u003e2.13.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.camel\u003c/groupId\u003e \u003cartifactId\u003ecamel-xstream\u003c/artifactId\u003e \u003cversion\u003e2.13.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jms\u003c/artifactId\u003e \u003cversion\u003e3.2.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-tx\u003c/artifactId\u003e \u003cversion\u003e3.2.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.activemq\u003c/groupId\u003e \u003cartifactId\u003eactivemq-all\u003c/artifactId\u003e \u003cversion\u003e5.10.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.thoughtworks.xstream\u003c/groupId\u003e \u003cartifactId\u003exstream\u003c/artifactId\u003e \u003cversion\u003e1.4.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.ogce\u003c/groupId\u003e \u003cartifactId\u003expp3\u003c/artifactId\u003e \u003cversion\u003e1.1.6\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 要排除所有scope为test的依赖： Xml代码 \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/vers","date":"2021-10-26","objectID":"/maven-dep-note/:2:2","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"插件目标(goals)标签说明 1、analyze：分析项目依赖，确定哪些是已使用已声明的，哪些是已使用未声明的，哪些是未使用已声明的 2、analyze-dep-mgt：分析项目依赖，列出已解析的依赖项与dependencyManagement中定义的依赖项不匹配的部分 3、analyze-report：分析项目依赖关系，并生成一个报告，该报告总结一下内容：使用和声明；使用和未声明的；未使用和声明 4、analyze-duplicate：分析pom.xml中的\u003cdependencies/\u003e和\u003cdependencyManagement/\u003e标记，确定重复声明的依赖项 5、build-classpath：告诉Maven以java.cp中使用的类路径格式从本地存储库输出依赖项的路径。类路径文件也可以与主要工件一起附加和安装/部署 6、copy：获取插件配置部分中定义的工件列表，并将它们复制到指定位置，重命名它们或根据需要剥离版本。如果本地存储库或者反应堆中都不存在远程工件，则此目标可以解决这些工件。 7、copy-dependencies：列出项目直接依赖项和(可选)传递性依赖项的列表，并将其复制到指定位置，如果需要，剥离版本。该目标也可以从命令行运行。 8、display-ancestors：显示项目所有祖先pom。在想要了解项目所有的父poms的连续集成系统中，这可能很有用。该目标也可以从命令行运行。 8、get：最终以可传递方式从指定的远程存储库解析单个工件 9、go-offline：让maven解决该项目所依赖的所有内容(依赖项、插件、报告)，以准备脱机 10、list：解析别名，列出项目的所有依赖项 11、list-repositores：显示项目所有依赖关系，然后列出使用的存储库 12、properties：为每个项目依赖项设置一个属性，该属性包含文件系统上工件 13、purge-local-repository：清除本地存储库中的依赖，并重新解析 14、resolve：告诉Maven解析所有依赖项并显示版本。JAVA 9注意： 在使用Java 9运行时将显示模块名称。 15、resolve-plugins：告诉Maven解决插件及其依赖项 16、sources：告诉Maven解析所有依赖项及其源附件、并显示版本 17、tree：显示该项目的依赖关系树 18、unpack：与copy功能一直，但是会解压缩 19、unpack-dependencies：与copy-dependencies功能一致，只是会解压 ","date":"2021-10-26","objectID":"/maven-dep-note/:2:3","tags":["Maven","Plugin","Dependency"],"title":"maven-dependency-plugin插件使用笔记","uri":"/maven-dep-note/"},{"categories":["Back","note"],"content":"记录Mysql索引笔记","date":"2021-10-19","objectID":"/mysql-index-note/","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"B+ 树的优缺点 ","date":"2021-10-19","objectID":"/mysql-index-note/:1:0","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"优点 单次请求涉及的磁盘IO次数少（出度d大，且非叶子节点不包含表数据，树的高度小）； 查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）； 遍历效率高（从符合条件的某个叶子节点开始遍历即可）； 在B+树中， 由于底层的各个叶子节点都通过指针组织成一个双向链表， 结构如下图所示。 因此，只需要从跟节点到叶子节点定位到第一个满足条件的Key, 然后不断在叶子节点迭代next指针即可实现遍历，此时相当于顺序IO。相反，如果通过每次从根节点查找进行遍历，相当于进行随机IO，效率低下，如下图所示： ","date":"2021-10-19","objectID":"/mysql-index-note/:1:1","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"缺点 B+树最大的性能问题在于会产生大量的随机IO，主要存在以下两种情况： 主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片； 即使主键是有序递增的，大量写请求的分布仍是随机的； ","date":"2021-10-19","objectID":"/mysql-index-note/:1:2","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"mysql的索引底层原理 ","date":"2021-10-19","objectID":"/mysql-index-note/:2:0","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"什么是索引 概念：索引是提高mysql查询效率的数据结构。总的一句话概括就是索引是一种数据结构。 数据库查询是数据库的最主要功能之一。设计者们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如：有顺序查找、折半查找、快速查找等。 但是每种查找算法都只能应用于特定的数据结构之上，例如顺序查找依赖于顺序结构，折半查找通过二叉查找树或红黑树实现二分搜索。因此在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这种数据结构，就是索引。 ","date":"2021-10-19","objectID":"/mysql-index-note/:2:1","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"Mysql索引原理 目前大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。 从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。 那么为什么mysql的索引选择B+数呢？ 红黑树也可以作为数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这里结合计算的组成原理来深入的分析。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，硬盘I/O存取的消耗要高几个数量级，查找过程中磁盘I/O的存取次数。 为什么硬盘的存取会如此的慢呢？ 这个就要讲硬盘的读写原理，硬盘有很多种，但是都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。 所有的盘片都固定在一条轴上，那条轴叫做盘片主轴，所有的盘片都是绝对平行的，也形成一个柱体，每个盘片上都有一个磁头，每个磁头都在同意轴线上，就是从上方往下看，磁头是绝对重叠的。 所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动，磁头可沿盘片的半径方向移动，实际上是斜切运动，每个磁头同一时刻必须是同轴的盘片以每分钟数千转到上万转的速度在高速运转，这样磁头就能对盘片上的指定位置进行数据的读写操作。结构图如下： 磁盘数据的读写原理 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。 当磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。 为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 即一次磁盘的读写操作完成过程由三个动作组成： 寻道（时间）：磁头移动定位到指定磁道。 旋转延迟（时间）：等待指定扇区从磁头下旋转经过。 数据传输（时间）：数据在磁盘与内存之间的实际传输 额外知识： （1）盘面：硬盘的每一个盘片都有上下两个盘面，一般每个盘面都会得到利用，都可以存储数据，盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。 （2）磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁道从外向内从 0 开始顺序编号，信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧。 （3）所有盘面上的同一磁道构成一个圆柱，通常称作柱面。所有盘面上的同一磁道构成一个圆柱，通常称作柱面。数据的读 / 写按柱面进行，而不按盘面进行，当一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个扇区开始写数据，读数据也按照这种方式进行，这样就提高了硬盘的读 / 写效率。 提高磁盘数据读写原理 局部性原理与磁盘预读。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。 这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。 所以，程序运行期间所需要的数据通常应当比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 预读的长度一般为页（page）4k的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。 当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 在硬盘中由于涉及到机械运动，所以一次的磁盘IO消耗的时间是非常大的，于内存的读取速度相比，就好比光速与声速的比较。那么回到我们的主题上为什么使用B+树作为数据结构呢？ B树、B-树、B+树、红黑树性能分析 对于B树和、B-树、B+树这里只做简单的介绍，详细的特性请看着一篇[]。 B树性能分析：B树是二叉查找平衡树，但是B树一个节点只存一个关键字，在大量数据的时候，B树树高非常大，性能低下。 B-树性能分析：B-树对B树性能做了很大优化，但是B-树在大量数据的时候，也会访问到叶子节点，这样性能也是大大降低。 根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存）。一般实际应用中，出度d（树中各个节点的度的最大值）是非常大的数字，通常超过100，因此树高h非常小（通常不超过3）。 模拟查找关键字 36 的过程： 根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】 比较关键字 36在区间（17,35），找到磁盘块 1 的指针 P3。 根据 P3指针找到磁盘块 4，读入内存。【磁盘 I/O 操作第 2 次】 比较关键字 36在区间（65,87），找到磁盘块 4 的指针 P1。 根据 P1 指针找到磁盘块 9，读入内存。【磁盘 I/O 操作第 3 次】 在磁盘块 98中的关键字列表中找到关键字 36。 分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。 红黑树性能分析：而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 B+树性能分析：B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。 在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。 B+Tree更适合外存索引，从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小。 在B+树的结构中，只在叶子节点存储数据，在非叶子节点中只存储的索引，在非叶子节点中可以有更大的空间储存更多的索引，这样B+树的出度d就可以大大的增加，从而降低的B+树的高度h，B树中一个节点的大小为一个page的大小，也就是一次IO的读取，h越小IO的次数就可以减少： dmax=floor(pagesize/(keysize+datasize+pointsize)) floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。 Mysql的InnoDB的索引的结构如下图所示： 在MySQL中，不同存储引擎对索引的实现方式是不同的，Mysql有MyISAM和InnoDB两个存储引擎的索引实现方式，下面就来分别介绍这两种存储引擎。 ","date":"2021-10-19","objectID":"/mysql-index-note/:2:2","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"Mysql引擎 MyISAM 在MyISAM储存引擎中，数据和索引文件试试分开储存的，Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。 Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。 Myisam 也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。 可以看出MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的如下图： MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。 InnoDB 在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。 在InnoDB虽然底层也是B+树实现的方式，当时与MyISAM却有明显的区别，在InnoDB实现的索引结构中，索引文件和数据文件是一起的，InnoDB中索引文件中的key就是数据表中的主键索引，因此InnoDB的索引文件也是主索引文件。如下图所示： 在InnoDB中的叶子节点中把保存和完整的数据，这就是聚集索引。因为InnoDB是按照主键聚集的，要是InnoDB没有主键就会找数据表中的位置标志的字段作为主键，要是没有这种字段就会隐世的生成唯一标识的主键，生成的主键默认为长整型，6个字节。 而MyISAM可以要求没有主键，这是这两者的一个明显的区别。另一个区别就是辅助索引的叶子节点的data域存储的是主键的值，而不是行数据。 所以，当查询不是按照主键查询时候就会先在辅助索引树上先找到主键的值，然后再到主索引树找到对应的行数据的值，这叫做回表，回表降低了表的查询效率。 如果给另一个字段指定为普通索引，则普通索引树的结构如下图所示： 知道了索引的底层原理的实现还是有很大的帮助的，例如：主键至不要过大，因为所有的普通索引都引用主索引，索引本身是占内存的，若是索引过大，这样就会大大影响查询的效率。 InnoDB其它特点： 在InnoDB 中存在表锁和行锁，不过行锁是在命中索引的情况下才会起作用，当索引失效时行锁也会失效。InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读；而在 Oracle 数据库中，只支持串行化级别和读已提交这两种级别，其中默认的为读已提交级别。 ","date":"2021-10-19","objectID":"/mysql-index-note/:2:3","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"Mysql索引最左匹配原则的理解 CREATETABLE`student`(`id`int(11)NOTNULLAUTO_INCREMENT,`name`varchar(255)DEFAULTNULL,`cid`int(11)DEFAULTNULL,PRIMARYKEY(`id`),KEY`name_cid_INX`(`name`,`cid`),KEY`name_INX`(`name`))ENGINE=InnoDBAUTO_INCREMENT=8DEFAULTCHARSET=utf8 ","date":"2021-10-19","objectID":"/mysql-index-note/:3:0","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"执行1 EXPLAINSELECT*FROMstudentWHEREname='小红'; ","date":"2021-10-19","objectID":"/mysql-index-note/:3:1","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"执行2 EXPLAINSELECT*FROMstudentWHEREcid=1; EXPLAINSELECT*FROMstudentWHEREcid=1ANDname='小红'; ","date":"2021-10-19","objectID":"/mysql-index-note/:3:2","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"为什么还能匹配索引？ 你的疑问是：sql查询用到索引的条件是必须要遵守最左前缀原则，为什么上面两个查询还能用到索引？ 讲上面问题之前，我先补充一些知识，因为我觉得你对索引理解是狭隘的： 上述你的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。你的查询中分别是： type: index type: ref 解释 ​ index：这种类型表示是mysql会对整个该索引进行扫描。 ​ 要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。 ​ 但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。 所以 对于你的第一条语句： EXPLAINSELECT*FROMstudentWHEREcid=1; 判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，可以进行index类型的索引扫描方式。explain显示结果使用到了索引，是index类型的方式。 ref ​ 这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。 ​ 而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。 ​ 简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。 有些了解的人可能会问，索引不都是一个有序排列的数据结构么。不过答案说的还不够完善，那只是针对单个索引，而复合索引的情况有些同学可能就不太了解了。 下面就说下复合索引： 以该表的(name,cid)复合索引为例,它内部结构简单说就是下面这样排列的： mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。 其实就相当于实现了类似 order by name cid这样一种排序规则。 所以 ​ 第一个name字段是绝对有序的，而第二字段就是无序的了。 ​ 所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。 ​ 这就是所谓的mysql为什么要强调最左前缀原则的原因。 ","date":"2021-10-19","objectID":"/mysql-index-note/:3:3","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"那么什么时候才能用到呢? ​ 当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？ ​ 观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。 ​ 发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4 5。 ​ 这也就是Mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。 所以对于你的这条sql查询： EXPLAINSELECT*FROMstudentWHEREcid=1ANDname='小红'; 没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。 你可能会问 ​ 我建的索引是(name,cid)。 ​ 而我查询的语句是cid=1 AND name=‘小红’; 我是先查询cid，再查询name的，不是先从最左面查的呀？ ​ 好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name=‘小红’ and cid=1; 最后所查询的结果是一样的。 ​ 那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？ 所以　 ​ 而此时那就是我们的Mysql查询优化器该登场了，Mysql查询优化器会判断纠正这条Sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。 ​ 所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。 ","date":"2021-10-19","objectID":"/mysql-index-note/:3:4","tags":["DataBase","Mysql","Index","MysqlNote"],"title":"Mysql索引笔记","uri":"/mysql-index-note/"},{"categories":["Back","note"],"content":"记录Redis缓存机制与应用的笔记","date":"2021-10-18","objectID":"/redis-note/","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":" Redis是目前最为主流的缓存技术之一，Redis基于内存操作从而拥有强大的性能，可以达到每秒10万次的请求，可以说是一款非常强大的缓存技术了。 ","date":"2021-10-18","objectID":"/redis-note/:0:0","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"基础知识介绍 NoSQL概述 什么是NoSQL？ NoSQL = Not Only SQL （不仅仅是SQL） 关系型数据库：表格 ，行 ，列 非关系型数据库：没有固定的查询语言，键值对存储，列存储，文档存储 随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区。 NoSQL 特点 1、方便扩展 2、大数据量高性能（Redis 一秒写8万次，读取11万） 3、数据类型是多样性的 NoSQL四大分类 KV键值对：如Redis主要是用于内容缓存，主要是为了处理大量数据高访问负载 文档型数据库：如MongoDBMongoDB 是一个基于分布式文件存储的数据库 列存储数据库：如HBase分布式文件系统，以列簇式存储，将同一列数据存储在一起 图关系数据库：如Neo4j他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！ Redis简介 Redis 是什么？ Redis（Remote Dictionary Server )，即远程字典服务，它是一个开源的由ANSI C语言编写，性能优秀、支持网络、可持久化的Key-Value内存的NoSQL数据库! Redis 能干嘛？ 1、内存存储、持久化。 2、效率高，可以用于高速缓存 3、发布订阅系统 4、计时器、浏览量！ 5、…….. Redis好处 主要从“高性能”和“高并发”这两点来介绍。 把数据库数据存入缓存，请求直接从内存中读取不用经过数据库，减轻数据库压力并且提升性能。 ","date":"2021-10-18","objectID":"/redis-note/:1:0","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"常用技术讲解与缓存机制 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 String String：session、对象、小文件（存文件流字节数组，比磁盘IO快）？ int：秒杀、限流、计数 bitmap： 场景1.setbit和bitcount结合可以统计一年365天哪天有用户操作过，getbit可以获取某一天是否用户操作过 场景2.权限控制，比如每个权限对应一个bit,哪个用户有该权限，该位为1，没权限为0 list 替换java jvm中的集合，可以作为数据共享，java的话多进程间不能共享或不好共享 hash 可以使redis key变少，类似对象。 场景1.商品详情页、商品对应的收藏数、库存啊，放在redis中因为是原子性的，多地方访问都是实时性的 场景2.聚合场景：一个对象在数据库中可能各个属性在不同表，可以聚合到redis同个对象中 set set性能慢，可以单独redis实例 场景1.SRANDMEMBER或者spop命令可以用来抽奖 场景2.随机事件 场景3.共同好友（交集） 场景4.推荐好友（差集） sorted_set 有序集合，数量少时底层是zipList压缩表，数据多了变skiplist 场景1.排行榜 场景2.有序事件 场景3.评论分页 Redis 中除开最常用的 5 种数据类型之外，还有 3 种特殊的数据类型 可以通过help命令查询相关类型命令说明，比如： help @string help @list1 分享一下我记录的几种数据类型的基本命令 String #设置值 set key value #获取值 get key #获取值类型（set的都是String） type key #获取值编码类型(raw/int) object encoding key #获取字节长度(注意1字节等于8位bit) strlen key #+1计算 #incr key1 bitmap（二进制操作） #设置该值左边第几位为1，bit长度不是8位整数的补成8的整数长度,如 10会补成00000010， 0100000001 会补成0000000100000001 格式：setbit key offset value setbit k1 1 1 #01000000 对应ascii码为‘@’ get k1 #'@' #将k1值得第7位设置为1 setbit k1 7 1 #01000001 对应ascii码为‘A’ setbit k1 8 1 #0100000110000000 #获取对应位置bit的值（1或0） getbit key offset getbit k1 7 #假如k1值位00000001，第7位返回1 getbit k1 5 #假如k1值位00000001，第5位返回0 #获取对应范围内1的数量（注意范围是字节区间，不是Bit位区间） bitcount key [start end] bitcount k1 #获取bit位为1的数量 相当于bitcount k1 0 -1（假如k1值位00001001，返回2，假如k1值位0000000100001001，返回3） bitcount k1 0 0 #获取第一个字节的8位Bit中有几位为1 （假如k1值位0000000100001001，返回1），注意是从左边开始数每8位为一个字节 #与、或、非、异或操作 bitop opration destkey key [key...] #opration可选值（and/or/not）,destkey为计算完后要保存的新的key bitop and k3 k1 k2 #与运算，假如k1为01000000，k2为00000001，则结果k3为00000000 bitop or k3 k1 k2 #或运算，假如k1为01000000，k2为00000001，则结果k3为01000001 bitop xor k3 k1 k2 #异或运算，假如k1为01000000，k2为01000001，则结果k3为00000001 bitop not k3 k1 #非运算，假如k1为01000000，则结果k3为101111111 list(链表) #左边插入 格式：lpush key value [value...] lpush k1 1 2 3 4 5 6 #k1值为六项：6 5 4 3 2 1 #右边插入 格式：rpush key value [value...] rpush k1 1 2 3 4 5 6 #k1值为六项：1 2 3 4 5 6 #获取k1范围内的的值 lrange k1 0 -1 #获取第一个数（最左边的数）并删除该值（像栈操作） lpop key #k1值为六项：1 2 3 4 5 6 那么会返回1，k1值变为2 3 4 5 6 #获取指定下标值 lindex key #删除范围之外的数值 ltrim key start end ltrim k1 0 3 #k1值为六项：1 2 3 4 5 6,那么k1只留下1 2 3 41 hash（对象） #设置对象属性值 hset key field value hset user1 name huangtl #设置user1的name属性为huangtl hset user1 age 18 #设置user1的age属性为18 #单个属性获取 hget user1 age #18 #所有属性获取 hgetall user1 #返回属性、值、属性、值 ：name huangtl age 18 #获取对象所有key hkeys user1 #返回user1的所有属性:name age #获取对象所有kvalue hvals user1 #返回user1的所有属性得值:huangtl 181 set(无序、去重集合) #存入集合数据 sadd key member [member...] sadd k1 1 2 3 4 5 6 2 #两个2知会存一个2，集合内数值有1 2 3 4 5 6 #获取集合数据 SMEMBERS k1 #随机获取集合几条数据 SRANDMEMBER k1 [count] SRANDMEMBER k1 #随机获取一条 SRANDMEMBER k1 8 #随机获取8条数据，不会重复的数据，集合不足8条取集合全部数据 SRANDMEMBER k1 -8 #随机取8条，可能会重复的数据，集合不足8条也会取8条数据 #取数值并删除 spop key [count] spop key #随机取一条并删除 spop key 5 #随机取5条并删除 #多个集合取并集 SUNION key [key...] SUNION k1 k2 #假如k1为1 2 3 4 5 6 ，k2为4 5 6 7 8 9，则返回1 2 3 4 5 6 7 8 9 #多个集合取交集 SINTER key [key...] SINTER k1 k2 #假如k1为1 2 3 4 5 6 ，k2为4 5 6 7 8 9，则返回4 5 6 #多个集合取差集 sdiff key [key...] sdiff k1 k2 #按顺序取k1减掉k2中的值后剩下的值 #假如k1为1 2 3 4 5 6 ，k2为4 5 6 7 8 9，则返回1 2 3 sdiff k2 k1 #按顺序取k2不减掉k1中的值值后剩下的值 #假如k1为1 2 3 4 5 6 ，k2为4 5 6 7 8 9，则返回7 8 9 1 sorted_set（有序集合） #新建key并添加元素 zadd key score member [score member...] zadd set1 1 apple 2 orange 3 banana #返回范围内集合数据，按score分值正序 zrange set1 0 -1 #默认返回 apple orange banana zrange set1 -2 -1 #按正序取最后两名，返回 orange banana ZREVRANGE set1 0 1 #倒序返回前两名，返回 banana orange #获取元素位置 zrank set1 apple #返回0，代表apple在第一位1 事务 Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！ Redis单条命令式保存原子性的，但是事务不保证原子性！ # 开启事务 multi #命令入队 set k1 v1 set k2 v2 get k2 # 执行事务 exec 1 Redis持久化 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 redis提供两种持久化机制 RDB（默认） 和 AOF 机制。 1、RDB RDB是Redis DataBase缩写快照 ，默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb 触发机制 （1）save的规则满足的情况下 （2）执行 flushall 命令 （3）退出redis，也会产生 rdb 文件 2、AOF： 持久化，AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 AOF的三种策略（1）always （2）everysec(默认值) （3）no always 在应用时，要根据自己的实际需求，选择RDB或者AOF，其实，如果想要数","date":"2021-10-18","objectID":"/redis-note/:2:0","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"使用场景、缓存问题 1、热点数据的缓存 公司项目用户量达到一定数量的时候，这时合理的利用缓存不仅能够提升项目访问速度，还能大大降低数据库的压力。 2、业务上的统计，排行榜 为了保证数据实时效，比如项目的访问量，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力 3、限时业务的运用 每日签到、限制登录功能等业务场景 4、消息队列 提供基本的发布订阅功能，但不像消息队列那种专业级别 缓存雪崩 原因：大量redis key在同一时间失效，导致大量请求访问数据库，数据库服务器宕机，线上服务大面积报错。 解决办法： （1）redis高可用 （2）加锁排队，限流降级 （3）缓存失效时间均匀分布 缓存穿透 原因：指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决办法： （1）接口层增加校验 （2）采用布隆过滤器 缓存击穿 原因：指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。比如微博热搜。 解决办法： （1）设置热点数据缓存没有过期时间 （2）加互斥锁 ","date":"2021-10-18","objectID":"/redis-note/:3:0","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"redis中的hash扩容渐进式rehash过程 背景： redis字典（hash表）当数据越来越多的时候，就会发生扩容，也就是rehash 对比：java中的hashmap，当数据数量达到阈值的时候(0.75)，就会发生rehash，hash表长度变为原来的二倍，将原hash表数据全部重新计算hash地址，重新分配位置，达到rehash目的 ","date":"2021-10-18","objectID":"/redis-note/:4:0","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"redis中的hash表采用的是渐进式hash的方式： 1、redis字典（hash表）底层有两个数组，还有一个rehashidx用来控制rehash 2、初始默认hash长度为4，当元素个数与hash表长度一致时，就发生扩容，hash长度变为原来的二倍 3、redis中的hash则是执行的单步rehash的过程： 每次的增删改查，rehashidx+1，然后执行对应原hash表rehashidx索引位置的rehash ","date":"2021-10-18","objectID":"/redis-note/:4:1","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"总结： 在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下： 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表 将rehashindex的值设置为0，表示rehash工作正式开始 在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1 随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束 渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。 需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果index大于rehashindex，访问ht[0]，否则访问ht[1]。 ","date":"2021-10-18","objectID":"/redis-note/:4:2","tags":["Database","Redis","Cash"],"title":"Redis缓存机制与应用","uri":"/redis-note/"},{"categories":["Back","note"],"content":"记录MySQL的concat以及group_concat的用法笔记","date":"2021-10-15","objectID":"/mysql-func-note/","tags":["Database","Mysql","Function"],"title":"concat以及group_concat的用法","uri":"/mysql-func-note/"},{"categories":["Back","note"],"content":"本文中使用的例子均在下面的数据库表tt2下执行： 一、concat()函数 1、功能：将多个字符串连接成一个字符串。 2、语法：concat(str1, str2,…) 返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 3、举例： 例1:select concat (id, name, score) as info from tt2; 中间有一行为null是因为tt2表中有一行的score值为null。 例2：在例1的结果中三个字段id，name，score的组合没有分隔符，我们可以加一个逗号作为分隔符： 这样看上去似乎顺眼了许多～～ 但是输入sql语句麻烦了许多，三个字段需要输入两次逗号，如果10个字段，要输入九次逗号…麻烦死了啦，有没有什么简便方法呢？——于是可以指定参数之间的分隔符的concat_ws()来了！！！ 二、concat_ws()函数 1、功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符～（concat_ws就是concat with separator） 2、语法：concat_ws(separator, str1, str2, …) 说明：第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。 3、举例： 例3:我们使用concat_ws()将 分隔符指定为逗号，达到与例2相同的效果： 例4：把分隔符指定为null，结果全部变成了null： 三、group_concat()函数 前言：在有group by的查询语句中，select指定的字段要么就包含在group by语句的后面，作为分组的依据，要么就包含在聚合函数中。（有关group by的知识请戳：浅析SQL中Group By的使用）。 例5： 该例查询了name相同的的人中最小的id。如果我们要查询name相同的人的所有的id呢？ 当然我们可以这样查询： 例6： 但是这样同一个名字出现多次，看上去非常不直观。有没有更直观的方法，既让每个名字都只出现一次，又能够显示所有的名字相同的人的id呢？——使用group_concat() 1、功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 2、语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] ) 说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。 3、举例： 例7：使用group_concat()和group by显示相同名字的人的id号： 例8：将上面的id号从大到小排序，且用'_‘作为分隔符： 例9：上面的查询中显示了以name分组的每组中所有的id。接下来我们要查询以name分组的所有组的id和score： ","date":"2021-10-15","objectID":"/mysql-func-note/:0:0","tags":["Database","Mysql","Function"],"title":"concat以及group_concat的用法","uri":"/mysql-func-note/"},{"categories":["Back","note"],"content":"记录Java自建类操作笔记","date":"2021-10-15","objectID":"/java-selfclass-note/","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"使用工具类判断对象里面的属性的值是否相等 例如下述Java类： import java.io.Serializable; import java.util.List; public class Bean_Topology implements Serializable { private static final long serialVersionUID = 1L; public static long getSerialversionuid() { return serialVersionUID; } private Long topology_pk; private String topology_id; public String getTopology_id() { return topology_id; } public void setTopology_id(String topology_id) { this.topology_id = topology_id; } public Long getTopology_pk() { return topology_pk; } public void setTopology_pk(Long topology_pk) { this.topology_pk = topology_pk; } @Override public String toString() { return \"当前拓扑的PK为：\" + topology_pk + \"，ID为：\" + topology_id; } } 如下想判断下面两个对象中全部属性值是否一致时，有哪些办法呢？ Bean_Topology topology1 = new Bean_Topology(); topology1.setTopology_id(\"1\"); Bean_Topology topology2 = new Bean_Topology(); topology2.setTopology_pk(1L); topology2.setTopology_id(\"1\"); ","date":"2021-10-15","objectID":"/java-selfclass-note/:1:0","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"方法一：重写Bean_Topology的equals方法和hashcode方法，代码如下 @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } Bean_Topology topology = (Bean_Topology) obj; if (topology_pk == null) { if (topology.topology_pk != null) { return false; } }else if (!topology_pk.equals(topology.topology_pk)) { return false; } if (topology_id == null) { if (topology.topology_id != null) { return false; } }else if (!topology_id.equals(topology.topology_id)) { return false; } return true; } @Override public int hashCode() { return topology_pk.hashCode()+topology_id.hashCode(); } 测试代码如下： if(topology1.equals(topology2)) { System.out.println(\"对象1与对象2的属性值无差异。\"); }else { System.out.println(\"对象1与对象2的属性值有差异。\"); } 输出结果为： 对象1与对象2的属性值有差异。 ","date":"2021-10-15","objectID":"/java-selfclass-note/:2:0","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"方法二：调用文章末尾的工具类，代码如下 Map\u003cString, Map\u003cString,Object\u003e\u003e resultMap=compareFields(topology1,topology2); int size=resultMap.size(); if(size\u003e0) { System.out.println(\"对象1与对象2的属性值有差异,差异结果如下：\"); Iterator\u003cString\u003e it = resultMap.keySet().iterator(); while(it.hasNext()) { String key=it.next(); System.out.println(\" \"+key+\"(oldValue:\"+resultMap.get(key).get(\"oldValue\")+\",newValue:\"+resultMap.get(key).get(\"newValue\")+\")\"); } }else { System.out.println(\"对象1与对象2的属性值无差异！\"); } 输出结果为： 对象1与对象2的属性值有差异,差异结果如下： topology_pk(oldValue:null,newValue:1) ","date":"2021-10-15","objectID":"/java-selfclass-note/:3:0","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"工具类如下 package com.sitech.modual.util.compare; import java.beans.Introspector; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import com.sitech.modual.bean.Bean_Link; import com.sitech.modual.bean.Bean_Topology; public class ClassCompareUtil { /** * 比较两个实体属性值，返回一个boolean,true则表时两个对象中的属性值无差异 * @param oldObject 进行属性比较的对象1 * @param newObject 进行属性比较的对象2 * @return 属性差异比较结果boolean */ public static boolean compareObject(Object oldObject, Object newObject) { Map\u003cString, Map\u003cString,Object\u003e\u003e resultMap=compareFields(oldObject,newObject); if(resultMap.size()\u003e0) { return false; }else { return true; } } /** * 比较两个实体属性值，返回一个map以有差异的属性名为key，value为一个Map分别存oldObject,newObject此属性名的值 * @param oldObject 进行属性比较的对象1 * @param newObject 进行属性比较的对象2 * @return 属性差异比较结果map */ @SuppressWarnings(\"rawtypes\") public static Map\u003cString, Map\u003cString,Object\u003e\u003e compareFields(Object oldObject, Object newObject) { Map\u003cString, Map\u003cString, Object\u003e\u003e map = null; try{ /** * 只有两个对象都是同一类型的才有可比性 */ if (oldObject.getClass() == newObject.getClass()) { map = new HashMap\u003cString, Map\u003cString,Object\u003e\u003e(); Class clazz = oldObject.getClass(); //获取object的所有属性 PropertyDescriptor[] pds = Introspector.getBeanInfo(clazz,Object.class).getPropertyDescriptors(); for (PropertyDescriptor pd : pds) { //遍历获取属性名 String name = pd.getName(); //获取属性的get方法 Method readMethod = pd.getReadMethod(); // 在oldObject上调用get方法等同于获得oldObject的属性值 Object oldValue = readMethod.invoke(oldObject); // 在newObject上调用get方法等同于获得newObject的属性值 Object newValue = readMethod.invoke(newObject); if(oldValue instanceof List){ continue; } if(newValue instanceof List){ continue; } if(oldValue instanceof Timestamp){ oldValue = new Date(((Timestamp) oldValue).getTime()); } if(newValue instanceof Timestamp){ newValue = new Date(((Timestamp) newValue).getTime()); } if(oldValue == null \u0026\u0026 newValue == null){ continue; }else if(oldValue == null \u0026\u0026 newValue != null){ Map\u003cString,Object\u003e valueMap = new HashMap\u003cString,Object\u003e(); valueMap.put(\"oldValue\",oldValue); valueMap.put(\"newValue\",newValue); map.put(name, valueMap); continue; } if (!oldValue.equals(newValue)) {// 比较这两个值是否相等,不等就可以放入map了 Map\u003cString,Object\u003e valueMap = new HashMap\u003cString,Object\u003e(); valueMap.put(\"oldValue\",oldValue); valueMap.put(\"newValue\",newValue); map.put(name, valueMap); } } } }catch(Exception e){ e.printStackTrace(); } return map; } } 示例： 测试结果： 不相等的字段名、旧值、新值会被查找出来。 ","date":"2021-10-15","objectID":"/java-selfclass-note/:3:1","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"如何获取父类的类名？ Java语言提供了获取类名的方法：getClass().getName()。代码如下所示： package com.haobi; /* * 获取类名 */ public class Test1 { public void test() { System.out.println(this.getClass().getName()); } public static void main(String[] args) { new Test1().test(); } } //程序输出结果如下： com.haobi.Test1 结果 //程序输出结果如下： com.haobi.Test1 从以上程序可以看出，调用当前类的getClass().getName()方法可以获取当前类的类名。假设一下，是否可以通过调用父类的getClass().getName()方法来获取父类的类名？代码如下所示： package com.haobi; /* * 调用父类的getClass().getName()方法 */ class A{} public class Test2 extends A { public void test() { System.out.println(super.getClass().getName()); } public static void main(String[] args) { new Test2().test(); } } 结果 //程序输出结果如下： com.haobi.Test2 上述程序的输出结果是com.haobi.Test2，而不是A。主要原因在于Java语言中任何类都继承自Object类，getClass()方法在Object类中被定义为final与native，子类不能覆盖该方法。因此this.getClass()和super.getClass()最终都调用的是Object中的getClass()方法。而Object的getClass()方法的释义是:返回此Object的运行时类。由于在上述程序中实际运行的类是Test2而不是A，因此程序输出结果为Test2。 要想在子类中得到父类的名字，可以通过Java的反射机制，使用getClass().getSuperclass().getName()，代码如下所示： package com.haobi; /* * 在子类中得到父类的名字 */ class B{} public class Test3 extends B{ public void test() { System.out.println(this.getClass().getSuperclass().getName()); } public static void main(String[] args) { new Test3().test(); } } 结果 //程序输出结果如下： com.haobi.B ","date":"2021-10-15","objectID":"/java-selfclass-note/:4:0","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"Java Class getEnclosingMethod()用法及代码示例 java.lang.Class类的getEnclosingMethod()方法用于获取此类的封闭方法。如果该类是该方法中声明的本地类或匿名类，则该方法返回此类的封闭方法。否则，此方法返回null。 ","date":"2021-10-15","objectID":"/java-selfclass-note/:5:0","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"用法 public Method getEnclosingMethod() **参数：**此方法不接受任何参数。 **返回值：**如果该类是该方法中声明的本地类或匿名类，则此方法返回此类的封闭方法。否则，此方法返回null。 异常如果存在安全管理器且不满足安全条件，则此方法将引发SecurityException。 下面的程序演示了getEnclosingMethod()方法。 ","date":"2021-10-15","objectID":"/java-selfclass-note/:5:1","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"示例1 // Java program to demonstrate getEnclosingMethod() method import java.util.*; public class Test { public static void main(String[] args) throws ClassNotFoundException { // returns the Class object for this class Class myClass = Class.forName(\"Test\"); System.out.println(\"Class represented by myClass: \" + myClass.toString()); // Get the enclosing methods of myClass // using getEnclosingMethod() method System.out.println(\"EnclosingMethod of myClass: \" + myClass.getEnclosingMethod()); } } 输出： Class represented by myClass: class Test EnclosingMethod of myClass: null ","date":"2021-10-15","objectID":"/java-selfclass-note/:5:2","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Back","note"],"content":"示例2 // Java program to demonstrate getEnclosingMethod() method import java.util.*; class Main { public Object obj; public Object func() { class Arr { }; return new Arr(); } public static void main(String[] args) throws ClassNotFoundException { Main t = new Main(); // returns the Class object Class myClass = t.func().getClass(); // Get the enclosing constructors of myClass // using getEnclosingConstructor() constructor System.out.println(\"getEnclosingMethod of myClass: \" + myClass.getEnclosingMethod()); } } 输出： EnclosingConstructor of myClass: public java.lang.Object Main.func() 参考 ","date":"2021-10-15","objectID":"/java-selfclass-note/:5:3","tags":["Java","JavaSelfClassNote","SelfClass"],"title":"Java自建类操作笔记","uri":"/java-selfclass-note/"},{"categories":["Algorithm","note"],"content":"记录常见排序算法总结笔记","date":"2021-10-15","objectID":"/rank-algorithm-note/","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"快速排序最坏的情况 这个答案还得看枢轴（pivot）的选择策略。在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦： 1）数组已经是正序（same order）排过序的。 2）数组已经是倒序排过序的。 3）所有的元素都相同（1、2的特殊情况） 因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。 ","date":"2021-10-15","objectID":"/rank-algorithm-note/:1:0","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"冒泡排序 ","date":"2021-10-15","objectID":"/rank-algorithm-note/:2:0","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"一.冒泡排序简介(从小到大排序） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个，即需要进行length-1次。 第一次是对n个数进行n-1次比较，进行到最后第n个的一个是最大的； 第二次是对n-1个数进行n-2次比较，进行到最后第n-1个的一个是最大的； …… 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动态图： ","date":"2021-10-15","objectID":"/rank-algorithm-note/:2:1","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"二.代码案例 package day0515; public class demo_sort { public static void main(String[] args) { //冒泡排序算法 int[] numbers=new int[]{1,5,8,2,3,9,4}; //需进行length-1次冒泡 for(int i=0;i\u003cnumbers.length-1;i++) { for(int j=0;j\u003cnumbers.length-1-i;j++) { if(numbers[j]\u003enumbers[j+1]) { int temp=numbers[j]; numbers[j]=numbers[j+1]; numbers[j+1]=temp; } } } System.out.println(\"从小到大排序后的结果是:\"); for(int i=0;i\u003cnumbers.length;i++) System.out.print(numbers[i]+\" \"); } } ","date":"2021-10-15","objectID":"/rank-algorithm-note/:2:2","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"有内存限制的海量数据排序 ","date":"2021-10-15","objectID":"/rank-algorithm-note/:3:0","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Algorithm","note"],"content":"磁盘文件排序 问题描述： 输入：给定一个文件，里面最多含有n个不重复的正整数（也就是说可能含有少于n个不重复正整数），且其中每个数都小于等于n，n = 10^7。 输出：得到按从小到大升序排列的包含所有输入的整数的列表。 条件：最多有大约1MB的内存空间可用，但磁盘空间足够。且要求运行时间在五分钟以下，10秒为最佳结果。 分析： 首先注意的是它的内存要求，基本上否决了大多数的排序算法。 文件里面的数据是不重复的，这个很关键，因为下面的方案前提就是数据不重复。 1、位图方案 用数组或者字符串代表位图。下标代表数字，值代表这个数字出现的次数。 以位为最小单位，对应位为1，代表位数值，可以用20位长的字符串来表示一个所有元素都小于20的简单的非负数集合，边框用如下字符串来表示集合{1,2,3,5,8,13}： 01110100100001000000 对应位置则置1，没用对应数的位置则置0，开始扳手指头数数吧。我们可以采用一个具有1000万个位的字符串来表示这个文件，其中，当整数i在文件中时，第i位为1。 第一步，所有位置0,将集合初始化。 第二步，通过读入文件中的每个整数来建立集合，将对应的位都置1. 第三步，检验每一位，如果该位为1，就输出对应的整数。 这里不得不提一下c++库中的一个容器bitset,发现这个在处理位的时候简直牛，先来瞅瞅。 #include \u003ciostream\u003e#include \u003cbitset\u003eusing namespace std; int main() { const int max = 20; int arr[10] = {2,9,3,5,4,0,18,11,12,15}; bitset\u003cmax\u003e bit_map; //一种类模板，放入长度，定义了一个max位，每位都为0 bit_map.reset(); //所有位置0 int i; for(i = 0;i\u003c 10;i++) { bit_map.set(arr[i]); //将对应位置1 } for(i = 0;i\u003c max;i++) { if(bit_map.test(i)) //判断第i位，如果为1，返回true cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c endl; return 0; } 再加上文件操作，就是针对海量数据排序。 #include \u003ciostream\u003e#include \u003cbitset\u003e#include \u003cassert.h\u003e#include \u003ctime.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003eusing namespace std; const int MAX = 5000000; int main() { clock_t begin = clock(); bitset\u003cMAX\u003e bit_map; bit_map.reset(); FILE * fp_unsort_file = fopen(\"data.txt\",\"r\"); assert(fp_unsort_file); int num; while(fscanf(fp_unsort_file,\"%d \",\u0026num)!= EOF) { if(num \u003c MAX) //先对1-4999999的数进行排序 bit_map.set(num); } FILE * fp_sort_file = fopen(\"sort.txt\",\"w\"); assert(fp_sort_file); int i; for(i= 0;i \u003c MAX;i++) { if(bit_map.test(i)) fprintf(fp_sort_file,\"%d \",i); } int result = fseek(fp_sort_file,0,SEEK_SET); //指针回到文件开始处 if(result) cout \u003c\u003c \"fseek failed\" \u003c\u003c endl; else { bit_map.reset(); while(fscanf(fp_unsort_file,\"%d \",\u0026num) !=EOF) { if(num \u003e MAX \u0026\u0026 num \u003c 10000000) //再对5000000-10000000的数排序 { num -=MAX; bit_map.set(num); } } for(i = 0;i\u003cMAX;i++) { if(bit_map.test(i)) fprintf(fp_sort_file,\"%d \",i+MAX); } } clock_t end = clock(); cout \u003c\u003c \"time is:\" \u003c\u003c endl; cout \u003c\u003c (end-begin)/CLOCKS_PER_SEC \u003c\u003c \"s\" \u003c\u003c endl; fclose(fp_sort_file); fclose(fp_unsort_file); return 0; } 第一次只处理1-4999999之间的数据，对这些数进行位图排序，只需要约5000000/8 = 625000byte，就是0.625M,排序后输出。 第二次,扫描输入文件，只处理4999999-10000000的数据项，只需要0.625M,因此只需要0.625M。 2、多路归并 我们先了解一下，归并排序的过程，归并排序就是2路归并。 归并排序的过程： （1）把无序表的每一个元素看做是一个有序表，则有n个有序子表； （2）把n个有序表按相邻位置分成若干对，每对中的两个表进行归并，归并后子表数减少一半。 （3）反复进行这一过程，直到归并为一个有序表为止。 是采用分治法的典型应用 首先考虑下如何将二个有序数列合并，比较二个数列第一个数，谁小就放入到临时数组中，然后再进行比较，如果一个数列到达结尾，直接将另一个数列放入就临时数组中。 void MemeryArray(int a[],int n,int b[],int m,int c[]) { int i,j,k; i = j= k = 0; while(i \u003c n \u0026\u0026 j\u003c m) { if(a[i] \u003c b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; } while(i \u003c n) c[k++] = a[i++]; while(j \u003c n) c[k++] = b[j++]; } 下一步考虑如何让两个A,B数组有序，可以将A,B各自再分成二组，依次类推，当分出来的小组只有一个元素时，这个小组内已经达到有序了，然后再合并相邻的二个小组就可以了，先递归分解，再合并数列就完成了归并排序。 //将二个有序数列a[first...mid] 和a[mid+1...last]合并 void MemeryArray(int a[],int first,int mid,int last,int temp[]) { int i = first; int j = mid+1; int m = mid; int n = last; int k = 0; while(i \u003c= m \u0026\u0026 j\u003c =n) { if(a[i] \u003c b[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while(i \u003c= m) temp[k++] = a[i++]; while(j \u003c=n) temp[k++] = a[j++]; for(i = 0;i\u003ck;i++) a[first+i] = temp[i]; } void mergesort(int a[],int first,int last,int temp[]) { if(first \u003c last) { int mid = (first + last)/2; mergesort(a,first,mid,tmep); mergesort(a,mid+1,last,temp); MemeryArray(a,first,mid ,last,temp); } } 归并排序是一种稳定排序，时间复杂度最好情况下和最坏情况下均是O（nlogn） 多路归并就是从多个有序数列中归并。 比如将10000000的数据，分成40个有序文件，分别在内存中排序，然后对这40个有序文件进行归并排序。 （1）读取每个文件中第一个数（每个文件的最小数），存放在一个大小为40的data数组中， （2）选择data数组中最小的数min_data，及其相应的文件索引（来自哪个文件）index （3）将min_data写入到文件result，然后更新数组data(根据index,读取该文件的下一个数代替min_data） （4）判读是否所有数据都读取完毕，否则返回到2步。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cassert.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003ctime.h\u003e using namespace std; int sort_num = 10000000; int memory_size = 250000; //每次排序250000个数据 int read_data(FILE *fp,int *space) { int index = 0; while(index \u003c memory \u0026\u0026 fscanf(fp,\"%d \",\u0026space[index])!= EOF) index++; return index; } void write_data(FILE * fp,int *space,int num) {","date":"2021-10-15","objectID":"/rank-algorithm-note/:3:1","tags":["Rank"],"title":"常见排序算法总结笔记","uri":"/rank-algorithm-note/"},{"categories":["Learning"],"content":"记录Json笔记","date":"2021-10-15","objectID":"/json-note/","tags":["Json","ElasticSearch","Error"],"title":"Json笔记","uri":"/json-note/"},{"categories":["Learning"],"content":"原因 ElasticSearch做原型系统时候使用了Excel填充数据导致索引中产生了回车换行，由于内网环境且没有其他插件仅能使用Postman用Http请求删除多余的数据，但是并不知道回车换行怎么解决 ","date":"2021-10-15","objectID":"/json-note/:1:0","tags":["Json","ElasticSearch","Error"],"title":"Json笔记","uri":"/json-note/"},{"categories":["Learning"],"content":"解决 查阅资料了解到Java有URLEncoder工具进行编码，于是将回车换行编码 System.out.println(URLEncoder.encode(\"\\r\\n\")); 结果 %0D%0A 将其添加到对应索引之后进行删除即可 ","date":"2021-10-15","objectID":"/json-note/:2:0","tags":["Json","ElasticSearch","Error"],"title":"Json笔记","uri":"/json-note/"},{"categories":["Operation","note"],"content":"记录ElasticSearch运维指令笔记","date":"2021-10-15","objectID":"/es-operation-note/","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"Windows安装Elasticsearch安装教程(超详细) ","date":"2021-10-15","objectID":"/es-operation-note/:1:0","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"一、安装jdk ElasticSearch是基于lucence开发的，也就是运行需要java jdk支持。所以要先安装JAVA环境。 由于ElasticSearch 5.x 往后依赖于JDK 1.8的，所以现在我们下载JDK 1.8或者更高版本。 下载JDK1.8,下载完成后安装。 ","date":"2021-10-15","objectID":"/es-operation-note/:1:1","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"二、安装ElasticSearch 1.ElasticSearch下载地址： https://www.elastic.co/downloads/elasticsearch 2.下载安装包后解压 3.进入bin目录下,双击执行elasticsearch.bat 4.看到started说明启动成功,打开浏览器测试一下,如下图 http://localhost:9200 ","date":"2021-10-15","objectID":"/es-operation-note/:1:2","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"三、安装ElasticSearch-head插件 1、安装node环境(更详细教程查看博主node安装教程篇) 网址：https://nodejs.org/en/download/ 下载Windows版msi的,下载完直接安装，一直确定 安装完后cmd查看版本node-v 2、安装grunt grunt是一个很方便的构建工具，可以进行打包压缩、测试、执行等等的工作，5.x里之后的head插件就是通过grunt启动的。因此需要安装grunt. npm install -g grunt-cli 查看版本号 grunt -version 注意:如果提示grunt命令不存在,转移博主node安装教程篇 3.下载head插件 1.网址:https://github.com/mobz/elasticsearch-head下载安装包 2.解压 3.进入head文件夹下，执行命令：npm install (此处是为安装进行安装pathomjs) 如果安装速度慢,设置成淘宝的镜像重新安装 npm config set registry https://registry.npm.taobao.org 4.安装完成之后npm run start或grunt server,启动head插件 5.修改es使用的参数.编辑D:\\elasticsearch\\elasticsearch-7.3.2-windows-x86_64\\elasticsearch-7.3.2\\config\\elasticsearch.yml文件 增加新的参数，这样head插件可以访问es http.cors.enabled: true http.cors.allow-origin: “*” @注意，设置参数的时候:后面要有空格！ 6.修改完配置将es重启,浏览器访问 http://localhost:9100 到此，Elasticsearch和ElasticSearch-head已经装好了。 ","date":"2021-10-15","objectID":"/es-operation-note/:1:3","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"四、ElasticSearch安装为Windows服务 1.elasticsearch的bin目录下有一个elasticsearch-service.bat 2.cmd 进入bin目录下执行: elasticsearch-service.bat install 3.查看电脑服务es已经存在了 elasticsearch-service.bat后面还可以执行这些命令 install: 安装Elasticsearch服务 remove: 删除已安装的Elasticsearch服务（如果启动则停止服务） start: 启动Elasticsearch服务（如果已安装） stop: 停止服务（如果启动） manager:启动GUI来管理已安装的服务 ","date":"2021-10-15","objectID":"/es-operation-note/:1:4","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"ElasticSearch关闭重启命令 很多人学习elasticSearch都是自学，想百度一下如何重启es也是没有答案，我硬着头皮，算是琢磨出来了，借此写博，希望能帮助您。 ","date":"2021-10-15","objectID":"/es-operation-note/:2:0","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"1.如何关闭ES，elasticsearch关闭办法 1.使用head插件 找到想关掉的节点进行关停 2.使用命令kill杀掉服务器的ES进程即可 1.查找ES进程 ps -ef | grep elastic 2.杀掉ES进程 kill -9 2382（进程号） 3.重启ES sh elasticsearch -d ","date":"2021-10-15","objectID":"/es-operation-note/:2:1","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"2.如何重启ES 没有重启的办法，只有参考上面关闭-\u003e开启这样。 以下是详细的操作过程 1.首先是查找服务器是否有ES进程，无果ES没有开启，也就不用关闭了，如果开启，则杀死进程就行 1.查找进程命令 ps -ef | grep elastic [root@bjdhj-125-203 _site]# ps -ef | grep elastic //然后可以看到如下的进程号，2382,2583之类的，之后kill掉就可以啦。 root 2382 1 0 Jan05 ? 00:10:57 /opt/soft/jdk/jdk1.7.0_80/bin/java -Xms2g -Xmx2g -Djava.awt.headless=true -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+HeapDumpOnOutOfMemoryError -XX:+DisableExplicitGC -Dfile.encoding=UTF-8 -Delasticsearch -Des.path.home=/opt/soft/elasticsearch-1.5.2-2 -cp :/opt/soft/elasticsearch-1.5.2-2/lib/elasticsearch-1.5.2.jar:/opt/soft/elasticsearch-1.5.2-2/lib/*:/opt/soft/elasticsearch-1.5.2-2/lib/sigar/* org.elasticsearch.bootstrap.Elasticsearch root 2583 1 0 Jan05 ? 00:10:24 /opt/soft/jdk/jdk1.7.0_80/bin/java -Xms2g -Xmx2g -Djava.awt.headless=true -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+HeapDumpOnOutOfMemoryError -XX:+DisableExplicitGC -Dfile.encoding=UTF-8 -Delasticsearch -Des.path.home=/opt/soft/elasticsearch-1.5.2 -cp :/opt/soft/elasticsearch-1.5.2/lib/elasticsearch-1.5.2.jar:/opt/soft/elasticsearch-1.5.2/lib/*:/opt/soft/elasticsearch-1.5.2/lib/sigar/* org.elasticsearch.bootstrap.Elasticsearch root 8682 8564 0 18:04 pts/0 00:00:00 grep elastic 2.杀掉进程 kill -9 2382（进程号） //杀掉杀掉统统杀掉，如果不确定进程号，可以看看上面信息里面的进程路径地址，防止杀错 [root@bjdhj-125-203 _site]# kill -9 2382 [root@bjdhj-125-203 _site]# ps -ef | grep elastic root 2583 1 0 Jan05 ? 00:10:24 /opt/soft/jdk/jdk1.7.0_80/bin/java -Xms2g -Xmx2g -Djava.awt.headless=true -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+HeapDumpOnOutOfMemoryError -XX:+DisableExplicitGC -Dfile.encoding=UTF-8 -Delasticsearch -Des.path.home=/opt/soft/elasticsearch-1.5.2 -cp :/opt/soft/elasticsearch-1.5.2/lib/elasticsearch-1.5.2.jar:/opt/soft/elasticsearch-1.5.2/lib/*:/opt/soft/elasticsearch-1.5.2/lib/sigar/* org.elasticsearch.bootstrap.Elasticsearch root 8684 8564 0 18:05 pts/0 00:00:00 grep elastic 3.重启命令 sh elasticsearch -d [root@bjdhj-125-203 elasticsearch-1.5.2]# ls bin config data lib LICENSE.txt logs NOTICE.txt plugins README.textile [root@bjdhj-125-203 elasticsearch-1.5.2]# cd bin [root@bjdhj-125-203 bin]# ./elasticsearch -d -bash: ./elasticsearch: Permission denied [root@bjdhj-125-203 bin]# sh elasticsearch -d link /opt/soft/jdk/jdk1.7.0_80 to /opt/soft/java User=root SourceJDKFileBase=10.126.103.198 JDKBasePath=/opt/soft/jdk Timeout=2 DefaultVer=jdk1.6.0_45 CurrentVer=jdk1.7.0_80 Initialize jdk(jdk1.7.0_80) done Current jdk version = 1.7.0_80 [root@bjdhj-125-203 bin]# ps -ef | grep elastic ","date":"2021-10-15","objectID":"/es-operation-note/:2:2","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"3.Dokcer启动 先进入对应容器 sh /路径/elasticsearch -d ","date":"2021-10-15","objectID":"/es-operation-note/:2:3","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation","note"],"content":"EasticHD安装部署 1.下载 elastichd 下载地址:https://github.com/360EntSecGroup-Skylar/ElasticHD/releases 或是直接在linux下下载 wget https://github.com/360EntSecGroup-Skylar/ElasticHD/releases/download/1.4/elasticHD_linux_amd64.zip 2.解压 [root@localhost soft]# mv elasticHD_darwin_amd64.zip /opt/ [root@localhost opt]# unzip elasticHD_darwin_amd64.zip Archive: elasticHD_darwin_amd64.zip inflating: ElasticHD 3.授权 [root@localhost opt]# chmod 0777 ElasticHD 4.启动 cd /opt 后台启动 exec ./ElasticHD -p 192.168.1.136:9800 \u0026 5.IE栏输入 http://192.168.1.136:9800/ ","date":"2021-10-15","objectID":"/es-operation-note/:3:0","tags":["ElasticSearch","Linux","Head"],"title":"ElasticSearch运维指令笔记","uri":"/es-operation-note/"},{"categories":["Operation"],"content":"记录Docker修改容器中的配置文件启动报错的解决办法","date":"2021-10-15","objectID":"/docker-edit-start-error/","tags":["Docker","Linux","Error"],"title":"Docker修改容器中的配置文件启动报错","uri":"/docker-edit-start-error/"},{"categories":["Operation"],"content":"原因 因为修改了容器的/etc/rc.d/rc.local 文件导致 容器无法启动，查看容器报错日志 docker logs 容器ID 把rc.local修改过来 容器数据都存在/var/lib/docker/overlay2路径下的 diff 目录里面 如果不确定可以通过查找 find . -name \"rc.local\" 我们可以找到相关的配置文件直接修改 修改完毕后用 docker restart 容器名/ID 即可重新启动容器 ","date":"2021-10-15","objectID":"/docker-edit-start-error/:1:0","tags":["Docker","Linux","Error"],"title":"Docker修改容器中的配置文件启动报错","uri":"/docker-edit-start-error/"},{"categories":["Back","Note"],"content":"记录Java-Collection笔记","date":"2021-10-15","objectID":"/java-collection-note/","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"前言 java中的集合主要分为三种类型： Set（集） List（列表） Map（映射） ","date":"2021-10-15","objectID":"/java-collection-note/:1:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List 数组：几乎所有集合实现的底层都有数据的身影存在，因此我们首先需要了解一下数组。以下这段话摘自《Thinking In Algorithm》，感觉很不错现在拿出来跟大家分享。 《Thinking In Algorithm》之数组 集合：接下来是集合，同样我们摘自网络上的一段解释，很不错也通俗易懂，与大家分享： 集合与数组 总结一下上面两段话： 数组的大小是固定不变的，并且同一个数组只能存储相同类型的数据，该数据类型可以是基本类型也可以是引用类型。Java中集合可以存储操作不同类型和大小不固定的数据，但是Java中集合只能存储引用类型，不能存储基本类型。 ","date":"2021-10-15","objectID":"/java-collection-note/:2:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"ArrayList初始化的4种方法 参考 1、Arrays.asList ArrayList\u003cType\u003e obj = new ArrayList\u003cType\u003e(Arrays.asList(Object o1, Object o2, Object o3, ....so on)); 2、生成匿名内部内进行初始化 ArrayList\u003cT\u003e obj = new ArrayList\u003cT\u003e() {{ add(Object o1); add(Object o2); ... ... }}; 3、常规方式 ArrayList\u003cT\u003e obj = new ArrayList\u003cT\u003e(); obj.add(\"o1\"); obj.add(\"o2\"); ... ... 或者 ArrayList\u003cT\u003e obj = new ArrayList\u003cT\u003e(); List list = Arrays.asList(\"o1\",\"o2\",...); obj.addAll(list); 4、Collections.ncopies ArrayList\u003cT\u003e obj = new ArrayList\u003cT\u003e(Collections.nCopies(count,element)); //把element复制count次填入ArrayList中 测试代码： // 交集 List\u003cString\u003e listA_01 = new ArrayList\u003cString\u003e(){{ add(\"A\"); add(\"B\"); }}; List\u003cString\u003e listB_01 = new ArrayList\u003cString\u003e(){{ add(\"B\"); add(\"C\"); }}; listA_01.retainAll(listB_01); System.out.println(listA_01); // 结果:[B] System.out.println(listB_01); // 结果:[B, C] // 差集 List\u003cString\u003e listA_02 = new ArrayList\u003cString\u003e(){{ add(\"A\"); add(\"B\"); }}; List\u003cString\u003e listB_02 = new ArrayList\u003cString\u003e(){{ add(\"B\"); add(\"C\"); }}; listA_02.removeAll(listB_02); System.out.println(listA_02); // 结果:[A] System.out.println(listB_02); // 结果:[B, C] // 并集 List\u003cString\u003e listA_03 = new ArrayList\u003cString\u003e(){{ add(\"A\"); add(\"B\"); }}; List\u003cString\u003e listB_03 = new ArrayList\u003cString\u003e(){{ add(\"B\"); add(\"C\"); }}; listA_03.removeAll(listB_03); listA_03.addAll(listB_03); System.out.println(listA_03); // 结果:[A, B, C] System.out.println(listB_03); // 结果:[B, C] ","date":"2021-10-15","objectID":"/java-collection-note/:2:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List数据去重的五种方法 方案一:借助Set的特性进行去重 /** * 去除重复数据 * 由于Set的无序性，不会保持原来顺序 * @param list */ public static List\u003cString\u003e list distinct(List\u003cString\u003e list) { final boolean sta = null != list \u0026\u0026 list.size() \u003e 0; List doubleList= new ArrayList(); if (sta) { Set set = new HashSet(); set.addAll(list); doubleList.addAll(set); } return doubleList; } 方案二 : 利用set集合特性保持顺序一致去重 // Set去重并保持原先顺序的两种方法 public static void delRepeat(List\u003cString\u003e list) { //方法一 List\u003cString\u003e listNew = new ArrayList\u003cString\u003e(new TreeSet\u003cString\u003e(list)); //方法二 List\u003cString\u003e listNew2 = new ArrayList\u003cString\u003e(new LinkedHashSet\u003cString\u003e(list)); } 方案三 : 使用list自身方法remove()–\u003e不推荐 /** * 去除重复数据(一般不推荐) * 类似于冒泡排序思想 * @param list */ public static List\u003cMap\u003cString, Object\u003e\u003e distinct(List\u003cMap\u003cString, Object\u003e\u003e list) { if (null != list \u0026\u0026 list.size() \u003e 0) { //循环list集合 for ( int i = 0 ; i \u003c list.size() - 1 ; i ++ ) { for ( int j = list.size() - 1 ; j \u003e i; j -- ) { // 这里是对象的比较，如果去重条件不一样，在这里修改即可 if (list.get(j).equals(list.get(i))) { list.remove(j); } } } } //得到最新移除重复元素的list return list; } 方案四 : 遍历List集合,将元素添加到另一个List集合中 // 遍历后判断赋给另一个list集合，保持原来顺序 public static List\u003cString\u003e delRepeat(List\u003cString\u003e list) { List\u003cString\u003e listNew = new ArrayList\u003cString\u003e(); for (String str : list) { if (!listNew.contains(str)) { listNew.add(str); } } return listNew ; } 方案5 : 使用Java8特性去重-\u003e推荐 public static List\u003cString\u003e delRepeat(List\u003cString\u003e list) { List\u003cString\u003e myList = list.stream().distinct().collect(Collectors.toList()); return myList ; } ","date":"2021-10-15","objectID":"/java-collection-note/:2:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List的复制 （浅拷贝与深拷贝） 开门见山的说，List的复制其实是很常见的，List其本质就是数组，而其存储的形式是地址 如图所示，将List A列表复制时，其实相当于A的内容复制给了B，java中相同内容的数组指向同一地址，即进行浅拷贝后A与B指向同一地址。 造成的后果就是，改变B的同时也会改变A，因为改变B就是改变B所指向地址的内容，由于A也指向同一地址，所以A与B一起改变。 这也就是List的浅拷贝，其常见的实现方式有如下几种： 浅拷贝 1、遍历循环复制 List\u003cPerson\u003e destList=new ArrayList\u003cPerson\u003e(srcList.size()); for(Person p : srcList){ destList.add(p); } 2、使用List实现类的构造方法 List\u003cPerson\u003e destList=new ArrayList\u003cPerson\u003e(srcList); 3、使用list.addAll()方法 List\u003cPerson\u003e destList=new ArrayList\u003cPerson\u003e(); destList.addAll(srcList); 4、使用System.arraycopy()方法 Person[] srcPersons=srcList.toArray(new Person[0]); Person[] destPersons=new Person[srcPersons.length]; System.arraycopy(srcPersons, 0, destPersons, 0, srcPersons.length); 测试及结果 printList(destList); //打印未改变B之前的A srcList.get(0).setAge(100);//改变B printList(destList); //打印改变B后的A //打印结果 123--\u003e20 ABC--\u003e21 abc--\u003e22 123--\u003e100 ABC--\u003e21 abc--\u003e22 ","date":"2021-10-15","objectID":"/java-collection-note/:2:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List 深拷贝 如图，深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。 import org.apache.commons.collections.CollectionUtils; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CopyTest { public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10; i++) { list.add(i); } //list深度拷贝 List\u003cInteger\u003e newList = new ArrayList\u003c\u003e(); CollectionUtils.addAll(newList, new Object[list.size()]); Collections.copy(newList, list); newList.set(0, 10); System.out.println(\"原list值：\" + list); System.out.println(\"新list值：\" + newList); } } 测试结果 原list值：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 新list值：[10, 1, 2, 3, 4, 5, 6, 7, 8, 9] 小结 Java对对象和基本的数据类型的处理是不一样的。在Java中用对象的作为入口参数的传递则缺省为”引用传递”，也就是说仅仅传递了对象的一个”引用”，这个”引用”的概念同C语言中的指针引用是一样的。当函数体内部对输入变量改变时，实质上就是在对这个对象的直接操作。 除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。 在浅复制的情况下，源数据被修改破坏之后，使用相同引用指向该数据的目标集合中的对应元素也就发生了相同的变化。因此，在需求要求必须深复制的情况下，要是使用上面提到的方法，请确保List中的T类对象是不易被外部修改和破坏的。 对象列表的深度复制 package top.luxd.Test; import org.apache.commons.collections.CollectionUtils; import org.junit.Test; import java.io.*; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CopyTest implements Serializable { public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10; i++) { list.add(i); } //list深度拷贝 List\u003cInteger\u003e newList = new ArrayList\u003c\u003e(); CollectionUtils.addAll(newList, new Object[list.size()]); Collections.copy(newList, list); newList.set(0, 10); System.out.println(\"原list值：\" + list); System.out.println(\"新list值：\" + newList); } @Test public void test() throws IOException, ClassNotFoundException { UserTest user1 = new UserTest(\"小明\", 18); UserTest user2 = new UserTest(\"小红\", 16); List\u003cUserTest\u003e list = new ArrayList\u003c\u003e(); list.add(user1); list.add(user2); System.out.println(\"原List：\" + list); // 进行深度复制 // List\u003cUserTest\u003e listNew = new ArrayList\u003c\u003e(); // for (int i = 0; i \u003c list.size(); i += 1) { // listNew.add((UserTest) list.get(i).clone()); // } List\u003cUserTest\u003e listNew = deepCopy(list); System.out.println(\"对新list进行操作\"); for (UserTest userTest : listNew) { userTest.setAge(99); } System.out.println(\"原list\" + list); System.out.println(\"新list\" + listNew); } class UserTest implements Serializable { String id; int age; public UserTest(String id, int age) { this.id = id; this.age = age; } public UserTest() { } public String getId() { return id; } public void setId(String id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"UserTest{\" + \"id='\" + id + '\\'' + \", age=\" + age + '}'; } } //关键代码 运行序列化和反序列化 进行深度拷贝 public static \u003cT\u003e List\u003cT\u003e deepCopy(List\u003cT\u003e src) throws IOException, ClassNotFoundException { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); @SuppressWarnings(\"unchecked\") List\u003cT\u003e dest = (List\u003cT\u003e) in.readObject(); return dest; } } 结果 原List：[UserTest{id='小明', age=18}, UserTest{id='小红', age=16}] 对新list进行操作 原list[UserTest{id='小明', age=18}, UserTest{id='小红', age=16}] 新list[UserTest{id='小明', age=99}, UserTest{id='小红', age=99}] ","date":"2021-10-15","objectID":"/java-collection-note/:2:4","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List根据下标修改 // 1 List 是通过指针指向地址来查询和存储数据的。而如果直接将一个List赋值给另一个List。则会导致该两个List都指向同一个地址。而导致如果后一个List的元素值改变，前一个List的元素值也随之改变。这个要记住。 List list1 = new ArrayList(); list1.add(\"1\"); list1.add(\"2\"); list1.add(\"3\"); System.out.println(\"list1:\" + list1); List list2 = new ArrayList(); list2 = list1;//简单的直接赋值 list2.set(1, \"12\"); System.out.println(\"list1:\" + list1); System.out.println(\"list2:\" + list2); // 2 所以为了避免出现上述现象和后果。则通过将元素值赋值给list的方法。这样则不会导致上述现象。 List list3 = new ArrayList(); list3.add(\"1\"); list3.add(\"2\"); list3.add(\"3\"); System.out.println(\"list3:\" + list3); List list4 = new ArrayList(); for (int i = 0; i \u003c list3.size(); i++) {//通过循环来赋值给另一个List Object object = list3.get(i); list4.add(object); } list4.set(1, \"12\"); System.out.println(\"list3:\" + list3); System.out.println(\"list4:\" + list4); ","date":"2021-10-15","objectID":"/java-collection-note/:2:5","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"List转Map的三种方法 一、 List转Map Map\u003cLong, User\u003e maps = userList.stream().collect(Collectors.toMap(User::getId,Function.identity())); 看来还是使用JDK 1.8方便一些。 二、 另外，转换成Map的时候，可能出现key一样的情况，如果不指定一个覆盖规则，上面的代码是会报错的。转成Map的时候，最好使用下面的方式： Map\u003cLong, User\u003e maps = userList.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -\u003e key2)); 三、 有时候，希望得到的Map的值不是对象，而是对象的某个属性，那么可以用下面的方式： Map\u003cLong, String\u003e maps = userList.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -\u003e key2)); 四、 List 以ID分组 Map\u003cInteger,List\u003e Map\u003cInteger, List\u003e groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId)); System.err.println(“groupBy:”+groupBy); {1=[Apple{id=1, name=‘苹果1’, money=3.25, num=10}, Apple{id=1, name=‘苹果2’, money=1.35, num=20}], 2=[Apple{id=2, name=‘香蕉’, money=2.89, num=30}], 3=[Apple{id=3, name=‘荔枝’, money=9.99, num=40}]} ","date":"2021-10-15","objectID":"/java-collection-note/:2:6","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java两个List的交集，并集 ⽅法⼀:使⽤apache的CollectionUtils⼯具类(推荐) publicstaticvoidmain(String[] args){ String[] arrayA =new String[]{\"1\",\"2\",\"3\",\"4\"}; String[] arrayB =new String[]{\"3\",\"4\",\"5\",\"6\"}; List\u003cString\u003e listA = Arrays.asList(arrayA); List\u003cString\u003e listB = Arrays.asList(arrayB); //1、并集 union System.out.println(CollectionUtils.union(listA, listB)); //输出: [1, 2, 3, 4, 5, 6] //2、交集 intersection System.out.println(CollectionUtils.intersection(listA, listB)); //输出:[3, 4] //3、交集的补集（析取）disjunction System.out.println(CollectionUtils.disjunction(listA, listB)); //输出:[1, 2, 5, 6] //4、差集（扣除） System.out.println(CollectionUtils.subtract(listA, listB)); //输出:[1, 2] } ⽅法⼆:List⾃带⽅法 需求 list的方法 说明 备注 交集 listA.retainAll(listB) listA内容变为listA和listB都存在的对象 listB不变 差集 listA.removeAll(listB) listA中存在的listB的内容去重 listB不变 并集 listA.removeAll(listB) listA.addAll(listB) 为了去重，listA先取差集，然后追加全部的listB listB不变 publicstaticvoidmain(String[] args){ String[] arrayA =new String[]{\"1\",\"2\",\"3\",\"4\"}; String[] arrayB =new String[]{\"3\",\"4\",\"5\",\"6\"}; List\u003cString\u003e listA = Arrays.asList(arrayA); List\u003cString\u003e listB = Arrays.asList(arrayB); //1、交集 List\u003cString\u003e jiaoList =new ArrayList\u003c\u003e(listA); jiaoList.retainAll(listB); System.out.println(jiaoList); //输出:[3, 4] //2、差集 List\u003cString\u003e chaList =new ArrayList\u003c\u003e(listA); chaList.removeAll(listB); System.out.println(chaList); //输出:[1, 2] //3、并集先做差集再做添加所有） ( List\u003cString\u003e bingList =new ArrayList\u003c\u003e(listA); bingList.removeAll(listB);// bingList为[1, 2] bingList.addAll(listB);//添加[3,4,5,6] System.out.println(bingList); //输出:[1, 2, 3, 4, 5, 6] } 注意 : intersection和retainAll的差别 要注意的是它们的返回类型是不⼀样的,intersection返回的是⼀个新的List集合，⽽retainAll返回是Bollean类型那就说明retainAll⽅法是 对原有集合进⾏处理再返回原有集合,会改变原有集合中的内容。 个⼈观点：1、从性能⾓度来考虑的话,List⾃带会⾼点,因为它不⽤再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使⽤就不适合⽤retainAll。 注意: Arrays.asList将数组转集合不能进⾏add和remove操作。 原因：调⽤Arrays.asList()⽣产的List的add、remove⽅法时报异常，这是由Arrays.asList() 返回的市Arrays的内部类ArrayList， ⽽ 不是java.util.ArrayList。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等⽅法AbstractList中 是默认throw UnsupportedOperationException⽽且不作任何操作。java.util.ArrayList重新了这些⽅法⽽Arrays的内部类ArrayList没 有重新，所以会抛出异常。 所以正确做法如下 String[] array ={\"1\",\"2\",\"3\",\"4\",\"5\"}; List\u003cString\u003e list = Arrays.asList(array); List arrList =new ArrayList(list); arrList.add(\"6\"); ⽅法三:JDK1.8 stream 新特性 String[] arrayA =new String[]{\"1\",\"2\",\"3\",\"4\"}; String[] arrayB =new String[]{\"3\",\"4\",\"5\",\"6\"}; List\u003cString\u003e listA = Arrays.asList(arrayA); List\u003cString\u003e listB = Arrays.asList(arrayB); // 交集 List\u003cString\u003e intersection = listA.stream().filter(item -\u003e listB.contains(item)).collect(toList()); System.out.println(intersection); //输出:[3, 4] // 差集(list1 - list2) List\u003cString\u003e reduceList = listA.stream().filter(item -\u003e!listB.contains(item)).collect(toList()); System.out.println(reduceList); //输出:[1, 2] // 并集（新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。 List\u003cString\u003e listAll = listA.parallelStream().collect(toList()); List\u003cString\u003e listAll2 = listB.parallelStream().collect(toList()); listAll.addAll(listAll2); System.out.println(listAll); //输出:[1, 2, 3, 4, 3, 4, 5, 6] // 去重并集 List\u003cString\u003e list =new ArrayList\u003c\u003e(listA); list.addAll(listB); List\u003cString\u003e listAllDistinct = list.stream().distinct().collect(toList()); System.out.println(listAllDistinct); //输出:[1, 2, 3, 4, 5, 6] 总结 ： 这三种推荐第⼀种⽅式，因为第⼆种还需要确定该集合是否被多次调⽤。第三种可读性不⾼。 对象集合交、并、差处理 因为对象的equels⽐较是⽐较两个对象的内存地址，所以除⾮是同⼀对象，否则equel返回永远是false。 但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是⼀种严格意义上的相等，⽽是⼀种业务上的对象相等。在这种情况 下，原⽣的equals⽅法就不能满⾜我们的需求了，所以这个时候我们需要重写equals⽅法。 说明 :String为什么可以使⽤equels⽅法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode⽅法，⽐较的是值。 public class Person { private String name; private Integer age; public Person(String name, Integer age) { this.name = name; this.age = age; } /** * 为什么重写equals ⽅法⼀定要重写hashCode⽅法下⾯也会讲 */ @Override public int hashCode() { String result = name + age; return result.hashCode(); } /** * 重写equals⽅法根据name和age都相同那么对象就默认相同 */ @Override public boolean equals(Object obj) { Person u = (Person) obj; return this.getName().equals(","date":"2021-10-15","objectID":"/java-collection-note/:2:7","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"在ArrayList的循环中删除元素，会不会出现问题？ 在 ArrayList 的循环中删除元素，会不会出现问题？我开始觉得应该会有什么问题吧，但是不知道问题会在哪里。在经历了一番测试和查阅之后，发现这个“小”问题并不简单！ 不在循环中的删除，是没有问题的，否则这个方法也没有存在的必要了嘛，我们这里讨论的是在循环中的删除，而对 ArrayList 的循环方法也是有多种的，这里定义一个类方法 remove()，先来看段代码吧。 public class ArrayListTest { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"aa\"); list.add(\"bb\"); list.add(\"aa\"); list.add(\"bb\"); list.add(\"cc\"); // 删除元素 aa remove(list, \"aa\"); for (String str : list) { System.out.println(str); } } public static void remove(ArrayList\u003cString\u003e list, String elem) { // 不同的循环及删除方法 // 方法一：普通for循环正序删除，删除过程中元素向左移动，不能删除重复的元素 // for (int i = 0; i \u003c list.size(); i++) { // if (list.get(i).equals(\"bb\")) { // list.remove(list.get(i)); // } // } // 方法二：普通for循环倒序删除，删除过程中元素向左移动，可以删除重复的元素 // for (int i = list.size() - 1; i \u003e= 0; i--) { // if (list.get(i).equals(\"bb\")) { // list.remove(list.get(i)); // } // } // 方法三：增强for循环删除，使用ArrayList的remove()方法删除，产生并发修改异常 ConcurrentModificationException // for (String str : list) { // if (str.equals(\"aa\")) { // list.remove(str); // } // } // 方法四：迭代器，使用ArrayList的remove()方法删除，产生并发修改异常 ConcurrentModificationException // Iterator iterator = list.iterator(); // while (iterator.hasNext()) { // if(iterator.next().equals(elem)) { // list.remove(iterator.next()); // } // } // 方法五：迭代器，使用迭代器的remove()方法删除，可以删除重复的元素，但不推荐 // Iterator iterator = list.iterator(); // while (iterator.hasNext()) { // if(iterator.next().equals(elem)) { // iterator.remove(); // } // } } } 这里我测试了五种不同的删除方法，一种是普通的 for 循环，一种是增强的 foreach 循环，还有一种是使用迭代器循环，一共这三种循环方式。也欢迎你点击文末的 “阅读全文”，留言和我们讨论哦！ 上面这几种删除方式呢，在删除 list 中单个的元素，也即是没有重复的元素，如 “cc”。在方法三和方法四中都会产生并发修改异常 ConcurrentModificationException，这两个删除方式中都用到了 ArrayList 中的 remove() 方法（快去上面看看代码吧）。而在删除 list 中重复的元素时，会有这么两种情况，一种是这两个重复元素是紧挨着的，如 “bb”，另一种是这两个重复元素没有紧挨着，如 “aa”。删除这种元素时，方法一在删除重复但不连续的元素时是正常的，但在删除重复且连续的元素时，会出现删除不完全的问题，这种删除方式也是用到了 ArrayList 中的 remove() 方法。而另外两种方法都是可以正常删除的，但是不推荐第五种方式，这个后面再说。 经过对运行结果的分析，发现问题都指向了 ArrayList 中的 remove() 方法，（感觉有种侦探办案的味道，可能是代码写多了的错觉吧，txtx…）那么看 ArrayList 源码是最好的选择了，下面是我截取的关键代码（Java1.8）。 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } public boolean remove(Object o) { if (o == null) { for (int index = 0; index \u003c size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index \u003c size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 可以看到这个 remove() 方法被重载了，一种是根据下标删除，一种是根据元素删除，这也都很好理解。 根据下标删除的 remove() 方法，大致的步骤如下： 1、检查有没有下标越界，就是检查一下当前的下标有没有大于等于数组的长度 2、列表被修改（add和remove操作）的次数加1 3、保存要删除的值 4、计算移动的元素数量 5、删除位置后面的元素向左移动，这里是用数组拷贝实现的 6、将最后一个位置引用设为 null，使垃圾回收器回收这块内存 7、返回删除元素的值 根据元素删除的 remove() 方法，大致的步骤如下： 1、元素值分为null和非null值 2、循环遍历判等 3、调用 fastRemove(i) 函数 3.1、修改次数加1 3.2、计算移动的元素数量 3.3、数组拷贝实现元素向左移动 3.4、将最后一个位置引用设为 null 3.5、返回 fase 4、返回 true 这里我有个疑问，第一个 remove() 方法中的代码和 fastRemove() 方法中的代码是完全一样的，第一个 remove() 方法完全可以向第二个 remove() 方法一样调用 fastRemove() 方法嘛，这里代码感觉有些冗余，个人理解有限，还请知道的大佬指教。 我们重点关注的是删除过程，学过数据结构的小伙伴可能手写过这样的删除，下面我画个图来让大家更清楚的看到整个删除的过程。以删除 “bb” 为例，当指到下标为 1 的元素时，发现是 “bb”，此处元素应该被删除，根据上面的删除步骤可知，删除位置后面的元素要向前移动，移动之后 “bb” 后面的 “bb” 元素下标为1，后面的元素下标也依次减1，这是在 i = 1 时循环的操作。在下一次循环中 i = 2，第二个 “bb” 元素就被遗漏了，所以这种删除方法在删除连续重复元素时会有问题。 循环中的正序删除.jpg\r但是如果我们使 i 递减循环，也即是方法二的倒序循环，这个问题就不存在了，如下图。 循环中的倒序删除.jpg\r既然我们已经搞清不能正常删除的原因，那么再来看看方法五中可以正常删除的原因。方法五中使用的是迭代器中的 remove() 方法，通过阅读 ArrayList 的源码可以发现，有两个私有内部类，Itr 和 ListItr，Itr 实现自 Iterator 接口，ListItr 继承 Itr 类和实现自 ListIterator 接口。Itr 类中也有一个 remove() 方法，迭代器实际调用的也正是这个 remove() 方法，我也截取这个方法的源码。 private class Itr implements Itera","date":"2021-10-15","objectID":"/java-collection-note/:2:8","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Map ","date":"2021-10-15","objectID":"/java-collection-note/:3:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"特点 map 没有无序，不能下标访问，只能通过keyvalue进行访问，能增加随机访问的速度 ","date":"2021-10-15","objectID":"/java-collection-note/:3:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"修改 map 直接put进行key，value覆盖修改即可，无需其他操作 ","date":"2021-10-15","objectID":"/java-collection-note/:3:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"遍历Map的几种方法 java中的map遍历有多种方法，从最早的Iterator，到java5支持的foreach,再到java8 Lambda，让我们一起来看下具体的用法以及各自的优缺点 先初始化一个map public class TestMap { public static Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); } keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 返回值类型Set\u003ck\u003e 方法是： keySet() :返回此映射中包含的键的 Set 视图将Map中所有的键存入到Set集合，因为Set具备迭代器，所有迭代方式取出所有的键再根据get()方法 ，获取每一个键对应的值 // KeySet 获取key public void testKeySet() { for (Integer key : map.keySet()) { System.out.println(key); } } // values 获取value public void testValues() { for (Integer value : map.values()) { System.out.println(value); } } keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 // keySet get(key) 获取key and value public void testKeySetAndGetKey() { for (Integer key : map.keySet()) { System.out.println(key + \":\" + map.get(key)); } } entrySet 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 返回值类型：Set\u003cMap.Entry\u003cK,V\u003e\u003e方法是：entrySet()取出的是关系，关系中包含key和value,其中Map.Entry\u003ck,V\u003e来表示这种数据类型即：将Map集合中的映射关系存入到Set集合中，这个关系的数据类型为:Map.Entry Map.Entry接口,此接口在java.util包中，其实Entry也是一个接口，它是Map接口中的一个内部接口 ,getKey()和getValue是接口Map.Entry\u003cK,V\u003e中的方法，返回对应的键和对应的值 // entrySet 获取key and value public void testEntry() { for (Map.Entry\u003cInteger, Integer\u003e entry : map.entrySet()) { System.out.println(entry.getKey() + \":\" + entry.getValue()); } } Iterator 对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 AbstractMap实现了Map接口。 Map接口里面有一个forEach方法，@since 1.8。 default void forEach(BiConsumer\u003c? super K, ? super V\u003e action) { Objects.requireNonNull(action); for (Map.Entry\u003cK, V\u003e entry : entrySet()) { K k; V v; try { k = entry.getKey(); v = entry.getValue(); } catch(IllegalStateException ise) { // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); } action.accept(k, v); } } 官方解释： 对此映射中的每个条目执行给定操作，直到所有条目已处理或操作引发异常。除非由实现类指定，操作将在入口集迭代的顺序（如果指定了迭代顺序）。 操作引发的异常将中继到调用方。 解读： 使用了try catch 抛出的异常为ConcurrentModificationException，标示在线程并发进行读写的时候会出现异常，即，不支持并发操作。 Map集合中是没有迭代器 的 ,Map集合取 出键值的原理：将map集合转成set集合，再通过迭代器取出 // Iterator entrySet 获取key and value public void testIterator() { Iterator\u003cMap.Entry\u003cInteger, Integer\u003e\u003e it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry\u003cInteger, Integer\u003e entry = it.next(); System.out.println(entry.getKey() + \":\" + entry.getValue()); // it.remove(); 删除元素 } } //Map.Entry的剖析和getKey(),getValue()的由来： interface Map{ //此内部接口的特点是静态的，而且是对外提供访问的 public static interface Entry{ //因为具体情况要视情况而定，所以是抽象的，具体由子类来实现 public abstract Object getKey(); public abstract Object getValue(); } } abstract class HashMap implements Map{ //内部类实现Map.Entry abstract class Hahs implements Map.Entry{ public Object getKey(){} public Object getValue(){} } } keySet()取值方式示例图： entrySet()取值方式示例图： 注意 Entry是接口 ，但是为什么不定义定义在外面呢？ Entry代表的是映射关系，先有Map集合，才有的映射关系，所以它是Map集合内部的事物，因此将Entry定义为 在Map的内部集合，可以直接访问Map集合中的元素 在API文档中有 public static interface Map.Entry\u003cK,V\u003e 其中被static静态修饰，只有接口在 成员位置上才能加静态修饰符 ,说明其是内部接口 Lambda java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 // Lambda 获取key and value public void testLambda() { map.forEach((key, value) -\u003e { System.out.println(key + \":\" + value); }); } 简单性能测试 用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap static { for (int i = 0; i \u003c 100000; i++) { map.put(i, 1); } } 测试结果如下： KeySet： 392 Values： 320 keySet get(key)： 552 entrySet： 465 entrySet Iterator：508 Lambda： 536 需要说明的是，map存储的数据类型，map的大小，以及map的不同实现方式都会影响遍历的性能，所以该测试结果仅供参考 总结 如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 分析 一般来讲使用entrySet的方式进行遍历是效率最高的，因为hashMap内部的存储结构就是基于Entry的数组，在用这种方式进行遍历时，只需要遍历一次即可。而使用其他方式的时间复杂度可以会提高，例如：keySet方式，每次都需要通过key值去计算对应的hash,然后再通过hash获取对应的结果值，因此效率较低。 扩容机制 导读 上期分享了HashMap的key定位以及数据节点的设计, 本期就下面三个问题来分享下个人对于HashMap扩容的理解: .1 HashMap为什么要扩容","date":"2021-10-15","objectID":"/java-collection-note/:3:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"HashMap 的 7 种遍历方式与性能分析 首先，给大家说声抱歉~ 事情经过是这样子的，五一节前我发布了一篇文章《HashMap 的 7 种遍历方式与性能分析！》，但是好心的网友却发现了一个问题，他说 “测试时使用了 sout 打印信息会导致测试的结果不准确，因为这样测试的话，大部分的性能消耗其实来源于信息打印”，我细想了一下，说的确实有道理，于是我就重写了测试部分的代码。 但是不写不知道，一写吓一跳，删除了打印信息的代码之后，惊奇的发现，之前得出的“EntrySet 和 KeySet 性能相近”的结论是错误的，并且我也把 JMH 测试吞吐量的代码换成了平均执行时间，因为这样看起来更直观。而测试的结果是，EntrySet 和 KeySet 的性能相差在一倍以上，详见下文。 本文改动了两处内容： 去掉了测试代码中的打印信息，把测试类型从吞吐量测试改成了平均执行时间测试（这样看起来更直观）； 新增了 EntrySet 和 KeySet 性能差别的原因分析。 备注：以上内容为更正后的完整文章。 随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式，但应该选择那种遍历方式？反而成了一个问题。 本文先从 HashMap 的遍历方法讲起，然后再从性能、原理以及安全性等方面，来分析 HashMap 各种遍历方式的优势与不足，本文主要内容如下图所示： HashMap 遍历 HashMap 遍历从大的方向来说，可分为以下 4 类： 迭代器（Iterator）方式遍历； For Each 方式遍历； Lambda 表达式遍历（JDK 1.8+）; Streams API 遍历（JDK 1.8+）。 但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种： 使用迭代器（Iterator）EntrySet 的方式进行遍历； 使用迭代器（Iterator）KeySet 的方式进行遍历； 使用 For Each EntrySet 的方式进行遍历； 使用 For Each KeySet 的方式进行遍历； 使用 Lambda 表达式的方式进行遍历； 使用 Streams API 单线程的方式进行遍历； 使用 Streams API 多线程的方式进行遍历。 接下来我们来看每种遍历方式的具体实现代码。 1.迭代器 EntrySet public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 Iterator\u003cMap.Entry\u003cInteger, String\u003e\u003e iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = iterator.next(); System.out.println(entry.getKey()); System.out.println(entry.getValue()); } } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 2.迭代器 KeySet public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 Iterator\u003cInteger\u003e iterator = map.keySet().iterator(); while (iterator.hasNext()) { Integer key = iterator.next(); System.out.println(key); System.out.println(map.get(key)); } } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 3.ForEach EntrySet public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 for (Map.Entry\u003cInteger, String\u003e entry : map.entrySet()) { System.out.println(entry.getKey()); System.out.println(entry.getValue()); } } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 4.ForEach KeySet public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 for (Integer key : map.keySet()) { System.out.println(key); System.out.println(map.get(key)); } } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 5.Lambda public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 map.forEach((key, value) -\u003e { System.out.println(key); System.out.println(value); }); } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 6.Streams API 单线程 public class HashMapTest { public static void main(String[] args) { // 创建并赋值 HashMap Map\u003cInteger, String\u003e map = new HashMap(); map.put(1, \"Java\"); map.put(2, \"JDK\"); map.put(3, \"Spring Framework\"); map.put(4, \"MyBatis framework\"); map.put(5, \"Java中文社群\"); // 遍历 map.entrySet().stream().forEach((entry) -\u003e { System.out.println(entry.getKey()); System.out.println(entry.getValue()); }); } } 以上程序的执行结果为： 1 Java 2 JDK 3 Spring Framework 4 MyBatis framework 5 Java中文社群 7.Streams API 多线程 public class HashMapTe","date":"2021-10-15","objectID":"/java-collection-note/:3:4","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java HashMap的死循环 在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程安全的，所以在并发下必然出现问题。但是，我发现近几年，很多人都经历过这个事（在网上查“HashMap Infinite Loop”可以看到很多人都在说这个事）所以，觉得这个是个普遍问题，需要写篇疫苗文章说一下这个事，并且给大家看看一个完美的“Race Condition”是怎么形成的。 问题的症状 从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。 我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。 但是在这里我们可以来研究一下原因。 Hash表数据结构 我需要简单地说一下HashMap这个经典的数据结构。 HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个\u003ckey, value\u003e插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。 我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《Hash Collision DoS 问题》）。 所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。 相信大家对这个基础知识已经很熟悉了。 HashMap的rehash源代码 下面，我们来看一下Java的HashMap的源代码。 Put一个Key,Value对到Hash表中： public V put(K key, V value) { ...... //算Hash值 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); //如果该key已被插入，则替换掉旧的value （链接操作） for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //该key不存在，需要增加一个结点 addEntry(hash, key, value, i); return null; } 检查容量是否超标 void addEntry(int hash, K key, V value, int bucketIndex) { Entry\u003cK,V\u003e e = table[bucketIndex]; table[bucketIndex] = new Entry\u003cK,V\u003e(hash, key, value, e); //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize if (size++ \u003e= threshold) resize(2 * table.length); } 新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; ...... //创建一个新的Hash Table Entry[] newTable = new Entry[newCapacity]; //将Old Hash Table上的数据迁移到New Hash Table上 transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } 迁移的源代码，注意高亮处： void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; //下面这段代码的意思是： // 从OldTable里摘一个元素出来，然后放到NewTable中 for (int j = 0; j \u003c src.length; j++) { Entry\u003cK,V\u003e e = src[j]; if (e != null) { src[j] = null; do { Entry\u003cK,V\u003e next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } 好了，这个代码算是比较正常的。而且没有什么问题。 正常的ReHash的过程 画了个图做了个演示。 我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。 最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。 接下来的三个步骤是Hash表 resize成4，然后所有的\u003ckey,value\u003e 重新rehash的过程 并发下的Rehash **1）假设我们有两个线程。**我用红色和浅蓝色标注了一下。 我们再回头看一下我们的 transfer代码中的这个细节： do { Entry\u003cK,V\u003e next = e.next; // \u003c--假设线程一执行到这里就被调度挂起了 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); 而我们的线程二执行完成了。于是我们有下面的这个样子。 注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。 2）线程一被调度回来执行。 先是执行 newTalbe[i] = e; 然后是e = next，导致了e指向了key(7)， 而下一次循环的next = e.next导致了next指向了key(3) 3）一切安好。 线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。 4）环形链接出现。 e.next = newTable[i] 导致 key(3).next 指向了 key(7) 注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。 设计思想 局部性原理，当时设计HashMap的大叔采用头插法而没有采用尾插法有一点考虑是性能优化，认为最近put进去的元素，被get的概率相对较其他元素大，采用头插法能够更快得获取到最近插入的元素。 但头插法的设计有一个特点，就是扩容之后，链表上的元素顺序会反过来，这也是死循环的一个重要原因。 问题答疑 1、有同学认为线程B对链表的操作，线程A怎么会看到呢？不是有线程可见性问题吗？ 首先得理解线程可见性的原因是因为有cpu缓存，在线程执行之前，读取了操作数，在操作过程中操作数都在CPU缓存中，在线程没有将操作数写入主存之前，线程中对操作数的修改则对于其他线程是不可见的。 而在hashMap扩容的过程中，线程操作的是堆中的对象，线程持有的是对对象的引用。引用就是一个地址，对引用的修改就是对堆中对象的修改。线程B的操作对于线程A的操作是透明的，所以线程A能看到线程B对链表的修改。 其它 有人把这个问题报给了Sun，不过Sun不认为这个是一个问题。因为HashMap本来就不支持并发。要并发就用ConcurrentHashmap http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457 我在这里把这个事情记录下来，只是为了让大家了解并体会一下并发环境下的危险。 修复","date":"2021-10-15","objectID":"/java-collection-note/:3:5","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java 集合 –tableSizeFor 在看 HashMap 源码的时候有这么一段代码 private static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30; private static final int tableSizeFor(int c) { int n = c - 1; n |= n \u003e\u003e\u003e 1; n |= n \u003e\u003e\u003e 2; n |= n \u003e\u003e\u003e 4; n |= n \u003e\u003e\u003e 8; n |= n \u003e\u003e\u003e 16; return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 第一眼看上去完全看不懂，这几个右移按位或是什么意思 运行一个例子看看 private static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30; private static int tableSizeFor(int c) { int n = c - 1; n |= n \u003e\u003e\u003e 1; n |= n \u003e\u003e\u003e 2; n |= n \u003e\u003e\u003e 4; n |= n \u003e\u003e\u003e 8; n |= n \u003e\u003e\u003e 16; return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } public static void main(String[] args) { System.out.println(tableSizeFor(6)); System.out.println(tableSizeFor(7)); System.out.println(tableSizeFor(10)); System.out.println(tableSizeFor(15)); System.out.println(tableSizeFor(18)); } // 输出 8 8 16 16 32 输入 6，7 都是输出 8 输入 10， 15 输出 16 输入 18 输出 32 输出的都是 2 的指数幂，其实这个方法是用于找到大于等于输入参数的的最小的 2 的指数幂。为什么需要这样的方法，因为 hashmap 的容量大小都是 2 的指数幂。 以输入 22 为例子， n = c - 1, n 为 21 每一次右移之后与上一次的结果做按位或操作（只要有一个位是 1，结果就是 1），通过几次操作之后将原本二进制最高位为 1 的后面几位全部至 1，最后再加 1，得到一个 2 的指数幂。 至于为什么一开始要执行 n = c - 1; 这是为了防止 c 已经是 2 的幂，如果 c 已经是 2 的幂， 又没有执行这个减 1 操作，则执行完后面的几条无符号右移操作之后，返回的结果将是这个 c 的 2 倍。 ","date":"2021-10-15","objectID":"/java-collection-note/:3:6","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java-Collectors常用的20个方法 返回List集合: toList()\r\r用于将元素累积到List集合中。它将创建一个新List集合（不会更改当前集合）。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); integers.stream().map(x -\u003e x*x).collect(Collectors.toList()); // output: [1,4,9,16,25,36,36] 返回Set集合: toSet()\r\r用于将元素累积到Set集合中。它会删除重复元素。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); integers.stream().map(x -\u003e x*x).collect(Collectors.toSet()); // output: [1,4,9,16,25,36] 返回指定的集合: toCollection()\r\r可以将元素雷击到指定的集合中。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); integers .stream() .filter(x -\u003e x \u003e2) .collect(Collectors.toCollection(LinkedList::new)); // output: [3,4,5,6,6] 计算元素数量: Counting()\r\r用于返回计算集合中存在的元素个数。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); Long collect = integers .stream() .filter(x -\u003e x \u003c4) .collect(Collectors.counting()); // output: 3 求最小值: minBy()\r\r用于返回列表中存在的最小值。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); integers .stream() .collect(Collectors.minBy(Comparator.naturalOrder())) .get(); // output: 1 strings .stream() .collect(Collectors.minBy(Comparator.naturalOrder())) .get(); // output: alpha 按照整数排序返回1，按照字符串排序返回alpha 可以使用reverseOrder（）方法反转顺序。 List\u003cInteger\u003e integers = Arrays.asList(1,2,3,4,5,6,6); List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); integers .stream() .collect(Collectors.minBy(Comparator.reverseOrder())) .get(); // output: 6 strings .stream() .collect(Collectors.minBy(Comparator.reverseOrder())) .get(); // output: gamma 同时可以自定义的对象定制比较器。 求最大值: maxBy()\r\r和最小值方法类似，使用maxBy（）方法来获得最大值。 List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); strings .stream() .collect(Collectors.maxBy(Comparator.naturalOrder())) .get(); // output: gamma 分区列表:partitioningBy()\r\r用于将一个集合划分为2个集合并将其添加到映射中，1个满足给定条件，另一个不满足，例如从集合中分离奇数。因此它将在map中生成2条数据，1个以true为key，奇数为值，第2个以false为key，以偶数为值。 List\u003cString\u003e strings = Arrays.asList(\"a\",\"alpha\",\"beta\",\"gamma\"); Map\u003cBoolean, List\u003cString\u003e\u003e collect1 = strings .stream() .collect(Collectors.partitioningBy(x -\u003e x.length() \u003e 2)); // output: {false=[a], true=[alpha, beta, gamma]} 这里我们将长度大于2的字符串与其余字符串分开。 返回不可修改的List集合：toUnmodifiableList（）\r\r用于创建只读List集合。任何试图对此不可修改List集合进行更改的尝试都将导致UnsupportedOperationException。 List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); List\u003cString\u003e collect2 = strings .stream() .collect(Collectors.toUnmodifiableList()); // output: [\"alpha\",\"beta\",\"gamma\"] 返回不可修改的Set集合：toUnmodifiableSet()\r\r用于创建只读Set集合。任何试图对此不可修改Set集合进行更改的尝试都将导致UnsupportedOperationException。它会删除重复元素。 List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\",\"alpha\"); Set\u003cString\u003e readOnlySet = strings .stream() .sorted() .collect(Collectors.toUnmodifiableSet()); // output: [\"alpha\",\"beta\",\"gamma\"] 连接元素：Joining（）\r\r用指定的字符串链接集合内的元素。 List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); String collect3 = strings .stream() .distinct() .collect(Collectors.joining(\",\")); // output: alpha,beta,gamma String collect4 = strings .stream() .map(s -\u003e s.toString()) .collect(Collectors.joining(\",\",\"[\",\"]\")); // output: [alpha,beta,gamma] Long类型集合的平均值：averagingLong()\r\r查找Long类型集合的平均值。 注意：返回的是Double类型而不是 Long类型 List\u003cLong\u003e longValues = Arrays.asList(100l,200l,300l); Double d1 = longValues .stream() .collect(Collectors.averagingLong(x -\u003e x * 2)); // output: 400.0 Integer类型集合的平均值：averagingInt()\r\r查找Integer类型集合的平均值。 注意：返回的是Double类型而不是int 类型 List\u003cLong\u003e longValues = Arrays.asList(100l,200l,300l); Double d1 = longValues .stream() .collect(Collectors.averagingLong(x -\u003e x * 2)); // output: 400.0 Double类型集合的平均值：averagingDouble()\r\r查找Double类型集合的平均值。 List\u003cDouble\u003e doubles = Arrays.asList(1.1,2.0,3.0,4.0,5.0,5.0); Double d3 = doubles .stream() .collect(Collectors.averagingDouble(x -\u003e x)); // output: 3.35 创建Map：toMap（）\r\r根据集合的值创建Map。 List\u003cString\u003e strings = Arrays.asList(\"alpha\",\"beta\",\"gamma\"); Map\u003cString,Integer\u003e map = strings .stream() .collect(Collectors .toMap(Function.identity(),String::length)); // output: {alpha=5, beta=4, gamma=5} 在创建Map时处理列表的重复项\r\r集合中可以包含重复的值，因此，如果想从列表中创","date":"2021-10-15","objectID":"/java-collection-note/:4:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java8-Stream集合操作 ","date":"2021-10-15","objectID":"/java-collection-note/:5:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Stream简介 Java 8引入了全新的Stream API。这里的Stream和I/O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同。 stream是对集合对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。 只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 ","date":"2021-10-15","objectID":"/java-collection-note/:5:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"为什么要使用Stream 函数式编程带来的好处尤为明显。这种代码更多地表达了业务逻辑的意图，而不是它的实现机制。易读的代码也易于维护、更可靠、更不容易出错。 高端 ","date":"2021-10-15","objectID":"/java-collection-note/:5:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"实例数据源 public class Data { private static List\u003cPersonModel\u003e list = null; static { PersonModel wu = new PersonModel(\"wu qi\", 18, \"男\"); PersonModel zhang = new PersonModel(\"zhang san\", 19, \"男\"); PersonModel wang = new PersonModel(\"wang si\", 20, \"女\"); PersonModel zhao = new PersonModel(\"zhao wu\", 20, \"男\"); PersonModel chen = new PersonModel(\"chen liu\", 21, \"男\"); list = Arrays.asList(wu, zhang, wang, zhao, chen); } public static List\u003cPersonModel\u003e getData() { return list; } } ","date":"2021-10-15","objectID":"/java-collection-note/:5:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Filter 遍历数据并检查其中的元素时使用。 filter接受一个函数作为参数，该函数用Lambda表达式表示。 /** * 过滤所有的男性 */ public static void fiterSex(){ List\u003cPersonModel\u003e data = Data.getData(); //old List\u003cPersonModel\u003e temp=new ArrayList\u003c\u003e(); for (PersonModel person:data) { if (\"男\".equals(person.getSex())){ temp.add(person); } } System.out.println(temp); //new List\u003cPersonModel\u003e collect = data .stream() .filter(person -\u003e \"男\".equals(person.getSex())) .collect(toList()); System.out.println(collect); } /** * 过滤所有的男性 并且小于20岁 */ public static void fiterSexAndAge(){ List\u003cPersonModel\u003e data = Data.getData(); //old List\u003cPersonModel\u003e temp=new ArrayList\u003c\u003e(); for (PersonModel person:data) { if (\"男\".equals(person.getSex())\u0026\u0026person.getAge()\u003c20){ temp.add(person); } } //new 1 List\u003cPersonModel\u003e collect = data .stream() .filter(person -\u003e { if (\"男\".equals(person.getSex())\u0026\u0026person.getAge()\u003c20){ return true; } return false; }) .collect(toList()); //new 2 List\u003cPersonModel\u003e collect1 = data .stream() .filter(person -\u003e (\"男\".equals(person.getSex())\u0026\u0026person.getAge()\u003c20)) .collect(toList()); } Map map生成的是个一对一映射,for的作用 比较常用 而且很简单 /** * 取出所有的用户名字 */ public static void getUserNameList(){ List\u003cPersonModel\u003e data = Data.getData(); //old List\u003cString\u003e list=new ArrayList\u003c\u003e(); for (PersonModel persion:data) { list.add(persion.getName()); } System.out.println(list); //new 1 List\u003cString\u003e collect = data.stream().map(person -\u003e person.getName()).collect(toList()); System.out.println(collect); //new 2 List\u003cString\u003e collect1 = data.stream().map(PersonModel::getName).collect(toList()); System.out.println(collect1); //new 3 List\u003cString\u003e collect2 = data.stream().map(person -\u003e { System.out.println(person.getName()); return person.getName(); }).collect(toList()); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:4","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"FlatMap 顾名思义，跟map差不多,更深层次的操作 但还是有区别的 map和flat返回值不同 Map 每个输入元素，都按照规则转换成为另外一个元素。 还有一些场景，是一对多映射关系的，这时需要 flatMap。 Map一对一 Flatmap一对多 map和flatMap的方法声明是不一样的 Stream map(Function mapper); Stream flatMap(Function\u003e mapper); map和flatMap的区别：我个人认为，flatMap的可以处理更深层次的数据，入参为多个list，结果可以返回为一个list，而map是一对一的，入参是多个list，结果返回必须是多个list。通俗的说，如果入参都是对象，那么flatMap可以操作对象里面的对象，而map只能操作第一层。 public static void flatMapString() { List\u003cPersonModel\u003e data = Data.getData(); //返回类型不一样 List\u003cString\u003e collect = data.stream() .flatMap(person -\u003e Arrays.stream(person.getName().split(\" \"))).collect(toList()); List\u003cStream\u003cString\u003e\u003e collect1 = data.stream() .map(person -\u003e Arrays.stream(person.getName().split(\" \"))).collect(toList()); //用map实现 List\u003cString\u003e collect2 = data.stream() .map(person -\u003e person.getName().split(\" \")) .flatMap(Arrays::stream).collect(toList()); //另一种方式 List\u003cString\u003e collect3 = data.stream() .map(person -\u003e person.getName().split(\" \")) .flatMap(str -\u003e Arrays.asList(str).stream()).collect(toList()); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:5","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Reduce 感觉类似递归 数字(字符串)累加 个人没咋用过 public static void reduceTest(){ //累加，初始化值是 10 Integer reduce = Stream.of(1, 2, 3, 4) .reduce(10, (count, item) -\u003e{ System.out.println(\"count:\"+count); System.out.println(\"item:\"+item); return count + item; } ); System.out.println(reduce); Integer reduce1 = Stream.of(1, 2, 3, 4) .reduce(0, (x, y) -\u003e x + y); System.out.println(reduce1); String reduce2 = Stream.of(\"1\", \"2\", \"3\") .reduce(\"0\", (x, y) -\u003e (x + \",\" + y)); System.out.println(reduce2); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:6","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Collect collect在流中生成列表，map，等常用的数据结构 toList() toSet() toMap() 自定义 /** * toList */ public static void toListTest(){ List\u003cPersonModel\u003e data = Data.getData(); List\u003cString\u003e collect = data.stream() .map(PersonModel::getName) .collect(Collectors.toList()); } /** * toSet */ public static void toSetTest(){ List\u003cPersonModel\u003e data = Data.getData(); Set\u003cString\u003e collect = data.stream() .map(PersonModel::getName) .collect(Collectors.toSet()); } /** * toMap */ public static void toMapTest(){ List\u003cPersonModel\u003e data = Data.getData(); Map\u003cString, Integer\u003e collect = data.stream() .collect( Collectors.toMap(PersonModel::getName, PersonModel::getAge) ); data.stream() .collect(Collectors.toMap(per-\u003eper.getName(), value-\u003e{ return value+\"1\"; })); } /** * 指定类型 */ public static void toTreeSetTest(){ List\u003cPersonModel\u003e data = Data.getData(); TreeSet\u003cPersonModel\u003e collect = data.stream() .collect(Collectors.toCollection(TreeSet::new)); System.out.println(collect); } /** * 分组 */ public static void toGroupTest(){ List\u003cPersonModel\u003e data = Data.getData(); Map\u003cBoolean, List\u003cPersonModel\u003e\u003e collect = data.stream() .collect(Collectors.groupingBy(per -\u003e \"男\".equals(per.getSex()))); System.out.println(collect); } /** * 分隔 */ public static void toJoiningTest(){ List\u003cPersonModel\u003e data = Data.getData(); String collect = data.stream() .map(personModel -\u003e personModel.getName()) .collect(Collectors.joining(\",\", \"{\", \"}\")); System.out.println(collect); } /** * 自定义 */ public static void reduce(){ List\u003cString\u003e collect = Stream.of(\"1\", \"2\", \"3\").collect( Collectors.reducing(new ArrayList\u003cString\u003e(), x -\u003e Arrays.asList(x), (y, z) -\u003e { y.addAll(z); return y; })); System.out.println(collect); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:7","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Optional Optional 是为核心类库新设计的一个数据类型，用来替换 null 值。 人们对原有的 null 值有很多抱怨，甚至连发明这一概念的Tony Hoare也是如此，他曾说这是自己的一个“价值连城的错误” 用处很广，不光在lambda中，哪都能用 Optional.of(T)，T为非空，否则初始化报错 Optional.ofNullable(T)，T为任意，可以为空 isPresent()，相当于 ！=null ifPresent(T)， T可以是一段lambda表达式 ，或者其他代码，非空则执行 public static void main(String[] args) { PersonModel personModel=new PersonModel(); //对象为空则打出 - Optional\u003cObject\u003e o = Optional.of(personModel); System.out.println(o.isPresent()?o.get():\"-\"); //名称为空则打出 - Optional\u003cString\u003e name = Optional.ofNullable(personModel.getName()); System.out.println(name.isPresent()?name.get():\"-\"); //如果不为空，则打出xxx Optional.ofNullable(\"test\").ifPresent(na-\u003e{ System.out.println(na+\"ifPresent\"); }); //如果空，则返回指定字符串 System.out.println(Optional.ofNullable(null).orElse(\"-\")); System.out.println(Optional.ofNullable(\"1\").orElse(\"-\")); //如果空，则返回 指定方法，或者代码 System.out.println(Optional.ofNullable(null).orElseGet(()-\u003e{ return \"hahah\"; })); System.out.println(Optional.ofNullable(\"1\").orElseGet(()-\u003e{ return \"hahah\"; })); //如果空，则可以抛出异常 System.out.println(Optional.ofNullable(\"1\").orElseThrow(()-\u003e{ throw new RuntimeException(\"ss\"); })); // Objects.requireNonNull(null,\"is null\"); //利用 Optional 进行多级判断 EarthModel earthModel1 = new EarthModel(); //old if (earthModel1!=null){ if (earthModel1.getTea()!=null){ //... } } //new Optional.ofNullable(earthModel1) .map(EarthModel::getTea) .map(TeaModel::getType) .isPresent(); // Optional\u003cEarthModel\u003e earthModel = Optional.ofNullable(new EarthModel()); // Optional\u003cList\u003cPersonModel\u003e\u003e personModels = earthModel.map(EarthModel::getPersonModels); // Optional\u003cStream\u003cString\u003e\u003e stringStream = personModels.map(per -\u003e per.stream().map(PersonModel::getName)); //判断对象中的list Optional.ofNullable(new EarthModel()) .map(EarthModel::getPersonModels) .map(pers-\u003epers .stream() .map(PersonModel::getName) .collect(toList())) .ifPresent(per-\u003e System.out.println(per)); List\u003cPersonModel\u003e models=Data.getData(); Optional.ofNullable(models) .map(per -\u003e per .stream() .map(PersonModel::getName) .collect(toList())) .ifPresent(per-\u003e System.out.println(per)); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:8","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"并发 stream替换成parallelStream或 parallel 输入流的大小并不是决定并行化是否会带来速度提升的唯一因素，性能还会受到编写代码的方式和核的数量的影响 影响性能的五要素是:数据大小、源数据结构、值是否装箱、可用的CPU核数量，以及处理每个元素所花的时间 //根据数字的大小，有不同的结果 private static int size=10000000; public static void main(String[] args) { System.out.println(\"-----------List-----------\"); testList(); System.out.println(\"-----------Set-----------\"); testSet(); } /** * 测试list */ public static void testList(){ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(size); for (Integer i = 0; i \u003c size; i++) { list.add(new Integer(i)); } List\u003cInteger\u003e temp1 = new ArrayList\u003c\u003e(size); //老的 long start=System.currentTimeMillis(); for (Integer i: list) { temp1.add(i); } System.out.println(+System.currentTimeMillis()-start); //同步 long start1=System.currentTimeMillis(); list.stream().collect(Collectors.toList()); System.out.println(System.currentTimeMillis()-start1); //并发 long start2=System.currentTimeMillis(); list.parallelStream().collect(Collectors.toList()); System.out.println(System.currentTimeMillis()-start2); } /** * 测试set */ public static void testSet(){ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(size); for (Integer i = 0; i \u003c size; i++) { list.add(new Integer(i)); } Set\u003cInteger\u003e temp1 = new HashSet\u003c\u003e(size); //老的 long start=System.currentTimeMillis(); for (Integer i: list) { temp1.add(i); } System.out.println(+System.currentTimeMillis()-start); //同步 long start1=System.currentTimeMillis(); list.stream().collect(Collectors.toSet()); System.out.println(System.currentTimeMillis()-start1); //并发 long start2=System.currentTimeMillis(); list.parallelStream().collect(Collectors.toSet()); System.out.println(System.currentTimeMillis()-start2); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:9","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"调试 list.map.fiter.map.xx 为链式调用，最终调用collect(xx)返回结果 分惰性求值和及早求值 判断一个操作是惰性求值还是及早求值很简单:只需看它的返回值。如果返回值是 Stream，那么是惰性求值;如果返回值是另一个值或为空，那么就是及早求值。使用这些操作的理想方式就是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。 通过peek可以查看每个值，同时能继续操作流 private static void peekTest() { List\u003cPersonModel\u003e data = Data.getData(); //peek打印出遍历的每个per data.stream().map(per-\u003eper.getName()).peek(p-\u003e{ System.out.println(p); }).collect(toList()); } ","date":"2021-10-15","objectID":"/java-collection-note/:5:10","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java8 stream().map().collect()用法 ","date":"2021-10-15","objectID":"/java-collection-note/:6:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"集合 List\u003cUser\u003e users = getList(); //从数据库查询的用户集合 现在想获取User的身份证号码；在后续的逻辑处理中要用； 常用的方法我们大家都知道，用for循环， List\u003cString\u003e idcards=new ArrayList\u003cString\u003e();//定义一个集合来装身份证号码 for(int i=0;i\u003cusers.size();i++){ idcards.add(users.get(i).getIdcard()); } 这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定： List\u003cString\u003e idcards= users.stream().map(User::getIdcard).collect(Collectors.toList()) 解释下一这行代码： users：一个实体类的集合，类型为List\u003cUser\u003e User：实体类 getIdcard：实体类中的get方法，为获取User的idcard ","date":"2021-10-15","objectID":"/java-collection-note/:6:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"stream()优点 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 stream().map()方法的使用示例: ","date":"2021-10-15","objectID":"/java-collection-note/:6:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"其他例子 再看几个例子：数组字母小写变大写 List\u003cString\u003e list= Arrays.asList(\"a\", \"b\", \"c\", \"d\"); List\u003cString\u003e collect =list.stream().map(String::toUpperCase).collect(Collectors.toList()); System.out.println(collect); //[A, B, C, D] 数组所有元素，按某种规律计算： List\u003cInteger\u003e num = Arrays.asList(1,2,3,4,5); List\u003cInteger\u003e collect1 = num.stream().map(n -\u003e n * 2).collect(Collectors.toList()); System.out.println(collect1); //[2, 4, 6, 8, 10] ","date":"2021-10-15","objectID":"/java-collection-note/:6:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"为什么在Java 8中String.chars（）是一个整数流？ 正如其他人已经提到的那样,这背后的设计决策是为了防止方法和类的爆炸. 不过,我个人认为这是一个非常糟糕的决定,并且鉴于他们不想制作CharStream,这应该是合理的,不同的方法而不是chars(),我会想到: Stream\u003cCharacter\u003e chars(),这给出了一个盒子字符流,这将有一些轻微的性能损失. IntStream unboxedChars(),将用于性能代码. 但是,我认为这个答案应该专注于展示使用Java 8获得的API的方法,而不是关注为什么它以这种方式完成. 在Java 7中,我会这样做: for (int i = 0; i \u003c hello.length(); i++) { System.out.println(hello.charAt(i)); } 我认为在Java 8中使用它的合理方法如下: hello.chars() .mapToObj(i -\u003e (char)i) .forEach(System.out::println); 在这里,我获得了一个IntStream并通过lambda i -\u003e (char)i将它映射到一个对象,这将自动将其打包成一个Stream\u003cCharacter\u003e,然后我们可以做我们想要的,并仍然使用方法引用作为加号. 请注意,你必须这样做mapToObj,如果你忘记并使用map,那么没有什么会抱怨,但你仍然IntStream会得到一个,你可能会想知道为什么它打印整数值而不是代表字符的字符串. Java 8的其他丑陋替代品: 通过保留IntStream并希望最终打印它们,您不能再使用方法引用进行打印: hello.chars() .forEach(i -\u003e System.out.println((char)i)); 而且,使用方法引用自己的方法不再起作用了!考虑以下: private void print(char c) { System.out.println(c); } 然后 hello.chars() .forEach(this::print); 这将产生编译错误,因为可能存在有损转换. 结论: API是这样设计的,因为不想添加CharStream,我个人认为该方法应该返回一个Stream\u003cCharacter\u003e,并且当前的解决方法是使用mapToObj(i -\u003e (char)i)on IntStream来能够正常使用它们. 补充 任何API的设计都是一系列的权衡.在Java中,其中一个难题是处理很久以前制定的设计决策. 从1.0开始,基元就一直在Java中.它们使Java成为一种\"不纯的\"面向对象语言,因为原语不是对象.我相信,添加原语是一种务实的决定,以牺牲面向对象的纯度为代价来提高性能. 这是近20年后我们仍然生活在今天的权衡.Java 5中添加的自动装箱功能大多消除了使用装箱和拆箱方法调用来混乱源代码的需要,但开销仍然存在.在许多情况下,它并不明显.但是,如果您要在内部循环中执行装箱或拆箱,您会发现它可能会产生大量的CPU和垃圾收集开销. 在设计Streams API时,很明显我们必须支持原语.装箱/拆箱开销会破坏并行性带来的任何性能优势.但是,我们不想支持所有原语,因为这会给API增加大量的混乱.(你能真正看到一个用途ShortStream？)“全部\"或\"无\"是设计的舒适场所,但都不可接受.所以我们必须找到合理的\"一些\"价值.我们结束了与原始的专长int,long和double.(我个人可能会漏掉int但那只是我.) 因为CharSequence.chars()我们考虑返回Stream\u003cCharacter\u003e(早期的原型可能实现了这个),但由于拳击开销而被拒绝.考虑到String将char值作为基元,当调用者可能只对该值进行一些处理并将其反转回字符串时,无条件地强加拳击似乎是错误的. 我们还考虑了一种CharStream原始的特化,但与它添加到API的批量相比,它的使用似乎相当狭窄.添加它似乎不值得. 对调用者施加的惩罚是他们必须知道IntStream包含的char值表示为ints和必须在适当的位置进行转换.这是令人困惑的,因为有过多的API调用,PrintStream.print(char)并且PrintStream.print(int)它们的行为明显不同.可能会出现另一个混乱点,因为codePoints()调用也返回一个IntStream但它包含的值非常不同. 因此,这归结为在几种选择中实际选择: 我们不能提供原始的特化,从而产生一个简单,优雅,一致的API,但它会带来高性能和GC开销; 我们可以提供一整套原始专业化,代价是混乱API并给JDK开发人员带来维护负担; 要么 我们可以提供一个原始特化的子集,给出一个中等大小,高性能的API,在相当窄范围的用例(字符处理)中给调用者带来相对较小的负担. 我们选择了最后一个 只有三种系统自带的streams：IntStream, LongStream and DoubleStream.CharStream 并不存在，原因就是防止方法和类的爆炸，其他类型如（char、short、float）可以用它们更大的等价类型（int、double）来表示，同时也不会有显著的性能损失。已有的三个流的重载可能已经存在接口爆炸的现象了，如果八个接口都存在流类型，可能爆炸会非常严重。 但我的建议是使用codePoints()而不是chars()你会发现很多库函数已经接受int除了char之外的代码点,例如的所有方法java.lang.Character以及StringBuilder.appendCodePoint等.这个支持从jdk1.5开始存在. 同时chars并不包含所有Unicode字符（他会切分代理对（UTF-16中用于扩展字符而使用的编码）），除非您确定不会是使用高位代码字符。 关于代码点的好处.使用它们将处理补充字符,它们在String或char []中表示为代理对.大多数char处理代码极有可能错误处理了代理对.，这就是为什么Stream\u003cCharacter\u003e不应该存在了 定义`void print(int ch){System.out.println((char)ch); 然后你可以使用方法引用，可能是一种办法 自带的StreamCollector的collect()方法.它们只有前面评论中提到的三参数collect()方法.可能代码要繁琐一点。使用代码点流(IntStream)也不错:collect(StringBuilder :: new,StringBuilder :: appendCodePoint,StringBuilder :: append).toString().我猜它不是很短,但使用代码点避免了(char)强制转换,并允许使用方法引用.此外,它正确处理代理人. 但是可以使用.collect(Collectors.joining()) 多亏了重复的问题,我注意到了这个.我同意chars()返回IntStream并不是一个大问题,特别是考虑到它很少使用这种方法的事实.然而,有一个内置的方法将IntStream转换回String会很好.它可以用.reduce(StringBuilder :: new,(sb,c) - \u003e sb.append((char)c),StringBuilder :: append).toString()完成,但它确实很长. 极简主义在这里出现.如果已经有chars()方法返回IntStream中的char值,那么为了获得相同的值但是以盒装形式的另一个API调用,它并没有增加太多.呼叫者可以毫不费力地打包值.当然,不必在这种(可能是罕见的)情况下执行此操作会更方便,但代价是为API添加混乱. 但是，它没有回答为什么chars（）不能有两个不同的方法，一个返回流Stream\u003cCharacter\u003e（性能损失很小），另一个是IntStream，这也被考虑了吗？如果人们认为便利性比性能损失更值得，那么他们很可能最终会将其映射到流Stream\u003cCharacter\u003e。 (我个人可能会漏掉int但那只是我.) int是唯一保证是原子的，不是长的和双精度的，所以并不对 真正的说法是long和double的非原子性在流中并不真正相关，因为这些值都不会出现在跨线程共享的字段中。从纯API的角度来看，int不能做long也不能做的事情，所以从这个意义上说int是多余的。我怀疑使用IntStream的真正原因是性能，因为它只需要移动LongStream的一半数据。不过，我还没有测量过这个。 非常不幸，这将花费开发人员数千小时的时间，因为像：array.stream（char[]）这样的自然构造不起作用，开发人员将在谷歌上寻找替代方案。至少应该存在array.stream（char/byte/short[]）并返回IntStream。 ","date":"2021-10-15","objectID":"/java-collection-note/:7:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"深入理解Java双冒号(::)运算符的使用 Jdk8中有好多新的特性，比如引入Lambda，简化代码的书写等等 Java8 推出了属于Java的lambda表达式，与一众的 =\u003e 不同，Java选择了 -\u003e 做为箭头符号。有没有观众知道为什么这么选择。 lambda表达式的基本格式是这样的 ( )-\u003e{ } 分析 java此时还有另外一个特性叫做lambda表达式和函数式接口，仅仅有一个未实现方法的接口，可以直接写作(参数列表) -\u003e {方法体}这种形式。 例如： @FunctionalInterface public interface FuncA { void doSomeThing(String str); } 那么上面这种接口就可以直接写作： FuncA funcA = (str) -\u003e { System.out.println(\"hello\"); }; 类似的还有Swing或者javaFx的监听器： btn.addActionListener(e-\u003e{ // do something }); 或者 java.lang.Iterable 的 foreach(xxx)方法中的xxx位置需要一个 Consumer 接口类 default void forEach(Consumer\u003c? super T\u003e action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } 而 Consumer 正好是一个函数式接口，@FunctionalInterface 注解和上面类似 @FunctionalInterface public interface Consumer\u003cT\u003e { ... void accept(T t); ... } 这样就省去了之前需要专为他编写一个实现类或者匿名内部类的代码，直接对接口进行实现。 而在这之上，如果一个方法的调用中，这个方法给接口提供的参数和他接收的返回，和你现有某个实现完全一致，就可以进一步进行简化，称为方法引用。 forEach方法提供一个某种类型的Object（具体是什么类型是要看Stream类的泛型参数的，不过一般就是这个集合提供的那种类型），而System.out.println可以接受一个Object，因此，forEach提供的参数和System.out.println的参数类型是一致的，可以进行这种简写。 具体来说就是：原本应该写为： .forEach(element -\u003e { System.out.println(element) }) 但是System.out.println的参数和传递的参数element 的类型完全匹配，所以这样的时候就可以简化为： .forEach（System.out::println) 即forEach将会使用System.out对象的println方法进行接下来的操作。 那么对于Coutum接口可以这么用 Consumer one = (x) -\u003e { System.out.println(x) } ，这句可以和上面结合起来看，x就是accept中的t，花括号里没有return是因为accept返回值是void。因为 Consumer 接口中只有一个方法，因此不会有冲突的可能。 然后再把 one 传进去forEach就可以了。 使用 我们先看一个关于Lambda的使用 /** * 输出list */ @Test public void test() { String[] array = {\"aaaa\", \"bbbb\", \"cccc\"}; List\u003cString\u003e list = Arrays.asList(array); //Java 7 for(String s:list){ System.out.println(s); } //Java 8 list.forEach(System.out::println); } 其中list.forEach(System.out::println);就是Java 8中的Lambda写法之一， 有没有特别注意到输出语句跟我们平时写的syso语句不一样，常规输出语句是这样的： System.out.println(\"流浪地球拍的不错哦！\"); 这里面使用到了::， 有点意思，来认识一下这个新东西！ ","date":"2021-10-15","objectID":"/java-collection-note/:8:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"双冒号（::） 英文：double colon，双冒号（::）运算符在Java 8中被用作方法引用（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。为此，方法引用需要由兼容的函数接口组成的目标类型上下文。 Method References You use lambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it’s often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name. 关于方法引用的描述，摘自oracle官网 大致意思是，使用lambda表达式会创建匿名方法， 但有时候需要使用一个lambda表达式只调用一个已经存在的方法（不做其它）， 所以这才有了方法引用！ 条件1 条件1为必要条件，必须要满足这个条件才能使用双冒号。 Lambda表达式内部只有一条表达式(第一种Lambda表达式)，并且这个表达式只是调用已经存在的方法，不做其他的操作。 条件2 由于双冒号是为了省略item -\u003e这一部分，所以条件2是需要满足不需要写参数item也知道如何使用item的情况。 有两种情况可以满足这个要求，这就是我将双冒号的使用分为2类的依据。 以下是Java 8中方法引用的一些语法： 静态方法引用（static method）语法：classname::methodname 例如：Person::getAge 对象的实例方法引用语法：instancename::methodname 例如：System.out::println 对象的超类方法引用语法： super::methodname 类构造器引用语法： classname::new 例如：ArrayList::new 数组构造器引用语法： typename[]::new 例如： String[]:new 总的来说lambda 表达式允许4种方式的双冒号 如果上的语法太枯燥，那就通过一些例子来加强对它的理解： 静态方法语法使用例子： import java.util.Arrays; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.ComponentScan; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ @RunWith(SpringJUnit4ClassRunner.class) @ComponentScan(\"com.zhoufy\") public class Demo { @Test public void test() { List\u003cString\u003e list = Arrays.asList(\"aaaa\", \"bbbb\", \"cccc\"); //静态方法语法 ClassName::methodName list.forEach(Demo::print); } public static void print(String content){ System.out.println(content); } } 类实例方法语法使用例子： 其中的 Class 指的是类名，产生于 class Class { }。object 是实例对象，产生于 Class object = new Class(); 一个一个的说。 object::instanceMethod` 的一个典型用法就是 `System.out::println 在此请回看 Consumer 类的代码，就明白了为什么 Consumer one = System.out::println 是 Consumer one = t -\u003e System.out.println(t) 的简写 在这里插一个多线程的lambda表达式使用技巧： package cn.edu.hubu.lhy; public class SynchronizedTest { public synchronized void method1() { System.out.println(\"当前线程：\" + Thread.currentThread()); System.out.println(\"Method 1 start\"); try { System.out.println(\"Method 1 execute\"); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Method 1 end\"); } public synchronized void method1(String flag) { System.out.println(\"当前线程：\" + Thread.currentThread()); System.out.println(\"Method 1 start,flag=\" + flag); try { System.out.println(\"Method 1 execute,flag=\" + flag); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Method 1 end,flag=\" + flag); } public synchronized void method2() { System.out.println(\"当前线程：\" + Thread.currentThread()); System.out.println(\"Method 2 start\"); try { System.out.println(\"Method 2 execute\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Method 2 end\"); } public synchronized void method2(String flag) { System.out.println(\"当前线程：\" + Thread.currentThread()); System.out.println(\"Method 2 start,flag=\" + flag); try { System.out.println(\"Method 2 execute,flag=\" + flag); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Method 2 end,flag=\" + flag); } public static void main(String[] args) { // 一种最简洁的启动方法 // new Thread( ()-\u003e new SynchronizedTest().method1() ).start(); //新建实例对象的启动方法 final SynchronizedTest test = new SynchronizedTest(); Thread t1 = new Thread(test::method1); System.out.println(\"t1:\" + t1); t1.start(); Thread t2 = new Thread(() -\u003e test.method1(\"1\")); System.out.println(\"t2:\" + t2); t2.start(); // // 显式的赋值Runnable后再启动 Runnable tt = test::method1; Thread t3 = new Thread(tt); System.out.println(\"t3:\" + t3); t3.start(); Runnable tt2 = () -\u003e test.method1(\"1\"); Thread t4 = new Thread(tt2); System.out.println(\"t4:\" + t4); t4.start(); // Thread t5 = new Thread(test::method2); System.out.println(\"t5:\" + t5","date":"2021-10-15","objectID":"/java-collection-note/:8:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"自定义接口的几种调用方法 interface Person{ void say(String t); } class AnimalSay{ public static void saySomething(String something,Person person) { person.say(something); } } public class Mian { public static void main(String[] args) { Person xiaoMing = (x) -\u003e { System.out.println(x); }; //1 //xiaoMing.say(\"hello\"); AnimalSay.saySomething(\"hello\", xiaoMing ); //2 //AnimalSay.saySomething(\"hello\", (x)-\u003e{System.out.println(x)};); //3 } } 可以直接把 lambda 表达式直接放在需要的位置。这时候 lambda 就可以自动变成所需类 （上面代码被注掉的部分）。 那么回到最开始也有两种用法 //第一种 Consumer one = (x) -\u003e { System.out.println(x);}; Iterable.foreach(one); //第二种 Iterable.foreach( x-\u003eSystem.out.println(x) ); ","date":"2021-10-15","objectID":"/java-collection-note/:8:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java双端队列Deque使用详解 Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。 ","date":"2021-10-15","objectID":"/java-collection-note/:9:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Deque有三种用途： 普通队列(一端进另一端出): Queue queue = new LinkedList()或Deque deque = new LinkedList() 双端队列(两端都可进出) Deque deque = new LinkedList() 堆栈 Deque deque = new LinkedList() 注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。 Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。 下表总结了上述 12 种方法： \r\r第一个元素 (头部)\r最后一个元素 (尾部)\r\r\r\r抛出异常\r特殊值\r抛出异常\r特殊值\r\r\r插入\raddFirst(e)\rofferFirst(e)\raddLast(e)\rofferLast(e)\r\r\r删除\rremoveFirst()\rpollFirst()\rremoveLast()\rpollLast()\r\r\r检查\rgetFirst()\rpeekFirst()\rgetLast()\rpeekLast()\r\r\r\rDeque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示： Queue方法 等效Deque方法 add add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示： 堆栈方法 等效Deque方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() ","date":"2021-10-15","objectID":"/java-collection-note/:9:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Queue队列操作 方法名 作用 区别 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false offer 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 ","date":"2021-10-15","objectID":"/java-collection-note/:10:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"HashSet 是否无序 ","date":"2021-10-15","objectID":"/java-collection-note/:11:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"(一) 问题起因： 《Core Java Volume I—Fundamentals》中对HashSet的描述是这样的： HashSet：一种没有重复元素的无序集合 解释：我们一般说HashSet是无序的，它既不能保证存储和取出顺序一致，更不能保证自然顺序（a-z） 下面是《Thinking in Java》中的使用Integer对象的HashSet的示例 import java.util.*; public class SetOfInteger { public static void main(String[] args) { Random rand = new Random(47); Set\u003cInteger\u003e intset = new HashSet\u003cInteger\u003e(); for (int i = 0; i\u003c10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); } } /* Output: [15, 8, 23, 16, 7, 22, 9, 21, 6, 1 , 29 , 14, 24, 4, 19, 26, 11, 18, 3, 12, 27, 17, 2, 13, 28, 20, 25, 10, 5, 0] 在0-29之间的10000个随机数被添加到了Set中，大量的数据是重复的，但输出结果却每一个数只有一个实例出现在结果中，并且输出的结果没有任何规律可循。 这正与其不重复，且无序的特点相吻合。 看来两本书的结果，以及我们之前所学的知识，看起来都是一致的，一切就是这么美好。 随手运行了一下这段书中的代码，结果却让人大吃一惊 //JDK1.8下 Idea中运行 import java.util.*; public class SetOfInteger { public static void main(String[] args) { Random rand = new Random(47); Set\u003cInteger\u003e intset = new HashSet\u003cInteger\u003e(); for (int i = 0; i\u003c10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); } } //运行结果 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] 嗯！不重复的特点依旧吻合，但是为什么遍历输出结果却是有序的？？？ 写一个最简单的程序再验证一下： import java.util.*; public class HashSetDemo { public static void main(String[] args) { Set\u003cInteger\u003e hs = new HashSet\u003cInteger\u003e(); hs.add(1); hs.add(2); hs.add(3); //增强for遍历 for (Integer s : hs) { System.out.print(s + \" \"); } } } //运行结果 1 2 3 我还不死心，是不是元素数据不够多，有序这只是一种巧合的存在，增加元素数量试试 import java.util.*; public class HashSetDemo { public static void main(String[] args) { Set\u003cInteger\u003e hs = new HashSet\u003cInteger\u003e(); for (int i = 0; i \u003c 10000; i++) { hs.add(i); } //增强for遍历 for (Integer s : hs) { System.out.print(s + \" \"); } } } //运行结果 1 2 3 ... 9997 9998 9999 可以看到，遍历后输出依旧是有序的 ","date":"2021-10-15","objectID":"/java-collection-note/:11:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"(二) 过程 通过一步一步分析源码，我们来看一看，这究竟是怎么一回事，首先我们先从程序的第一步——集合元素的存储开始看起，先看一看HashSet的add方法源码： // HashSet 源码节选-JKD8 public boolean add(E e) { return map.put(e, PRESENT)==null; } 我们可以看到，HashSet直接调用HashMap的put方法，并且将元素e放到map的key位置（保证了唯一性 ） 顺着线索继续查看HashMap的put方法源码： //HashMap 源码节选-JDK8 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 而我们的值在返回前需要经过HashMap中的hash方法 接着定位到hash方法的源码： //HashMap 源码节选-JDK8 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } hash方法的返回结果中是一句三目运算符，键 (key) 为null即返回 0,存在则返回后一句的内容 (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16) JDK8中 HashMap——hash 方法中的这段代码叫做 “扰动函数” 我们来分析一下： hashCode是Object类中的一个方法，在子类中一般都会重写，而根据我们之前自己给出的程序，暂以Integer类型为例，我们来看一下Integer中hashCode方法的源码： /** * Returns a hash code for this {@code Integer}. * * @return a hash code value for this object, equal to the * primitive {@code int} value represented by this * {@code Integer} object. */ @Override public int hashCode() { return Integer.hashCode(value); } /** * Returns a hash code for a {@code int} value; compatible with * {@code Integer.hashCode()}. * * @param value the value to hash * @since 1.8 * * @return a hash code value for a {@code int} value. */ public static int hashCode(int value) { return value; } Integer中hashCode方法的返回值就是这个数本身 注：整数的值因为与整数本身一样唯一，所以它是一个足够好的散列 所以，下面的A、B两个式子就是等价的 //注：key为 hash(Object key)参数 A：(h = key.hashCode()) ^ (h \u003e\u003e\u003e 16) B：key ^ (key \u003e\u003e\u003e 16) 分析到这一步，我们的式子只剩下位运算了，先不急着算什么，我们先理清思路 HashSet因为底层使用哈希表（链表结合数组）实现，存储时key通过一些运算后得出自己在数组中所处的位置。 我们在hashCoe方法中返回到了一个等同于本身值的散列值，但是考虑到int类型数据的范围：-2147483648~2147483647 ，着很显然，这些散列值不能直接使用，因为内存是没有办法放得下，一个40亿长度的数组的。所以它使用了对数组长度进行取模运算，得余后再作为其数组下标，indexFor() ——JDK7中，就这样出现了，在JDK8中 indexFor()就消失了，而全部使用下面的语句代替，原理是一样的。 //JDK8中 (tab.length - 1) \u0026 hash； //JDK7中 bucketIndex = indexFor(hash, table.length); static int indexFor(int h, int length) { return h \u0026 (length - 1); } 提一句，为什么取模运算时我们用 \u0026 而不用 % 呢，因为位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快，这样就导致位运算 \u0026 效率要比取模运算 % 高很多。 看到这里我们就知道了，存储时key需要通过hash方法和indexFor()运算，来确定自己的对应下标 (取模运算，应以JDK8为准，但为了称呼方便，还是按照JDK7的叫法来说，下面的例子均为此，特此提前声明) 但是先直接看与运算(\u0026)，好像又出现了一些问题，我们举个例子： HashMap中初始长度为16，length - 1 = 15；其二进制表示为 00000000 00000000 00000000 00001111 而与运算计算方式为：遇0则0，我们随便举一个key值 1111 1111 1010 0101 1111 0000 0011 1100 \u0026 0000 0000 0000 0000 0000 0000 0000 1111 ---------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1100 我们将这32位从中分开，左边16位称作高位，右边16位称作低位，可以看到经过\u0026运算后 结果就是高位全部归0，剩下了低位的最后四位。但是问题就来了，我们按照当前初始长度为默认的16，HashCode值为下图两个，可以看到，在不经过扰动计算时，只进行与(\u0026)运算后 Index值均为 12 这也就导致了哈希冲突 哈希冲突的简单理解：计划把一个对象插入到散列表(哈希表)中，但是发现这个位置已经被别的对象所占据了 例子中，两个不同的HashCode值却经过运算后，得到了相同的值，也就代表，他们都需要被放在下标为2的位置 一般来说，如果数据分布比较广泛，而且存储数据的数组长度比较大，那么哈希冲突就会比较少，否则很高。 但是，如果像上例中只取最后几位的时候，这可不是什么好事，即使我的数据分布很散乱，但是哈希冲突仍然会很严重。 别忘了，我们的扰动函数还在前面搁着呢，这个时候它就要发挥强大的作用了,还是使用上面两个发生了哈希冲突的数据，这一次我们加入扰动函数再进行与(\u0026)运算 补充 ：\u003e\u003e\u003e 按位右移补零操作符，左操作数的值按右操作数指定的为主右移，移动得到的空位以零填充 ​ ^ 位异或运算，相同则0，不同则1 可以看到，本发生了哈希冲突的两组数据，经过扰动函数处理后，数值变得不再一样了，也就避免了冲突 其实在扰动函数中，将数据右位移16位，哈希码的高位和低位混合了起来，这也正解决了前面所讲 高位归0，计算只依赖低位最后几位的情况, 这使得高位的一些特征也对低位产生了影响，使得低位的随机性加强，能更好的避免冲突 到这里，我们一步步研究到了这一些知识 HashSet add() → HashMap put() → HashMap hash() → HashMap (tab.length - 1) \u0026 hash； 有了这些知识的铺垫，我对于刚开始自己举的例子又产生了一些疑惑,我使用for循环添加一些整型元素进入集合，难道就没有任何一个发生哈希冲突吗，为什么遍历结果是有序输出的，经过简单计算 2 和18这两个值就都是2 (这个疑惑是有问题的，后面解释了错在了哪里) //key = 2,(length -1) = 15 h = key.hashCode() 0000 0000 0000 0000 0000 0000 0000 0010 h \u003e\u003e\u003e 16 0000 0000 0000 0000 0000 0000 0000 0000 hash = h^(h \u003e\u003e\u003e 16) 0000 0000 0000 0000 0000 0000 0000 0010 (tab.length-1)\u0026hash 0000 0000 0000 0000 0000 0000 0000 1111 0000 0000 0000 0000 0000 0000 0000 0010 ------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0010 //2的十进制结果：2 //key = 18,(length -1) = 15 h = key.hashCode() 0000 0000 0000 0000 0000 0000 0001 0010 h \u003e\u003e\u003e 16 0000 0000 0000 0000 0000 0000 0000 0000 hash = h^(h \u003e\u003e\u003e 16) 0000 0000 0000 0000 0000 0000 0001 0010 (tab.length-1)\u0026hash 0000 0000 0000 0000 0000 0000 0000 1111 0000 0000 0000 0000 0000 0000 0000 0010 ----------------","date":"2021-10-15","objectID":"/java-collection-note/:11:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"(三) 总结 JDK7到JDK8，其内部发生了一些变化，导致在不同版本JDK下运行结果不同，根据上面的分析，我们从HashSet追溯到HashMap的hash算法、加载因子和默认长度。 由于我们所创建的HashSet是Integer类型的，这也是最巧的一点，Integer类型hashCode()的返回值就是其int值本身，而存储的时候元素通过一些运算后会得出自己在数组中所处的位置。由于在这一步，其本身即下标(只考虑这一步)，其实已经实现了排序功能，由于int类型范围太广，内存放不下，所以对其进行取模运算，为了减少哈希冲突，又在取模前进行了，扰动函数的计算，得到的数作为元素下标，按照JDK8下的hash算法，以及load factor及扩容机制，这就导致数据在经过 HashMap.hash()运算后仍然是自己本身的值，且没有发生哈希冲突。 补充：对于有序无序的理解 集合所说的序，是指元素存入集合的顺序，当元素存储顺序和取出顺序一致时就是有序，否则就是无序。 并不是说存储数据的时候无序，没有规则，当我们不论使用for循环随机数添加元素的时候，还是for循环有序添加元素的时候，最后遍历输出的结果均为按照值的大小排序输出，随机添加元素，但结果仍有序输出，这就对照着上面那句，存储顺序和取出顺序是不一致的，所以我们说HashSet是无序的，虽然我们按照123的顺序添加元素，结果虽然仍为123，但这只是一种巧合而已。 所以HashSet只是不保证有序，并不是保证无序 ","date":"2021-10-15","objectID":"/java-collection-note/:11:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"Java中List, Integer[], int[]的相互转换 相信新手们在学习Java的过程中都会遇到和我一样的问题：想要把List和int[]相互转换太麻烦了。 List和String[]也同理。难道每次非得写一个循环遍历吗？其实一步就可以搞定。 本文涉及到一些Java8的特性。如果没有接触过就先学会怎么用，然后再细细研究。 import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { int[] data = {4, 5, 3, 6, 2, 5, 1}; // int[] 转 List\u003cInteger\u003e List\u003cInteger\u003e list1 = Arrays.stream(data).boxed().collect(Collectors.toList()); // Arrays.stream(arr) 可以替换成IntStream.of(arr)。 // 1.使用Arrays.stream将int[]转换成IntStream。 // 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream\u003cInteger\u003e。 // 3.使用Stream的collect()，将Stream\u003cT\u003e转换成List\u003cT\u003e，因此正是List\u003cInteger\u003e。 // int[] 转 Integer[] Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::new); // 前两步同上，此时是Stream\u003cInteger\u003e。 // 然后使用Stream的toArray，传入IntFunction\u003cA[]\u003e generator。 // 这样就可以返回Integer数组。 // 不然默认是Object[]。 // List\u003cInteger\u003e 转 Integer[] Integer[] integers2 = list1.toArray(new Integer[0]); // 调用toArray。传入参数T[] a。这种用法是目前推荐的。 // List\u003cString\u003e转String[]也同理。 // List\u003cInteger\u003e 转 int[] int[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray(); // 想要转换成int[]类型，就得先转成IntStream。 // 这里就通过mapToInt()把Stream\u003cInteger\u003e调用Integer::valueOf来转成IntStream // 而IntStream中默认toArray()转成int[]。 // Integer[] 转 int[] int[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray(); // 思路同上。先将Integer[]转成Stream\u003cInteger\u003e，再转成IntStream。 // Integer[] 转 List\u003cInteger\u003e List\u003cInteger\u003e list2 = Arrays.asList(integers1); // 最简单的方式。String[]转List\u003cString\u003e也同理。 // 同理 String[] strings1 = {\"a\", \"b\", \"c\"}; // String[] 转 List\u003cString\u003e List\u003cString\u003e list3 = Arrays.asList(strings1); // List\u003cString\u003e 转 String[] String[] strings2 = list3.toArray(new String[0]); } } 由此可见，流操作还是很方便的。我对这些知识的掌握也不深，就不误人子弟了，只是给刚接触的人提供一个思考的方向。 ","date":"2021-10-15","objectID":"/java-collection-note/:12:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"数组操作 数组的初始化填充 int[] iL = new int[100]; //将数组填充为100个-1 Arrays.fill(iL,-1) ","date":"2021-10-15","objectID":"/java-collection-note/:13:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"字符串操作 String根据下标访问 String s = \"abcd\" Char c = s.charAt(0)//c结果为a ","date":"2021-10-15","objectID":"/java-collection-note/:14:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"String.format()的详细用法 ","date":"2021-10-15","objectID":"/java-collection-note/:15:0","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"问题 在开发的时候一段字符串的中间某一部分是需要可变的 比如一个Textview需要显示”XXX用户来自 上海 年龄 21 性别 男” 其中的 XXX 是用户名 每个用户也是不一样的 地区 上海 为可变的string数据 年龄 21 为可变的int数据 性别 男 为可变的string数据 遇到这种情况你们是怎么样解决的呢?把这段字符串保存在常量类里吗?不!我们应该遵循Google的开发模式 XML \u003cstring name=\"user_info'\u003e %1$s\u003c/span\u003e 用户来自 \u003cspan class=\"hljs-variable\"\u003e%2\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003e$s 年龄 %3$d\u003c/span\u003e 性别 \u003cspan class=\"hljs-variable\"\u003e%4\u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003e$s\u003c/string\u003e JAVA String userName=\"XXX\"; String userProvince=\"上海\"; int userAge=21; String userSex=\"男\"; String string=getResources().getString(R.string.user_info); String userInfo=String.format(string,userName,userProvince,userAge,userSex); 是不是觉得很方便 本来是打算当笔记记录下来备忘的,但是有朋友有朋友问到的一些相关的东西,我就完善一下吧 ","date":"2021-10-15","objectID":"/java-collection-note/:15:1","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"String.format()字符串常规类型格式化的两种重载方式 format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。 format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。 ","date":"2021-10-15","objectID":"/java-collection-note/:15:2","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"上个栗子有用到了字符类型和整数类型的格式化 下面我把常用的类型例举出来 转换符 详细说明 示例 %s 字符串类型 “喜欢请收藏” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 88 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 8.888 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） 不举例(基本用不到) %h 散列码 不举例(基本用不到) %% 百分比类型 ％(%特殊字符%%才能显示%) %n 换行符 不举例(基本用不到) %tx 日期与时间类型（x代表不同的日期与时间转换符) 不举例(基本用不到) ","date":"2021-10-15","objectID":"/java-collection-note/:15:3","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"为了方便理解还是举个例子 String str=null; str=String.format(\"Hi,%s\", \"小超\"); System.out.println(str); str=String.format(\"Hi,%s %s %s\", \"小超\",\"是个\",\"大帅哥\"); System.out.println(str); System.out.printf(\"字母c的大写是：%c %n\", 'C'); System.out.printf(\"布尔结果是：%b %n\", \"小超\".equal(\"帅哥\")); System.out.printf(\"100的一半是：%d %n\", 100/2); System.out.printf(\"100的16进制数是：%x %n\", 100); System.out.printf(\"100的8进制数是：%o %n\", 100); System.out.printf(\"50元的书打8.5折扣是：%f 元%n\", 50*0.85); System.out.printf(\"上面价格的16进制数是：%a %n\", 50*0.85); System.out.printf(\"上面价格的指数表示：%e %n\", 50*0.85); System.out.printf(\"上面价格的指数和浮点数结果的长度较短的是：%g %n\", 50*0.85); System.out.printf(\"上面的折扣是%d%% %n\", 85); System.out.printf(\"字母A的散列码是：%h %n\", 'A'); 输出结果 Hi,小超 Hi,小超 是个 大帅哥 字母c的大写是：C 布尔的结果是：false 100的一半是：50 100的16进制数是：64 100的8进制数是：144 50元的书打8.5折扣是：42.500000 元 上面价格的16进制数是：0x1.54p5 上面价格的指数表示：4.250000e+01 上面价格的指数和浮点数结果的长度较短的是：42.5000 上面的折扣是85% 字母A的散列码是：41 ###搭配转换符还有实现高级功能 第一个例子中有用到 $ 标志 说明 示例 结果 + 为正数或者负数添加符号 (“%+d”,15) +15 0 数字前面补0(加密常用) (“%04d”, 99) 0099 空格 在整数之前添加指定数量的空格 (“% 4d”, 99) 99 , 以“,”对数字分组(常用显示金额) (“%,f”, 9999.99) 9,999.990000 ( 使用括号包含负数 (“%(f”, -99.99) (99.990000) # 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0 (“%#x”, 99)(“%#o”, 99) 0x63 0143 \u003c 格式化前一个转换符所描述的参数 (“%f和%\u003c3.2f”, 99.45) 99.450000和99.45 d,%2$s”, 99,”abc”) 99,abc 第一个例子中有说到 %tx x代表日期转换符 我也顺便列举下日期转换符 标志 说明 示例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 来个例子方便理解 Date date=new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\",date); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\",date); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\",date); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\",date); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\",date); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\",date); 输出结果 全部日期和时间信息：星期三 九月 21 22:43:36 CST 2016 年-月-日格式：2016-09-21 月/日/年格式：16/10/21 HH:MM:SS PM格式（12时制）：10:43:36 下午 HH:MM:SS格式（24时制）：22:43:36 HH:MM格式（24时制）：22:43 其实还有很多其他有趣的玩法 我这边只列举一些常用的 有兴趣的朋友可以自己再去多了解了解 ","date":"2021-10-15","objectID":"/java-collection-note/:15:4","tags":["Java","Collection","JavaNote"],"title":"Java-Collection笔记","uri":"/java-collection-note/"},{"categories":["Back","Note"],"content":"记录Java不同数字对比不同笔记","date":"2021-10-15","objectID":"/java-integer-equal-note/","tags":["Java","Number","Equal"],"title":"Java不同数字对比不同笔记","uri":"/java-integer-equal-note/"},{"categories":["Back","Note"],"content":"介绍 Integer 不同大小和不同创建方式equal和等于后产生了不同的结果 ","date":"2021-10-15","objectID":"/java-integer-equal-note/:1:0","tags":["Java","Number","Equal"],"title":"Java不同数字对比不同笔记","uri":"/java-integer-equal-note/"},{"categories":["Back","Note"],"content":"代码 public class ObjectEqueal { public static void main(String[] args) { Integer i1 = 100, i2 = 100, i3 = 150, i4 = 150;//-128,127为界限 Integer i5 = new Integer(100); Integer i6 = new Integer(100); Integer i7 = new Integer(\"100\"); Integer i8 = Integer.parseInt(\"100\"); System.out.println(i1 == i2);//true System.out.println(i3 == i4);//false System.out.println(i1==i5);//false System.out.println(i6==i5);//false System.out.println(i1==i7);//false System.out.println(i8==i7);//false System.out.println(i1==i8);//true System.out.println(i5.equals(i6));//true System.out.println(i3.equals(i4));//true Double d1 = 100.0, d2 = 100.0, d3 = 150.0, d4 = 150.0;//-128,127为界限 Double d5 = new Double(100); Double d6 = new Double(100); Double d7 = new Double(\"100\"); Double d8 = Double.parseDouble(\"100\"); System.out.println(d1 == d2);//false System.out.println(d3 == d4);//false System.out.println(d1==d5);//false System.out.println(d6==d5);//false System.out.println(d1==d7);//false System.out.println(d8==d7);//false System.out.println(d1==d8);//false System.out.println(d5.equals(d6));//true System.out.println(d3.equals(d4));//true Float f1 = 100.0f, f2 = 100.0f, f3 = 150.0f, f4 = 150.0f;//-128,127为界限 Float f5 = new Float(100f); Float f6 = new Float(100f); Float f7 = new Float(\"100f\"); Float f8 = Float.parseFloat(\"100f\"); System.out.println(f1==f2);//false System.out.println(f3==f4);//false System.out.println(f1==f5);//false System.out.println(f6==f5);//false System.out.println(f1==f7);//false System.out.println(f8==f7);//false System.out.println(f1==f8);//false System.out.println(f5.equals(f6));//true System.out.println(f3.equals(f4));//true } } ","date":"2021-10-15","objectID":"/java-integer-equal-note/:2:0","tags":["Java","Number","Equal"],"title":"Java不同数字对比不同笔记","uri":"/java-integer-equal-note/"},{"categories":["Back","Note"],"content":"结果 在代码中请自行验证 ","date":"2021-10-15","objectID":"/java-integer-equal-note/:3:0","tags":["Java","Number","Equal"],"title":"Java不同数字对比不同笔记","uri":"/java-integer-equal-note/"},{"categories":["Operation","note"],"content":"记录Linux指令操作笔记","date":"2021-10-15","objectID":"/linux-common-cmd-note/","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"使用grep筛选多个条件 1.grep 同时满足多个关键字和满足任意关键字 #① grep -E \"word1|word2|word3\" file.txt 2.满足任意条件（word1、word2和word3之一）将匹配。 # ② grep word1 file.txt | grep word2 |grep word3 必须同时满足三个条件（word1、word2和word3）才匹配。 3.统计符合条件的个数 *.log ——-当前目录下所有以.log结尾的日志 grep word1 *.log | grep word2 | wc -l 4.分页查看符合条件的内容 grep word1 *.log | grep word2 | more 不说废话, 例如需要排除 abc.txt 中的 mmm nnn grep -v 'mmm\\|nnn' abc.txt 但是这样还是很多，需要从这几条信息里面去找到所需要的 ip 地址，我们可能想到了使用 grep -v 屏蔽掉 inet6，结果如下： bash-3.2# ifconfig | grep inet | grep -v inet6 inet 127.0.0.1 netmask 0xff000000 inet 10.60.104.38 netmask 0xfffffe00 broadcast 10.60.105.255 ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:1:0","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"md5sum ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:2:0","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"1、简介 MD5算法一般用于检查文件完整性，尤其常用于检测在（网络）文件传输、拷贝、磁盘错误或其他无恶意涉入的情况下文件的正确性。MD5全称报文摘要算法（Message-DigestAlgorithm 5）[RFC 1321]，该算法对任意长度的信息进行逐位计算，产生一个二进制长度128位（十六进制长度32位）的校验和（或称“指纹”，“报文摘要”），不同的文件内容生成相同的报文摘要的概率是极其小的。 在Linux或Unix上，md5sum是用来计算和校验文件报文摘要的工具程序。一般来说，安装了Linux后，就会有md5sum工具，可以在命令行终端直接执行。 ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:2:1","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"2、命令格式 md5sum [OPTION]... [FILE]... 命令选项 -b或 –binary:以二进制模式读入文件； -t或 –text:以文本文件模式读入文件（默认）； -c或 –check:用来从文件中读取md5信息检查文件的一致性； –status:该选项与check一起使用，在check时不输出，根据返回值表示检查结果； -w或 –warn:在check时，检查输入的md5信息有没有非法行，若有则输出相应信息。 ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:2:2","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"3、实例演示 1）生成一个文件的md5值，如下所示： [root@HLZ test]# ll total 16 -rw-r--r--1 root root 240 Sep 4 22:26 aaa_pkg.tgz -rw-r--r--1 root root 11 Sep 4 22:01 aaa.txt -rw-r--r--1 root root 46 Sep 4 22:24 bbb.log drwxr-xr-x2 root root 4096 Sep 4 22:24 checksum [root@HLZ test]# [root@HLZ test]# md5sum aaa.txt \u003e checksum/aaa.md5 这样，就生成了文件aaa.txt的md5校验文件aaa.md5，打开可以看到如下内容： [root@HLZ test]# cat checksum/aaa.md5 d700cf9bb133858df4d3e0486848be78 aaa.txt 2）md5sum支持多个文件输入或通配符 [root@HLZ test]# md5sum aaa.txt bbb.log aaa_pkg.tgz \u003e checksum/all.md5 [root@HLZ test]# cat checksum/all.md5 d700cf9bb133858df4d3e0486848be78 aaa.txt fff62b77988e5b9d83a2872bb2247b21 bbb.log 36eb58b2563f91baf61531aef126eea6 aaa_pkg.tgz [root@HLZ test]# md5sum aaa* \u003e checksum/aaa_all.md5 [root@HLZ test]# cat checksum/aaa_all.md5 36eb58b2563f91baf61531aef126eea6 aaa_pkg.tgz d700cf9bb133858df4d3e0486848be78 aaa.txt 3）文件内容校验 [root@HLZ test]# md5sum -c ./checksum/aaa.md5 aaa.txt:OK [root@HLZ test]# md5sum -c ./checksum/all.md5 aaa.txt:OK bbb.log:OK aaa_pkg.tgz:OK [root@HLZ test]# vi bbb.log ---修改bbb.log文件内容，添加7个0 abceefghijklmnopqr0000000stuvwxyz1234567890987654321 [root@HLZ test]# md5sum -c ./checksum/all.md5 aaa.txt:OK bbb.log: FAILED aaa_pkg.tgz:OK md5sum: WARNING: 1 of 3 computed checksums did NOT match [root@HLZ test]# 4）文件路径的考虑（$PWD即当前路径/home/hanlzh/test/） [root@HLZ test]# pwd /home/hanlzh/test [root@HLZ test]# md5sum $PWD/aaa.txt \u003e ./checksum/aaa.md5 [root@HLZ test]# cat checksum/aaa.md5 d700cf9bb133858df4d3e0486848be78 /home/hanlzh/test/aaa.txt [root@HLZ test]# md5sum -c ./checksum/aaa.md5 /home/hanlzh/test/aaa.txt:OK [root@HLZ test]# cd .. [root@HLZ hanlzh]# md5sum -c ./test/checksum/aaa.md5 /home/hanlzh/test/aaa.txt:OK 4）文件缺失或不存在情况 [root@HLZ test]# rm -rf aaa_pkg.tgz [root@HLZ test]# md5sum -c ./checksum/aaa_all.md5 md5sum: aaa_pkg.tgz: No such file or directory aaa_pkg.tgz: FAILED open or read aaa.txt:OK md5sum: WARNING: 1 of 2 listed files could not be read ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:2:3","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Operation","note"],"content":"4、总结 特殊说明 1）md5sum是校验文件内容，与文件名是否相同无关； 2）md5sum是逐位校验，所以文件越大，校验时间越长。 md5校验，可能极小概率出现不同的文件生成相同的校验和，比md5更安全的校验算法还有SHA*系列，如sha1sum/sha224sum/sha256sum/sha384sum/sha512sum等等，基本用法与md5sum命令类似，详情可通过man sha1sum查询。 以下仅简单列举一例，不再赘述。 [root@HLZ test]# sha512sum aaa.txt \u003e aaa.sha512 [root@HLZ test]# cat aaa.sha512 8edb9790359ef641112fa85eea5c8f09b7330564a58cddf39aef66006f32454a8879b1e63d9f667ecf86264d4d5b6a602a4c94c79d962ec755345a3837217f89 aaa.txt [root@HLZ test]# [root@HLZ test]# sha512sum -c ./aaa.sha512 aaa.txt:OK ","date":"2021-10-15","objectID":"/linux-common-cmd-note/:2:4","tags":["Linux","Command"],"title":"Linux通用指令操作笔记","uri":"/linux-common-cmd-note/"},{"categories":["Front","note"],"content":"记录Css笔记","date":"2021-10-15","objectID":"/css-note/","tags":["UI","Css"],"title":"Css笔记","uri":"/css-note/"},{"categories":["Front","note"],"content":"div布局根据内容自适应宽度 display:inline-block; *display:inline; *zoom:1; ","date":"2021-10-15","objectID":"/css-note/:1:0","tags":["UI","Css"],"title":"Css笔记","uri":"/css-note/"},{"categories":["Back"],"content":"记录Mysql和PostgreSql的Truncate指令区别","date":"2021-10-15","objectID":"/mysql-postgresql-truncate-diff/","tags":["Mysql","PostgreSql","Truncate","Difference"],"title":"Mysql和PostgreSql的Truncate指令区别","uri":"/mysql-postgresql-truncate-diff/"},{"categories":["Back"],"content":"介绍 清空数据表数据使用 Truncate指令 ","date":"2021-10-15","objectID":"/mysql-postgresql-truncate-diff/:1:0","tags":["Mysql","PostgreSql","Truncate","Difference"],"title":"Mysql和PostgreSql的Truncate指令区别","uri":"/mysql-postgresql-truncate-diff/"},{"categories":["Back"],"content":"区别 在 mysql中，只需要执行： TRUNCATEtable_name; 即可，数据会情况，而且自增id也会变回0； 但在 postgresql 则稍有不同，因为 postgresql 的自增id是通过序列 sequence来完成的， 所以情况数据后，还需要还原序列 sequence： TRUNCATEbigtable,fattableRESTARTIDENTITY; 官方文档 另一种方式：（因为版本不同，可能命令不同） TRUNCATEtabletable_name;altersequenceseq_namestart1; 参考 ","date":"2021-10-15","objectID":"/mysql-postgresql-truncate-diff/:2:0","tags":["Mysql","PostgreSql","Truncate","Difference"],"title":"Mysql和PostgreSql的Truncate指令区别","uri":"/mysql-postgresql-truncate-diff/"},{"categories":["Test","note"],"content":"记录Jmeter笔记","date":"2021-10-15","objectID":"/jmeter-note/","tags":["Jmeter"],"title":"Jmeter笔记","uri":"/jmeter-note/"},{"categories":["Test","note"],"content":"线程数、Ramp-Up时间、循环次数的关系 线程数：a Ramp-Up时间:b 循环次数：c 说明： （1）每个线程可以看做是一个用户 （2）循环次数指每个用户的循环次数 （3）Ramp-Up时间指的是需要在这个时间内完成所有的请求： 得出： 最终请求次数= a*c 每个请求间隔时间 b/(a*c) ","date":"2021-10-15","objectID":"/jmeter-note/:1:0","tags":["Jmeter"],"title":"Jmeter笔记","uri":"/jmeter-note/"},{"categories":["Learning","note"],"content":"记录时间戳笔记","date":"2021-10-15","objectID":"/timestraip-note/","tags":["Time","Timestamp"],"title":"时间戳笔记","uri":"/timestraip-note/"},{"categories":["Learning","note"],"content":"介绍 时间戳是自 1970 年 1 月 1 日（08:00:00 GMT）至当前时间的总秒数，它也被称为 Unix 时间戳。 ","date":"2021-10-15","objectID":"/timestraip-note/:1:0","tags":["Time","Timestamp"],"title":"时间戳笔记","uri":"/timestraip-note/"},{"categories":["Learning","note"],"content":"规则 时间戳（timestamp），一个能表示一份数据在某个特定时间之前已经存在的、 完整的、 可验证的数据,通常是一个字符序列，唯一地标识某一刻的时间。使用数字签名技术产生的数据， 签名的对象包括了原始文件信息、 签名参数、 签名时间等信息。广泛的运用在知识产权保护、 合同签字、 金融帐务、 电子报价投标、 股票交易等方面。 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 通俗的讲， 时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。 它的提出主要是为用户提供一份电子证据， 以证明用户的某些数据的产生时间。 在实际应用上， 它可以使用在包括电子商务、 金融活动的各个方面， 尤其可以用来支撑公开密钥基础设施的 “不可否认” 服务。 《时间戳规范》的标准中规定了时间戳的保存、 时间戳的备份、 时间戳的检索、 时间戳的删除和销毁、 时间戳的查看和验证。 时间戳的保存包括在TSA （时间戳机构）方的保存和在用户方的保存。 在TSA方的保存涉及到时间戳数据库的管理和时间戳 记录应当包含的信息项， 一般最少应包括入库时间、 序列号、 完整编码等。 时间戳在用户方一般由用户自行保存。 ","date":"2021-10-15","objectID":"/timestraip-note/:2:0","tags":["Time","Timestamp"],"title":"时间戳笔记","uri":"/timestraip-note/"},{"categories":["Back","note"],"content":"记录Java类序列化与反序列化工具笔记","date":"2021-10-14","objectID":"/json-and-collection-note/","tags":["Java","Json","Fastjson","Gson"],"title":"Java类序列化与反序列化工具笔记","uri":"/json-and-collection-note/"},{"categories":["Back","note"],"content":"1 Alibaba Fastjson 1.Map转JSON Map\u003cString, Object\u003e Map = new HashMap\u003cString, Object\u003e(); Map.put(\"a\", \"a\"); Map.put(\"b\", \"123\"); JSONObject json = new JSONObject(Map); 2.Map转string Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"a\", \"b\"); String s = JSONObject.toJSONString(map); 3.JSON转String JSONObject json = new JSONObject(); json.put(\"c\", \"v\"); json.put(\"z\", \"123n); json.toJSONString(); 4.JSON转Map JSONObject json = new JSONObject(); json.put(\"ccc\", \"321\"); json.put(\"bbb\", \"123\"); Map\u003cString, Object\u003e map = (Map\u003cString, Object\u003e)json; 5.String转JSON String str = \"{\\\"username\\\":\\\"dsad\\\",\\\"qwewqe\\\":\\\"123\\\"}\"; JSONObject json = JSONObject.parseObject(str); ","date":"2021-10-14","objectID":"/json-and-collection-note/:1:0","tags":["Java","Json","Fastjson","Gson"],"title":"Java类序列化与反序列化工具笔记","uri":"/json-and-collection-note/"},{"categories":["Back","note"],"content":"2 Google gson maven坐标 \u003c!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.google.code.gson\u003c/groupId\u003e \u003cartifactId\u003egson\u003c/artifactId\u003e \u003cversion\u003e2.3.1\u003c/version\u003e \u003c/dependency\u003e Map转换成JSON Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e(); map.put(\"a\",\"aaa\"); map.put(\"b\",\"bbb\"); map.put(\"c\",\"ccc\"); String json=JSON.toJSONString(map); System.out.println(json);//输出{\"a\":\"aaa\",\"b\":\"bbb\",\"c\":\"ccc\"} JSON转换成Map Map map1 = JSON.parseObject(json); System.out.println(map1.get(\"a\")); for (Object mapData : map.entrySet()) { Map.Entry\u003cString,String\u003e entry = (Map.Entry\u003cString,String\u003e)mapData; System.out.println(entry.getKey()+\"---\u003e\"+entry.getValue()); } /*输出 b---\u003ebbb c---\u003eccc a---\u003eaaa */ Map中含有对象Map -\u003e JSON //Map -\u003e JSON Map\u003cString,Bar\u003e map = new HashMap\u003cString, Bar\u003e(); map.put(\"a\",new Bar()); map.put(\"b\",new Bar()); map.put(\"c\",new Bar()); String json = JSON.toJSONString(map,true); System.out.println(json); /* 输出{ \"a\":{ \"barAge\":383687382, \"barDate\":1494945882018, \"barName\":\"name_1689176802\" }, \"b\":{ \"barAge\":-100528778, \"barDate\":1494945882018, \"barName\":\"name_-878176366\" }, \"c\":{ \"barAge\":-344075192, \"barDate\":1494945882018, \"barName\":\"name_-1710740534\" } } */ JSON -\u003e Map Map\u003cString,Bar\u003e map1 = (Map\u003cString,Bar\u003e)JSON.parse(json); for (String key : map1.keySet()) { System.out.println(key+\":\"+map1.get(key)); } /*输出 b:{\"barAge\":-100528778,\"barDate\":1494945882018,\"barName\":\"name_-878176366\"} c:{\"barAge\":-344075192,\"barDate\":1494945882018,\"barName\":\"name_-1710740534\"} a:{\"barAge\":383687382,\"barDate\":1494945882018,\"barName\":\"name_1689176802\"} */ 附Map的ASCII排序 StringBuilder sb = new StringBuilder(); List\u003cString\u003e keys = new ArrayList\u003cString\u003e(map.keySet()); Collections.sort(keys);//排序。 for(String k : keys){ String v = params.get(k); if(StringUtils.isNotEmpty(v)){ sb.append(v); } } //return MD5.toMD5(sb+key, \"UTF-8\");这个就不用看了~~~ ","date":"2021-10-14","objectID":"/json-and-collection-note/:2:0","tags":["Java","Json","Fastjson","Gson"],"title":"Java类序列化与反序列化工具笔记","uri":"/json-and-collection-note/"},{"categories":["Back"],"content":"记录明明设置了目的List的大小，为什么执行Collections.copy()还是报错：Source does not fit in dest的解决办法","date":"2021-10-14","objectID":"/java-source-not-fit-dest-error/","tags":["Java","Collections","Copy","Error"],"title":"Java Collections.copy()报错：Source does not fit in dest","uri":"/java-source-not-fit-dest-error/"},{"categories":["Back"],"content":"报错原因分析 首先说一下，报错Source does not fit in dest。 在复制List时，使用Collections.copy(dest, src)方法，首先会检查src的大小是否大于dest的大小，如果大于，则报错。 这一点，源码写的很清楚： /** * Copies all of the elements from one list into another. After the * operation, the index of each copied element in the destination list * will be identical to its index in the source list. The destination * list must be at least as long as the source list. If it is longer, the * remaining elements in the destination list are unaffected. \u003cp\u003e * * This method runs in linear time. * * @param dest The destination list. * @param src The source list. * @throws IndexOutOfBoundsException if the destination list is too small * to contain the entire source List. * @throws UnsupportedOperationException if the destination list's * list-iterator does not support the \u003ctt\u003eset\u003c/tt\u003e operation. */ public static \u003cT\u003e void copy(List\u003c? super T\u003e dest, List\u003c? extends T\u003e src) { int srcSize = src.size(); if (srcSize \u003e dest.size()) //在这里判断大小 throw new IndexOutOfBoundsException(\"Source does not fit in dest\"); if (srcSize \u003c COPY_THRESHOLD || (src instanceof RandomAccess \u0026\u0026 dest instanceof RandomAccess)) { for (int i=0; i\u003csrcSize; i++) dest.set(i, src.get(i)); } else { ListIterator\u003c? super T\u003e di=dest.listIterator(); ListIterator\u003c? extends T\u003e si=src.listIterator(); for (int i=0; i\u003csrcSize; i++) { di.next(); di.set(si.next()); } } } 但是，如果给dest的List设置了大小，比如下面这样，为什么还是报错？ List dest = new ArrayList(src.size()); Collections.copy(dest, src); 实际上，这样传入的size，只分配了内存，却没有定义元素。 如果这时候打印dest的size，得到的是0。 怎么办？ ","date":"2021-10-14","objectID":"/java-source-not-fit-dest-error/:1:0","tags":["Java","Collections","Copy","Error"],"title":"Java Collections.copy()报错：Source does not fit in dest","uri":"/java-source-not-fit-dest-error/"},{"categories":["Back"],"content":"解决 当你百度如何深拷贝List时，你可能会看到以下两种写法 List dest = Arrays.asList(new String[src.size()]); CollectionUtils.addAll(dest, new Object[src.size()]); 其本质都是把dest撑起来，此时再执行copy就没有问题了。 ","date":"2021-10-14","objectID":"/java-source-not-fit-dest-error/:2:0","tags":["Java","Collections","Copy","Error"],"title":"Java Collections.copy()报错：Source does not fit in dest","uri":"/java-source-not-fit-dest-error/"},{"categories":["Back","note"],"content":"记录TransportClient访问ES笔记","date":"2021-10-14","objectID":"/es-transportclient-note/","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"索引 ","date":"2021-10-14","objectID":"/es-transportclient-note/:1:0","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"获取ES库下所有索引 tcp/ip IndicesStatsResponse resp = client.admin().indices().prepareStats().execute().actionGet(); GetIndexResponse resp = client.admin().indices().prepareGetIndex().execute().actionGet(); http GetMapping getMapping = new GetMapping.Builder().build(); JestResult results = jestclient.execute(getMapping); ","date":"2021-10-14","objectID":"/es-transportclient-note/:1:1","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"判断索引是否存在 public boolean isIndexExist(String index) { return client.admin().indices().prepareExists(index).execute().actionGet().isExists(); } ","date":"2021-10-14","objectID":"/es-transportclient-note/:1:2","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"删除索引 public boolean deleteIndex(String index) { return isIndexExist(index) ? client.admin().indices().prepareDelete(index).execute().actionGet().isAcknowledged() : false; } ","date":"2021-10-14","objectID":"/es-transportclient-note/:1:3","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"新增索引 public boolean addIndex(String index) { return isIndexExist(index) ? false : client.admin().indices().prepareCreate(index).execute().actionGet().isAcknowledged(); } ","date":"2021-10-14","objectID":"/es-transportclient-note/:1:4","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"类型 ","date":"2021-10-14","objectID":"/es-transportclient-note/:2:0","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"判断inde下指定type是否存在 public boolean isTypeExist(String index, String type) { return isIndexExist(index) ? client.admin().indices().prepareTypesExists(index).setTypes(type).execute().actionGet().isExists() : false; } ","date":"2021-10-14","objectID":"/es-transportclient-note/:2:1","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"新增类型 public boolean addIndexAndType() throws IOException { String index = \"ahut\"; String type = \"goods\"; // 创建索引映射,相当于创建数据库中的表操作 CreateIndexRequestBuilder cib = client.admin().indices().prepareCreate(index); XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject(\"properties\") // 设置自定义字段 .startObject(\"goodsName\").field(\"type\", \"string\").endObject() // 商品名称 .startObject(\"goodsPrice\").field(\"type\", \"double\").endObject()// 商品价格 .startObject(\"goodsUser\").field(\"type\", \"string\").endObject()// 商品主人 .startObject(\"goodsTime\").field(\"type\", \"date\").field(\"format\", \"yyyy-MM-dd HH:mm:ss\").endObject() // 商品上架时间 .endObject().endObject(); cib.addMapping(type, mapping); return cib.execute().actionGet().isAcknowledged(); } ","date":"2021-10-14","objectID":"/es-transportclient-note/:2:2","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"文档 ","date":"2021-10-14","objectID":"/es-transportclient-note/:3:0","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"修改文档 新增文档 public long addDocument() throws IOException { String index = \"ahut\"; String type = \"goods\"; // 自定义主键id,这个id也可以不要,让es自动为我们生成id String id = UUID.randomUUID().toString().replace(\"-\", \"\"); // 创建文档,相当于往表里面insert一行数据 IndexResponse response = client.prepareIndex(index, type, id) .setSource(XContentFactory.jsonBuilder().startObject()// 开始 .field(\"goodsName\", \"大学英语\")// 商品名称 .field(\"goodsPrice\", 22.33)// 商品价格 .field(\"goodsUser\", \"大拿\")// 商品主人 .field(\"goodsTime\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date()))// 商品上架时间 .endObject()) .get(); return response.getVersion(); } 删除文档 public String deleteDocument() { String index = \"ahut\"; String type = \"goods\"; String id = \"5b1c93212c2f4d8e88e6bc91de22d08d\"; return client.prepareDelete(index, type, id).get().getId(); } ","date":"2021-10-14","objectID":"/es-transportclient-note/:3:1","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Back","note"],"content":"查询文档 依据id查询 @Test public void testSearchById() { String index = \"ahut\"; String type = \"goods\"; String id = \"9d3bd69ce77f41ab8b12b165483452f6\"; GetResponse response = client.prepareGet(index, type, id).execute().actionGet(); String jsonStr = response.getSourceAsString(); if (jsonStr != null) { System.out.println(jsonStr); } else { System.out.println(\"没有查到\"); } } 查询索引下所有数据 @Test public void matchAllQuery() { String index = \"ahut\"; QueryBuilder query = QueryBuilders.matchAllQuery(); SearchResponse response = client.prepareSearch(index).setQuery(query).execute().actionGet(); for (SearchHit searchHit : response.getHits()) { String jsonStr = searchHit.getSourceAsString(); System.out.println(jsonStr); } } 查询类型下所有数据 @Test public void matchAllQueryInType() { String index = \"ahut\"; String type = \"goods\"; SearchResponse response = client.prepareSearch(index).setTypes(type).execute().actionGet(); for (SearchHit searchHit : response.getHits()) { String jsonStr = searchHit.getSourceAsString(); System.out.println(jsonStr); } } ","date":"2021-10-14","objectID":"/es-transportclient-note/:3:2","tags":["ElasticSearch","TransportClient"],"title":"TransportClient访问ES笔记","uri":"/es-transportclient-note/"},{"categories":["Learning","note"],"content":"记录Cron表达式笔记","date":"2021-10-14","objectID":"/cron-express-note/","tags":["Time","Cron"],"title":"Cron表达式笔记","uri":"/cron-express-note/"},{"categories":["Learning","note"],"content":"介绍 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： 　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year 　（2）Seconds Minutes Hours DayofMonth Month DayofWeek ","date":"2021-10-14","objectID":"/cron-express-note/:1:0","tags":["Time","Cron"],"title":"Cron表达式笔记","uri":"/cron-express-note/"},{"categories":["Learning","note"],"content":"结构 　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 ","date":"2021-10-14","objectID":"/cron-express-note/:2:0","tags":["Time","Cron"],"title":"Cron表达式笔记","uri":"/cron-express-note/"},{"categories":["Learning","note"],"content":"各字段的含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 　注意事项： 　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： 　（1）：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. 　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 ","date":"2021-10-14","objectID":"/cron-express-note/:3:0","tags":["Time","Cron"],"title":"Cron表达式笔记","uri":"/cron-express-note/"},{"categories":["Learning","note"],"content":"常用表达式例子 　（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 　（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 　（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 　（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 　（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 　（6）0 0 12 ? * WED 表示每个星期三中午12点 　（7）0 0 12 * * ? 每天中午12点触发 　（8）0 15 10 ? * * 每天上午10:15触发 　（9）0 15 10 * * ? 每天上午10:15触发 　（10）0 15 10 * * ? * 每天上午10:15触发 　（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 　（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 　（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 　（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 　（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 　（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 　（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 　（18）0 15 10 15 * ? 每月15日上午10:15触发 　（19）0 15 10 L * ? 每月最后一日的上午10:15触发 　（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 　（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 　（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 　注： 　（1）有些子表达式能包含一些范围或列表 　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT” “*”字符代表所有可能的值 　因此，“”在子表达式（月）里表示每个月的含义，“”在子表达式（天（星期））表示星期的每一天 　“/”字符用来指定数值的增量 例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟 在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样 　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？” 　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 但是它在两个子表达式里的含义是不同的。 在天（月）子表达式中，“L”表示一个月的最后一天 在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT 　如果在“L”前有具体的内容，它就具有其他的含义了 　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题 ","date":"2021-10-14","objectID":"/cron-express-note/:4:0","tags":["Time","Cron"],"title":"Cron表达式笔记","uri":"/cron-express-note/"},{"categories":["Back","Note"],"content":"记录Sql笔记","date":"2021-10-14","objectID":"/sql-note/","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"Mysql行列转置 ","date":"2021-10-14","objectID":"/sql-note/:1:0","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"需求 我们想跑一个数据，格式如下图： 但是我们一般的mysql语句跑出来的数据却是下面这样，不但不方便查看，在数据量比较大的时候，我们需要每个地区都转置粘贴一遍，耗时耗力还容易出错，下面提供一个方法，可以让跑出来的数据就是你一开始想要的样子（上图），不但方便线上化的查看，也方便线下的粘贴。 ","date":"2021-10-14","objectID":"/sql-note/:1:1","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"方法 代码 - case when语句： SELECTt.`地区`,COUNT(DISTINCT(caseWHENt.班级=1THENt.学号end))AS'班级1',COUNT(DISTINCT(caseWHENt.班级=2THENt.学号end))AS'班级2',COUNT(DISTINCT(caseWHENt.班级=3THENt.学号end))AS'班级3',COUNT(DISTINCT(caseWHENt.班级=4THENt.学号end))AS'班级4'FROMcm1_0625twheret.`地区`\u003c\u003e''GROUPBY1; 代码 - IF语句： SELECTt.`地区`,COUNT(DISTINCTIF(t.班级=1,t.学号,0))AS'班级1',COUNT(DISTINCTIF(t.班级=2,t.学号,0))AS'班级2',COUNT(DISTINCTIF(t.班级=3,t.学号,0))AS'班级3',COUNT(DISTINCTIF(t.班级=4,t.学号,0))AS'班级4'FROMcm1_0625twheret.`地区`\u003c\u003e''GROUPBY1; 运行结果： ","date":"2021-10-14","objectID":"/sql-note/:1:2","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"将A列赋值给B列 Mysql UPDATEtableNameSETb=a; PostgreSql UPDATEtableNameSET\"b\"=\"a\"; ","date":"2021-10-14","objectID":"/sql-note/:2:0","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"left join的用法 在讲left join（左关联）之前，要说下right join（右关联）的用法其实类似left join,把right join想象成是left join的一种转化方式即可。 我们工作中经常会用到left join来进行联表取数分析，今天就专门来讲讲left join的用法。 很多基础的数据库应用的书籍都有讲到left join的用法，但是都没有深入在运用过程中应该注意哪些地方。如果你仅是单纯地套用你会发现在实际工作中会遇到各种各样的问题。 ","date":"2021-10-14","objectID":"/sql-note/:3:0","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"一、基本语句 selecta.id,a.column,b.id,b.columnfromaleftjoinbona.id=b.id 在这里a表与b表以主键id进行联接。查询的结果保留a表中全部的id数据和选到的某列的数据，而b.id和其他列只保留与a表相匹配的数据。而不匹配的b表的id和其他列以null填充。这个用法类似excel中的vlookup的用法。掌握了vlookup的用法，基本上对left join的用法也掌握了。 ","date":"2021-10-14","objectID":"/sql-note/:3:1","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"二、如何解决一对多的问题 当a表有100行数据，而b表有1000行数据，并且b表中的b.id是有重复值的，而且在实际应用过程中，这确实属于正常现象。 我们可以想象a表是用户表，b表是订单表。自然也就想到了一个用户可能多次下单。我们假设b表中的用户id在a表中匹配到50个用户id，但是这50个用户id总订单数是500个。 那么当我们在执行以上sql语句时，就会出现查询的结果550条，为什么呢？ 因为当left join 一对多的时候，就会出现将b表中相同匹配的数据填充到查询结果去。 如何解决这种问题呢，我们可以根据实际情况来做调整。 把一对多的问题转化成聚合查询 如果业务需求是要查询用户的下单量，可以将sql语句编程如下 selecta.用户id,a.用户姓名,count(订单id)from用户表aleftjoin订单表bona.用户id=b.用户idgroupbya.用户id,a.用户姓名 把一对多的问题转化成多对一的问题 如果业务需求是要查询用户的下单明细，可以将sql语句编程如下 selecta.订单id,a.业务类型a.单价a.消费数量b.用户姓名,b.用户联系方式from订单表aleftjoin用户表bona.用户id=b.用户id ","date":"2021-10-14","objectID":"/sql-note/:3:2","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Back","Note"],"content":"三、条件联接查询 以上的sql语句都是全量查询，在面对表数据较大的情况，全量查询是非常耗时的。 所以查询过程中，我们一定要运用where子句来限定条件，提高查询效率。 在这里有两种方式：一种是全量查询后+where子句，一种是联接前就先做限定。 全量查询后+where子句。 如查询用户为男，消费总价大于1w元的用户明细 selecta.订单id,a.业务类型a.单价a.消费数量b.用户姓名,b.用户联系方式from订单表aleftjoin用户表bona.用户id=b.用户idwhereb.用户性别='男'and(a.单价*a.消费数量)\u003e10000andb.用户idisnotnull 联接前就先做限定。 如我们需要查询用户在某时间段，访问A页面再访问B页面的留存用户量。查询的表只有用户行为表。 selectcount(a.user_id),count(b.user_id)from(selectdistinctuser_idfrom用户行为表wheredate_str='2016-11-01'andurl=‘A页面路径’)aleftjoin(selectdistinctuser_idfrom用户行为表wheredate_str='2016-11-01'andurl=‘B页面路径’)bona.user_id=b.user_idwhereb.user_idisnotnull OK! 先讲到这里，希望对大家有用！ ","date":"2021-10-14","objectID":"/sql-note/:3:3","tags":["Database","Sql"],"title":"Sql笔记","uri":"/sql-note/"},{"categories":["Learning","note"],"content":"记录查找算法和对应的数据结构的笔记","date":"2021-10-11","objectID":"/search-algorithm-note/","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"七大查找算法 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:0","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"1. 顺序查找 顺序查找适合于存储结构为顺序存储或链接存储的线性表，时间复杂度为O(n) ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:1","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"2. 二分查找 元素必须是有序的，如果是无序的则要先进行排序操作。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:2","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"3. 插值查找 基于二分查找算法，将查找点的选择改进为自适应选择，mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，适合表长较大，而关键字分布又比较均匀的查找表 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:3","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"4. 斐波那契查找 二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1)。如果\u003e，low=mid+1,k-=2;如果\u003c，high=mid-1,k-=1。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:4","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"5. 树表查找 （1）二叉查找树与平衡二叉树（AVL） （2）平衡查找树之2-3查找树**（2-3 Tree）** ：其实和B树很像，只不过限定了m=3，节点只有1个或者2个key 效率： （3）平衡查找树之红黑树（Red-Black Tree） 　2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。 　**基本思想：**红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，**使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。**这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。 　红黑树是一种具有红色和黑色链接的平衡查找树，同时满足： 红色节点向左倾斜 一个节点不可能有两个红色链接 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。 　下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。 　红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：平均高度大约为logn 红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如： Java中的java.util.TreeMap,java.util.TreeSet； C++ STL中的：map,multimap,multiset； .NET中的：SortedDictionary,SortedSet 等。 （4）B树和B+树（B Tree/B+ Tree） 平衡查找树中的2-3树以及其实现红黑树。2-3树中，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。 所以B树其实是对*2-3树的扩展* *B+树是对B树的变形：* B+ 树的优点在于： 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。 B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 　但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如： Windows：HPFS文件系统； Mac：HFS，HFS+文件系统； Linux：ResiserFS，XFS，Ext3FS，JFS文件系统； 数据库：ORACLE，MYSQL，SQLSERVER等中。 树表查找总结： 　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:5","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"6. 分块查找 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:6","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"7. 哈希查找 散列查找（直接定址），哈希函数构造方法（尽量减少冲突）+解决冲突的方法（开放定址和拉链法） 以空间换时间，map的本质就是Hash表 字符串匹配算法：KMP（从O（mn）降低到O（m+n）） KMP如何借助next数组移位 道理其实很简单，如果目标串和模式串的字符匹配，那么就同时移动两者的下标；如果不能匹配，就使用next数组来获得移动的数目。但编程方法实现的话，next数组我们需要再修改一下，这样就能够直接获得当前失配位置应当对应的新的模式串字符下标（因为我们关注的是在失配字符之前有几个匹配的字符）。 所以，next数组来对每个位置找到最长公共前缀 适合主串和子串有很多部分匹配的情况 大致求next数组的代码：注意这里是设置最开始是-1和0，也可以设置0，1 void kmp(const string\u0026 match, const string\u0026 pattern) { int posP = -1, posM = -1, lenM = match.length(), lenP = pattern.length(); while (posP \u003c lenP \u0026\u0026 posM \u003c lenM) { if (posP == -1 || pattern[posP] == match[posM]) { posP++; posM++; } else { posP = nextArr[posP]; } } } ","date":"2021-10-11","objectID":"/search-algorithm-note/:1:7","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"查找数据结构 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:0","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"查找概论 查找表 定义 查找表（Search Table）是同一类型的数据元素（或记录）的集合。 查找表分类 静态查找表 静态查找表（Static Search Table）：只做查找操作的查找表。 它的主要操作有： 查找某个“特定的”数据元素是否存在于查找表中。 检索某个“特定的”数据元素和各种属性。 动态查找表 动态查找表（Dynamic Search Table）：在查找过程中同时插入不存在的数据元素， 或在查找过程中删除已经存在的数据元素。 它的主要操作有： 查找时插入数据元素。 查找时删除数据元素。 关键字 关键字（Key）是数据元素中某个数据项的值，又称为键值。（难理解） 若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary key）。 可以识别多个数据元素（或记录）的关键字，是次关键字（Secondary Key）。 意思是根据次关键字可以查询到多条数据元素吗？ 查找定义 查找（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定 值的数据元素（或记录）。 若查找到了数据元素，则查找成功；否则，查找失败。 查找结构 面向查找操作的数据结构叫做查找结构。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:1","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"顺序表查找 概念 顺序表查找（Sequential Search）又叫线性查找，是最基本的查找技术。它的查找过程是： 从表中第一个（或最后一个）记录开始，逐个比较记录的关键字和给定值。 若某个记录的关键字和给定值相等，则查找成功。 若一直查找到最后一个（或第一个）记录，其关键字都不等于给定值，则查找失败。 代码 int Sequential_search(int *a, int n, int key) { int i; for(i = 1; i \u003c n; i++){ if(a[i] == key){ return i; } } return 0; } 顺序表查找代码优化 int Sequential_search(int *a, int n, int key) { int i; a[0] = key; i = 1; while(a[i] != key){ i--; } return i; // 当i等于0时查找失败 } 或 int Sequential_search(int *a, int n, int key) { int i; a[n-1] = key; while(a[i] != key){ i++; } return i; // 当i等于n-1时查找失败 } 时间复杂度 $O(n)$ ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:2","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"有序表查找 折半查找 摘抄 一看就懂的知识点，一般不再打字记录笔记，直接摘抄书本。 数据结构_查找_折半查找 代码 int Binary_search(int *a, int n, int key) { int low, high, mid; low = 1; high = n; while(low \u003c= high){ /*1*/ mid = (low + high) / 2; if(key \u003e a[mid]){ low = mid + 1; }else if(key \u003c a[mid]){ high = mid - 1; }else{ return mid; } } /*2*/ return 0; } 第1行，取值相当于PHP中的 floor 函数。 第2行，查找结果不是 mid 就是查找失败。这说明，若查找表中存在要 查找的关键字，那么该关键字的位置一定是某个中间位置。不能理解这点。 差值查找 差值计算公式 $key-a[low]\\over a[high]-a[low]$ 这个公式是如何得到的？ 代码 int Binary_search(int *a, int n, int key) { int low, high, mid; low = 1; high = n; while(low \u003c= high){ mid = (key - a[low]) / (a[high] - a[low]); if(key \u003e a[mid]){ low = mid + 1; }else if(key \u003c a[mid]){ high = mid - 1; }else{ return mid; } } /*2*/ return 0; } 时间复杂度 $O(logn)$ 斐波那契查找 代码 int Fibonacci_Search(int *a, int n, int key) { int low, high, mid, i, k; low = 1; high = n; k = 0; /*1*/ while(n\u003eF[k]-1){ // 计算n位于斐波那契数列的位置 k++; } for(i = n; i \u003c F[k]-1; i++){ // 将不满的数值补全 a[i] = a[n]; } while(low \u003c= high){ mid = low + F[k-1] - 1; // 计算当前分隔的下标 if(key \u003c a[mid]){ high = mid - 1; /*2*/ k = k -1; // 斐波那契数列下标减一位 }else if(key \u003e a[mid]){ low = mid + 1; /*3*/ k = k - 2; // 斐波那契数列下标减二位 }else{ if(mid \u003c= n){ return mid; // 若相等则说明mid即为查找到的位置 }else{ return n; // 若mid\u003en说明是补全数值，返回n } } } return 0; } 理解不了第1行、第2行、第3行。 摘抄 数据结构_查找_斐波那契查找_核心 不理解上图中的范围个数是怎么得到的。 数据结构_查找_斐波那契查找_范围个数示意图 这个图好像有助于理解某些东西。 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:3","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"线性索引查找 摘抄 概念 数据结构_查找_线性索引查找_概念 稠密索引 概念 数据结构_查找_线性索引查找_稠密索引_概念 对于稠密索引的的索引表，索引项一定是按照关键码有序的排列。 分块索引 概念 数据结构_查找_线性索引查找_分块索引_概念 数据结构_查找_线性索引查找_分块索引_例子 时间复杂度（不懂） 数据结构_查找_线性索引查找_分块索引_时间复杂度 倒排索引 概念 数据结构_查找_线性索引查找_倒排索引_概念 存储技巧 数据结构_查找_线性索引查找_倒排索引_存储技巧 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:4","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"二叉排序树 二叉排序树查找操作代码 typedef struct BiTNode { int data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; Status SearchBST(BiTree T, int key, BiTree f, BiTree *p) { if(!T){ *p = f; return FALSE; }else if(key == T-\u003edata){ *p = T; return TRUE; }else if(key \u003e T-\u003edata){ return SearchBST(T-\u003erchild, key, T, p); }else{ return SearchBST(T-\u003elchild, key, T, p); } } 二叉排序树插入操作代码 二叉排序树插入操作代码 Status InsertBST(BiTree *T, int key) { BiTree p, s; if(!SearchBST(*T, key, NULL, \u0026p)){ s = (BiTree)malloc(sizeof(BiTNode)); s-\u003edata = key; s-\u003elchild = s-\u003erchild = NULL; if(!p){ *T = s; }else if(key \u003e p-\u003edata){ p-\u003erchild = s; }else{ p-\u003elchild = s; } return TRUE; }else{ return FALSE; } } 如果查找到的是叶子结点，插入新的结点很容易。 如果查找到的不是叶子结点，假如此结点刚好有左右孩子结点，如何插入新的结点？ 查找停止的情况有两种：找到了和关键字匹配的记录；查找失败。第二种情况，必然 是遍历到了叶子结点。好不能透彻地理解这点，只能大概不确定地得出这样的结论。 创建二叉排序树代码 int CreateBST(void) { int i; int a[10] = {62, 88, 58, 47, 35, 73, 51, 99, 37, 93}; BiTree T = NULL; for(i = 0; i \u003c 10; i++){ InsertBST(T, a[i]); } return 0; } 二叉排序树删除操作代码 代码 Status Delete(BiTree *p) { BiTree q, s; if((*p)-\u003erchild == NULL){ q = *p; *p = (*p)-\u003elchild; free(q); }else if((*p)-\u003elchild == NULL){ q = *p; *p = (*p)-\u003erchild; free(q); }else{ q = *p; s = (*p)-\u003elchild; while(s-\u003erchild){ q = s; s = s-\u003erchild; } (*p)-\u003edata = s-\u003edata; if(q != *p){ q-\u003erchild = s-\u003elchild; }else{ q-\u003elchild = s-\u003elchild; } free(s); } } 二叉排序树删除结点代码 Status DeleteBST(BiTree *T, int key) { if(!*T){ return FALSE; }else{ if(key == (*T)-\u003edata){ return Delete(T); }else if(key \u003c (*T)-\u003edata){ return DeleteBST(\u0026(*T)-\u003elchild, key); }else{ return DeleteBST(\u0026(*T)-\u003erchild, key); } } } 删除操作有四种情况： 要删除的结点是叶子结点。 要删除的结点有左孩子。 要删除的结点有右孩子。 要删除的结点有左右孩子。理解不了这种情况的代码。 代码解读 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_7 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_1 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_2 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_3 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_4 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_5 数据结构_查找_二叉排序树_二叉排序树删除操作代码_代码解读_6 摘抄 概念 数据结构_查找_二叉排序树_概念 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:5","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"平衡二叉树（AVL树） 概念 平衡二叉树 平衡二叉树（Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree）， 是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。 平衡因子 平衡二叉树上的结点的左子树减去右子树的得到的差值，叫做平衡因子（Balance Factor）。 平衡因子可能的值是 -1，0 和 1。 数据结构_查找_平衡二叉树（AVL树）_平衡因子 书中认为图3中，结点58的左子树的高度是2，我认为是3。 最小不平衡子树 距离插入结点最近的、平衡因子的绝对值大于 1 的结点为根的子树，叫做最小不平衡子树。 什么叫插入结点？是指插入新结点的那个位置吗？ 数据结构_查找_平衡二叉树（AVL树）_最小不平衡子树 结点58的左子树的高度，我认为是3。 平衡二叉树实现算法代码 旋转操作 树的结点结构 typedef struct BiTNode { int data; int bf; // 结点的平衡因子 struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; 右旋转操作代码 void R_Rotate(BiTree *p) { BiTree L; L = (*p)-\u003elchild; // L指向p的左子树根结点 (*p)-\u003elchild = L-\u003erchild; // L的右子树挂结为p的左子树 L-\u003erchild = (*p); *p = L; // P指向新的根结点 } 左旋操作代码 void L_Rotate(BiTree *p) { BiTree R; R = (*p)-\u003erchild; // R指向p的右子树根结点 (*p)-\u003erchild = R-\u003elchild; // R的左子树挂接为p的右子树 R-\u003elchild = (*p); *p = R; // p指向新的根结点 } 理解不了。按照我的思路，p 是 R-\u003elchild 的左子树，可是这和左旋转 后的结果不吻合。 重新画了几次，根据代码，可以得到预期效果图了。可是，L 的右子树为何 会变成 p 的左子树？ 旋转操作的关键在于：第一步的时候，原树拆成了两棵树。旋转过程见纸质笔记。 左平衡旋转处理函数代码 代码 #define LH +1; // 左高 #define EH 0; // 等高 #define RH -1; // 右高 void LeftBalance(BiTree *T) { BiTree L, Lr; L = (*T)-\u003elchild; // L指向T的左子树根结点 switch(L-\u003ebf){ case LH: /*1*/ (*T)-\u003ebf = L-\u003ebf = EH; R_Rotate(T); break; case RH: Lr = L-\u003erchild; // Lr指向T的左孩子的右子树的根 switch(Lr-\u003ebf){ // 修改T及其左孩子的平衡因子 case LH: (*T)-\u003ebf = RH; L-\u003ebf = EH; break; case EH: (*T)-\u003ebf = L-\u003ebf = EH; break; case RH: (*T)-\u003ebf = EH; L-\u003ebf = LH; break; } Lr-\u003ebf = EH; L_Rotate(\u0026(*T)-\u003elchild); // 对T的左子树作左旋平衡处理 R_Rotate(T); // 对T做右旋平衡处理 } } 代码解读 数据结构_查找_平衡二叉树（AVL树）_最小不平衡子树_左平衡旋转处理函数代码_代码解读_1 数据结构_查找_平衡二叉树（AVL树）_最小不平衡子树_左平衡旋转处理函数代码_代码解读_2 数据结构_查找_平衡二叉树（AVL树）_最小不平衡子树_左平衡旋转处理函数代码_代码解读_3 数据结构_查找_平衡二叉树（AVL树）_最小不平衡子树_左平衡旋转处理函数代码_代码解读_4 主函数代码 代码 Status InsertAVL(BiTree *T, int e, Status *taller) { if(!T){ *T = (BiTree)malloc(sizeof(BiTNode)); (*T)-\u003edata = e; (*T)-\u003elchild = (*T)-\u003erchild = NULL; (*T)-\u003ebf = EH; *taller = TRUE; }else{ if(e = (*T)-\u003edata){ *taller = FALSE; return FALSE; } if(e \u003c(*T)-\u003edata){ if(!InsertAVL(\u0026(*T)-\u003elchild, e, taller)){ return FALSE; } if(taller){ switch((*T)-\u003ebf){ case LH: LeftBalance(T); *taller = FALSE; break; case EH: (*T)-\u003ebf = LH; *taller = TRUE; break; case RH: (*T)-\u003ebf = EH; *taller = FALSE; break; } } }else{ if(!InsertAVL(\u0026(*T)-\u003erchild, e, taller)){ return FALSE; } if(*taller){ switch((*T)-\u003ebf){ case LH: (*T)-\u003ebf = EH; *taller = FALSE; break; case EH: (*T)-\u003ebf = RH; *taller = TRUE; break; case RH: RightBalance(T); *taller = FALSE; break; } } } } return TRUE; } 代码解读 《大话数据结构》中的代码，好像有很多错误，只可以当作逼真的伪代码去看待。 数据结构_查找_平衡二叉树（AVL树）_平衡二叉树实现算法代码_代码解读_1 数据结构_查找_平衡二叉树（AVL树）_平衡二叉树实现算法代码_代码解读_2 数据结构_查找_平衡二叉树（AVL树）_平衡二叉树实现算法代码_代码解读_3 数据结构_查找_平衡二叉树（AVL树）_平衡二叉树实现算法代码_代码解读_4 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:6","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"多路查找树（B树） 摘抄 必要性 要操作的数据非常大，大到无法在内存中处理。 定义 多路查找树（multi-way search tree）的每一个结点的孩子数可以多于两个，且每一个结点 处可以存储多个元素。元素之间存在某种特定的排序关系。 2-3树 概念 数据结构_查找_多路查找树_23树_概念_1 数据结构_查找_多路查找树_23树_概念_2 2-3树的插入实现 数据结构_查找_多路查找树_23树_插入_1 数据结构_查找_多路查找树_23树_插入_2 数据结构_查找_多路查找树_23树_插入_3 数据结构_查找_多路查找树_23树_插入_4 2-3树的删除实现 数据结构_查找_多路查找树_23树_删除_1 数据结构_查找_多路查找树_23树_删除_2 数据结构_查找_多路查找树_23树_删除_3 数据结构_查找_多路查找树_23树_删除_4 数据结构_查找_多路查找树_23树_删除_5 数据结构_查找_多路查找树_23树_删除_6 数据结构_查找_多路查找树_23树_删除_7 数据结构_查找_多路查找树_23树_删除_8 可以理解这些方法能够保证删除的元素在被删除后，新树仍然是2-3树，但不明白这么做的规律性， 更无能力用代码实现删除操作。 2-3-4树 概念 数据结构_查找_多路查找树_234树_概念 2-3-4树的插入和删除 数据结构_查找_多路查找树_234树_插入删除_1 数据结构_查找_多路查找树_234树_插入删除_2 B树 概念与性质 数据结构_查找_多路查找树_B树_概念与性质_1 数据结构_查找_多路查找树_B树_概念与性质_2 减少内存与外存交换数据的频率的原因 数据结构_查找_多路查找树_B树_减少内存与外存交换数据的频率的原因_1 数据结构_查找_多路查找树_B树_减少内存与外存交换数据的频率的原因_2 B+树 产生原因–优化B树 数据结构_查找_多路查找树_B加树_产生原因 概念 数据结构_查找_多路查找树_B加树_概念_1 数据结构_查找_多路查找树_B加树_概念_2 与B树的对比 数据结构_查找_多路查找树_B加树_与B树的对比 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:7","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"散列查找表概述 摘抄 定义 数据结构_查找_散列查找表概述_摘抄_定义_1 散列表查找步骤 1.存储时，通过散列函数计算记录的散列地址，并按该存储地址存储这条记录。 2.查找时，通过相同的散列函数计算记录的散列地址，并按该散列地址读取记录。 散列表适用场景 1.最适合的求解问题是查找与给定关键字等值的记录。 2.同样的关键字对应很多记录的问题，不适合用散列表查找。 3.范围查找，不适合用散列表查找。 冲突 数据结构_查找_散列查找表概述_摘抄_冲突 散列函数的构造方法 设计好的散列函数的原则 1.计算简单。 2.散列地址分布均匀。这和“使用连续的存储空间存储记录”有关吗？ 直接定址法 概念 数据结构_查找_散列查找表概述_摘抄_直接定址法_概念 优缺点 数据结构_查找_散列查找表概述_摘抄_直接定址法_优缺点 数字分析法 数据结构_查找_散列查找表概述_摘抄_数字分析法 只强调了抽取，对散列函数并无固定要求。 平方取中法 数据结构_查找_散列查找表概述_摘抄_平方取中法 折叠法 数据结构_查找_散列查找表概述_摘抄_折叠法 存储标签id时，我常用的方法是，存储“1,2,3,4”这样的字段。有人提出， 计算这4个标签ID的“位运算”，存储“位运算”的结果。具体应用方法已经 忘记。这也是折叠法。它们都减少了占用的存储空间。 除留余数法 数据结构_查找_散列查找表概述_摘抄_除留余数法_1 数据结构_查找_散列查找表概述_摘抄_除留余数法_2 随机数法 数据结构_查找_散列查找表概述_摘抄_随机数法 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:8","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"处理散列冲突的方法 摘抄 开放定址法 数据结构_查找_处理散列冲突的方法_摘抄_开放定址法_1 数据结构_查找_处理散列冲突的方法_摘抄_开放定址法_2 数据结构_查找_处理散列冲突的方法_摘抄_开放定址法_3 再散列函数法 数据结构_查找_处理散列冲突的方法_摘抄_再散列函数法 存储的时候，是否应该记录解决冲突使用的散列函数？若不记录，读取 数据的时候，如何计算存储时候的地址？ 链接地址法 数据结构_查找_处理散列冲突的方法_摘抄_链接地址法_1 数据结构_查找_处理散列冲突的方法_摘抄_链接地址法_1 公共溢出法 数据结构_查找_处理散列冲突的方法_摘抄_公共溢出法_1 数据结构_查找_处理散列冲突的方法_摘抄_公共溢出法_2 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:9","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Learning","note"],"content":"散列表查找实现 代码 散列表结构 #define SUCCESS 1 #define UNSUCCESS 0 #define HASHSIZE 12 #define NULLKEY -32768 typedef struct { int *elem; // 数据元素存储基址 int count; // 当前数据元素个数 }HashTable; int m = 0; // 散列表表长，全局变量 散列表初始化 Status InitHashTable(HashTable *H) { int i; m = HASHSIZE; H-\u003ecount = m; H-\u003eelem = (int *)malloc(m*sizeof(int)); for(i = 0; i \u003c m; i++){ H-\u003eelem[i] = NULLKEY; } return OK; } 散列函数 int Hash(int key) { return key % m; } 插入操作 void InsertHash(HashTable *H, int key) { int addr = Hash(key); // 求散列地址 while(H-\u003eelem[addr] != NULLKEY) addr = (addr + 1) % m; H-\u003eelem[addr] = key; } 查询操作 void SearchHash(HashTable *H, int key) { int addr = Hash(key); while(H-\u003eelem[addr] != key){ addr = (addr + 1) % m; if(H-\u003eelem[addr] != key || addr == Hash(key)) { return UNSUCCESS; } } return SUCCESS; } if(H-\u003eelem[addr] != key || addr == Hash(key)) 中的 addr == Hash(key) 说明 循环回到原点，我不理解这点。 if(H-\u003eelem[addr] != key || addr == Hash(key)) { return UNSUCCESS; } 这块代码是否有问题？ 当 H-\u003eelem[addr] != key 成立时，应该继续计算哈希地址。 散列表查找性能分析 数据结构_查找_散列表查找实现_摘抄_散列表查找性能分析_1 数据结构_查找_散列表查找实现_摘抄_散列表查找性能分析_2 ","date":"2021-10-11","objectID":"/search-algorithm-note/:2:10","tags":["DataStructure","Algorithm","Search"],"title":"查找算法和对应的数据结构","uri":"/search-algorithm-note/"},{"categories":["Operation"],"content":"git pull/merge遇到错误：error: Your local changes to the following files would be overwritten by merge的解决办法","date":"2021-09-10","objectID":"/git-error/","tags":["Git","Error","Idea"],"title":"Git: 'error: Your local changes to the following files would be overwritten by merge'","uri":"/git-error/"},{"categories":["Operation"],"content":"1. IDEA 中git 文件颜色标识 绿色，已经加入控制暂未提交 红色，未加入版本控制 蓝色，加入，已提交，有改动 白色，加入，已提交，无改动 灰色：版本控制已忽略文件。 ","date":"2021-09-10","objectID":"/git-error/:1:0","tags":["Git","Error","Idea"],"title":"Git: 'error: Your local changes to the following files would be overwritten by merge'","uri":"/git-error/"},{"categories":["Operation"],"content":"2. git pull遇到错误：error: Your local changes to the following files would be overwritten by merge.md 参考：git pull遇到错误：error: Your local changes to the following files would be overwritten by merge: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来) 输入以下命令 git stash git pull origin master git stash pop 然后diff一下文件，看看自动合并的情况，并作出需要的修改。 git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。 git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。 git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 ","date":"2021-09-10","objectID":"/git-error/:2:0","tags":["Git","Error","Idea"],"title":"Git: 'error: Your local changes to the following files would be overwritten by merge'","uri":"/git-error/"},{"categories":["Back","note"],"content":"记录Windows安装绿色版Redis教程的笔记","date":"2021-09-07","objectID":"/redis-green-install-note/","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"前言: 项目使用到了Redis,服务器的Redis总是挂,难受,于是有了接下来的这篇windows端安装绿色版Redis的教程 1.欢迎来到世界上最大的同性交友圈gayhup(错了,错了,是githup),直接放上链接 https://github.com/MicrosoftArchive/redis 2.已经有个正式版本啦,点击进去,我一般选择的都是最新的releases版本,目前为止最新的是 Redis最新的版本 3.下载下来的Redis-x64-3.2.100.zip解压到一个路径为英文且名字中间不能有空格的文件夹下(虽然有中文,有空格大多数情况下不会出问题,以防一些莫名奇妙的错误发生),最好分个类(安装),我的如下: 4.呀!自带文档呀!可惜全是英文,大致的我们还是都能看的懂得,本人英语也是个渣,后悔当初没有好好学英语啊,ε=(´ο｀*)))唉! 没事,咱们慢慢来! ","date":"2021-09-07","objectID":"/redis-green-install-note/:1:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"Installing the Service –service-install This must be the first argument on the redis-server command line. Arguments after this are passed in the order they occur to Redis when the service is launched. The service will be configured as Autostart and will be launched as “NT AUTHORITY\\NetworkService”. Upon successful installation a success message will be displayed and Redis will exit. This command does not start the service. For instance: redis-server –service-install redis.windows-service.conf –loglevel verbose 大致翻译一下: ","date":"2021-09-07","objectID":"/redis-green-install-note/:2:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"安装Redis服务 安装指令: –service-install 这必须是redis-server命令行上的第一个参数。 之后的参数按照它们在启动服务时发生的顺序传递给Redis。 该服务将配置为自动启动，并将作为\"NT AUTHORITY \\ NetworkService\"启动。 成功安装后，将显示成功消息，Redis将退出。 该命令只负责安装Redis服务,不启动Redis服务. (不安装服务,怎么启动服务,执行程序啊,所以安装服务就是第一步,基础) 例子: redis-server –service-install redis.windows-service.conf –loglevel verbose 大致解释下各个参数的意思: (1)redis-server对应zip文件下的redis-server.exe程序 (2)–service-install 安装服务 (3)redis.windows-service.conf对应zip文件下的redis.windows-service.conf文件(该文件负责配置Redis的相关信息,比如端口号,密码等等) (4)–loglevel verbose :日志等级-详细(安装Redis服务时,显示安装的信息) 实战一下,打开cmd窗口 D:\\DevInstall\\DataBase\\Redis\\Redis-x64-3.2.100为redis-server.exe所在程序的路径(取决于你把下载的zip文件解压到哪) 进入redis-server.exe程序所在的文件夹下执行上述的安装服务的命令 redis-server –service-install redis.windows-service.conf –loglevel verbose 没有报错信息的话应该就是安装成功了,我们可以windows+R键,输入services.msc指令查看一下Redis服务有没有安装成功,如下图: 如果是上图这样,表示Redis服务已经安装成功了! ","date":"2021-09-07","objectID":"/redis-green-install-note/:3:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"启动服务 2种启动方式: (1)鼠标选中\"Redis\"服务,右键–\u003e启动,启动成功后的Redis服务如下图 (2)指令启动: 文档中是这样描述的: ","date":"2021-09-07","objectID":"/redis-green-install-note/:4:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"Starting the Service –service-start This will start the Redis service. Upon successful start, a success message will be displayed and Redis will begin running. For instance: redis-server –service-start 翻译一下: ","date":"2021-09-07","objectID":"/redis-green-install-note/:5:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"启动服务 –service-start 这将启动Redis服务。 成功启动后，将显示成功消息，Redis将开始运行。 例子: redis-server –service-start dos操作如下: 3.停止服务(同启动服务,也有2种方式) (1)选中\"Redis\"服务,鼠标右键–\u003e停止,成功如下图,状态为空 (2)通过指令停止Redis服务 文档是这样描述的 ","date":"2021-09-07","objectID":"/redis-green-install-note/:6:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"Stopping the Service –service-stop This will stop the Redis service. Upon successful termination a success message will be displayed and Redis will exit. For instance: redis-server –service-stop 翻译一下: ","date":"2021-09-07","objectID":"/redis-green-install-note/:7:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Back","note"],"content":"停止服务 –service-stop 这将停止Redis服务。 成功终止后，将显示成功消息，Redis将退出。 例子: redis-server –service-stop dos操作: ","date":"2021-09-07","objectID":"/redis-green-install-note/:8:0","tags":["Database","Redis"],"title":"Windows安装绿色版Redis教程","uri":"/redis-green-install-note/"},{"categories":["Front"],"content":"记录Choco安装Vctools报错的解决办法","date":"2021-09-06","objectID":"/vue-install-base-error/","tags":["Vue","Chocolate","Vctools","Error"],"title":"Choco安装Vctools报错","uri":"/vue-install-base-error/"},{"categories":["Front"],"content":"报错 Windows安装Vue时说vctools没有安装成功，本机装的2019VS，为了使用SAS，node版本用的比较低，所以要再装一个2017的vctools，于是执行choco install visualstudio2017-workload-vctools报错 C:\\WINDOWS\\system32\u003echoco install visualstudio2017-workload-vctools Chocolatey v0.10.15 Installing the following packages: visualstudio2017-workload-vctools By installing you accept licenses for the packages. Progress: Downloading visualstudio2017-workload-vctools 1.3.2... 100% visualstudio2017-workload-vctools v1.3.2 [Approved] visualstudio2017-workload-vctools package files install completed. Performing other installation steps. The package visualstudio2017-workload-vctools wants to run 'ChocolateyInstall.ps1'. Note: If you don't run this script, the installation will fail. Note: To confirm automatically next time, use '-y' or consider: choco feature enable -n allowGlobalConfirmation Do you want to run the script?([Y]es/[A]ll - yes to all/[N]o/[P]rint): a ERROR: Unable to detect any supported Visual Studio product. You may try passing --installPath or both --productId and --channelId parameters. The install of visualstudio2017-workload-vctools was NOT successful. Error while running 'C:\\ProgramData\\chocolatey\\lib\\visualstudio2017-workload-vctools\\tools\\ChocolateyInstall.ps1'. See log for details. Chocolatey installed 0/1 packages. 1 packages failed. See the log for details (C:\\ProgramData\\chocolatey\\logs\\chocolatey.log). Failures - visualstudio2017-workload-vctools (exited -1) - Error while running 'C:\\ProgramData\\chocolatey\\lib\\visualstudio2017-workload-vctools\\tools\\ChocolateyInstall.ps1'. See log for details. ","date":"2021-09-06","objectID":"/vue-install-base-error/:1:0","tags":["Vue","Chocolate","Vctools","Error"],"title":"Choco安装Vctools报错","uri":"/vue-install-base-error/"},{"categories":["Front"],"content":"解决 ","date":"2021-09-06","objectID":"/vue-install-base-error/:2:0","tags":["Vue","Chocolate","Vctools","Error"],"title":"Choco安装Vctools报错","uri":"/vue-install-base-error/"},{"categories":["Front"],"content":"法1 choco upgrade -y visualstudio2019-workload-vctools ","date":"2021-09-06","objectID":"/vue-install-base-error/:2:1","tags":["Vue","Chocolate","Vctools","Error"],"title":"Choco安装Vctools报错","uri":"/vue-install-base-error/"},{"categories":["Front"],"content":"法2 我的解决办法 使用管理员权限打开CMD或者PowerShell，执行命令 choco install visualstudio2017-workload-vctools ​ ","date":"2021-09-06","objectID":"/vue-install-base-error/:2:2","tags":["Vue","Chocolate","Vctools","Error"],"title":"Choco安装Vctools报错","uri":"/vue-install-base-error/"},{"categories":["Front"],"content":"记录Module build failed: Error: Node Sass does not yet support your current environment 的解决办法","date":"2021-09-06","objectID":"/vue-node-sass-not-support-error/","tags":["Vue","Node","Sass","Error"],"title":"Module build failed: Error: Node Sass does not yet support your current environment","uri":"/vue-node-sass-not-support-error/"},{"categories":["Front"],"content":"问题概述 公司的项目想跑一下前端，执行npm install报错 再执行npm audit fix还报错 查看对应的日志目录发现里面报错，\"Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime\"，提示系统的node-sass不被支持的，截图如下： 具体内容如下： ERROR Failed to compile with 6 errors 下午4:01:38 error in ./src/assets/scss/index.scss Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (83) For more information on which environments are supported please see: https://github.com/sass/node-sass/releases/tag/v4.13.1 at module.exports (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\node-sass\\lib\\binding.js:13:13) at Object.\u003canonymous\u003e (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\node-sass\\lib\\index.js:14:35) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at Object.\u003canonymous\u003e (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\sass-loader\\lib\\loader.js:3:14) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at loadLoader (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\loader-runner\\lib\\loadLoader.js:18:17) @ ./src/assets/scss/index.scss 4:14-212 13:3-17:5 14:22-220 @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:8001 webpack/hot/dev-server babel-polyfill ./src/main.js error in ./src/views/modules/sys/menu-add-or-update.vue Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (83) For more information on which environments are supported please see: https://github.com/sass/node-sass/releases/tag/v4.13.1 at module.exports (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\node-sass\\lib\\binding.js:13:13) at Object.\u003canonymous\u003e (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\node-sass\\lib\\index.js:14:35) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at Object.\u003canonymous\u003e (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\sass-loader\\lib\\loader.js:3:14) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at loadLoader (E:\\code\\VSCode_Code\\renren-fast-vue\\node_modules\\loader-runner\\lib\\loadLoader.js:18:17) @ ./node_modules/vue-style-loader!./node_modules/css-loader?{\"sourceMap\":false}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-1ed9424a\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/sass-loader/lib/loader.js?{\"sourceMap\":false}!./node_modules/vue-loader/lib/selector.js?type=styles\u0026index=0\u0026bustCache!./src/views/modules/sys/menu-add-or-update.vue 4:14-422 13:3-17:5 14:22-430 @ ./src/views/modules/sys/menu-add-or-update.vue @ ./src/views ^\\.\\/.*\\.vue$ @ ./src/router/import-development.js @ ./src/router/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:8001 webpack/hot/dev-server babel-polyfill ./src","date":"2021-09-06","objectID":"/vue-node-sass-not-support-error/:0:1","tags":["Vue","Node","Sass","Error"],"title":"Module build failed: Error: Node Sass does not yet support your current environment","uri":"/vue-node-sass-not-support-error/"},{"categories":["Front"],"content":"解决办法 经过BUG的诊断，发现是当前系统下的Node版本过高导致的， 注意编译报错内容提示，当前的node-sass是不被支持的， 再查看错误日志中的一行：https://github.com/sass/node-sass/releases/tag/v4.13.1，如下图： 当前系统的node版本为v4.13.1，如下图： 而当前node-sass支持的最高版本为13，如下图： 所以，最终找到问题的所在了，是因为系统的Node版本过高导致的编译异常，只需要将版本降低到13，在重新build一下node-sass就可以了，输入指令：npm rebuild node-sass即可， ","date":"2021-09-06","objectID":"/vue-node-sass-not-support-error/:0:2","tags":["Vue","Node","Sass","Error"],"title":"Module build failed: Error: Node Sass does not yet support your current environment","uri":"/vue-node-sass-not-support-error/"},{"categories":["Software","note"],"content":"记录Android Studio向AVD模拟器发送短信教程的笔记","date":"2021-09-06","objectID":"/android-avd-sms-note/","tags":["AndroidStudio","Android-Sdk"],"title":"Android Studio向AVD模拟器发送短信","uri":"/android-avd-sms-note/"},{"categories":["Software","note"],"content":"步骤 如上图所示，点击\"Tools\"–\u003e“Android”–\u003e“Monitor Device Monitor”按钮后弹出如下图所示的窗口： 选中正在运行的模拟器-\u003eIncoming number:输入发送信息的号码-\u003e勾选SMS-\u003eMessage:填写短信内容 奇妙的事情发生了，咱这个版本的Android Studio对应目录没看到这个选项，那就重新解释下 ","date":"2021-09-06","objectID":"/android-avd-sms-note/:1:0","tags":["AndroidStudio","Android-Sdk"],"title":"Android Studio向AVD模拟器发送短信","uri":"/android-avd-sms-note/"},{"categories":["Software","note"],"content":"为什么Android Studio的Tools中没有Android选项 1.来自Google官方文档的一段话： However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher. 但是，大多数Android设备监视器组件已弃用，以支持Android Studio 3.0和更高版本中提供的更新工具。 2.如果要使用: 要启动独立的设备监视器应用程序，请在android-sdk/tools/目录的命令行中输入以下内容： monitor 然后，您可以通过从Devices窗格中选择设备，将该工具链接到已连接的设备。如果您在查看窗格或窗口时遇到问题，请从菜单栏中选择Window \u003e Reset Perspective 。 注意：每个设备一次只能连接到一个调试器进程。因此，例如，如果您使用Android Studio在设备上调试您的应用程序，则需要从Android设备监视器附加调试器进程之前断开Android Studio调试器与设备的连接。 对于Windows，其实这个命令执行的是这个目录下的这个.bat脚本 双击启动就行，再按照上面步骤的第二个执行就行 常用放桌面一个快捷方式 ","date":"2021-09-06","objectID":"/android-avd-sms-note/:2:0","tags":["AndroidStudio","Android-Sdk"],"title":"Android Studio向AVD模拟器发送短信","uri":"/android-avd-sms-note/"},{"categories":["Total","note"],"content":"记录Android 百度地图SDK 自动定位、标记定位教程的笔记","date":"2021-09-06","objectID":"/android-bdmap-note/","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"先看效果图,如果不是你想要的，也就不浪费你时间了，这样对大家都好。 ","date":"2021-09-06","objectID":"/android-bdmap-note/:0:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"一、创建项目引入SDK 如果是你满意的那样，我们就可以开始写了，首先创建一个名为MapDemo的项目。 打开AndroidManifest.xml，复制你的包名 然后进入百度地图开放平台，没有注册的小伙伴先注册，已注册的就直接登录，登录进去之后找到控制台→我的应用→创建应用 点击之后进入,填写相关资料 输入了应用名称、选择了应用类型和启用的服务，输入了包名。还差开发版和发布版的SHA1了 ① 获取开发版SHA1 鼠标点击右侧边栏的Gradle→ app→Tasks→ android→ 双击signingReport 当你的AS版本为最新版时，你会发现这里好像有点不一样了，找不到signingReport了，这是AS更新之后默认这个功能关掉了，需要去手动打开它。在设置里面 如下图这里默认勾选上了，现在把这根勾选上的去掉， 然后Sync，或者点击这个小图标。 然后你的项目的右侧边栏就会出现这个熟悉的task了。 粘贴到开发版SHA1的输入框 ② 获取发布版SHA1 Build → Generate Signed Bundle or APK 选择APK 点击Next 这里是没有秘钥的，需要创建一个新的秘钥，点击 Create New… 先创建项目的jks文件,点击右侧的文件夹图标，指定对应的文件 没有文件夹就先自己创建一个，选择好文件夹之后，输入jks的名字，这里你可以自己取名，然后点击OK 输入密码，点击OK 别管这个，点击OK 勾选上记住密码，然后OK 下面还有一个地方要改一下就是APK生成的位置，我不希望它生成在项目里面的默认文件夹，因为找起来不方便，还有一个原因就是clean Project的时候会删除掉你的APK，不管是调试版还是发布版，点击那个小文件夹进行路径修改 选中APK,点击创建文件图标，新建一个子文件夹 输入文件夹名称，点击OK 然后选中这个刚创建的文件夹,点击Finish 这个时候，底部会出现一个进度条，表示在生成APK文件，然后底部右侧出现这个这个提示弹窗表示，生成APK成功。 然后找到这个APK的所在目录 这个就是你生成的APK所在地址。以你自己前面设置的路径为准。接下来进入Android Studio的Terminal工具输入如下图所示的命令和jks存放路径。 #//如果你前面的步骤和我一模一样的话，这里你就可以复制粘贴，不一样的话就修改jks的路径就可以了 keytool -list -v -keystore D:\\APK\\mapdemo.jks 输入这行命令之后回车会让你输入密码，就是之前创建秘钥的的那个密码，输入的过程中你是看不见密码的，光标也不会移动，不过不用担心，输入无误后回车就可以了 找到这个SHA1，然后复制，粘贴到发布版SHA1的输入框里 那么这个页面的所需资料就填写完毕，点击提交 应用创建成功 点击开发文档选择Android地图SDK 点击自定义下载 选择Jar 下载开发包 下载后解压文件夹，进入libs里面 复制这些文件，然后进入你的Android Studio,切换到Project模式，找到libs，然后粘贴 打开build.gradle，复制如下代码进去，注意放置的位置是在android闭包中，然后Sync，保存修改配置文件 sourceSets{ main{ jniLibs.srcDir 'libs' jni.srcDirs = [] //disable automatic ndk-build } } 配置成功，jar包就是可以展开的 然后进入开放平台，复制你的应用AK ","date":"2021-09-06","objectID":"/android-bdmap-note/:1:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"二、显示地图 切换到Android文件模式，打开AndroidManifest.xml,在application标签下写入 \u003c!--百度定位AK--\u003e \u003cmeta-data android:name=\"com.baidu.lbsapi.API_KEY\" android:value=\"WpVg5eIh4kYWPHtPjG3arHIf6bGEn49s\" /\u003e 注意这个value里面的值是你自己的应用的，你用我的是没用的。 然后放入定位服务 \u003c!--百度定位服务 这个服务也是放在application标签下的--\u003e \u003cservice android:name=\"com.baidu.location.f\" android:enabled=\"true\" android:process=\":remote\" /\u003e 最后放入权限 \u003c!--以下权限与application标签是平级的--\u003e \u003c!-- 这个权限用于进行网络定位--\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /\u003e \u003c!-- 这个权限用于访问GPS定位--\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /\u003e \u003c!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /\u003e \u003c!-- 获取运营商信息，用于支持提供运营商信息相关的接口--\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e \u003c!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--\u003e \u003cuses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /\u003e \u003c!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /\u003e \u003c!-- 访问网络，网络定位需要上网--\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e 创建一个MapApplication类，继承Application，在onCreate方法中完成SDK的初始化，代码如下： package com.llw.mapdemo; import android.app.Application; import com.baidu.mapapi.CoordType; import com.baidu.mapapi.SDKInitializer; public class MapApplication extends Application { @Override public void onCreate() { super.onCreate(); //在使用SDK各组件之前初始化context信息，传入ApplicationContext SDKInitializer.initialize(this); //自4.3.0起，百度地图SDK所有接口均支持百度坐标和国测局坐标，用此方法设置您使用的坐标类型. //包括BD09LL和GCJ02两种坐标，默认是BD09LL坐标。 SDKInitializer.setCoordType(CoordType.BD09LL); } } 然后在AndroidManifest.xml文件中声明该Application 现在修改activity_main.xml文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003ccom.baidu.mapapi.map.MapView android:id=\"@+id/bmapView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clickable=\"true\" /\u003e \u003c/LinearLayout\u003e 然后在MainActivity中 这个时候你的地图就会显示出来，可能会比较慢，这个与网络有关。运行起来 SDK默认指定了北京的坐标，那么这肯定不是你想要的，所以要定位到实际的位置才行。 ","date":"2021-09-06","objectID":"/android-bdmap-note/:2:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"三、定位当前所在位置 修改一下styles.xml文件 进入MainActivity initLocation方法代码如下： /** * 定位初始化 */ public void initLocation(){ // 开启定位图层 mBaiduMap.setMyLocationEnabled(true); // 定位初始化 mLocClient = new LocationClient(this); MyLocationListener myListener = new MyLocationListener(); mLocClient.registerLocationListener(myListener); LocationClientOption option = new LocationClientOption(); // 打开gps option.setOpenGps(true); // 设置坐标类型 option.setCoorType(\"bd09ll\"); option.setScanSpan(1000); mLocClient.setLocOption(option); mLocClient.start(); } MyLocationListener 代码如下： /** * 定位SDK监听函数 */ public class MyLocationListener implements BDLocationListener { @Override public void onReceiveLocation(BDLocation location) { // MapView 销毁后不在处理新接收的位置 if (location == null || mMapView == null) { return; } MyLocationData locData = new MyLocationData.Builder() .accuracy(location.getRadius())// 设置定位数据的精度信息，单位：米 .direction(location.getDirection()) // 此处设置开发者获取到的方向信息，顺时针0-360 .latitude(location.getLatitude()) .longitude(location.getLongitude()) .build(); // 设置定位数据, 只有先允许定位图层后设置数据才会生效 mBaiduMap.setMyLocationData(locData); if (isFirstLoc) { isFirstLoc = false; LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude()); MapStatus.Builder builder = new MapStatus.Builder(); builder.target(latLng).zoom(20.0f); mBaiduMap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build())); } } } 最后改动一下onDestroy @Override protected void onDestroy() { super.onDestroy(); // 退出时销毁定位 mLocClient.stop(); // 关闭定位图层 mBaiduMap.setMyLocationEnabled(false); // 在activity执行onDestroy时必须调用mMapView.onDestroy() mMapView.onDestroy(); } 运行效果如下图 现在就已经在地图上定位到当前所在位置了。 当然光是定位到自己的位置也是不够的，我还希望点击地图的时候能够定位过去， ","date":"2021-09-06","objectID":"/android-bdmap-note/:3:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"四、标点定位、回到原位 先修改MainActivity.xml文件， 根布局改为RelativeLayout，然后增加一个ImageButton 里面用到的图标 写完之后你会发现你的你少了一个resetLocation方法,进入MainActivity,写下如下方法： /** * 点切换到其他标点位置时，重置定位显示，点击之后回到自动定位 * * @param view */ public void resetLocation(View view) { } 然后 既然要定位到其他地方肯定是要先点击地图的，所以写一个地图的点击方法 /** * 地图点击 */ private void mapOnClick() { // 设置marker图标 bitmap = BitmapDescriptorFactory.fromResource(R.drawable.icon_marka); mBaiduMap.setOnMapClickListener(new BaiduMap.OnMapClickListener() { @Override public void onMapPoiClick(MapPoi mapPoi) { } //此方法就是点击地图监听 @Override public void onMapClick(LatLng latLng) { //获取经纬度 markerLatitude = latLng.latitude; markerLongitude = latLng.longitude; //先清除图层 mBaiduMap.clear(); // 定义Maker坐标点 LatLng point = new LatLng(markerLatitude, markerLongitude); // 构建MarkerOption，用于在地图上添加Marker MarkerOptions options = new MarkerOptions().position(point) .icon(bitmap); // 在地图上添加Marker，并显示 //mBaiduMap.addOverlay(options); marker = (Marker) mBaiduMap.addOverlay(options); Bundle bundle = new Bundle(); bundle.putSerializable(\"info\", \"纬度：\" + markerLatitude + \" 经度：\" + markerLongitude); marker.setExtraInfo(bundle);//将bundle值传入marker中，给baiduMap设置监听时可以得到它 //点击地图之后重新定位 initLocation(); } }); } 这里面有一个图标icon_marka 上面的代码很明确了吧，当点击地图时添加一个标点，同时绑定它的经纬度，当点击标点的时候就会显示出经纬度。当标点在地图上绘制之后，就重新定位。再来看看这个方法吧 /** * 定位初始化 */ public void initLocation() { // 开启定位图层 mBaiduMap.setMyLocationEnabled(true); // 定位初始化 mLocClient = new LocationClient(this); MyLocationListener myListener = new MyLocationListener(); mLocClient.registerLocationListener(myListener); LocationClientOption option = new LocationClientOption(); option.setOpenGps(true);// 打开gps option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy);// 设置高精度定位 option.setCoorType(\"bd09ll\");//可选，默认gcj02，设置返回的定位结果坐标系 option.setScanSpan(0);//可选，默认0，即仅定位一次，设置发起定位请求的间隔需要大于等于1000ms才是有效的 option.setIsNeedAddress(true);//可选，设置是否需要地址信息，默认不需要 option.setOpenGps(true);//可选，默认false,设置是否使用gps option.setIsNeedLocationDescribe(true);//可选，默认false，设置是否需要位置语义化结果，可以在BDLocation.getLocationDescribe里得到，结果类似于“在北京天安门附近” option.setIsNeedLocationPoiList(true);//可选，默认false，设置是否需要POI结果，可以在BDLocation.getPoiList里得到 option.setIgnoreKillProcess(false);//可选，默认false，定位SDK内部是一个SERVICE，并放到了独立进程，设置是否在stop的时候杀死这个进程，默认杀死 option.SetIgnoreCacheException(false);//可选，默认false，设置是否收集CRASH信息，默认收集 option.setEnableSimulateGps(false);//可选，默认false，设置是否需要过滤gps仿真结果，默认需要 mLocClient.setLocOption(option); mLocClient.start();//开始定位 } 这里面我增加了一些属性，重点不是这个，是定位后的监听。 /** * 定位SDK监听函数 */ public class MyLocationListener implements BDLocationListener { @Override public void onReceiveLocation(BDLocation location) { // MapView 销毁后不在处理新接收的位置 if (location == null || mMapView == null) { return; } double resultLatitude; double resultLongitude; if (markerLatitude == 0) {//自动定位 resultLatitude = location.getLatitude(); resultLongitude = location.getLongitude(); ibLocation.setVisibility(View.GONE); } else {//标点定位 resultLatitude = markerLatitude; resultLongitude = markerLongitude; ibLocation.setVisibility(View.VISIBLE); } MyLocationData locData = new MyLocationData.Builder() .accuracy(location.getRadius())// 设置定位数据的精度信息，单位：米 .direction(location.getDirection()) // 此处设置开发者获取到的方向信息，顺时针0-360 .latitude(resultLatitude) .longitude(resultLongitude) .build(); mBaiduMap.setMyLocationData(locData);// 设置定位数据, 只有先允许定位图层后设置数据才会生效 LatLng latLng = new LatLng(resultLatitude, resultLongitude); MapStatus.Builder builder = new MapStatus.Builder(); builder.target(latLng).zoom(20.0f); mBaiduMap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build())); } } 在一开始我生命两个double类型的变量，分别是标点的经度和纬度，当一开始进来的时候判断是否等于0，如果是，则使用自动的定位，如果不是，则使用标点的定位，我在点击地图时，将获得的位置坐标赋值给了这两个变量，所以当你点击其他地方的时候就会马上定位过去。这时候就要显示出重置定位这个图标，在手机屏幕的左下角。 然后在这个定位图标的点击时写入如下代碼。 /** * 点切换到其他标点位置时，重置定位显示，点击之后回到自动定位 * * @param view */ public void resetLocation(View view) { markerLatitude = 0; initLocation(); marker.remove();//清除标点 } 最后还差一个标点的点击，那就重新写一个initView,把相关的findById都写到这里面吧。 private void initView() { // 地图初始化 mMapView = (MapView) findViewById(","date":"2021-09-06","objectID":"/android-bdmap-note/:4:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"五、源码  做一个Demo，自然要把源码放上去，先看效果图，合适再运行源码，OK，最后不理解代码再来看博客的讲述，你就知道是怎么回事了，至于自己写的原因是在于官方的文档我觉得并不详细，而我可以把每一步写进来，这才是我写作的初衷。 源码地址：MapDemo，还是我懂你吧！ ","date":"2021-09-06","objectID":"/android-bdmap-note/:5:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Total","note"],"content":"六、疑问解决 如果你运行源码之后发现定位到的地方并不是当前的位置，甚至偏了十万八千里，那么你就要检查一下是不是鉴权信息错误了，这其实是你当前相关的开发版SHA1和当前平台上的不一致造成了，比如我现在在家里的电脑克隆源码下来，然后运行在自己的手机上，发现定位在海里，等我放大之后发现在几内亚湾，都到了非洲的海域了。 你可以看一下你运行时你的Run里面有没有如下这样的异常信息。 如果有的话，那么现在就来解决一下。首先重新获取一下当前的开发版SHA1，如果你不记得了，往上滑动再看看就好。 然后你再看看平台上的开发版SHA1 你都不用全部看完，只要有一个鉴权失败，铁定就不行，那么只要改变一下平台上的开发版SHA1就可以了，复制刚才控制台中的SHA1，然后粘贴到平台的这个输入框中，然后点击提交，之前你再运行刚才的项目。 然后你会发现，还是在几内亚湾，不过你看Run中的报错已经没有了，不过还有一个错误，我之前写这个文章的时候这个地图的SDK还不需要我写数据，所以我就没有动态请求权限，而现在又要了，很明显是百度的人动了手脚。 那么下面就来动态请求一下写入文件的权限。 在app的build.gralde中的android闭包下增加如下jdk1.8的使用代码： compileOptions { sourceCompatibility = 1.8 targetCompatibility = 1.8 } 然后在dependencies闭包下增加如下依赖 //动态权限请求 implementation 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar' implementation 'io.reactivex.rxjava2:rxandroid:2.0.2' implementation \"io.reactivex.rxjava2:rxjava:2.0.0\" 然后点击Sync同步一下，然后进入到MainActivity，新增检查权限的方法 /** * 检查版本 */ private void checkVersion() { if(Build.VERSION.SDK_INT\u003e=Build.VERSION_CODES.M){ RxPermissions rxPermissions = new RxPermissions(this); rxPermissions.request(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.READ_PHONE_STATE, Manifest.permission.WRITE_EXTERNAL_STORAGE) .subscribe(granted -\u003e { if (granted) {//申请成功 //发起连续定位请求 initLocation();// 定位初始化 } else {//申请失败 Toast.makeText(MainActivity.this,\"权限未开启\",Toast.LENGTH_SHORT).show(); } }); }else { initLocation();// 定位初始化 } } Android6.0以下和动态权限请求允许之后调用initLocation()进行定位，然后在onCreate中调用 最后在AndroidManifest.xml中增加一个静态权限。 \u003c!--读取手机状态--\u003e \u003cuses-permission android:name=\"android.permission.READ_PHONE_STATE\"/\u003e 然后运行，发现就可以了，终于不是在几内亚湾了。 下载源码和APK，通过CSDN资源下载，原作者设置的0积分。 地址： 百度地图Demo源码和APK ","date":"2021-09-06","objectID":"/android-bdmap-note/:6:0","tags":["Android","BDMap"],"title":"Android 百度地图SDK 自动定位、标记定位教程","uri":"/android-bdmap-note/"},{"categories":["Software"],"content":"记录Android Studio 的 Gradle Task 没有显示的解决办法","date":"2021-09-06","objectID":"/androidstudio-no-gradle-task-error/","tags":["AndroidStudio","Gradle","Error"],"title":"Android Studio 的 Gradle Task 没有显示","uri":"/androidstudio-no-gradle-task-error/"},{"categories":["Software"],"content":"问题描述 Android Studio Gradle 窗口没有显示 task 列表的问题，如下图所示： 网上找了好久都没有找到原因，最后自己摸索，找了解决方法。 ","date":"2021-09-06","objectID":"/androidstudio-no-gradle-task-error/:1:0","tags":["AndroidStudio","Gradle","Error"],"title":"Android Studio 的 Gradle Task 没有显示","uri":"/androidstudio-no-gradle-task-error/"},{"categories":["Software"],"content":"解决方法 依次点击：File -\u003e Settings -\u003e Experimental -\u003e 取消勾选 “Do not build Gradle task list during Gradle sync”，如下图所示 最后，sync 一下即可。 ","date":"2021-09-06","objectID":"/androidstudio-no-gradle-task-error/:2:0","tags":["AndroidStudio","Gradle","Error"],"title":"Android Studio 的 Gradle Task 没有显示","uri":"/androidstudio-no-gradle-task-error/"},{"categories":["Back","note"],"content":"记录Spring的通过@Value注入自定义类型教程的笔记","date":"2021-09-06","objectID":"/spring-value-collection-overide-note/","tags":["Java","Spring"],"title":"Spring的通过@Value注入自定义类型教程","uri":"/spring-value-collection-overide-note/"},{"categories":["Back","note"],"content":"之前写了一篇关于Spring的@Value注入的文章《SpringBoot读取yml/properties的几种方法》里面列出了@Value和@ConfigurationProperties的对比，其中有一条是写的@Value不支持复杂类型封装（数组、Map、对象等）。 但是后来有小伙伴留言说他用@Value测试的时候，是可以注入的数组和集合的。于是我就跟着做了一些测试，发现确实可以。但是只有在以，分割的字符串的时候才可以。 为什么用，分割的字符串可以注入数组？于是我就去一步一步的断点去走了一遍@Value注入属性的过程，才发现了根本原因。 @Value不支持复杂类型封装（数组、Map、对象等）这个说法确实是有问题的，不够严谨，因为在特殊情况下，是可以注入复杂类型的。 ","date":"2021-09-06","objectID":"/spring-value-collection-overide-note/:0:0","tags":["Java","Spring"],"title":"Spring的通过@Value注入自定义类型教程","uri":"/spring-value-collection-overide-note/"},{"categories":["Back","note"],"content":"先来梳理一下@Value对属性的注入流程 先交代一下我们的代码： 一个yml文件a.yml test:a,b,c,d 一个Bean A.java @Component @PropertySource(Value = {\"classpath:a.yml\"},ignoreResourceNotFound = true, encoding = \"utf-8\") public class A { @Value(\"${test}\") private String[] test; public void test(){ System.out.println(\"test:\"+Arrays.toString(test)); System.out.println(\"长度：\"+test.length); } } @Value(\"${test}\")也可使用冒号语法：@Value(\"${test:testValue}\")，表示当从配置文件中获取不到test时，则test值为testValue 2.@Value(“#{}”)是获取bean属性，系统属性，表达式 main方法： @Configuration @ComponentScan(\"com.kinyang\") public class HelloApp { public static void main(String[] args) { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(HelloApp.class); A bean = ac.getBean(A.class); bean.test(); } } ok！下面开始分析 1、从AutowiredAnnotationBeanPostProcessor后置处理说起吧 过多的Spring初始化Bean的流程就不说了，我们直接定位到Bean的属性注入的后置处理器 AutowiredAnnotationBeanPostProcessor。此类中的processInjection（）方法中完成了Bean 中@Autowired、@Inject、 @Value 注解的解析并注入的功能。 此方法中完成了Bean 中@Autowired、@Inject、 @Value 注解的解析并注入的功能 public void processInjection(Object bean) throws BeanCreationException { Class\u003c?\u003e clazz = bean.getClass(); /// 找到 类上所有的需要自动注入的元素 // （把@Autowired、@Inject、 @Value注解的字段和方法包装成InjectionMetadata类的对象返回） InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null); try { metadata.inject(bean, null, null); } catch (BeanCreationException ex) { throw ex; } catch (Throwable ex) { throw new BeanCreationException( \"Injection of autowired dependencies failed for class [\" + clazz + \"]\", ex); } } 2、接着进入InjectionMetadata的inject()方法 inject（）方法就是一个循环上面一步解析出来的注解信息，注解的方法或者字段包装后的对象是InjectedElement类型的类，InjectedElement是一个抽象类，他的实现主要有两个：对注解字段生成的是AutowiredFieldElement类，对注解方法生成的是AutowiredMethodElement类。 我们这里只分析@Value注解字段的注入流程，所以下一步会进到AutowiredFieldElement类的inject()方法. 此方法就两大步骤: 获取要注入的Value 通过反射，把值去set字段上 其中获取要注入的Value过程比较复杂，第二步set值就两行代码搞定 具体逻辑看下面代码上我写的注释 protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { Field field = (Field) this.member; Object Value; if (this.cached) { /// 优先从缓存中获取 Value = resolvedCachedArgument(beanName, this.cachedFieldValue); } else { ///缓存中没有的话，走下面的逻辑处理 DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(1); Assert.state(beanFactory != null, \"No BeanFactory available\"); 这个对我们今天讨论的问题很关键 获取一个 类型转换器 TypeConverter typeConverter = beanFactory.getTypeConverter(); try { /// 获取值（重点，这里把一个TypeConverter传进去了） Value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); /// 经过上面的方法返回来的 Value 就是要注入的值了 /// 通过断点调试，我们可以发现我们在配置文件yml中配置的 “a,b,c,d”字符串已经变成了一个String[]数组 } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } synchronized (this) { ..... 这里不是我们本次讨论的重点所以就去掉了 } } if (Value != null) { 这里就是第二步，赋值 ReflectionUtils.makeAccessible(field); field.set(bean, Value); } } } 从上面代码来看，所有重点就都落到了这行代码 Value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); 推断下来resolveDependency方法里应该是读取配置文件字符串，然后将字符串用，分割转换了数组。 那么具体怎么转换的呢？我们继续跟进！ 进入resolveDependency（）方法，里面逻辑很简单做了一些判断，真正实现其实是doResolveDependency（）方法，进行跟进。 根据@Value注解，从配置文件a.yml中解析出配置的内容：“a,b,c,d” 到这里我们得到值还是配置文件配置的字符串，并没有变成我们想要的String[]字符串数组类型。 我们继续往下走，下面是获取一个TypeConverter类型转换器，这里的类型转换器是上面传进来的，具体类型SimpleTypeConverter类。 然后通过这个类型转换器的convertIfNecessary方法把，我们的字符串\"a,b,c,d\"转换成了String[]数组。 所以我们现在知道了，我们从配置文件获取到的值，通过了Spring转换器，调用了convertIfNecessary方法后，进行了类型自动转换。 那么这转换器到底是怎么进行工作的呢？ 继续研究~~ 那接下来要研究的就是Spring的TypeConverter的工作原理问题了 在这里推荐大家去看看 A哥的《3. 搞定收工，PropertyEditor就到这》 这篇文章，一共三篇，看完后，在回来看你会更通透！！ 首先我们这里知道了外面传进来的那个转换器是一个叫SimpleTypeConverter 的转换器。 这转换器是org.springframework.beans.factory.support.AbstractBeanFactory#getTypeConverter方法得到的 @Override public TypeConverter getTypeConverter() { TypeConverter customConverter = getCustomTypeConverter(); if (customConverter != null) { return customConverter; } else { /// 如果没有 用户自定的TypeC","date":"2021-09-06","objectID":"/spring-value-collection-overide-note/:0:1","tags":["Java","Spring"],"title":"Spring的通过@Value注入自定义类型教程","uri":"/spring-value-collection-overide-note/"},{"categories":["Learning","note"],"content":"记录RESTful的笔记","date":"2021-09-06","objectID":"/restful-note/","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"老婆经常喜欢翻看我订阅的技术杂志，她总能从她的视角提出很多有趣的问题。 一个悠闲的周日下午，她午觉醒来，又习惯性的抓起这个月的杂志，饶有兴趣地看了起来。 果不其然，看着看着，她又对我发难了，“Restful是什么呀，老公？是restaurant的形容词吗，突然就觉得好饿了啊……” 作为一个合格的程序员，我一直把能够将一项技术讲给老婆听，并且能给她讲懂，作为我已经掌握了这项技术的标准。 如果我直接回答说，“REST就是Representational State Transfer的缩写呀，翻译为中文就是‘表述性状态转移’”，那她今晚肯定得罚我跪键盘。我必须找个合适的机会，把Restful的来龙去脉给她形象的描述一遍。 “走，咱们去楼下咖啡厅吃个下午茶吧”，我对老婆说。 “一个芝士蛋糕，一杯拿铁，两条吸管，谢谢”，我对前台的服务员说，然后我们找了个角落坐了下来。 ","date":"2021-09-06","objectID":"/restful-note/:0:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"Level 0 - 面向前台 “刚才我们向前台点了一杯拿铁，这个过程可以用这段文字来描述”，说着，我在纸上写下了这段JSON，虽然她不知道什么叫JSON，但理解这段文字对于英语专业8级的她，实在再简单不过。 { \"addOrder\": { \"orderName\": \"latte\" } } “我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡”，接着，前台给我们返回这么一串回复： { \"orderId\": \"123456\" } “订单ID？还是订单编号？” “恩恩，就是订单编号” “那我们就等着前台喊‘订单123456的客户可以取餐了’，然后就可以开吃了！” “哈哈，你真聪明，不过，在这之前，假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问”，我继续在纸上写着： { \"queryBalance\": { \"cardId\": \"886333\" } } “查询卡号为886333的卡的余额？” “真棒！接着，查询的结果返回来了” { \"balance\": \"0\" } “切，没钱……” “哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了”，我在纸上写到： { \"deleteOrder\": { \"orderId\": \"123456\" } } “哼，这就把订单取消啦？” ","date":"2021-09-06","objectID":"/restful-note/:1:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"Level 1 - 面向资源 “现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。” “面向资源？” “是的，比如还是下单，请求的内容不变，但是我们多了一条消息”，我在纸上画出这次的模型： /orders { \"addOrder\": { \"orderName\": \"latte\" } } “多了一个斜杠和orders？这是什么意思？” “这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作” “Soga…” “接着还是会返回订单的编号给我们” { \"orderId\": \"123456\" } “下面，我们还是要查询会员卡余额，这次请求的资源变成了cards” /cards { \"queryBalance\": { \"cardId\": \"886333\" } } “接下来是取消订单” “这个我会”，说着，她抢走我手上的笔，在纸上写了起来： /orders { \"deleteOrder\": { \"orderId\": \"123456\" } } ","date":"2021-09-06","objectID":"/restful-note/:2:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"Level 2 - 打上标签 “接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求” “其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示” “还有修改类的，修改分为两种，第一种，如果这个修改，无论发送多少次，最后一次修改后的资源，总是和第一次修改后的一样，比如将拿铁改为猫屎，那么用‘PUT’表示；第二种，如果这个修改，每次修改都会让这个资源和前一次的不一样，比如是加一杯咖啡，那么这种请求用‘PATCH’或者‘POST’表示”，一口气讲了这么多，发现她有点似懂非懂。 “来，我们再来重复上面那个过程，来一杯拿铁”，我边说边画着： POST /orders { \"orderName\": \"latte\" } “请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增”，她听的很认真，理解的也很透彻。 “恩恩，返回的内容还是一样” { \"orderId\": \"123456\" } “接着是查询会员卡余额，这次也简化了很多” GET /cards { \"cardId\": \"886333\" } “这个请求我们还可以进一步优化为这样” GET /cards/886333 “Soga，直接把要查询的卡号写在后面了” “没错，接着，取消订单” DELETE /orders/123456 ","date":"2021-09-06","objectID":"/restful-note/:3:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"Level 3 - 完美服务 “忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着： DELETE /orders/{orderId} 顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……据说后面两人吵着吵着还打了起来…” “噗，真是悲剧…” “有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样” POST /orders { \"orderName\": \"latte\" } “但是这次返回时多了些内容” { \"orderId\": \"123456\", \"link\": { \"rel\": \"cancel\", \"url\": \"/order/123456\" } } “这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦” DELETE /orders/123456 “哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了” “订单123456的客户可以取餐了”，伴随着咖啡厅的广播，我们吃起了下午茶，一杯拿铁，两支吸管…… ","date":"2021-09-06","objectID":"/restful-note/:4:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"对程序员的话 用了大白话，给老婆讲明白了RESTful的来龙去脉，当然，我还是有些话想说的，只是怕老婆听完一脸懵逼，没给她说： 1、上面讲的Level0~Level3，来自Leonard Richardson提出的Richardson Maturity Model： Level0和Level1最大的区别，就是Level1拥有了Restful的第一个特征——面向资源，这对构建可伸缩、分布式的架构是至关重要的。同时，如果把Level0的数据格式换成Xml，那么其实就是SOAP，SOAP的特点是关注行为和处理，和面向资源的RESTful有很大的不同。 Level0和Level1，其实都很挫，他们都只是把HTTP当做一个传输的通道，没有把HTTP当做一种传输协议。 Level2，真正将HTTP作为了一种传输协议，最直观的一点就是Level2使用了HTTP动词，GET/PUT/POST/DELETE/PATCH….,这些都是HTTP的规范，规范的作用自然是重大的，用户看到一个POST请求，就知道它不是幂等的，使用时要小心，看到PUT，就知道他是幂等的，调用多几次都不会造成问题，当然，这些的前提都是API的设计者和开发者也遵循这一套规范，确保自己提供的PUT接口是幂等的。 Level3，关于这一层，有一个古怪的名词，叫HATEOAS（Hypertext As The Engine Of Application State），中文翻译为“将超媒体格式作为应用状态的引擎”，核心思想就是每个资源都有它的状态，不同状态下，可对它进行的操作不一样。理解了这一层，再来看看REST的全称，Representational State Transfer，中文翻译为“表述性状态转移”，是不是好理解多了？ Level3的Restful API，给使用者带来了很大的便利，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。 现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，这个模型并不是一种规范，只是用来理解Restful的工具。所以，做到了Level2，也就是面向资源和使用Http动词，就已经很Restful了。Restful本身也不是一种规范，我比较倾向于用“风格“来形容它。如果你想深入了解Level3，可以阅读《Rest in Practice》第五章。 2、我跟老婆讲的时候，用的数据格式是JSON，但是要强调一点，Restful对数据格式没有限制，就算你用的是XML或者其他格式，只要符合上面提到的几个特征，也算Restful。 3、关于如何写出好的Restful API， @ruanyf 老师已经写过一篇非常棒的文章：RESTful API 设计指南，这篇文章将指导你写出优雅的Restful。 ","date":"2021-09-06","objectID":"/restful-note/:5:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Learning","note"],"content":"参考 Richardson Maturity Model 《Rest in Practice》 HATEOAS - Wikipedia RESTful API 设计指南 PUT vs. POST in REST SOAP - Wikipedia SOAP vs REST (differences) Best Practices for Designing a Pragmatic RESTful API API design guidance The Fundamentals of REST API Design Building REST services with Spring The RESTful cookbook ","date":"2021-09-06","objectID":"/restful-note/:6:0","tags":["Http","RESTful"],"title":"RESTful笔记","uri":"/restful-note/"},{"categories":["Back","note"],"content":"记录SpringBoot读取yml/properties的几种方法的笔记","date":"2021-09-02","objectID":"/springboot-config-note/","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"前言 由于一些众所周知且不可抗拒的力量，个人的Spring底子很差，Boot和MVC部分还可以。特别是学习了设计模式，认为开发一个软件时Spring这种解耦合的框架对于软件开发是非常重要的。甚至决定了一个项目的整个生命周期。 正好在整理笔记的时候看到了之前检索的SpringBoot读取yml/properties知识。由于很零碎，故再次检索并尝试将能想到的情况整合到一个项目中。 ","date":"2021-09-02","objectID":"/springboot-config-note/:1:0","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"方法 ","date":"2021-09-02","objectID":"/springboot-config-note/:2:0","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"1@Component+@Value+@Resource 数据 yml first:id:1name:zhangsan1age:771array:1,6,11list:1,6,11map:'{ \"key1\": \"value1\",\"num\": \"111\" }' properties config.first.id=1 config.first.name=zhangsan1 config.first.age=771 config.first.array=1,6,11 config.first.list=1,6,11 config.first.map={\"key1\":\"value1\",\"num\":\"111\"} 实体类 @Component //Configuration @Data public class First { @Value(\"${config.first.id}\") private String id; @Value(\"${config.first.name}\") private String name; @Value(\"${config.first.age}\") private Integer age; @Value(\"${config.first.array}\") private int[] array; @Value(\"${config.first.array1:}\") private int[] array1; @Value(\"#{'${config.first.list:}'.split(',')}\") private List list; @Value(\"#{${config.first.map:}}\") private Map map; } 调用方法 public class ConfigTestController { @Resource // @Autowired private First first; @GetMapping(\"/first\") public String getFirst() { String single = \"first.id=\" + first.getId() + \"；first.age=\" + first.getAge() + \"；first.name=\" + first.getName() + \"；\u003cbr/\u003efirst.array=\"; for (int mi : first.getArray()) { single += (mi + \",\"); } single += \"；\"; if (first.getArray1().length == 0) single += \"\u003cbr/\u003efirst.getArray1()key不存在，长度为0\u003cbr/\u003e\"; single+=first.getList(); single+=\"\u003cbr/\u003e\"; single+=first.getMap(); return single; } 注意 基本数据类型的Collection类型数据需要在外面加上#{} 后面加上冒号是可以在配置文件不存在时，设置默认值，Collection类型数据长度为0 的对象 这种方法只能返回基本类型和对应的Collection类型，不能直接返回first对象，会报错 大佬自己想办法实现了复杂类型的读取，我没实验，看这 解析Collection类型时可以用CollectionUtils.isEmpty对对象进行是否成功输入进行判断，或者用这样的el表达式 @Value(\"#{'${test.list:}'.empty ? null : '${test.list:}'.split(',')}\") private List testList;  解析map在配置文件中要是直接写map结构 test: map1: '{\"name\": \"zhangsan\", \"sex\": \"male\"}' map2: '{\"math\": \"90\", \"english\": \"85\"}'  在程序中，利用 EL 表达式注入： @Value(\"#{${test.map1}}\") private Map map1; @Value(\"#{${test.map2}}\") private Map map2;  注意，使用这种方式，必须得在配置文件中配置该 key 及其 value。我在网上找了许多资料，都没找到利用 EL 表达式支持不配置 key/value 的写法。 如果你真的很需要这个功能，就得自己写解析方法了，这里以使用 fastjson 进行解析为例： (1) 自定义解析方法 public class MapDecoder { public static Map decodeMap(String value) { try { return JSONObject.parseObject(value, new TypeReference\u003e(){}); } catch (Exception e) { return null; } } } (2) 在程序中指定解析方法 @Value(\"#{T(com.github.jitwxs.demo.MapDecoder).decodeMap('${test.map1:}')}\") private Map map1; @Value(\"#{T(com.github.jitwxs.demo.MapDecoder).decodeMap('${test.map2:}')}\") private Map map2;  注意的是 @Value 注解不能和 @AllArgsConstructor 注解同时使用，否则会报错 Consider defining a bean of type 'java.lang.String' in your configuration  这种做法唯一不优雅的地方就是，这样写出来的 @Value 的内容都很长，既不美观，也不容易阅读。 优缺点 可以看见，单值十分的不方便，最大的问题是配置和代码高耦合了，增加一个配置，还需要对配置类做增减改动，这样就能够直接使用了，就是这么的简单方便，如果你想要支持不配置 key 程序也能正常运行的话，给它们加上默认值即可 不需要写配置类，使用逗号分割，一行配置，即可完成多个数值的注入，配置文件更加精简，但是业务代码中数组使用很少，基本需要将其转换为 List，去做 contains、foreach 等操作。 ","date":"2021-09-02","objectID":"/springboot-config-note/:2:1","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"2@Component+@ConfigurationProperties+@Resource 数据 yml second:id:2name:zhangsan2age:772array:2,7,12list:2,7,12map:key2:value2num:222users:-id:11name:lileiage:10-id:2name:zhaosiage:65-id:3name:wangwuage:23 properties config.second.id=2 config.second.name=zhangsan2 config.second.age=772 config.second.array=2,7,12 config.second.list=2,7,12 #config.second.map={\"key2\":\"value2\",\"num\":\"222\"} config.second.map.key2=value2 config.second.map[num]=222 config.second.users[0].id=11 config.second.users[0].name=lilei config.second.users[0].age=10 config.second.users[1].id=2 config.second.users[1].name=zhaosi config.second.users[1].age=65 config.second.users[2].id=3 config.second.users[2].name=wangwu config.second.users[2].age=23 实体类 @Component @Data @ConfigurationProperties(prefix = \"config.second\") public class Second { private String id; private String name; private Integer age; private int[] array; // private int[] array1; private List list; private Map map; public List\u003cUser\u003e users; @Data public static class User { private Long id; private String name; private Integer age; } } 调用方法 @Resource // @Autowired private Second second; @GetMapping(\"/second\") public Second getSecond() { return second; } 注意 不允许有不存在的字段，需要和配置文件一一对应 除了基本数据类型还允许配置自定义对象及自定义对象的Collection类型 ","date":"2021-09-02","objectID":"/springboot-config-note/:2:2","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"3@EnableConfigurationProperties+@ConfigurationProperties+@Resource 数据 yml 同Second properties 同Second 实体类 同Second，去掉@Component注解 调用方法 需要在注入的类添加@EnableConfigurationProperties(Third.class)注解， @EnableConfigurationProperties(Third.class) public class ConfigTestController {/*调用逻辑同Second*/} 注意 同Second ","date":"2021-09-02","objectID":"/springboot-config-note/:2:3","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"4@Configuration+@ConfigurationProperties+@Bean 数据 yml 同Second **properties **同Second 实体类 同Second，去掉@Component注解 调用方法 将@Resource换为@Bean 需要在注入的类添加@Configuration注解 注意 同Second 调用方法的@Configuration不能换为@Component；不添加@Configuration或添加了@Component会报错 Method annotated with @Bean is called directly. Use dependency injection instead. ","date":"2021-09-02","objectID":"/springboot-config-note/:2:4","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"5@Resource+Environment 数据 **yml **同First **properties **同First 实体类 不需要 调用方法 @Resource private Environment env; public String getFifth() { String single = \"fifth.id=\" + env.getProperty(\"config.fifth.id\") + \"；fifth.age=\" + env.getProperty(\"config.fifth.age\") + \"；fifth.name=\" + env.getProperty(\"config.fifth.name\") + \"；\u003cbr/\u003efifth.array=\"+env.getProperty(\"config.fifth.array\") + \"；\u003cbr/\u003efifth.list=\"+env.getProperty(\"config.fifth.list\") + \"；\u003cbr/\u003efifth.map=\"+env.getProperty(\"config.fifth.map\"); return single; } } 注意 只能读取为String，其他结构需要自己对字符串进行处理转化其他类型数据，因为很底层，所以用的很少 所有的@Resource都可以用@Autowired替换，区别看这 ","date":"2021-09-02","objectID":"/springboot-config-note/:2:5","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back","note"],"content":"总结 文中的@Configuration 可以替换为@Component运行结果是一样的，但是两者是有不同的，@Configuration会为配置类生成CGLIB代理Class，@Component不会；看了篇博文有解释 @ConfigurationProperties详解的博文 在yml中： 字符串默认不用加上单引号或者双引号； “\"：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ‘'：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 不添加@PropertySource注解会访问默认的application.yml或者properties ","date":"2021-09-02","objectID":"/springboot-config-note/:3:0","tags":["Java","SpringBoot","Yml","Properties"],"title":"SpringBoot读取yml/properties的几种方法","uri":"/springboot-config-note/"},{"categories":["Back"],"content":"记录log4j和slf4j分析及教程的笔记","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"为什么要log4j和slf4j代替System.out.println()输出日志 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:1:0","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"内容： 1.什么是log4j 2.log4j的特点 3.为什么要用Log4j来替代System.out.println ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:1:1","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"一、什么是log4j Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:1:2","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"二、log4j的特点 三、为什么要用Log4j来替代System.out.println 关于log4j 的五个问题及答案： (1)什么情况使用log4j、什么情况下使用System.out.println? System.out.println在开发中可以使用，部署项目后用日志文件。最好不要用System.out.println。 (2)log4j是否会影响性能？ 是的，log4j会拖慢进程响应时间 (3)为什么log4j日志的最高级是error，但error却是\"虽然发生错误事件，但仍然不影响系统的继续运行\"？ 日志有7个等级： A：off 最高等级，用于关闭所有日志记录。 B：fatal 指出每个严重的错误事件将会导致应用程序的退出。 C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。 D：warm 表明会出现潜在的错误情形。 E：info 一般和在粗粒度级别上，强调应用程序的运行全程。 F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。 G：all 最低等级，用于打开所有日志记录。 而log4j建议使用四种：debug、info、warn、error (4)log4j 的文件保存位置？ 存放到项目目录下： ${task5.root}/WEB-INF/logs/log.log (5)log4j打印堆栈信息？ log.info(“xxx”, e) ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:1:3","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"看到log4j有好处也有缺点，我再来看看为什么要使用slf4j结合log4j来使用 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:2:0","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"为什么使用 SLF4J 而不是 Log4J 来做 Java 日志 每个Java开发人员都知道日志记录对Java应用的重要性，尤其是对服务端应用，而且其中许多人都已经熟悉了各种记录日志的库，比如java.util.logging,Apache的log4j,logback，然而如果你不知道 SLF4J，java的简单记录日志的设计的话 ，那么到了学习并在你的项目中使用它的时候了。在这篇Java文档里，我们将学习为什么使用SLF4J比使用log4j或者java.util.logging更好。从我写 Java开发人员的10个记录日志的技巧 算起已经过去了很长一段时间了。我不记得我所写的有关日志记录的任何事情了。无论如何，让我们回归到这个主题上来，与所有提到的这些日志记录库相比，SLF4J与它们之间有一个主要的区别。SLF4J或者说是Java的简单记录日志设计没有真正地实现日志记录，相反它只是一个允许你使用任何处于后端的日志记录库的 抽象层 。如果你正在编写内部或者外部使用的API或者应用库的话，那么你真的不需要让使用你所编写的库的客户端还去选择日志库。假设项目已经使用了log4j，而且你包含一个名为Apache Active MQ的库，这个库还依赖于另一个日志记录库logback的话，那么你还需要包含它们，然而，如果Apache Active MQ使用了SLF4J的话，你可以继续使用你的日志记录库，而不需要痛苦地添加和维护新的日志记录框架。简短的说，SLF4J让你的代码独立于任何特定的日志记录API，这个好的想法尤其适合于公共的API开发人员。虽然日志记录库的抽象理念不是新的，而且Apache的commons logging日志记录库也是用了这个理念，不过现在SLF4J很快就会成为Java世界里标准的日志记录库。让我们看一些使用 SLF4J而不使用log4j,logback或者java.util.logging的理由。 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:3:0","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"宁愿使用SLF4J也不愿使用Log4J,logback和java.util.Logging 正如我前面所说，在你的代码中编写日志记录语句使用SLF4J的主要动机是让你的程序独立于任何特定的日志记录库，这些日志记录库可能需要与你现在配置不同的配置，而且还会引入更多令人头疼的维护问题。然而除了这个之外，SLF4J API还有一个让你使用SLF4J而不是用长期感兴趣的 Log4j 更让人信服的功能，也就是占位符功能，在代码中用{}来表示。占位符功能与 String的format()方法中 的%s非常相似，因为它在运行时刻才提取所提供的真正的字符串。这不仅缩减了代码中的许多字符串连接，而且减少了创建String对象所需要的资源。即便在你生产环境日志级别比如DEBUG和INFO级别的字符串连接可能不需要的时候，仍然可以起到同样的效果。由于 字符串是不可更改的 ，而且它们是在字符串池中创建的，这些字符串使用了 堆内存 ，当应用在生产环境中运行在ERROR级别的时候，字符串在大多数情况下就不是必须的，比如DEBUG语句里的字符串就不是必须的。通过使用SLF4J，你可以延迟字符串的创建到运行时刻，这意味着只有在需要字符串的时候才创建它。如果你已经使用了log4j,那么你已经熟悉把调试语句放入if()条件内的工作场景，而SLF4J占位符功能比log4j更适合这种场景。 下面是你用Log4j时的做法，当然这并不好玩而且它增加了不必要的公式化的代码，减少了代码的可读性。 if (logger.isDebugEnabled()) { logger.debug(\"Processing trade with id: \" + id + \" symbol: \" + symbol); } 而如果你使用SLF4J，你可以使用更简洁的格式达到同样的效果，如下: logger.debug(\"Processing trade with id: {} and symbol : {} \", id, symbol); 在SLF4J中，我们不需要进行字符串拼接，不会导致使用临时字符串带来的消耗。相反，我们使用带占位符的模板消息来记录日志信息，并提供实际值作为参数。也许你会想，要是有多个参数该怎么办，你可以使用带参数版的日志方法，也可以通过Object数组传入。这确实是非常方便而且高效的记日志的方法。记住，在为日志信息产生最终的字符串之前，该方法会检查是否开启了特定的日志级别，这不仅降低了内存占用，而且预先减少了执行字符串拼接所消耗的CPU时间。下面的SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar包里的Log4j的适配器类Log4jLoggerAdapter. public void debug(String format, Object arg1, Object arg2) { if (logger.isDebugEnabled()) { FormattingTuple ft = MessageFormatter.format(format, arg1, arg2); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); } } 同样值得了解是，日志也会对应用程序的性能产生压力，大家通常宣扬的是只在生产环境中才强制记录日志。 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:3:1","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"slf4j的优势与使用原理 概述 slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案，比如apache的 org.apache.log4j.Logger，jdk自带的 java.util.logging.Logger等等。 slf4j的优势 知道什么是slf4j之后我们应该明白为什么要使用slf4j，为什么不适用具体的日志实现方案。笔者理解，slf4j主要有以下几点优势： 与客户端解耦 想象一下下面的场景： 有一个别人写的很棒的类库，里面使用的是jdk自带的java.util.logging.Logger这个日志系统，现在你有一个程序需要用到这个类库，并且你自己的程序现在是使用apache的org.apache.log4j.Logger这个日志系统。那么问题来了，如果你的程序导入了这个类库，那么是不是必须两种日志系统都要支持，那么你是不是需要多配置一些东西，多维护一些东西？耗费了太多维护成本，你想死的心都有了吧？ 有问题就要有解决方案，不错，解决方案就是： 使用slf4j。 slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。 省内存 如果大家之前使用过log4j，那么一定基本都是这样用的： package com.winwill.test; import org.apache.log4j.Logger; * @author qifuguang * @date 15/8/26 21:54 */ public class TestLog4j { private static final Logger LOGGER = Logger.getLogger(TestLog4j.class); public static void main(String[] args) { String message = \"Hello World.\"; LOGGER.info(\"This is a test message: \" + message); } } 注意到log4j的info函数有两种使用方式： public void info(Object message) public void info(Object message, Throwable t) 第一个参数是要输出的信息，假设要输出的是一个字符串，并且字符串中包含变量，则message参数就必须使用字符串相加操作，就比如上面测试代码的14行一样。姑且不说字符串相加是一个比较消耗性能的操作，字符串是一个不可变对象，一旦创建就不能被修改，创建的字符串会保存在String池中，占用内存。更糟糕的是如果配置文件中配置的日志级别是ERROR的话，这行info日志根本不会输出，则相加得到的字符串对象是一个非必须对象，白白浪费了内存空间。有人会说了，那我可以这样写啊： package com.winwill.test; import org.apache.log4j.Logger; * @author qifuguang * @date 15/8/26 21:54 */ public class TestLog4j { private static final Logger LOGGER = Logger.getLogger(TestLog4j.class); public static void main(String[] args) { String message = \"Hello World.\"; if (LOGGER.isInfoEnabled()) { LOGGER.info(\"This is a test message: \" + message); } } } 这样不就解决了白白浪费内存的问题了吗？没错，这是一个变通方案，但是这样的代码太繁琐，不直观！ 再来看看slf4j的打日志的方式： package com.winwill.test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; * @author qifuguang * @date 15/8/26 21:54 */ public class TestLog4j { private static final Logger LOGGER = LoggerFactory.getLogger(TestLog4j.class); public static void main(String[] args) { String message = \"Hello World.\"; LOGGER.info(\"This is a test message: {}\", message); } } 看到没有，打日志的时候使用了{}占位符，这样就不会有字符串拼接操作，减少了无用String对象的数量，节省了内存。并且，记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。 public void debug(String format, Object arg1, Object arg2) { if (logger.isDebugEnabled()) { FormattingTuple ft = MessageFormatter.format(format, arg1, arg2); logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); } } slf4j的使用与绑定原理 前面介绍了slf4j的优势，本节介绍怎么使用slf4j以及其中的原理，前文说到了，单独的slf4j是不能工作的，必须带上其他具体的日志实现方案。就以apache的log4j作为具体日志实现方案为例，如果在工程中要使用slf4j作为接口，并且要用log4j作为具体实现方案，那么我们需要做的事情如下：（下面的xxx表示具体版本号） 将slf4j-api-xxx.jar加入工程classpath中； 将slf4j-log4jxx-xxx.jar加入工程classpath中； 将log4j-xxx.jar加入工程classpath中； 将log4j.properties（log4j.xml）文件加入工程classpath中。 介绍一下工作原理： 首先，slf4j-api作为slf4j的接口类，使用在程序代码中，这个包提供了一个Logger类和LoggerFactory类，Logger类用来打日志，LoggerFactory类用来获取Logger；slf4j-log4j是连接slf4j和log4j的桥梁，怎么连接的呢？我们看看slf4j的LoggerFactory类的getLogger函数的源码： /** * Return a logger named corresponding to the class passed as parameter, using * the statically bound {@link ILoggerFactory} instance. * * @param clazz the returned logger will be named after clazz * @return logger */ public static Logger getLogger(Class clazz) { return getLogger(clazz.getName()); } /** * Return a logger named according to the name parameter using the statically * bound {@link ILoggerFactory} instance. * @param name The name of the logger. * @return logger */ public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } public static ILoggerFactory getILoggerFactory() { if (INITIALIZATION_STATE == UNINITIALIZED) { INITIALIZATION_STATE = ONGOING_INITIALIZATION; performInitialization(); } switch (INITIALIZATION_STATE) { case SUCCESSFUL_INITIALIZATION: return StaticLoggerBinder.getSingle","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:3:2","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"如何使用SLF4J和Log4J来做日志 除了上面所说的好处，我认为还有个警告需要说一下，为了使用SLF4J你不仅需要进入SLF4J API Jar包，比如slf4j-api-1.6.1.jar，还需要引入协同工作的JAR包，具体是什么jar包则依赖于后端你使用了什么日志工具库。假如你想使用 _SLF4J，Simple Logging Facade for Java，还想使用Lo4J，_那么你需要把下列jar包引入到你的classpath中，具体版本要视你使用的SLF4J和log4J版本而定， 比如： slf4j-api-1.6.1.jar - JAR for SLF4J API log4j-1.2.16.jar - JAR for Log4J API slf4j-log4j12-1.6.1.jar - Log4J Adapter for SLF4J 如果你正在使用Maven来管理你的项目依赖，你可以只引入SLF4J JAR，然后maven会引入它所依赖的其它JAR包。为了使用Log4J和SLF4J，你可以在你项目的pom.xml中添加下列依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.6.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.6.1\u003c/version\u003e \u003c/dependency\u003e 顺便说一下，如果你对使用带参数版的日志方法感兴趣，那就需要引入SLF4J 1.7版本。 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:3:3","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back"],"content":"总结 总结这篇文章，我具有充分的理由的来选择SLF4J而不是直接选用Log4j, commons logging, logback 或者 java.util.logging。 1）在你的开源库或者私有库中使用SLF4J，可以使它独立于任何的日志实现，这就意味着不需要管理多个库和多个日志文件。你的客户端将会体会到这一点。 2）SLF4J提供了占位日志记录，通过移除对isDebugEnabled(), isInfoEnabled()等等的检查提高了代码的可读性。 3）通过使用日志记录方法，直到你使用到的时候，才会去构造日志信息（字符串），这就同时提高了内存和CPU的使用率。 4）做一个侧面的说明，越少的临时字符串，垃圾回收器就意味着越少的工作，这就意味着为你的应用程序提供更好的吞吐量和性能。 这些优势都只是冰山一角，当你开始使用SL4J并阅读它，你会学到更多的好处。我强烈建议，在java中任何新的代码开发，都应使用SLF4J而不是任何的日志API，包括log4J。 ","date":"2021-09-02","objectID":"/java-log4j-slf4j-note/:3:4","tags":["Java","Log","log4j","slf4j"],"title":"log4j和slf4j分析及教程","uri":"/java-log4j-slf4j-note/"},{"categories":["Back","note"],"content":"记录Spring @Aspect、@Before、@After 注解实现 AOP 切面功能的笔记","date":"2021-09-01","objectID":"/spring-aop-note/","tags":["AOP","Spring"],"title":"Spring @Aspect、@Before、@After 注解实现 AOP 切面功能","uri":"/spring-aop-note/"},{"categories":["Back","note"],"content":"Spring AOP 注解概述 1、Spring 的 AOP 功能除了在配置文件中配置一大堆的配置，比如切入点、表达式、通知等等以外，使用注解的方式更为方便快捷，特别是 Spring boot 出现以后，基本不再使用原先的 beans.xml 等配置文件了，而都推荐注解编程。 @Aspect 切面声明，标注在类、接口（包括注解类型）或枚举上。 @Pointcut 切入点声明，即切入到哪些目标类的目标方法。value 属性指定切入点表达式，默认为 “\"，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式 @Before 前置通知 ,在目标方法(切入点)执行之前执行。value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -\u003e 异常通知。 @After 后置通知, 在目标方法(切入点)执行之后执行 @AfterReturning 返回通知, 在目标方法(切入点)返回结果之后执行，在 @After 的后面执行pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 \"” @AfterThrowing 异常通知, 在方法抛出异常之后执行, 意味着跳过返回通知pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “\"注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数 @Around 环绕通知：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。通常用于统计方法耗时，参数校验等等操作。环绕通知早于前置通知，晚于返回通知。 2、上面这些 AOP 注解都是位于如下所示的 aspectjweaver依赖中： 3、对于习惯了 Spring 全家桶编程的人来说，并不是需要直接引入 aspectjweaver 依赖，因为spring-boot-starter-aop 组件默认已经引用了 aspectjweaver 来实现 AOP 功能。换句话说 Spring 的 AOP 功能就是依赖的 aspectjweaver ！ \u003c!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-aop\u003c/artifactId\u003e \u003cversion\u003e2.1.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-09-01","objectID":"/spring-aop-note/:1:0","tags":["AOP","Spring"],"title":"Spring @Aspect、@Before、@After 注解实现 AOP 切面功能","uri":"/spring-aop-note/"},{"categories":["Back","note"],"content":"@Aspect 快速入门 1、@Aspect 常见用于记录日志、异常集中处理、权限验证、Web 参数校验、事务处理等等 2、要想把一个类变成切面类，只需3步： 1）在类上使用 @Aspect 注解使之成为切面类 2）切面类需要交由 Sprign 容器管理，所以类上还需要有 @Service、@Repository、@Controller、@Component 等注解 2）在切面类中自定义方法接收通知 3、AOP 的含义就不再累述了，下面直接上示例： import org.apache.commons.lang3.time.StopWatch; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.Signature; import org.aspectj.lang.annotation.*; import org.aspectj.lang.reflect.SourceLocation; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import java.util.Arrays; /** * 切面注解 Aspect 使用入门 * 1、@Aspect：声明本类为切面类 * 2、@Component：将本类交由 Spring 容器管理 * 3、@Order：指定切入执行顺序，数值越小，切面执行顺序越靠前，默认为 Integer.MAX_VALUE * * @author wangMaoXiong * @version 1.0 * @date 2020/8/20 19:22 */ @Aspect @Order(value = 999) @Component public class AspectHelloWorld { private static final Logger LOG = LoggerFactory.getLogger(AspectHelloWorld.class); /** * @Pointcut ：切入点声明，即切入到哪些目标方法。value 属性指定切入点表达式，默认为 \"\"。 * 用于被下面的通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式 * \u003cp\u003e * 切入点表达式常用格式举例如下： * - * com.wmx.aspect.EmpService.*(..))：表示 com.wmx.aspect.EmpService 类中的任意方法 * - * com.wmx.aspect.*.*(..))：表示 com.wmx.aspect 包(不含子包)下任意类中的任意方法 * - * com.wmx.aspect..*.*(..))：表示 com.wmx.aspect 包及其子包下任意类中的任意方法 * \u003c/p\u003e * value 的 execution 可以有多个，使用 || 隔开. */ @Pointcut(value = \"execution(* com.wmx.hb.controller.DeptController.*(..)) \" + \"|| execution(* com.wmx.hb.controller.EmpController.*(..))\") private void aspectPointcut() { } /** * 前置通知：目标方法执行之前执行以下方法体的内容。 * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式 * \u003cbr/\u003e * * @param joinPoint：提供对连接点处可用状态和有关它的静态信息的反射访问\u003cbr/\u003e \u003cp\u003e * * * Object[] getArgs()：返回此连接点处（目标方法）的参数，目标方法无参数时，返回空数组 * * * Signature getSignature()：返回连接点处的签名。 * * * Object getTarget()：返回目标对象 * * * Object getThis()：返回当前正在执行的对象 * * * StaticPart getStaticPart()：返回一个封装此连接点的静态部分的对象。 * * * SourceLocation getSourceLocation()：返回与连接点对应的源位置 * * * String toLongString()：返回连接点的扩展字符串表示形式。 * * * String toShortString()：返回连接点的缩写字符串表示形式。 * * * String getKind()：返回表示连接点类型的字符串 * * * \u003c/p\u003e */ @Before(value = \"aspectPointcut()\") public void aspectBefore(JoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); Signature signature = joinPoint.getSignature(); Object target = joinPoint.getTarget(); Object aThis = joinPoint.getThis(); JoinPoint.StaticPart staticPart = joinPoint.getStaticPart(); SourceLocation sourceLocation = joinPoint.getSourceLocation(); String longString = joinPoint.toLongString(); String shortString = joinPoint.toShortString(); LOG.debug(\"【前置通知】\" + \"args={},signature={},target={},aThis={},staticPart={},\" + \"sourceLocation={},longString={},shortString={}\" , Arrays.asList(args), signature, target, aThis, staticPart, sourceLocation, longString, shortString); } /** * 后置通知：目标方法执行之后执行以下方法体的内容，不管目标方法是否发生异常。 * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式 */ @After(value = \"aspectPointcut()\") public void aspectAfter(JoinPoint joinPoint) { LOG.debug(\"【后置通知】kind={}\", joinPoint.getKind()); } /** * 返回通知：目标方法返回后执行以下代码 * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式 * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 \"\" * returning 属性：通知签名中要将返回值绑定到的参数的名称，默认为 \"\" * * @param joinPoint ：提供对连接点处可用状态和有关它的静态信息的反射访问 * @param result ：目标方法返回的值，参数名称与 returning 属性值一致。无返回值时，这里 result 会为 null. */ @AfterReturning(pointcut = \"aspectPointcut()\", returning = \"result\") public void aspectAfterReturning(JoinPoint joinPoint, Object result) { LOG.debug(\"【返回通知】,shortString={},result=\", joinPoint.toShortString(), result); } /** * 异常通知：目标方法发生异常的时候执行以下代码，此时返回通知不会再触发 * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式 * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 \"\" * throwing 属性：与方法中的异常参数名称一致， * * @param ex：捕获的异常对象，名称与 throwing 属性值一致 */ @AfterThrowing(pointcut = \"aspectPointcut()\", throwing = \"ex\") public void aspectAfterThrowing(JoinPoint jp, Exception ex) { String methodName = jp.getSignature().getName(); if (ex instanceof ArithmeticException) { LOG.error(\"【异常通知】\" + methodName","date":"2021-09-01","objectID":"/spring-aop-note/:2:0","tags":["AOP","Spring"],"title":"Spring @Aspect、@Before、@After 注解实现 AOP 切面功能","uri":"/spring-aop-note/"},{"categories":["Back","note"],"content":"execution 切点表达式 1、@Pointcut 切入点声明注解，以及所有的通知注解都可以通过 value 属性或者 pointcut 属性指定切入点表达式。 2、切入点表达式通过 execution 函数匹配连接点，语法：execution([方法修饰符] 返回类型 方法路径(参数类型) [异常类型]) 3、切入点表达式的写法比较灵活，比如：* 号表示任意一个，.. 表示任意多个，还可以使用 \u0026\u0026、||、! 进行逻辑运算，不过实际开发中通常用不到那么多花里胡哨的，掌握以下几种就基本够用了。 **切入点表达式常用举例** execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(Integer)) 匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个 Integer 类型参数。 execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(*)) 匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个任意类型参数。 execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(..)) 匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，参数不限。 execution(* grp.basic3.se.service.SEBasAgencyService3.editAgencyInfo(..)) 匹配 editAgencyInfo 方法或者 adjustAgencyInfo 方法 execution(* com.wmx.aspect.EmpService.*(..)) 匹配 com.wmx.aspect.EmpService 类中的任意方法 execution(* com.wmx.aspect..(..)) 匹配 com.wmx.aspect 包(不含子包)下任意类中的任意方法 execution(* com.wmx.aspect...(..)) 匹配 com.wmx.aspect 包及其子包下任意类中的任意方法 execution(* grp.pm..Controller.(..)) 匹配 grp.pm 包下任意子孙包中以 “Controller” 结尾的类中的所有方法 ","date":"2021-09-01","objectID":"/spring-aop-note/:3:0","tags":["AOP","Spring"],"title":"Spring @Aspect、@Before、@After 注解实现 AOP 切面功能","uri":"/spring-aop-note/"},{"categories":["Learning","note"],"content":"记录EJB解释分析的笔记","date":"2021-09-01","objectID":"/ejb-note/","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"1. 我们不禁要问，什么是\"服务集群\"？什么是\"企业级开发\"？ 既然说了EJB 是为了\"服务集群\"和\"企业级开发\"，那么，总得说说什么是所谓的\"服务 集群\"和\"企业级开发\"吧！ 这个问题其实挺关键的，因为J2EE 中并没有说明白，也没有具体的指标或者事例告诉 广大程序员什么时候用EJB 什么时候不用。于是大家都产生一些联想，认为EJB\"分布式运 算\"指得是\"负载均衡\"提高系统的运行效率。然而，估计很多人都搞错了，这个\"服务群集\" 和\"分布式运算\"并没有根本解决运行负载的问题，尤其是针对数据库的应用系统。 为什么？ 我们先把EJB 打回原形给大家来慢慢分析。 ","date":"2021-09-01","objectID":"/ejb-note/:1:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"2. 把EJB 掰开了揉碎了 我们把EJB 的概念好好的分析一下，看看能发现些什么蛛丝马迹。 ","date":"2021-09-01","objectID":"/ejb-note/:2:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"3.1 EJB 概念的剖析 我们先看一下，EJB 的官方解释： 商务软件的核心部分是它的业务逻辑。业务逻辑抽象了整个商务过程的流程，并使用计 算机语言将他们实现。 …… J2EE 对于这个问题的处理方法是将业务逻辑从客户端软件中抽取出来，封装在一个组 件中。这个组件运行在一个独立的服务器上，客户端软件通过网络调用组件提供的服务以实 现业务逻辑，而客户端软件的功能单纯到只负责发送调用请求和显示处理结果。在J2EE 中， 这个运行在一个独立的服务器上，并封装了业务逻辑的组件就是EJB（Enterprise Java Bean）组件。 这其中我们主要关注这么几点，我们来逐条剖析： 剖析1：所谓：“业务逻辑” 我们注意到在EJB 的概念中主要提到的就是\"业务逻辑\"的封装，而这个业务逻辑到底是 什么？说的那么悬乎，其实这个所谓的\"业务逻辑\"我们完全可以理解成执行特定任务的\"类 “。 剖析2：所谓：“将业务逻辑从客户端软件中抽取出来，封装在组件中……运行在一个服 务器上” 既然我们知道了\"业务逻辑\"的概念就是执行特定任务的\"类”，那么，什么叫\"从客户端 软件中抽取出来\"？其实，这个就是把原来放到客户端的\"类\"，拿出来不放到客户端了，放 到一个组件中，并将这个组件放到一个服务器上去运行。 ","date":"2021-09-01","objectID":"/ejb-note/:2:1","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"3.2 把EJB 这个概念变成大白话 变成大白话就是，“把你编写的软件中那些需要执行制定的任务的类，不放到客户端软 件上了，而是给他打成包放到一个服务器上了”。 ","date":"2021-09-01","objectID":"/ejb-note/:2:2","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"3.3 发现问题了 不管是用\"八股文\"说，还是用大白话说这个EJB 概念都提到了一个词–“客户端软件”。 “客户端软件”？难道EJB 的概念中说的是C/S 软件？ 是的，没错！ EJB 就是将那些\"类\"放到一个服务器上，用C/S 形式的软件客户端对服务器上的\"类\"进 行调用。 快崩溃了吧！ EJB 和JSP 有什么关系？EJB 和JSP 有关系，但是关系还真不怎么大，至多是在JSP 的 服务器端调用远端服务上的EJB 类，仅此而已。 ","date":"2021-09-01","objectID":"/ejb-note/:2:3","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4 .1 EJB 的最底层究竟是什么 我们揭开了EJB\"八股\"概念的真谛，那么，再来分析EJB 的底层实现技术，通过底层实 现技术来分析EJB 的工作方式。 ","date":"2021-09-01","objectID":"/ejb-note/:2:4","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4.2 EJB 的实现技术 EJB 是运行在独立服务器上的组件，客户端是通过网络对EJB 对象进行调用的。在Java 中，能够实现远程对象调用的技术是RMI，而EJB 技术基础正是RMI。通过RMI 技术，J2EE 将EJB 组件创建为远程对象，客户端就可以通过网络调用EJB 对象了。 ","date":"2021-09-01","objectID":"/ejb-note/:2:5","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4.3 看看RMI 是什么东东 在说RMI 之前，需要理解两个名词： 对象的序列化 分布式计算与RPC 名词1：对象的序列化 对象的序列化概念：对象的序列化过程就是将对象状态转换成字节流和从字节流恢复对 象。将对象状态转换成字节流之后，可以用java.io 包中的各种字节流类将其保存到文件中， 或者通过网络连接将对象数据发送到另一个主机。 上面的说法有点\"八股\"，我们不妨再用白话解释一下：对象的序列化就是将你程序中实 例化的某个类的对象，比如，你自定一个类MyClass，或者任何一个类的对象，将它转换成 字节数组，也就是说可以放到一个byte 数组中，这时候，你既然已经把一个对象放到了byte 数组中，那么你当然就可以随便处置了它了，用得最多的就是把他发送到网络上远程的计算 机上了。如图所示。 名词2：分布式计算与RPC RPC 并不是一个纯粹的Java 概念，因为在Java 诞生之前就已经有了RPC 的这个概念，RPC 是\"Remote Procedure Call\"的缩写，也就是\"远程过程调用\"。在Java 之前的大多数编程语 言，如，Fortran、C、COBOL 等等，都是过程性的语言，而不是面向对象的。所以，这些编 程语言很自然地用过程表示工作，如，函数或子程序，让其在网络上另一台机器上执行。说 白了，就是本地计算机调用远程计算机上的一个函数。 如下图所示。 名词3：二者结合就是RMI RMI 英文全称是\"Remote Method Invocation\"，它的中文名称是\"远程方法调用\"，它就 是利用Java 对象序列化的机制实现分布式计算，实现远程类对象的实例化以及调用的方法。 说的更清楚些，就是利用对象序列化来实现远程调用，也就是上面两个概念的结合体，利用 这个方法来调用远程的类的时候，就不需要编写Socket 程序了，也不需要把对象进行序列 化操作，直接调用就行了非常方便。 远程方法调用是一种计算机之间对象互相调用对方函数，启动对方进程的一种机制，使用这 种机制，某一台计算机上的对象在调用另外一台计算机上的方法时，使用的程序语法规则和 在本地机上对象间的方法调用的语法规则一样。 如图所示。 ","date":"2021-09-01","objectID":"/ejb-note/:2:6","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4.4 优点 这种机制给分布计算的系统设计、编程都带来了极大的方便。只要按照RMI 规则设计程 序，可以不必再过问在RMI 之下的网络细节了，如：TCP 和Socket 等等。任意两台计算机 之间的通讯完全由RMI 负责。调用远程计算机上的对象就像本地对象一样方便。 RMI 可将完整的对象作为参数和返回值进行传递，而不仅仅是预定义的数据类型。也就 是说，可以将类似Java 哈西表这样的复杂类型作为一个参数进行传递。 ","date":"2021-09-01","objectID":"/ejb-note/:2:7","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4.5 缺点 如果是较为简单的方法调用，其执行效率也许会比本地执行慢很多，即使和远程Socket 机制的简单数据返回的应用相比，也会慢一些，原因是，其在网络间需要传递的信息不仅仅 包含该函数的返回值信息，还会包含该对象序列化后的字节内容。 ","date":"2021-09-01","objectID":"/ejb-note/:2:8","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"4.6 EJB 是以RMI 为基础的 通过RMI 技术，J2EE 将EJB 组件创建为远程对象，EJB 虽然用了RMI 技术，但是却只需 要定义远程接口而无需生成他们的实现类，这样就将RMI 技术中的一些细节问题屏蔽了。 但不管怎么说，EJB 的基础仍然是RMI，所以，如果你想了解EJB 的原理，只要把RMI 的原理搞清楚就行了。你也就弄清楚了什么时候用EJB 什么时候不需要用EJB 了。 ","date":"2021-09-01","objectID":"/ejb-note/:2:9","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"5. EJB 中所谓的\"服务群集\" 既然已经知道了，RMI 是将各种任务与功能的类放到不同的服务器上，然后通过各个服 务器间建立的调用规则实现分布式的运算，也就明白EJB 所谓的\"服务群集\"的概念。 就是将原来在一个计算机上运算的几个类，分别放到其他计算机上去运行，以便分担运 行这几个类所需要占用的CPU 和内存资源。同时，也可以将不同的软件功能模块放到不同的 服务器上，当需要修改某些功能的时候直接修改这些服务器上的类就行了，修改以后所有客 户端的软件都被修改了。如图所示。 ","date":"2021-09-01","objectID":"/ejb-note/:3:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"6. 这种部署难道是无懈可击 图2 14所示的这个\"服务群集\"看似\"无懈可击\"，其实是它这个图没有画完整，我们来 把这个图画完整，再来看看有什么问题没有。 ","date":"2021-09-01","objectID":"/ejb-note/:4:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"6.1 瓶颈在数据库端 仔细观察之后，发现这种配置是有瓶颈的，如图所示。 我们看看图2 15的结构图，现在如果想实现各个服务器针对同一个数据库的查询，那 么，不管你部署多少个功能服务器，都需要针对一个数据库服务器进行查询操作。也就是说， 不管你的\"计算\"有多么\"分布\"也同样需要从一台服务器中取得数据。虽然，看起来将各个功 能模块分布在不同的服务器上从而分担了各个主计算机的CPU 资源，然而，真正的瓶颈并不 在这里，而是，数据库服务器那里。数据库服务器都会非常忙的应付各个服务器的查询及操 作请求。 因此，通过这个结构图使我们了解到了EJB 根本不能完全解决负载的问题，因为，瓶颈 并不在功能模块的所在位置，而是在数据库服务器这里。 ","date":"2021-09-01","objectID":"/ejb-note/:4:1","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"6.2 假如分开数据库，数据共享怎么办 有的读者一定会想到下面的这个应用结构，如图所示。 就是把每一个功能服务器后面都部署一个数据库，这样不就解决了上节所说的问题了 吗？是的解决了数据库查询负载的问题，然而又出现了新的问题，就是\"数据共享\"的问题就 又不容易解决了。 6.3 网络面临较大压力，让你的应用慢如老牛 我们再向前翻看看如图2 15所示的这种架构中存在两个网络，一个是\"A 网\"一个是\"B 网\"，这两个网络是不同的。“B 网\"往往是局域网，一般带宽是10M/100M，速度较快，因此 到还好说，然而，“A 网\"往往是互联网或者是利用电信网络互联VPN 网或称广域网。“A 网” 的特点是带宽一般较窄，如ADSL 的网络仅仅有512K-2M 的带宽，由于广域网互联的成本较 高，所以一般不会有较高的带宽。 而在这个网络上恰恰跑的是功能模块和客户端软件之间交换的数据，而这部分数据恰恰 优势非常占用带宽的。 因此，这个应用架构其运行速度可以想见是多么的慢了。说句不夸张的话，有点想老牛 拉破车一样的慢。 一个如老牛的系统： 目前在中国互联网做运营商网络管理系统的一个大公司，它的一个早期的网管软件就是 采用了这种架构来做的C/S 结构的应用系统。 有一次，我作为评估者来对其应用系统进行评估，将其部署到一个非运营商大型的网络 中的时候，便出现了我们上述描述的情况，速度已经到了难以忍受的地步，打开一个流量图， 有时候需要用15分钟的时间才能呈现完整。然而，该系统在开发阶段并没有发现这个问题， 为什么呢？因为，他们没有考虑到应用的实际用户连接网络的复杂性，从而给该公司造成较 大损失，以至于，这个开发架构被最终遗弃。 ","date":"2021-09-01","objectID":"/ejb-note/:4:2","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"7. EJB 活学活用，J2EE 不是必须使用EJB 通过上面小节的讲解似乎好像EJB 和开发Web 应用的B/S 结构的系统关系并不大，其实 倒也不然。我们如果把\"客户端程序\"理解成某一台服务器，这样也是可以被应用的，而且， 如果是服务器互相之间做EJB 的调用的话，也就不存在广域网带宽限制的问题了。 但是，如下情况尽量就不要使用EJB 了： 1、较为简单的纯Web 应用开发，不需要用EJB。 2、需要与其他服务程序配合使用的应用，但调用或返回的自定义的网络协议可以解决 的应用程序,不需要使用EJB。 3、较多人并发访问的C/S 结构的应用程序，尽量不要使用EJB。 ","date":"2021-09-01","objectID":"/ejb-note/:5:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Learning","note"],"content":"总结 a.EJB实现原理 ： 就是把原来放到客户端实现的代码放到服务器端，并依靠RMI进行通信。 b.RMI实现原理 ：就是通过Java对象可序列化机制实现分布计算。 c.服务器集群 ： 就是通过RMI的通信，连接不同功能模块的服务器，以实现一个完整的功能。 ","date":"2021-09-01","objectID":"/ejb-note/:6:0","tags":["Microservices","EJB"],"title":"EJB解释分析","uri":"/ejb-note/"},{"categories":["Back","note"],"content":"记录lombok常用注解及其使用方法的笔记","date":"2021-09-01","objectID":"/lombok-note/","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"以下类为例 public class User { int id; String name; List list; } ","date":"2021-09-01","objectID":"/lombok-note/:1:0","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Data、@Value @Data注解在类上，将类提供的所有属性都添加get、set方法，并添加equals、canEquals、hashCode、toString方法 @Value注解用于修饰类，相当于是@Data的不可变形式，因为字段都被修饰为 private和 final，默认的情况下不会生成 settter。还有一点更狠的，默认类本身也是 final的，不能被继承。 参考 ","date":"2021-09-01","objectID":"/lombok-note/:1:1","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Setter、@Getter、lombok.config 给类添加set、get方法 参考 ","date":"2021-09-01","objectID":"/lombok-note/:2:0","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Builder 使用builder模式创建对象 //创建新的对象 User aaa = User.builder().id(1).name(\"aaa\").build(); //修改原有对象的属性值;要求实体上添加@Builder(toBuilder=true) aaa = User.toBuilder().id(2).name(\"bbb).build(); ","date":"2021-09-01","objectID":"/lombok-note/:2:1","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Singular和@Builder联合使用 可以给集合更加方便的添加多条数据 @Singular(value = \"list\") List list; User aaa = User.builder().id(1).name(\"aaa\").list(\"aaa\").list(\"djsij\").build(); 参考 ","date":"2021-09-01","objectID":"/lombok-note/:2:2","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@NoArgsConstructor、@AllArgsConstructor、@RequiredArgsConstructor 可以创造一个无参构造器、或者有参构造器、第三个生成final或者@notnull修饰的无参或者有参构造器 参考 ","date":"2021-09-01","objectID":"/lombok-note/:2:3","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@ToStirng 可以添加一个toString方法 ","date":"2021-09-01","objectID":"/lombok-note/:2:4","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@NotNull 不能为空，否则抛出空指针异常 ","date":"2021-09-01","objectID":"/lombok-note/:2:5","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Accessors(chain = true)：使用链式创建 //添加注解 @Data @Accessors(chain = true) //使用方法 User aaa = new User().setId(1).setName(\"aaa\"); ","date":"2021-09-01","objectID":"/lombok-note/:3:0","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Synchronized、@SneakyThrows @Sychronized 是一个处理线程安全问题的annotation， 他的使用方法和关键字 synchronized比较类似，但是有一些不同点就是，关键字synchronized是锁定当前对象（this指针） ， 而@Synchronized则会锁定一个private的常量。如果当前类中没有这个常量，就会自动生成一个 @Synchronized public static void hello(){ System.out.println(\"hello\"); } @Synchronized public int hello2(){ System.out.println(\"hello\"); return 1; } @Synchronized public void hello3(){ System.out.println(\"hello\"); } 以下是它生成的方法 private static final Object $LOCK = new Object[0]; private final Object $lock = new Object[0]; private final Object readLock = new Object(); public static void hello() { synchronized($LOCK) { System.out.println(\"hello\"); } } public int hello2() { synchronized($lock) { return 1; } } public void hello3() { synchronized(readLock) { System.out.println(\"hello\"); } } @SneakyThrows让你的代码拥有try….catch包裹 @SneakyThrows public static void throwException() { String str = null; String[] split = str.split(\",\"); System.out.println(split); } 实际上 public SneakyThrowsTest() {} public static void throwException() { try { String str = null; String[] split = ((String)str).split(\",\"); System.out.println(split); } catch (Throwable var2) { throw var2; } } ","date":"2021-09-01","objectID":"/lombok-note/:4:0","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Cleanup: 关闭流、连接点 用于处理写入写出流的异常问题，可以让代码简洁 使用前： public class Cleanup01 { public static void main(String[] args) throws IOException { InputStream in = new FileInputStream(args[0]); try { OutputStream out = new FileOutputStream(args[1]); try { byte[] b = new byte[1000]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } finally { if (out != null) { out.close(); } } } finally { if (in != null) { in.close(); } } } } 使用后： public class Cleanup01 { public static void main(String[] args) throws IOException { @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1000]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } } ","date":"2021-09-01","objectID":"/lombok-note/:4:1","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@Log 参考 ","date":"2021-09-01","objectID":"/lombok-note/:4:2","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@EqualsAndHashCode 重写equals和hashcode方法。 ","date":"2021-09-01","objectID":"/lombok-note/:4:3","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@UtilityClass 官方文档是这么说的 创建实用程序类的注释。如果使用注释了一个类，则会 @UtilityClass发生以下情况： 它被标记为最终。 如果在其中声明了任何构造函数，则会生成错误。否则，将生成一个私有的无参数构造函数。它抛出一个 UnsupportedOperationException。 所有方法，内部类和类中的字段均标记为静态。 ","date":"2021-09-01","objectID":"/lombok-note/:4:4","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@ExtensionMethod 设置父类 ","date":"2021-09-01","objectID":"/lombok-note/:4:5","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@FieldDefaults 设置属性的使用范围，如private、public等，也可以设置属性是否被final修饰。 ","date":"2021-09-01","objectID":"/lombok-note/:4:6","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"@SneakyThrows @SneakyThrows注解的用途得从java的异常设计体系说起。 java中我们常见的2类异常。 1.普通Exception类,也就是我们常说的受检异常或者Checked Exception。 2.RuntimeException类，既运行时异常。 前者会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。 但是现实，往往事与愿违。大部分情况下的异常，我们都是一路往外抛了事。（强制处理我也处理不了啊！臣妾做不到）所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢。这种解决思想尤其在Spring中到处出现。参见《Spring in Action》 try{}catch(Exception e){ throw new RuntimeException(e); } Lombok的@SneakyThrows就是为了消除这样的模板代码。 使用注解后不需要担心Exception的处理 import lombok.SneakyThrows; public class SneakyThrowsExample implements Runnable { @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) { return new String(bytes, \"UTF-8\"); } @SneakyThrows public void run() { throw new Throwable(); } } 真正生成的代码 import lombok.Lombok; public class SneakyThrowsExample implements Runnable { public String utf8ToString(byte[] bytes) { try { return new String(bytes, \"UTF-8\"); } catch (UnsupportedEncodingException e) { throw Lombok.sneakyThrow(e); } } public void run() { try { throw new Throwable(); } catch (Throwable t) { throw Lombok.sneakyThrow(t); } } } 原理 显然魔法 藏在Lombok.sneakyThrow(t);中。可能大家都会以为这个方法就是new RuntimeException()之类的。然而事实并非如此。阅读代码可以看出整个方法其实最核心的逻辑是throw (T)t;，利用泛型将我们传入的Throwable强转为RuntimeException。虽然事实上我们不是RuntimeException。但是没关系。因为JVM并不关心这个。泛型最后存储为字节码时并没有泛型的信息。这样写只是为了骗过javac编译器。源码中注释有解释。 public static RuntimeException sneakyThrow(Throwable t) { if (t == null) throw new NullPointerException(\"t\"); return Lombok.\u003cRuntimeException\u003esneakyThrow0(t); } private static \u003cT extends Throwable\u003e T sneakyThrow0(Throwable t) throws T { throw (T)t; } ","date":"2021-09-01","objectID":"/lombok-note/:4:7","tags":["Java","Object","Lombok"],"title":"lombok常用注解及其使用方法","uri":"/lombok-note/"},{"categories":["Back","note"],"content":"记录Feign 基本使用教程和原理分析的笔记","date":"2021-09-01","objectID":"/springcloud-feign-note/","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Feign 基本使用  在开发 Spring Cloud 微服务的时候，我们知道，服务之间都是以 HTTP 接口的形式对外提供服务的，因此消费者在进行调用的时候，底层就是通过 HTTP Client 的这种方式进行访问。当然我们可以使用JDK原生的 URLConnection、Apache 的 HTTP Client、Netty 异步 Http Client，Spring 的 RestTemplate 去实现服务间的调用。但是最方便、最优雅的方式是通过 Spring Cloud Open Feign 进行服务间的调用 Spring Cloud 对 Feign 进行了增强，使 Feign 支持 Spring Mvc 的注解，并整合了 Ribbon 等，从而让 Feign 的使用更加方便。 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:1:0","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Feign 概述 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:2:0","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"什么是 Feign Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。 Feign 是一种声明式、模板化的 HTTP 客户端。在 Spring Cloud 中使用 Feign，可以做到使用 HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问 HTTP 请求。接下来介绍一下 Feign 的特性，具体如下： 可插拔的注解支持，包括 Feign 注解和AX-RS注解。 支持可插拔的 HTTP 编码器和解码器。 支持 Hystrix 和它的 Fallback。 支持 Ribbon 的负载均衡。 支持 HTTP 请求和响应的压缩。Feign 是一个声明式的 WebService 客户端，它的目的就是让 Web Service 调用更加简单。它整合了 Ribbon 和 Hystrix，从而不需要开发者针对 Feign 对其进行整合。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。Feign 会完全代理 HTTP 的请求，在使用过程中我们只需要依赖注入 Bean，然后调用对应的方法传递参数即可。 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:2:1","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Feign 入门案例  此处以调用 Github API 查询服务为例。 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:3:0","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"引入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e  启动类加入如下注解： /** 开启 Feign 扫描支持 */ @EnableFeignClients ","date":"2021-09-01","objectID":"/springcloud-feign-note/:3:1","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Feign 接口编写 /** * @Author：大漠知秋 * @Description：使用 Feign 访问 Github 查询 API * @CreateDate：2:36 PM 2018/10/24 */ @FeignClient(name = \"github-client\", url = \"https://api.github.com\") public interface GitHubFeign { @RequestMapping( value = \"/search/repositories\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE ) String searchRepo(@RequestParam(\"q\") String q); } ","date":"2021-09-01","objectID":"/springcloud-feign-note/:3:2","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Controller /** * @Author：大漠知秋 * @Description：使用 Feign 访问 Github 查询 API * @CreateDate：2:42 PM 2018/10/24 */ @RestController @RequestMapping( value = \"/github\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE ) public class GitHubController { @Resource private GitHubFeign gitHubFeign; @RequestMapping( value = \"/search/repositories\", method = RequestMethod.GET ) String searchRepo(@RequestParam(\"q\") String q) { return gitHubFeign.searchRepo(q); } } ","date":"2021-09-01","objectID":"/springcloud-feign-note/:3:3","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"结果 源码 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:3:4","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"Feign 工作原理 在开发微服务应用时，我们会在主程序入口添加 @EnableFeignClients 注解开启对 Feign Client 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加 @FeignClients 注解。 当程序启动时，会进行包扫描，扫描所有 @FeignClients 的注解的类，并将这些信息注入 Spring IOC 容器中。当定义的 Feign 接口中的方法被调用时，通过JDK的代理的方式，来生成具体的 RequestTemplate。当生成代理时，Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，如请求参数名、请求方法等信息都是在这个过程中确定的。 然后由 RequestTemplate 生成 Request，然后把 Request 交给 Client 去处理，这里指的 Client 可以是 JDK 原生的 URLConnection、Apache 的 Http Client 也可以是 Okhttp。最后 Client 被封装到 LoadBalanceclient 类，这个类结合 Ribbon 负载均衡发起服务之间的调用。 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:4:0","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Back","note"],"content":"@FeignClient 注解 name：指定 Feign Client 的名称，如果项目使用了 Ribbon，name 属性会作为微服务的名称，用于服务发现。 url：url 一般用于调试，可以手动指定 @FeignClient 调用的地址。 decode404：当发生404错误时，如果该字段为 true，会调用 decoder 进行解码，否则抛出 FeignException。 configuration：Feign 配置类，可以自定义 Feign 的 Encoder、Decoder、LogLevel、Contract。 fallback：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback 指定的类必须实现 @FeignClient 标记的接口。 fallbackFactory：工厂类，用于生成 fallback 类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。 path：定义当前 FeignClient 的统一前缀。 ","date":"2021-09-01","objectID":"/springcloud-feign-note/:4:1","tags":["Java","SpringCloud","Feign"],"title":"Feign 基本使用教程和原理分析","uri":"/springcloud-feign-note/"},{"categories":["Learning","note"],"content":"记录离不开的微服务架构，脱不开的RPC细节","date":"2021-08-31","objectID":"/microsvc-rpc-axiom/","tags":["Microservices","RPC"],"title":"微服务RPC原理与好处","uri":"/microsvc-rpc-axiom/"},{"categories":["Learning","note"],"content":"服务化有什么好处？ 服务化的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现大公司跨团队的技术解耦，如下图所示： 服务A：欧洲团队维护，技术背景是Java 服务B：美洲团队维护，用C++实现 服务C：中国团队维护，技术栈是go 服务的上游调用方，按照接口、协议即可完成对远端服务的调用。 但实际上，大部分互联网公司，研发团队规模有限，大都使用同一套技术体系来实现服务： 这样的话，如果没有统一的服务框架，各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等“业务之外”的重复技术劳动，造成整体的低效。 因此，统一服务框架把上述“业务之外”的工作统一实现，是服务化首要解决的问题。 什么是RPC？ Remote Procedure Call Protocol，远程过程调用。 什么是“远程”，为什么“远”？ 先来看下什么是“近”，即“本地函数调用”。 当我们写下： int result = Add(1, 2); 这行代码的时候，到底发生了什么？ 传递两个入参 调用了本地代码段中的函数，执行运算逻辑 返回一个出参 这三个动作，都发生在同一个进程空间里，这是本地函数调用。 那有没有办法，调用一个跨进程的函数呢？ 典型的，这个进程部署在另一台服务器上。 最容易想到的，两个进程约定一个协议格式，使用Socket通信，来传输： 入参 调用哪个函数 出参 如果能够实现，那这就是“远程”过程调用。 Socket通信只能传递连续的字节流，如何将入参、函数都放到连续的字节流里呢？ 假设，设计一个11字节的请求报文： 前3个字节填入函数名“add” 中间4个字节填入第一个参数“1” 末尾4个字节填入第二个参数“2” 同理，可以设计一个4字节响应报文： 4个字节填入处理结果“3” 调用方的代码可能变为： request = MakePacket(“add”, 1, 2); SendRequest_ToService_B(request); response = RecieveRespnse_FromService_B(); int result = unMakePacket(respnse); 这4个步骤是： （1）将传入参数变为字节流； （2）将字节流发给服务B； （3）从服务B接受返回字节流； （4）将返回字节流变为传出参数； 服务方的代码可能变为： request = RecieveRequest(); args/function = unMakePacket(request); result = Add(1, 2); response = MakePacket(result); SendResponse(response); 这个5个步骤也很好理解： （1）服务端收到字节流； （2）将字节流转为函数名与参数； （3）本地调用函数得到结果； （4）将结果转变为字节流； （5）将字节流发送给调用方； 这个过程用一张图描述如下： 调用方与服务方的处理步骤都是非常清晰。 这个过程存在最大的问题是什么呢？ 调用方太麻烦了，每次都要关注很多底层细节： 入参到字节流的转化，即序列化应用层协议细节 socket发送，即网络传输协议细节 socket接收 字节流到出参的转化，即反序列化应用层协议细节 能不能调用层不关注这个细节？ 可以，RPC框架就是解决这个问题的，它能够让调用方“像调用本地函数一样调用远端的函数（服务）”。 讲到这里，是不是对RPC，对序列化范序列化有点感觉了？往下看，有更多的底层细节。 ","date":"2021-08-31","objectID":"/microsvc-rpc-axiom/:1:0","tags":["Microservices","RPC"],"title":"微服务RPC原理与好处","uri":"/microsvc-rpc-axiom/"},{"categories":["Learning","note"],"content":"RPC框架的职责是什么？ RPC框架，要向调用方屏蔽各种复杂性，要向服务提供方也屏蔽各类复杂性： 服务调用方client感觉就像调用本地函数一样，来调用服务 服务提供方server感觉就像实现一个本地函数一样，来实现服务 所以整个RPC框架又分为client部分与server部分，实现上面的目标，把复杂性屏蔽，就是RPC框架的职责。 如上图所示，业务方的职责是： 调用方A，传入参数，执行调用，拿到结果 服务方B，收到参数，执行逻辑，返回结果 RPC框架的职责是，中间大蓝框的部分： client端：序列化、反序列化、连接池管理、负载均衡、故障转移、队列管理，超时管理、异步管理等等 server端：服务端组件、服务端收发包队列、io线程、工作线程、序列化反序列化等 server端的技术大家了解的比较多，接下来重点讲讲client端的技术细节。 先来看看RPC-client部分的“序列化反序列化”部分。 为什么要进行序列化？ 工程师通常使用“对象”来进行数据的操纵： class User{ ​ std::String user_name; ​ uint64_t user_id; ​ uint32_t user_age; }; User u = new User(“shenjian”); u.setUid(123); u.setAge(35); 但当需要对数据进行存储或者传输时，“对象”就不这么好用了，往往需要把数据转化成连续空间的“二进制字节流”，一些典型的场景是： 数据库索引的磁盘存储：数据库的索引在内存里是b+树，但这个格式是不能够直接存储到磁盘上的，所以需要把b+树转化为连续空间的二进制字节流，才能存储到磁盘上 缓存的KV存储：redis/memcache是KV类型的缓存，缓存存储的value必须是连续空间的二进制字节流，而不能够是User对象 数据的网络传输：socket发送的数据必须是连续空间的二进制字节流，也不能是对象 所谓序列化（Serialization），就是将“对象”形态的数据转化为“连续空间二进制字节流”形态数据的过程。这个过程的逆过程叫做反序列化。 怎么进行序列化？ 这是一个非常细节的问题，要是让你来把“对象”转化为字节流，你会怎么做？很容易想到的一个方法是xml（或者json）这类具有自描述特性的标记性语言： 规定好转换规则，发送方很容易把User类的一个对象序列化为xml，服务方收到xml二进制流之后，也很容易将其范序列化为User对象。 画外音：语言支持反射时，这个工作很容易。 第二个方法是自己实现二进制协议来进行序列化，还是以上面的User对象为例，可以设计一个这样的通用协议： 头4个字节表示序号 序号后面的4个字节表示key的长度m 接下来的m个字节表示key的值 接下来的4个字节表示value的长度n 接下来的n个字节表示value的值 像xml一样递归下去，直到描述完整个对象 上面的User对象，用这个协议描述出来可能是这样的： 第一行：序号4个字节（设0表示类名），类名长度4个字节（长度为4），接下来4个字节是类名（”User”），共12字节 第二行：序号4个字节（1表示第一个属性），属性长度4个字节（长度为9），接下来9个字节是属性名（”user_name”），属性值长度4个字节（长度为8），属性值8个字节（值为”shenjian”），共29字节 第三行：序号4个字节（2表示第二个属性），属性长度4个字节（长度为7），接下来7个字节是属性名（”user_id”），属性值长度4个字节（长度为8），属性值8个字节（值为123），共27字节 第四行：序号4个字节（3表示第三个属性），属性长度4个字节（长度为8），接下来8个字节是属性名（”user_name”），属性值长度4个字节（长度为4），属性值4个字节（值为35），共24字节 整个二进制字节流共12+29+27+24=92字节。 实际的序列化协议要考虑的细节远比这个多，例如：强类型的语言不仅要还原属性名，属性值，还要还原属性类型；复杂的对象不仅要考虑普通类型，还要考虑对象嵌套类型等。无论如何，序列化的思路都是类似的。 序列化协议要考虑什么因素？ 不管使用成熟协议xml/json，还是自定义二进制协议来序列化对象，序列化协议设计时都需要考虑以下这些因素。 解析效率：这个应该是序列化协议应该首要考虑的因素，像xml/json解析起来比较耗时，需要解析doom树，二进制自定义协议解析起来效率就很高 压缩率，传输有效性：同样一个对象，xml/json传输起来有大量的xml标签，信息有效性低，二进制自定义协议占用的空间相对来说就小多了 扩展性与兼容性：是否能够方便的增加字段，增加字段后旧版客户端是否需要强制升级，都是需要考虑的问题，xml/json和上面的二进制协议都能够方便的扩展 可读性与可调试性：这个很好理解，xml/json的可读性就比二进制协议好很多 跨语言：上面的两个协议都是跨语言的，有些序列化协议是与开发语言紧密相关的，例如dubbo的序列化协议就只能支持Java的RPC调用 通用性：xml/json非常通用，都有很好的第三方解析库，各个语言解析起来都十分方便，上面自定义的二进制协议虽然能够跨语言，但每个语言都要写一个简易的协议客户端 有哪些常见的序列化方式？ xml/json：解析效率，压缩率都较差，扩展性、可读性、通用性较好 thrift protobuf：Google出品，必属精品，各方面都不错，强烈推荐，属于二进制协议，可读性差了点，但也有类似的to-string协议帮助调试问题 Avro CORBA mc_pack：懂的同学就懂，不懂的就不懂了，09年用过，传说各方面都超越protobuf，懂行的同学可以说一下现状 … RPC-client除了： 序列化反序列化的部分（上图中的1、4） 还包含： 发送字节流与接收字节流的部分（上图中的2、3） 这一部分，又分为同步调用与异步调用两种方式，下面一一来进行介绍。 画外音：搞通透RPC-client确实不容易。 同步调用的代码片段为： Result = Add(Obj1, Obj2);// 得到Result之前处于阻塞状态 异步调用的代码片段为： Add(Obj1, Obj2, callback);// 调用后直接返回，不等结果 处理结果通过回调为： callback(Result){// 得到处理结果后会调用这个回调函数 ​ … } 这两类调用，在RPC-client里，实现方式完全不一样。 RPC-client同步调用架构如何？ 所谓同步调用，在得到结果之前，一直处于阻塞状态，会一直占用一个工作线程，上图简单的说明了一下组件、交互、流程步骤： 左边大框，代表了调用方的一个工作线程 左边粉色中框，代表了RPC-client组件 右边橙色框，代表了RPC-server 蓝色两个小框，代表了同步RPC-client两个核心组件，序列化组件与连接池组件 白色的流程小框，以及箭头序号1-10，代表整个工作线程的串行执行步骤： 1）业务代码发起RPC调用： Result=Add(Obj1,Obj2) 2）序列化组件，将对象调用序列化成二进制字节流，可理解为一个待发送的包packet1； 3）通过连接池组件拿到一个可用的连接connection； 4）通过连接connection将包packet1发送给RPC-server； 5）发送包在网络传输，发给RPC-server； 6）响应包在网络传输，发回给RPC-client； 7）通过连接connection从RPC-server收取响应包packet2； 8）通过连接池组件，将conneciont放回连接池； 9）序列化组件，将packet2范序列化为Result对象返回给调用方； 10）业务代码获取Result结果，工作线程继续往下走； 画外音：请对照架构图中的1-10步骤阅读。 连接池组件有什么作用？ RPC框架锁支持的负载均衡、故障转移、发送超时等特性，都是通过连接池组件去实现的。 典型连接池组件对外提供的接口为： int ConnectionPool::init(…); Connection ConnectionPool::getConnection(); int ConnectionPool::putConnection(Connection t); init做了些什么？ 和下游RPC-server（一般是一个集群），建立N个tcp长连接，即所谓的连接“池”。 getConnection做了些什么？ 从连接“池”中拿一个连接，加锁（置一个标志位），返回给调用方。 putConnection做了些什么？ 将一个分配出去的连接放回连接“池”中，解锁（也是置一个标志位）。 如何实现负载均衡？ 连接池中建立了与一个RPC-server集群的连接，连接池在返回连接的时候，需要具备随机性。 如何实现故障转移？ 连接池中建立了与一个RPC-server集群的连接，当连接池发现某一个机器的连接异常后，需要将这个机器的连接排除掉，返回正常的连接，在机器恢复后，再将连接加回来。 如何实现发送超时？ 因为是同步阻塞调用，拿到一个连接后，使用带超时的send/recv即可实现带超时的发送和接收。 总的来说，同步的RPC-client的实现是相对比较容易的，序列化组件、连接池组件配合多工作线程数，就能够实现。 遗留问题，工作线程数设置为多少最合适？ 这个问题在《工作线程数究竟要设置为多少最合适？》中讨论过，此处不再深究。 RPC-client异步回调架构如何？ 所谓异步回调，在得到结","date":"2021-08-31","objectID":"/microsvc-rpc-axiom/:2:0","tags":["Microservices","RPC"],"title":"微服务RPC原理与好处","uri":"/microsvc-rpc-axiom/"},{"categories":["Back"],"content":"记录IDEA启动项目报错 Command line is too long的解决办法","date":"2021-08-31","objectID":"/java-shorten-command-line-for-error/","tags":["Java","Idea","Error"],"title":"IDEA启动项目报错 Command line is too long","uri":"/java-shorten-command-line-for-error/"},{"categories":["Back"],"content":"报错 在Intell IDEA运行main函数的时候遇到了如下错误： Error running' xxxxxx': Command line is too long. Shorten command line for xxxxxxxxx1 ","date":"2021-08-31","objectID":"/java-shorten-command-line-for-error/:1:0","tags":["Java","Idea","Error"],"title":"IDEA启动项目报错 Command line is too long","uri":"/java-shorten-command-line-for-error/"},{"categories":["Back"],"content":"解决 ","date":"2021-08-31","objectID":"/java-shorten-command-line-for-error/:2:0","tags":["Java","Idea","Error"],"title":"IDEA启动项目报错 Command line is too long","uri":"/java-shorten-command-line-for-error/"},{"categories":["Back"],"content":"SpringBoot(Configuration) 在Run-\u003e Edit Configuration中修改红色画圈部分，选择如下选项图中红色画圈的部分即可： ","date":"2021-08-31","objectID":"/java-shorten-command-line-for-error/:2:1","tags":["Java","Idea","Error"],"title":"IDEA启动项目报错 Command line is too long","uri":"/java-shorten-command-line-for-error/"},{"categories":["Back"],"content":"其他工程（Junit Configuration） 在该项目文件夹.idea/workspace.xml中找到 \u003ccomponent name=\"PropertiesComponent\"\u003e ... \u003c/component\u003e 然后在其中添加: \u003cproperty name=\"dynamic.classpath\" value=\"true\" /\u003e 问题得到解决。 ","date":"2021-08-31","objectID":"/java-shorten-command-line-for-error/:2:2","tags":["Java","Idea","Error"],"title":"IDEA启动项目报错 Command line is too long","uri":"/java-shorten-command-line-for-error/"},{"categories":["SoftwareDesign","note"],"content":"记录Surrogate Pair的笔记和相关示例","date":"2021-08-31","objectID":"/surrogate-pair-note/","tags":["Code","UTF","UTF-16"],"title":"Surrogate Pair笔记","uri":"/surrogate-pair-note/"},{"categories":["SoftwareDesign","note"],"content":"引言 Surrogate Pair是UTF-16中用于扩展字符而使用的编码方式，是一种采用四个字节(两个UTF-16编码)来表示一个字符。 中文名 代理对 外文名 surrogate pair ","date":"2021-08-31","objectID":"/surrogate-pair-note/:1:0","tags":["Code","UTF","UTF-16"],"title":"Surrogate Pair笔记","uri":"/surrogate-pair-note/"},{"categories":["SoftwareDesign","note"],"content":"概述 在UTF-16中，在范围U+0000到U+FFFF间的码点使用一个单一的16位编码单元表示。但是，随着国际字符的不断增加，16位编码空间无法满足编码的要求。 UNICODE标准组织UTF-16优化了基本多语言平面(BMP, Basic Multilingual Plane)中字符的表示，即位于U+0000到U+FFFF范围内的字符。该范围包含了世界上所使用的书写系统中的绝大多数字符，每个字符只需要一 个16位的编码单元。对于基本多语言平面，UTF-16可作为固定宽度的编码格式来有效使用。 但对于增补字符，UTF-16需要两个16位的编码单元，意味着正式的UTF-16是一个变宽的编码格式。就在范围U+10000到U+10FFFF间的编码则使用一对16位编码单元表示，称作代理对(surrogate pair)。 UTF-16是早期Unicode遗留下的历史产物，原本被设计成具有固定宽度的16位编码格式。为支持超过U+FFFF的增补字符，设立了代理机制。 ","date":"2021-08-31","objectID":"/surrogate-pair-note/:2:0","tags":["Code","UTF","UTF-16"],"title":"Surrogate Pair笔记","uri":"/surrogate-pair-note/"},{"categories":["SoftwareDesign","note"],"content":"编码规则 在BMP内的字符，仍然按照UTF-16的编码规则，使用两个字符来表示。 [1] （注：BMP内的字符编码，不包含从U+D800到U+DFFF的预留码位。这些预留码位就恰好用于扩展字符编码） 增补字符的编码值已经超过了BMP的编码范围，所以，需要使用一对UTF-16字符来表示一个字符。UTF-16编码以16位无符号整数为单位。我们把Unicode编码记作U。编码规则如下： 如果U\u003c0x10000，U的UTF-16编码就是U对应的16位无符号整数。 如果U≥0x10000， 我们先计算U’=U-0x10000， 然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx， U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。 这两个字符就称为surrogate pair（代理对）。第一个代理字符为16位编码，范围为U+D800到U+DFFF，第二个代理字符也是一个16位编码，范围为U+DC00 to U+DFFF。 ","date":"2021-08-31","objectID":"/surrogate-pair-note/:3:0","tags":["Code","UTF","UTF-16"],"title":"Surrogate Pair笔记","uri":"/surrogate-pair-note/"},{"categories":["Back","note"],"content":"记录Maven的笔记","date":"2021-08-31","objectID":"/maven-note/","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Transitive Dependencies（Maven依赖可传递性） 这里是官网地址，本人英语渣渣，依靠翻译软件勉勉强强看懂，就不翻译出来班门弄斧了，请大家八仙过海各显神通 Maven avoids the need to discover and specify the libraries that your own dependencies require by including transitive dependencies automatically. This feature is facilitated by reading the project files of your dependencies from the remote repositories specified. In general, all dependencies of those projects are used in your project, as are any that the project inherits from its parents, or from its dependencies, and so on. There is no limit to the number of levels that dependencies can be gathered from. A problem arises only if a cyclic dependency is discovered. With transitive dependencies, the graph of included libraries can quickly grow quite large. For this reason, there are additional features that limit which dependencies are included: Dependency mediation - this determines what version of an artifact will be chosen when multiple versions are encountered as dependencies. Maven picks the “nearest definition”. That is, it uses the version of the closest dependency to your project in the tree of dependencies. You can always guarantee a version by declaring it explicitly in your project’s POM. Note that if two dependency versions are at the same depth in the dependency tree, the first declaration wins. “nearest definition” means that the version used will be the closest one to your project in the tree of dependencies. Consider this tree of dependencies: A ├── B │ └── C │ └── D 2.0 └── E └── D 1.0 In text, dependencies for A, B, and C are defined as A -\u003e B -\u003e C -\u003e D 2.0 and A -\u003e E -\u003e D 1.0, then D 1.0 will be used when building A because the path from A to D through E is shorter. You could explicitly add a dependency to D 2.0 in A to force the use of D 2.0, as shown here: A ├── B │ └── C │ └── D 2.0 ├── E │ └── D 1.0 │ └── D 2.0 Dependency management - this allows project authors to directly specify the versions of artifacts to be used when they are encountered in transitive dependencies or in dependencies where no version has been specified. In the example in the preceding section a dependency was directly added to A even though it is not directly used by A. Instead, A can include D as a dependency in its dependencyManagement section and directly control which version of D is used when, or if, it is ever referenced. Dependency scope - this allows you to only include dependencies appropriate for the current stage of the build. This is described in more detail below. Excluded dependencies - If project X depends on project Y, and project Y depends on project Z, the owner of project X can explicitly exclude project Z as a dependency, using the “exclusion” element. Optional dependencies - If project Y depends on project Z, the owner of project Y can mark project Z as an optional dependency, using the “optional” element. When project X depends on project Y, X will depend only on Y and not on Y’s optional dependency Z. The owner of project X may then explicitly add a dependency on Z, at her option. (It may be helpful to think of optional dependencies as “excluded by default.\") Although transitive dependencies can implicitly include desired dependencies, it is a good practice to explicitly specify the dependencies your source code uses directly. This best practice proves its value especially when the dependencies of your project change their dependencies. For example, assume that your project A specifies a dependency on another project B, and project B specifies a dependency on project C. If you are directly using components in project C, and you don’t specify project C in your project A, it may cause build failure when project B suddenly updates/removes its dependency on project C. Another reason to directly specify dependencies is that it provides better documentation for your project: one can learn more information by just reading the POM file in your project, or by executing mvn dependency:tree. Maven also provides dependency:analyze plug","date":"2021-08-31","objectID":"/maven-note/:1:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Maven的六类属性，${project.basedir}，${project.build.directory} ","date":"2021-08-31","objectID":"/maven-note/:2:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"内置属性 主要有两个常用内置属性：basedir项目的根目录(包含pom.xml文件的目录)，{version}项目版本 ","date":"2021-08-31","objectID":"/maven-note/:2:1","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"POM属性 用户可以使用该属性引用POM文件中对应元素的值，常用的POM属性包括： ${project.build.sourceDirectory}：项目的主源码目录，默认为 src/main/java ${project.build.testSourceDirectory}：项目的测试源码目录，默认为 src/test/java ${project.build.directory}：项目构件输出目录，默认为 target/ ${project.outputDirectory}：项目主代码编译输出目录，默认为 target/classes/ ${project.testOutputDirectory}：项目测试代码编译输出目录，默认为 target/test-classes/ ${project.groupId}：项目的 groupId ${project.artifactId}：项目的 artifactId project.version：项目的version，与{version}等价 *project.build.fianlName：*项目打包输出文件的名称。默认为{project.artifactId}-${project.version} ","date":"2021-08-31","objectID":"/maven-note/:2:2","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"自定义属性 用户可以在POM的元素下自定义Maven属性 ","date":"2021-08-31","objectID":"/maven-note/:2:3","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Settings属性 用户使用settings.开头的属性引用 settings.xml 文件中XML元素的值 ","date":"2021-08-31","objectID":"/maven-note/:2:4","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Java系统属性 所有Java系统属性都可以使用Maven属性引用 ","date":"2021-08-31","objectID":"/maven-note/:2:5","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"环境变量属性 所有环境变量都可以使用以env.开头的Maven属性引用 ","date":"2021-08-31","objectID":"/maven-note/:2:6","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"在依赖中 使用pom变量 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003e${project.groupId}\u003c/groupId\u003e \u003cartifactId\u003epart-a\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003e${project.groupId}\u003c/groupId\u003e \u003cartifactId\u003epart-b\u003c/artifactId\u003e \u003cversion\u003e${project-version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 123456789101112 ","date":"2021-08-31","objectID":"/maven-note/:2:7","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"在插件中使用pom变量 \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003cconfiguration\u003e \u003crepositoryDirectory\u003e${project.build.directory}/test-reports\u003c/repositoryDirectory\u003e \u003c/configuration\u003e \u003c/plugin\u003e 12345678 ","date":"2021-08-31","objectID":"/maven-note/:2:8","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"自定义变量 \u003cproperties\u003e \u003cdb.driver\u003ecom.mysql.jdbc.Driver\u003c/db.driver\u003e \u003cdb.url\u003ejdbc:mysql://localhost:3360/test\u003c/db.url\u003e \u003cdb.username\u003eusername\u003c/db.username\u003e \u003cdb.password\u003epassword\u003e\u003c/db.password\u003e \u003c/properties\u003e \u003c/profiles\u003e 1234567 Maven属性默认只有在POM中才会被解析，因此需要让Maven解析资源文件中的Maven属性。Maven用maven-resources-plugin处理资源文件。它默认的行为只是将项目主资源文件复制到主代码编译输出目录中，将测试资源文件复制到测试代码编译输出目录中。 Maven默认的主资源目录和测试资源目录的定义是在超级POM中，要为资源目录开启过滤，只要在此基础上添加一行filtering配置即可。 Filtering是maven resource插件的功能，作用是用环境变量，pom文件里定义的属性和指定文件里的属性替换属性文件的占位符。（超级pom在 apache-maven-3.3.9\\lib\\maven-model-builder-3.3.9.jar\\org\\apache\\maven\\model\\pom-4.0.0.xml） ","date":"2021-08-31","objectID":"/maven-note/:2:9","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"resource元素的作用 ","date":"2021-08-31","objectID":"/maven-note/:3:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"子工程获取父工程路径 尝试在每个pom中设置属性以查找主项目目录。 在父级： \u003cproperties\u003e \u003cmain.basedir\u003e${project.basedir}\u003c/main.basedir\u003e \u003c/properties\u003e 在子元素们身上： \u003cproperties\u003e \u003cmain.basedir\u003e${project.parent.basedir}\u003c/main.basedir\u003e \u003c/properties\u003e 在孙辈中： \u003cproperties\u003e \u003cmain.basedir\u003e${project.parent.parent.basedir}\u003c/main.basedir\u003e \u003c/properties\u003e 注意 由于maven插件的生命周期原因，传递给子模块basedir属性为子模块属性，类似懒加载，传递至子目录才读取值，故需要添加parent，且忽略编译异常。此属性禁止在父POM工程中使用，仅允许传递给子模块使用。 \u003cjar.target\u003eD:/tmp/target\u003c/jar.target\u003e \u003c!--suppress UnresolvedMavenProperty --\u003e \u003cjar.target\u003e${project.parent.basedir}/target/\u003c/jar.parent.target\u003e \u003c!--suppress UnresolvedMavenProperty --\u003e \u003cjar.target1\u003e${project.parent.parent.basedir}/target/\u003c/jar.parent2.target\u003e 在这篇文章中有详细的例子 其他方式方法未验证，中文参考，英文参考 ","date":"2021-08-31","objectID":"/maven-note/:4:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"打包过程排除文件夹 排除的文件夹位置src/main/dml \u003cexcludes\u003e \u003cexclude\u003edml/**\u003c/exclude\u003e \u003c/excludes\u003e **注意：**避免使用\u003cexclude\u003esrc/main/dml/**\u003c/exclude\u003e会导致找不到 ","date":"2021-08-31","objectID":"/maven-note/:5:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Windows环境下maven 安装与环境变量配置 Maven是一个项目管理的Java 工具，在JavaEE中，我们可以使用Maven方便地管理团队合作的项目，现在我们在学习JavaEE框架，使用Maven可以管理类库，有效方便地供团队中的其他人员使用。 ","date":"2021-08-31","objectID":"/maven-note/:6:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"一、下载 Maven 请访问Maven的下载页面：http://maven.apache.org/download.html，其中包含针对不同平台的各种版本的Maven下载文件。 注意： 我这里下载的是：apache-maven-3.3.9-bin.zip 版本。 ","date":"2021-08-31","objectID":"/maven-note/:6:1","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"二、解压 maven 压缩包。 解压apache-maven-3.1.1-bin.zip，并把解压后的文件夹下的apache-maven-3.1.1文件夹移动到E:\\Maven 下，如果没有Maven 这个文件夹的话，请自行创建。 ","date":"2021-08-31","objectID":"/maven-note/:6:2","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"三、配置maven 的环境变量 右键“计算机”，选择“属性”，之后点击“高级系统设置”，点击“环境变量”，来设置环境变量，有以下系统变量需要配置： 新建系统变量 MAVEN_HOME 变量值： E:\\Maven\\apache-maven-3.3.9 编辑系统变量 Path 添加变量值： ;%MAVEN_HOME%\\bin 注意：注意多个值之间需要有分号隔开，然后点击确定。 ","date":"2021-08-31","objectID":"/maven-note/:6:3","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"四、检测是否安装成功。 最后检验配置是否成功：用win键+R，来打开命令行提示符窗口，即Dos界面，输入mvn --version若出现以下情况说明配置成功 或是输入：echo %M2_HOME% 查看版本：mvn -v ","date":"2021-08-31","objectID":"/maven-note/:6:4","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"五、升级。 Maven还比较年轻，更新比较频繁，因此用户往往会需要更新Maven安装以获得更多更酷的新特性，以及避免一些旧的bu 只需要按照上面的配置过程换成新的包即可。 ","date":"2021-08-31","objectID":"/maven-note/:6:5","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"Maven配置阿里镜像仓库 打开maven的配置文件(windows机器一般在maven安装目录的conf/settings.xml)，在\u003cmirrors\u003e\u003c/mirrors\u003e标签中添加mirror子节点： \u003cmirror\u003e \u003cid\u003ealiyunmaven\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003e阿里云公共仓库\u003c/name\u003e \u003curl\u003ehttps://maven.aliyun.com/repository/public\u003c/url\u003e \u003c/mirror\u003e ","date":"2021-08-31","objectID":"/maven-note/:7:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Back","note"],"content":"修改本地仓库的路径 另外最好修改本地仓库的路径，否则默认存储在C盘，容易占用过多。 在\u003csettings\u003e\u003c/settings\u003e标签中添加localRepository子节点： \u003clocalRepository\u003eD:\\repository\u003c/localRepository\u003e ","date":"2021-08-31","objectID":"/maven-note/:8:0","tags":["Package","Maven"],"title":"Maven笔记","uri":"/maven-note/"},{"categories":["Front","note"],"content":"记录Vue开发的笔记","date":"2021-08-30","objectID":"/vue-note/","tags":["Vue"],"title":"Vue笔记","uri":"/vue-note/"},{"categories":["Front","note"],"content":"将vue文档下载到本地预览 1下载：https://github.com/vuejs/cn.vuejs.org 到本地 2.执行指令 npm install npm start # 开发服务器地址为 http://localhost:4000 3.访问http://localhost:4000即可 ","date":"2021-08-30","objectID":"/vue-note/:1:0","tags":["Vue"],"title":"Vue笔记","uri":"/vue-note/"},{"categories":["Operation"],"content":"记录Win10该设备正在使用中报错的解决办法","date":"2021-08-30","objectID":"/win10-usb-in-use-error/","tags":["Windows","Windows10","Error"],"title":"Win10该设备正在使用中报错","uri":"/win10-usb-in-use-error/"},{"categories":["Operation"],"content":"方法一 我反正不行，搜索结果为空 电脑弹出USB设备时提示该设备正在使用，虽然在正常显示时并没有程序在使用，但是确实会出现这种情况，实际上确实有自动启动的软件占用USB设备，可以通过下面的步骤查找该软件 1、任务管理器-性能-打开资源监视器 2、资源监视器窗口中：CPU-关联的句柄，搜索框里面输入USB设备所属磁盘如“K：”，可以查看到占用USB设备的软件，右键-结束进程，就可以拔出USB设备了。 ","date":"2021-08-30","objectID":"/win10-usb-in-use-error/:1:0","tags":["Windows","Windows10","Error"],"title":"Win10该设备正在使用中报错","uri":"/win10-usb-in-use-error/"},{"categories":["Operation"],"content":"方法二 基本没用过 重启，比较扯的方法弊病很多，但是相对安全 ","date":"2021-08-30","objectID":"/win10-usb-in-use-error/:2:0","tags":["Windows","Windows10","Error"],"title":"Win10该设备正在使用中报错","uri":"/win10-usb-in-use-error/"},{"categories":["Operation"],"content":"方法三 一般用这个 win+x，选磁盘管理器，脱机相关磁盘。 然后挂载，就可以正常安全退出了 ","date":"2021-08-30","objectID":"/win10-usb-in-use-error/:3:0","tags":["Windows","Windows10","Error"],"title":"Win10该设备正在使用中报错","uri":"/win10-usb-in-use-error/"},{"categories":["Operation"],"content":"方法四 我的某个电脑并不能解除完退出 某些安全软件可以解除占用退出 ","date":"2021-08-30","objectID":"/win10-usb-in-use-error/:4:0","tags":["Windows","Windows10","Error"],"title":"Win10该设备正在使用中报错","uri":"/win10-usb-in-use-error/"},{"categories":["Operation","note"],"content":"记录Linux硬件相关的笔记","date":"2021-08-30","objectID":"/linux-hardware-note/","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"CentOs7排查CPU高占用 ","date":"2021-08-30","objectID":"/linux-hardware-note/:1:0","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"一、查看CPU高占用 ## 执行top命令 top PS:P按照CPU排序显示，M按照内存排序； ","date":"2021-08-30","objectID":"/linux-hardware-note/:1:1","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"二、查看进程中最占CPU的线程 # top中最高占用CPU的PID top -p 24212 -H ","date":"2021-08-30","objectID":"/linux-hardware-note/:1:2","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"三、最耗CPU的线程PID转换为16进制输出 printf \"%x \\n\" 24213 ","date":"2021-08-30","objectID":"/linux-hardware-note/:1:3","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"四、查看高占用CPU具体问题 # jstack 进程pid | grep 线程pid jstack 24212| grep 5e95 -A 30 ","date":"2021-08-30","objectID":"/linux-hardware-note/:1:4","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"查看Linux硬件信息 ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:0","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"CPU lscpu命令，查看的是CPU的统计信息. blue@blue-pc:~$ lscpu Architecture: i686 #cpu架构 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian #小尾序 CPU(s): 4 #总共有4核 On-line CPU(s) list: 0-3 Thread(s) per core: 1 #每个cpu核，只能支持一个线程，即不支持超线程 Core(s) per socket: 4 #每个cpu，有4个核 Socket(s): 1 #总共有1一个cpu Vendor ID: GenuineIntel #cpu产商 intel CPU family: 6 Model: 42 Stepping: 7 CPU MHz: 1600.000 BogoMIPS: 5986.12 Virtualization: VT-x #支持cpu虚拟化技术 L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 6144K 查看/proc/cpuinfo,可以知道每个CPU信息，如每个CPU的型号，主频等。 #cat /proc/cpuinfo processor : 0 vendor_id : GenuineIntel cpu family : 6 model : 42 model name : Intel(R) Core(TM) i5-2320 CPU @ 3.00GHz ..... 上面输出的是第一个CPU部分信息，还有3个CPU信息省略了。 ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:1","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"内存 概要查看内存情况 free -m total used free shared buffers cached Mem: 3926 3651 274 0 12 404 -/+ buffers/cache: 3235 691 Swap: 9536 31 9505 这里的单位是MB，总共的内存是3926MB。 查看内存详细使用 # cat /proc/meminfo MemTotal: 4020868 kB MemFree: 230884 kB Buffers: 7600 kB Cached: 454772 kB SwapCached: 836 kB ..... 查看内存硬件信息 dmidecode -t memory # dmidecode 2.11 SMBIOS 2.7 present. Handle 0x0008, DMI type 16, 23 bytes Physical Memory Array Location: System Board Or Motherboard .... Maximum Capacity: 32 GB .... Handle 0x000A, DMI type 17, 34 bytes .... Memory Device Array Handle: 0x0008 Error Information Handle: Not Provided Total Width: 64 bits Data Width: 64 bits Size: 4096 MB ..... 我的主板有4个槽位，只用了一个槽位，上面插了一条4096MB的内存。 ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:2","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"磁盘 查看硬盘和分区分布 # lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 465.8G 0 disk ├─sda1 8:1 0 1G 0 part /boot ├─sda2 8:2 0 9.3G 0 part [SWAP] ├─sda3 8:3 0 74.5G 0 part / ├─sda4 8:4 0 1K 0 part ├─sda5 8:5 0 111.8G 0 part /home └─sda6 8:6 0 269.2G 0 part 显示很直观 如果要看硬盘和分区的详细信息 # fdisk -l Disk /dev/sda: 500.1 GB, 500107862016 bytes 255 heads, 63 sectors/track, 60801 cylinders, total 976773168 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk identifier: 0x00023728 Device Boot Start End Blocks Id System /dev/sda1 * 2048 2148351 1073152 83 Linux /dev/sda2 2148352 21680127 9765888 82 Linux swap / Solaris /dev/sda3 21680128 177930239 78125056 83 Linux /dev/sda4 177932286 976771071 399419393 5 Extended/dev/sda5 177932288 412305407 117186560 83 Linux /dev/sda6 412307456 976771071 282231808 83 Linux ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:3","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"网卡 查看网卡硬件信息 # lspci | grep -i 'eth' 02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 06) 查看系统的所有网络接口 # ifconfig -a eth0 Link encap:以太网 硬件地址 b8:97:5a:17:b3:8f ..... lo Link encap:本地环回 ..... 或者是 ip link show 1: lo: \u003cLOOPBACK\u003e mtu 16436 qdisc noqueue state DOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether b8:97:5a:17:b3:8f brd ff:ff:ff:ff:ff:ff 如果要查看某个网络接口的详细信息，例如eth0的详细参数和指标 # ethtool eth0 Settings for eth0: Supported ports: [ TP MII ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Half 1000baseT/Full #支持千兆半双工，全双工模式 Supported pause frame use: No Supports auto-negotiation: Yes #支持自适应模式，一般都支持 Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Half 1000baseT/Full Advertised pause frame use: Symmetric Receive-only Advertised auto-negotiation: Yes #默认使用自适应模式 Link partner advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full ..... Speed: 100Mb/s #现在网卡的速度是100Mb,网卡使用自适应模式，所以推测路由是100Mb，导致网卡从支持千兆，变成要支持百兆 Duplex: Full #全双工 ..... Link detected: yes #表示有网线连接，和路由是通的 ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:4","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation","note"],"content":"其他 查看pci信息，即主板所有硬件槽信息 lspci 00:00.0 Host bridge: Intel Corporation 2nd Generation Core Processor Family DRAM Controller (rev 09) #主板芯片 00:02.0 VGA compatible controller: Intel Corporation 2nd Generation Core Processor Family Integrated Graphics Controller (rev 09) #显卡 00:14.0 USB controller: Intel Corporation Panther Point USB xHCI Host Controller (rev 04) #usb控制器 00:16.0 Communication controller: Intel Corporation Panther Point MEI Controller #1 (rev 04) 00:1a.0 USB controller: Intel Corporation Panther Point USB Enhanced Host Controller #2 (rev 04) 00:1b.0 Audio device: Intel Corporation Panther Point High Definition Audio Controller (rev 04) #声卡 00:1c.0 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 1 (rev c4) #pci 插槽 00:1c.2 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 3 (rev c4) 00:1c.3 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 4 (rev c4) 00:1d.0 USB controller: Intel Corporation Panther Point USB Enhanced Host Controller #1 (rev 04) 00:1f.0 ISA bridge: Intel Corporation Panther Point LPC Controller (rev 04) 00:1f.2 IDE interface: Intel Corporation Panther Point 4 port SATA Controller [IDE mode] (rev 04) #硬盘接口 00:1f.3 SMBus: Intel Corporation Panther Point SMBus Controller (rev 04) 00:1f.5 IDE interface: Intel Corporation Panther Point 2 port SATA Controller [IDE mode] (rev 04) #硬盘接口 02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 06) #网卡 03:00.0 PCI bridge: Integrated Technology Express, Inc. Device 8893 (rev 41) 如果要更详细的信息:lspci -v 或者 lspci -vv 如果要看设备树:lscpi -t 查看bios信息 # dmidecode -t bios ...... BIOS Information Vendor: American Megatrends Inc. Version: 4.6.5 Release Date: 04/25/2012 ....... BIOS Revision: 4.6 ...... dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。 如果要查看所有有用信息 dmidecode -q 里面包含了很多硬件信息。 ","date":"2021-08-30","objectID":"/linux-hardware-note/:2:5","tags":["Linux","HardWare"],"title":"Linux硬件相关笔记","uri":"/linux-hardware-note/"},{"categories":["Operation"],"content":"记录Win10启动蓝屏报错BAD_SYSTEM_CONFIG的解决办法","date":"2021-08-30","objectID":"/win10-bad-system-config-error/","tags":["Windows","Windows10","Error"],"title":"Win10启动蓝屏报错BAD_SYSTEM_CONFIG","uri":"/win10-bad-system-config-error/"},{"categories":["Operation"],"content":"原因 本人Win10虚拟机突然启动不起来了，蓝屏报错BAD_SYSTEM_CONFIG，遂检索寻找方法。 发现方法作用于实体机，故尝试，终成功，并撰写笔记记录 ","date":"2021-08-30","objectID":"/win10-bad-system-config-error/:1:0","tags":["Windows","Windows10","Error"],"title":"Win10启动蓝屏报错BAD_SYSTEM_CONFIG","uri":"/win10-bad-system-config-error/"},{"categories":["Operation"],"content":"情况 电脑开启后出现了几个选项 进入高级选项 启动修复：发现修复不了，无限蓝屏重启，然后我打算进入安全模式看看，高级选项中有个启动设置，在启动设置里面我选择带网络链接的安全模式，然后无用~ 卸载预览更新：我想我是因为安装影子系统造成的，那我把影子软件卸载了不就好了吗？然后尝试了下不让你执行卸载操作，通过黑窗口进入影子软件安装所在目录，删除文件同样不行，因为系统文件已经损坏，再删也没用~ 系统还原：这个有人成功的，但是我失败了因为我之前没有设置还原点（没备份自然不能还原）~ 重置电脑：没办法了我只能重置了，我选择保留文件重置，删除所有文件就太狠了（如果你电脑没啥东西且下面方法你都试过了，我觉得你可以这样操作），毕竟电脑里面很多有用的东西，重置到50%时候失败了，这个时候我想起来无限蓝屏时候有提示一行终止代码：BAD_SYSTEM_CONFIG 意思是坏的系统配置文件，这个时候我知道系统文件损坏造成的，我估计影子系统对我电脑干了啥或者我关机操作不当造成的，当下只有这个原因了，系统这么强大，更加坚定了不重装系统就能恢复的信念（出去怕传染）~ ","date":"2021-08-30","objectID":"/win10-bad-system-config-error/:2:0","tags":["Windows","Windows10","Error"],"title":"Win10启动蓝屏报错BAD_SYSTEM_CONFIG","uri":"/win10-bad-system-config-error/"},{"categories":["Operation"],"content":"解决 命令提示符☆：点击命令提示符进入黑窗口操作——找到系统文件所在，因为电脑恢复了所以那个窗口找不回来了，操作是一样的,看操作。 输入每行命令就点回车，表示执行此命令 第一步(切换到C盘)：输入c: 打开窗口我们看到的是X:,不碍事，输入就好 第二步（进入系统文件所在目录）：输入cd Windows\\System32\\config cd是进入目录的指令 cd … 是返回上一级目录（记住） 可以查看config文件里面有啥，输入dir 标了颜色的五个文件是系统相关文件，有人说是绿色的，有人说是黄色的，还有人说是褐色的。。。 别说话，你暴露了~ 根据单词可以大概知道这些文件是什么相关的 这时候你发现有一个文件夹Regback 根据单词大概知道有还原意思，好进入看看 输入:cd Regback 输入：dir 这里有分歧了。。 是不是有的人RegBack里面包含了上面标了颜色的五个文件，那么恭喜你，你直接将RegBack里面的五个文件把config里面的替换掉即可，具体操作如下(提示是否替换，输入Y即可替换，注意一定要进入RegBack目录)： 因为楼主RegBack里面没有文件，所以系统找不到，你们有的输入Y替换即可。。 替换好了，退出 有人直接点X退出，能不能逼格高一点。。。 输入：exit 回车 重启电脑 ============================================= 说说RegBack中没有文件怎么办（我就没有，心塞！） 针对终止代码为：BAD_SYSTEM_CONFIG的网络上的办法最实用的是通过高级选项中命令指示符操作，在dos黑窗口中通过指令操作将Regback中的五个文件把config中的替换掉（上面操作），如果没有这些文件只能重装系统了，毕竟咱们能看到的高级选项就那几个，玩不出什么花来~ 但是楼主觉得win10系统应该很牛逼，所以打算再试试（出去怕传染） 现在基本上确定是系统文件损坏，在不重装系统的情况下我只能把文件修复，操作文件先做好备份不要把文件搞没了。。 第一步：在config目录下创建文件夹 输入：md ss 将config里面的五个文件复制到ss文件夹中（操作类似上面） 输入：copy DEFAULT ss … 源文件已经备份，随便玩吧！ ============================================= 说说config中没有文件怎么办（我还是没有，心塞+1！） 大概有两个方法： 一：我让朋把他的系统文件（win10）发给我，我再通过U盘设备传到电脑上 问题1：设备连接上电脑后，无法显示，所以无法完成文件替换操作，原因不明 问题2：朋友因为系统正常使用，文件使用中无法操作，所以需要重启进入高级选项在命令指示符中将系统文件复制到磁盘中再传给我，我怕朋友打我，太麻烦~ 二：只能依赖系统的自动修复了 但是之前就修复失败，于是我对五个系统文件进行尝试，反正都损坏而且备份了 我将五个文件进行删除操作，文件出错无法修复，干脆破罐子破摔直接删了，我看系统能不能有点作用~ 在config目录中输入：del 文件名 五个文件，一个一个试，无效果我再把分到ss文夹下的文件还原到config中即可 从ss中还原文件 我进行不停地删文件即还原操作之后再进行系统修复（总共就五个文件，主要是自动修复和重置电脑费时间），然后我重置电脑（保留文件），成功了，c盘清理掉了，系统还原到初始，其他正常使用！ 最终删除了default，使用系统还原到初始成功救活虚拟机 ","date":"2021-08-30","objectID":"/win10-bad-system-config-error/:3:0","tags":["Windows","Windows10","Error"],"title":"Win10启动蓝屏报错BAD_SYSTEM_CONFIG","uri":"/win10-bad-system-config-error/"},{"categories":["Operation"],"content":"总结 RegBack中有文件的基本上恢复没问题，系统还原也可以尝试下，而RegBack中没有文件的比如我，其实操作说的很模糊，虽然成功了，只是瞎尝试的，具体删除那个文件再修复再重启，我不确定，但是我确定的是win10自动修复可能很慢，但是是有作用的。 走投无路连重置都重置不了的你就一顿操作猛如虎吧，大不了重装系统呗，不想出去装，网上也有教学装系统的。遇到这种状况的可以花点时间自己研究下，总之电脑我自己修了一天，学的东西还挺多的，虽然不精，但是这些知识都是自己的。如果RegBack中无文件不通过重装系统也可以解决的可以留下你的宝贵意见，给大家提示下，少走弯路，心塞+n~ ","date":"2021-08-30","objectID":"/win10-bad-system-config-error/:4:0","tags":["Windows","Windows10","Error"],"title":"Win10启动蓝屏报错BAD_SYSTEM_CONFIG","uri":"/win10-bad-system-config-error/"},{"categories":["Learning","note"],"content":"记录树的笔记","date":"2021-08-30","objectID":"/datastructure-tree-note/","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"二叉树 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:1:0","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"引言 顺序表和链表的时间复杂度由给定条件不同从而会得出不同的时间复杂度结果，对于程序设计时并不总是最好用的存储方式。二叉树是一种更加稳定的数据存储方式，其复杂度总是能表示为一个固定的形式。以下来分析二叉树增删改查操作做的时间复杂度。 设有如下数据需要进行二叉树形式存储： 二叉树存储\r","date":"2021-08-30","objectID":"/datastructure-tree-note/:1:1","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"分析 首先对二叉树进行基本分析： 二叉树每层最大容纳量为2^(n-1)个； 前n行共可存储1+2+4+8+···+2^(n-1)=2^n -1个数据； 二叉树节点分布规律是：左节点\u003c父节点\u003c右节点； 由第一层延某条路径查询到最后一层的某个数据共需要查询log2（2^n）=n次； 当删除某个节点时，需要将左子树最右节点或右子树最左节点移动至被删除节点处，且被移动节点的左或右节点移至被移动节点的位置。 由上述规律归纳二叉树的时间复杂度如下（以下设总结点数为n）： 增：循环遍历每个节点，比较各节点的值，直到找到相应位置，时间复杂度为log2n，2为底数。 查：循环遍历每个节点，比较各节点的值，直到找到相应位置，时间复杂度为log2n。 改：循环遍历每个节点，比较各节点的值，直到找到相应位置，将此节点数据值改为相应值，时间复杂度为log2n。 删：循环遍历每个节点，比较各节点的值，直到找到相应位置，将左子树最右节点或右子树最左节点移动至被删除节点处，且被移动节点的左或右节点移至被移动节点的位置，时间复杂度为log2n。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:1:2","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"代码 增删改查的代码分别如下： 1.定义二叉树： public class StudentNode { public int num; public String name; public StudentNode left, right, pre; StudentNode() { pre = left = right = null; } StudentNode(int num, String name) { this.num = num; this.name = name; pre = left = right = null; } @Override public String toString() { return \"StudentNode [num=\" + num + \", name=\" + name + \", left=\" + left + \", right=\" + right + \", pre=\" + pre + \"]\"; } } 2.增：构建包含100个不等随机数的数组，并将数据插入二叉树： public static int[] randomCommon(int min, int max, int n) { if (n \u003e (max - min + 1) || max \u003c min) { return null; } int[] result = new int[n]; int count = 0; while (count \u003c n) { int num = (int) (Math.random() * (max - min)) + min; boolean flag = true; for (int j = 0; j \u003c n; j++) { if (num == result[j]) { flag = false; break; } } if (flag) { result[count] = num; count++; } } return result; } public static void insert(int num, String name, StudentNode node) { if (num \u003e node.num) { StudentNode temp = new StudentNode(num, \"我是第\" + num); if (node.right != null) { insert(num, name, node.right); } else { temp.pre = node; node.right = temp; } } else { StudentNode temp = new StudentNode(num, \"我是第\" + num); if (node.left != null) { insert(num, name, node.left); } else { temp.pre = node; node.left = temp; } } } 3.查： public static StudentNode find(StudentNode root, int num) { StudentNode point = new StudentNode(); //StudentNode copy=new StudentNode(); point = root; while (point != null) { if (num == point.num) { return point; } else if (num \u003e point.num) { if (point.right == null) { System.out.println(\"该学生不存在\"); return null; } else point = point.right; } else { if (point.left == null) { System.out.println(\"该学生不存在\"); return null; } else point = point.left; } } return null; } 4.改： public static String change(StudentNode root, int num, String name) { StudentNode point = new StudentNode(); point = root; String copy; while (point != null) { if (num == point.num) { copy = point.name; point.name = name; return \"该学生原名为\" + copy + \",现在是\" + name; } else if (num \u003e point.num) { if (point.right == null) { return \"该学生不存在\"; } else point = point.right; } else { if (point.left == null) { return \"该学生不存在\"; } else point = point.left; } } return null; } 5.删： public static String delete(StudentNode root, int num) { StudentNode find = find(root, num); StudentNode point = new StudentNode(); point = find; if (find != null) { int target_num, find_num; String target_name, find_name; find_num = find.num; find_name = find.name; if (find.left != null) { point = find.left; while (point.right != null) { point = point.right; } target_num = point.num; target_name = point.name; if (point.left != null) { point.pre.right = point.left; } find.num = target_num; find.name = target_name; return find_name + \"已删除\" + \"现在由\" + find.name + \"取代\"; } else if (find.right != null) { point = find.right; while (point.left != null) { point = point.left; } target_num = point.num; target_name = point.name; if (point.right != null) { point.pre.left = point.right; } find.num = target_num; find.name = target_name; return find_name + \"已删除\" + \"现在由\" + find.name + \"取代\"; } else { if (find == root) { find = root = null; return find_name + \"根节点已删除\"; } else if (find.num \u003c find.pre.num) { find.pre.left = null; return find_name + \"已删除\"; } else { find.pre.right = null; return find_name + \"已删除\"; } } } else { System.out.println(\"删除失败！\"); return null; } } 6.main函数： public static void main(String[] args) { // TODO Auto-generated method stub //增加 int[] arr = randomCommon(1, 101, 100); StudentNode root = new StudentNode(1, \"我是第\" + 1); root.pre = null; for (int i = 1; i \u003c arr.length; i++) { insert(arr[i], \"我是\" + arr[i], root); } //查询 StudentNode find = find(root, 53); System.out.println(find.name); //修改 String change = change(root, 53, \"小李\"); System.out.println(change); //删除 String delete = delete(root, 14); System.out.println(delete); } 二叉树是一种存储数据比较稳定的方法，其增删改查的时间复杂度均为log2n，但其原理实现较线性表更难理解，需要花更多精力去消化吸收。关键在于理解二叉树的构造形式，牢记二叉树的特点。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:1:3","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"B（B-）树，B+树，B树和B+树的区别，B树和B+树的优点 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:0","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"M阶B树（B-树）特点 一种二叉搜索树。 除根节点外的所有非叶节点至少含有（M/2（向上取整）-1）个关键字，每个节点最多有M-1个关键字，并且以升序排列。所以M阶B树的除根节点外的所有非叶节点的关键字取值区间为[M/2-1(向上取整),M-1]。 每个节点最多有M-1个关键字。 B树示例：4阶B树 下面是往B树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的演示动画： ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:1","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"M阶B+数特点 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。 通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。 B+树示例 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:2","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"B树与B+树的区别 B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。 B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 B树中每个节点（非根节点）关键字个数的范围为m/2(向上取整)-1,m-1，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为m/2(向上取整),m，具有n个关键字的节点包含（n）棵子树。 B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:3","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"B树的优点 1.B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:4","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"B+树的优点 所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 b+树的中间节点不保存数据，能容纳更多节点元素。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:5","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"B树和B+树的共同优点 考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。 ","date":"2021-08-30","objectID":"/datastructure-tree-note/:2:6","tags":["DataStructure","Algorithm","Tree","BinaryTree\""],"title":"树笔记","uri":"/datastructure-tree-note/"},{"categories":["Learning","note"],"content":"记录进程与线程的区别","date":"2021-08-30","objectID":"/system-proc-thd-diff/","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"一、进程与线程的区别： 1、根本区别：进程是操作系统资源分配的最小单位，线程是程序执行(任务调度和执行)的最小单位（资源调度的最小单位） 2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 3、对比总结： 在开销方面，每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 内存分配方面，系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 4、所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。因此多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 5、最终总结： 包含关系，没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 参考1 参考2 ","date":"2021-08-30","objectID":"/system-proc-thd-diff/:1:0","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"二、进程与线程的资源： ","date":"2021-08-30","objectID":"/system-proc-thd-diff/:2:0","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"1、堆与栈 堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此栈是threadsafe的。操作系统在切换线程的时候会自动的切换栈，就是切换ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。 ","date":"2021-08-30","objectID":"/system-proc-thd-diff/:2:1","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"2、其他 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括： 1.线程ID 每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。 2.寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。 3.线程的堆栈 堆栈是保证线程独立运行所必须的。 线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。 4.错误返回码 由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。 所以，不同的线程应该拥有自己的错误返回码变量。 5.线程的信号屏蔽码 由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。 6.线程的优先级 由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。 参考 ","date":"2021-08-30","objectID":"/system-proc-thd-diff/:2:2","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"3、进程与线程的同步 进程：无名管道、有名管道、信号、共享内存、消息队列、信号量 进程：互斥量、读写锁、自旋锁、线程信号、条件变量 ","date":"2021-08-30","objectID":"/system-proc-thd-diff/:3:0","tags":["OperationSystem","Difference"],"title":"进程与线程的区别","uri":"/system-proc-thd-diff/"},{"categories":["Learning","note"],"content":"记录计算机网络笔记的相关笔记","date":"2021-08-29","objectID":"/comp-net-note/","tags":["ComputerNet","TCP"],"title":"计算机网络笔记","uri":"/comp-net-note/"},{"categories":["Learning","note"],"content":"TCP三次握手、四次挥手的理解及面试题（图解过程） TCP 和 UDP是网络协议的传输层上的两种不同的协议。TCP的特点是面向连接的、可靠的字节流服务。客户端需要和服务器之间建立一个TCP连接，之后才能传输数据。数据到达之前对方就一直在等待，除非对方直接关闭连接，数据有序，先发先到。UDP是一种无连接、不可靠的数据发送协议。发送方根据对方的ip地址发送数据包，但是不保证接收发接包的质量，数据无序还容易丢包。虽然UDP协议不稳定但是在即时通讯（QQ聊天、在线视频、网络语音电话）的场景下，可以允许偶尔的断续，但是这种协议速度快。 TCP、UDP的报文结构 详细引用 UDP的报文结构 \r TCP的报文结构\rTCP协议三次握手、四次挥手、超时重传 通过抓包观察TCP三次握手具体报文 三次握手是指建立TCP连接协议时，需要在客户端和服务器之间发送三个包，握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 第一次握手：客户端发送第一个包，其中SYN标志位为1, ACK=0，发送顺序号sequence=X(随机int)。客户端进入SYN发送状态，等待服务器确认。 第二次握手：服务器收到这个包后发送第二个包，其中包SYN、ACK标志位为1，发送顺序号seq=Y(随机int)，接收顺序号ACK=X+1，此时服务器进入SYN接收状态。 第三次握手：客户端收到服务器传来的包后，向服务器发送第三个包，SYN=0, ACK=1，接收顺序号ACK = Y+1,发送顺序号seq=X+1。此包发送完毕，客户端和服务器进入ESTABLISHED建立成功状态，完成三次握手。 四次握手是指终止TCP连接协议时，需要在客户端和服务器之间发送四个包 第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。 第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。 第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。 第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。 超时重传指的是，发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为RTO. ","date":"2021-08-29","objectID":"/comp-net-note/:1:0","tags":["ComputerNet","TCP"],"title":"计算机网络笔记","uri":"/comp-net-note/"},{"categories":["Learning","note"],"content":"深入讨论 1、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 2、为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 两个存在的理由：1、无法保证最后发送的ACK报文会一定被对方收到，所以需要重发可能丢失的ACK报文。2、关闭链接一段时间后可能会在相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接已经终止后再现。2MSL足以让分组最多存活msl秒被丢弃。 3、为什么必须是三次握手，不能用两次握手进行连接？ ​ 记住服务器的资源宝贵不能浪费! 如果在断开连接后，第一次握手请求连接的包才到会使服务器打开连接，占用资源而且容易被恶意攻击！防止攻击的方法，缩短服务器等待时间。两次握手容易死锁。如果服务器的应答分组在传输中丢失，将不知道S建立什么样的序列号，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 ","date":"2021-08-29","objectID":"/comp-net-note/:1:1","tags":["ComputerNet","TCP"],"title":"计算机网络笔记","uri":"/comp-net-note/"},{"categories":["Learning","note"],"content":"TCP/IP五层模型和OSI网络七层协议 TCP/IP五层模型 应用层： 提供给客户端访问服务器网络服务的接口 。常用协议：HTTP、SMTP、FTP、ping、telnet、DNS、DHCP等 HTTP协议（超文本传输协议） 详见本篇博客 传输层：数据传输协议TCP 或 UDP 网络层 : 负责对数据包进行路由选择和存储转发，负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组（IP数据报）或包进行传送。 IP协议:逐跳发送模式；根据数据包的目的地IP地址决定数据如何发送；如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发 ICMP协议：因特网控制报文协议，用于检测网络连接 数据链路层： 负责分配MAC地址常用协议：地址解析协议（ARP）和反地址解析协议（RARP）,实现IP地址与机器物理地址（MAC地址）之间的转换两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。网卡接口的网络驱动程序，处理数据在物理媒介上的传输；不同的物理网络具有电气特性，网络驱动程序隐藏实现细节，为上层协议提供一致接口 **物理层:**所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。 各网络层对应的工作设备： 物理层：中继器、集线器 数据链路层：网桥或交换机 网络层中继系统：路由器 网络层以上的中继系统：网关 ","date":"2021-08-29","objectID":"/comp-net-note/:1:2","tags":["ComputerNet","TCP"],"title":"计算机网络笔记","uri":"/comp-net-note/"},{"categories":["Operation","note"],"content":"记录服务器大量TIME_WAIT和CLOSE_WAIT的原因及解决办法","date":"2021-08-29","objectID":"/server-timewait-closewait-note/","tags":["Server","Linux","Net"],"title":"服务器大量TIME_WAIT和CLOSE_WAIT","uri":"/server-timewait-closewait-note/"},{"categories":["Operation","note"],"content":"0.引言 Linux服务器下查看网络连接的状态 netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' 它会显示例如下面的信息： TIME_WAIT 814 CLOSE_WAIT 1 FIN_WAIT1 1 ESTABLISHED 634 SYN_RECV 2 LAST_ACK 1 常用的三个状态是：ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。 ","date":"2021-08-29","objectID":"/server-timewait-closewait-note/:1:0","tags":["Server","Linux","Net"],"title":"服务器大量TIME_WAIT和CLOSE_WAIT","uri":"/server-timewait-closewait-note/"},{"categories":["Operation","note"],"content":"1.服务器保持了大量TIME_WAIT状态 这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，这个问题是怎么产生的呢？ 从上面的示意图可以看得出来，TIME_WAIT是主动关闭连接的一方保持的状态，对于爬虫服务器来说他本身就是“客户端”，在完成一个爬取任务之后，他就 会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么要这么做？明明就已经主动关闭连接了为啥还要保持资源一段时间呢？这个是TCP/IP的设计者规定 的，主要出于以下两个方面的考虑： 1.防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） \\2. 可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。 现在来说如何来解决这个问题。 解决思路很简单，就是让服务器能够快速回收和重用那些TIME_WAIT的资源。 下面是一篇文章中提到的/etc/sysctl.conf文件的修改 #对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间 net.ipv4.tcp_syn_retries=2 #net.ipv4.tcp_synack_retries=2 #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒 net.ipv4.tcp_keepalive_time=1200 net.ipv4.tcp_orphan_retries=3 #表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间 net.ipv4.tcp_fin_timeout=30 #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 net.ipv4.tcp_max_syn_backlog = 4096 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭 net.ipv4.tcp_syncookies = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 net.ipv4.tcp_tw_reuse = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 net.ipv4.tcp_tw_recycle = 1 ##减少超时前的探测次数 net.ipv4.tcp_keepalive_probes=5 ##优化网络设备接收队列 net.core.netdev_max_backlog=3000 　修改完之后执行/sbin/sysctl -p让参数生效。 net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。 net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。 net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。 修改方法： sudo vi /etc/sysctl.conf 增加如下： net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 net.ipv4.ip_local_port_range = 10000 65000 net.ipv4.tcp_max_syn_backlog = 8192 net.ipv4.tcp_max_tw_buckets = 10000 sudo /sbin/sysctl -p 实时生效 ","date":"2021-08-29","objectID":"/server-timewait-closewait-note/:2:0","tags":["Server","Linux","Net"],"title":"服务器大量TIME_WAIT和CLOSE_WAIT","uri":"/server-timewait-closewait-note/"},{"categories":["Operation","note"],"content":"2.服务器保持了大量CLOSE_WAIT状态 TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。 但 是CLOSE_WAIT就不一样了，从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程 序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直 被程序占着。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。 如果你使用的是HttpClient并且你遇到了大量CLOSE_WAIT的情况，那么这篇日志也许对你有用 在那边日志里头我举了个场景，来说明CLOSE_WAIT和TIME_WAIT的区别，这里重新描述一下： 服 务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完 资源后，服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设 请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后程序员忘了 让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了。 所以如果将大量CLOSE_WAIT的解决办法总结为一句话那就是：查代码。因为问题出在服务器程序里头啊。 你的程序有问题！ ","date":"2021-08-29","objectID":"/server-timewait-closewait-note/:3:0","tags":["Server","Linux","Net"],"title":"服务器大量TIME_WAIT和CLOSE_WAIT","uri":"/server-timewait-closewait-note/"},{"categories":["Back","note"],"content":"记录Python环境搭建相关笔记","date":"2021-08-29","objectID":"/python_env_note/","tags":["Python","Environment"],"title":"Python环境搭建相关笔记","uri":"/python_env_note/"},{"categories":["Back","note"],"content":"卸载Python 要想彻底干净的卸载python,如果是使用的安装版的话，其实很简单。【windows安装版】 就是点击安装包。 例如，当前你安装的版本是3.6.5，你想要把它卸载掉。 查看python版本的命令： 只需要点击对应版本的安装包： 点击卸载选项 完成即可。 最后需要注意的是，将你的安装目录也删除掉就好了。 这样，你安装其他版本的python就不会担心没有卸载干净原版本的导致安装不成功了。 ","date":"2021-08-29","objectID":"/python_env_note/:1:0","tags":["Python","Environment"],"title":"Python环境搭建相关笔记","uri":"/python_env_note/"},{"categories":["Back"],"content":"记录Java报错Can not find table primary key in Class的解决办法","date":"2021-08-29","objectID":"/java_cant_find_primary_key/","tags":["Java","Database","Mybatis","Error"],"title":"Java报错Can not find table primary key in Class","uri":"/java_cant_find_primary_key/"},{"categories":["Back"],"content":"报错 项目启动之后，报错 Can not find table primary key in Class: “com.unicloud.common.core.domain.entity.SysDept”. 09:57:19.227 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.common.core.domain.entity.SysDept\". 09:57:19.272 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.common.core.domain.entity.SysDictData\". 09:57:19.318 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.common.core.domain.entity.SysDictType\". 09:57:19.359 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.system.domain.SysLogininfor\". 09:57:19.403 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.common.core.domain.entity.SysMenu\". 09:57:19.445 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.system.domain.SysNotice\". 09:57:19.489 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.system.domain.SysOperLog\". 09:57:19.532 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.system.domain.SysPost\". 09:57:19.572 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.system.domain.SysRoleDept\". 09:57:19.613 [restartedMain] WARN c.b.m.c.m.TableInfoHelper - [initTableFields,307] - Can not find table primary key in Class: \"com.unicloud.common.core.domain.entity.SysRole\". ","date":"2021-08-29","objectID":"/java_cant_find_primary_key/:1:0","tags":["Java","Database","Mybatis","Error"],"title":"Java报错Can not find table primary key in Class","uri":"/java_cant_find_primary_key/"},{"categories":["Back"],"content":"分析 原因发现没有在实体类的自增主键上加自增主键的注解 点击 关/系/外键 这个表是有主键的，并且是自增 然而：我们的实体类里 ","date":"2021-08-29","objectID":"/java_cant_find_primary_key/:2:0","tags":["Java","Database","Mybatis","Error"],"title":"Java报错Can not find table primary key in Class","uri":"/java_cant_find_primary_key/"},{"categories":["Back"],"content":"解决 我们加上 就OK了 ","date":"2021-08-29","objectID":"/java_cant_find_primary_key/:3:0","tags":["Java","Database","Mybatis","Error"],"title":"Java报错Can not find table primary key in Class","uri":"/java_cant_find_primary_key/"},{"categories":["SoftwareDesign"],"content":"记录C/S和B/S结构的优缺点的区别","date":"2021-08-29","objectID":"/cs_and_bs_diff/","tags":["SoftwareStructure"],"title":"C/S和B/S结构的优缺点","uri":"/cs_and_bs_diff/"},{"categories":["SoftwareDesign"],"content":"引言 为了区别于传统的C/S模式，才特意将其称为B/S模式。认识到这些结构的特征，对于系统的选型而言是很关键的。 ","date":"2021-08-29","objectID":"/cs_and_bs_diff/:1:0","tags":["SoftwareStructure"],"title":"C/S和B/S结构的优缺点","uri":"/cs_and_bs_diff/"},{"categories":["SoftwareDesign"],"content":"分类对比 1、系统的性能 在系统的性能方面，B/S占有优势的是其异地浏览和信息采集的灵活性。任何时间、任何地点、任何系统，只要可以使用浏览器上网，就可以使用B/S系统的终端。 不过，采用B/S结构，客户端只能完成浏览、查询、数据输入等简单功能，绝大部分工作由服务器承担，这使得服务器的负担很重。采用C/S结构时，客户端和服务器端都能够处理任务，这虽然对客户机的要求较高，但因此可以减轻服务器的压力。而且，由于客户端使用浏览器，使得网上发布的信息必须是以HTML格式为主，其它格式文件多半是以附件的形式存放。而HTML格式文件（也就是Web页面）不便于编辑修改，给文件管理带来了许多不便。 2、系统的开发 C/S结构是建立在中间件产品基础之上的，要求应用开发者自己去处理事务管理、消息队列、数据的复制和同步、通信安全等系统级的问题。这对应用开发者提出了较高的要求，而且迫使应用开发者投入很多精力来解决应用程序以外的问题。这使得应用程序的维护、移植和互操作变得复杂。如果客户端是在不同的操作系统上，C/S结构的软件需要开发不同版本的客户端软件。但是，与B/S结构相比，C/S技术发展历史更为\"悠久\"。从技术成熟度及软件设计、开发人员的掌握水平来看，C/S技术应是更成熟、更可靠的。 3、系统的升级维护 C/S系统的各部分模块中有一部分改变，就要关联到其它模块的变动，使系统升级成本比较大。B/S与C/S处理模式相比，则大大简化了客户端，只要客户端机器能上网就可以。对于B/S而言，开发、维护等几乎所有工作也都集中在服务器端，当企业对网络应用进行升级时，只需更新服务器端的软件就可以，这减轻了异地用户系统维护与升级的成本。如果客户端的软件系统升级比较频繁，那么B/S架构的产品优势明显——所有的升级操作只需要针对服务器进行，这对那些点多面广的应用是很有价值的，例如一些招聘网站就需要采用B/S模式，客户端分散，且应用简单，只需要进行简单的浏览和少量信息的录入。 ","date":"2021-08-29","objectID":"/cs_and_bs_diff/:2:0","tags":["SoftwareStructure"],"title":"C/S和B/S结构的优缺点","uri":"/cs_and_bs_diff/"},{"categories":["SoftwareDesign"],"content":"总体对比 1、C/S 模式的优点和缺点 ★ C/S 模式的优点 由于客户端实现与服务器的直接相连，没有中间环节，因此响应速度快。 操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求。 C/S结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程。 ★ C/S 模式的缺点 需要专门的客户端安装程序，分布功能弱，针对点多面广且不具备网络条件的用户群体，不能够实现快速部署安装和配置。 兼容性差，对于不同的开发工具，具有较大的局限性。若采用不同工具，需要重新改写程序。 开发成本较高，需要具有一定专业水准的技术人员才能完成。 2、B/S模式的优点和缺点 ★ B/S 模式的优点 具有分布性特点，可以随时随地进行查询、浏览等业务处理。 业务扩展简单方便，通过增加网页即可增加服务器功能。 维护简单方便，只需要改变网页，即可实现所有用户的同步更新。 开发简单，共享性强。 ★ B/S 模式的缺点 个性化特点明显降低，无法实现具有个性化的功能要求。 操作是以鼠标为最基本的操作方式，无法满足快速操作的要求。 页面动态刷新，响应速度明显降低。 无法实现分页显示，给数据库访问造成较大的压力。 功能弱化，难以实现传统模式下的特殊功能要求。 ","date":"2021-08-29","objectID":"/cs_and_bs_diff/:3:0","tags":["SoftwareStructure"],"title":"C/S和B/S结构的优缺点","uri":"/cs_and_bs_diff/"},{"categories":["SoftwareDesign"],"content":"后记 近年来，随着软硬件技术发展和人们意识的提高，Web应用得到广泛的普及，一方面在互联网浪潮的推动下，基于互联网的信息共享和电子商务不断发展，像新浪、搜狐、8848等大型网站不断涌现出来，另一方面随着Java、CGI等网络技术的成熟，基于B/S结构的大型软件逐渐显示出巨大的优势。同时，也就产生了一个焦点问题，什么样的服务器能够满足不同用户的需求，怎么能够保证Web服务器能够长期稳定地运行，为了满足这样的需求Web测试也就同样变得十分重要。 当前Web测试主要通过Web测试工具加上良好的测试案例完成的，我们认为主要有以下两种测试类型：基准测试、非基准测试 基准测试：主要指测试工具已经提供了标准的测试案例库，包括静态测试案例（HTM、JPG）、动态测试案例（CGI）和SSL测试案例等。这类测试工具分为测试案例库、控制台程序、客户端程序三个部分。它的原理是，Web服务器开启特定的Web服务程序，并且运行上述测试案例，由控制台程序控制各个客户端按照一定的脚本访问顺序遍历Web服务器的各个测试案例，每个请求完成后，各个客户端向控制台报告访问的结构，当一个测试集完成后由控制台将所有的信息综合统计，测试过程中控制台还需要采用SNMP协议对服务器进行实时监控，综合两个方面的因素可以反映出Web服务器在不同压力情况下的综合性能。 在测试过程中，主要影响测试结果的因素有网络环境、客户端性能。目前无论IA架构服务器还是SUN、HP、IBM的UNIX服务器性能都越来越优越，有可能出现在100MB网络下不能够提供足够的网络压力，有可能网络首先出现瓶颈，这样就需要扩展到1000MB网络环境或使用多个网段对服务器提供足够的压力，而稳定的客户端对于测试来说也是十分重要的，因为客户端如果出现性能下降，就会造成系统崩溃或者不能提供稳定的测试压力从而导致测试结果出现偏差；一台客户端到底能够稳定运行多少数量的连接是根据不同的硬件配置和操作系统决定的，因此对客户端的硬件资源进行监控是保证客户端可以稳定运行的必要手段。 由于这类测试工具使用的是工具开发商提供的测试案例集，虽然也具有一定的权威性，但是目前再完美的测试案例集也不能涵盖所有的Web应用情况，所以也不能够完全体现出Web服务器完整的性能，因此该类测试工具更加适合IT媒体对Web类服务器软硬件的横向对比测试，在测试对象和环境大体统一的情况下，可以比较出各个测试对象的性能差异。而对于有实际应用背景的Web服务器进行测试，使用这样的测试工具就不适合了，我们在以后的测试漫谈中会继续介绍。 ","date":"2021-08-29","objectID":"/cs_and_bs_diff/:4:0","tags":["SoftwareStructure"],"title":"C/S和B/S结构的优缺点","uri":"/cs_and_bs_diff/"},{"categories":["Operation","note"],"content":"记录Win10根据弹窗定位窗口进程（程序）的笔记","date":"2021-08-28","objectID":"/win-locate-pop-form-note/","tags":["Windows","Windows10","WinForm","PopForm"],"title":"Win10根据弹窗定位窗口进程（程序）","uri":"/win-locate-pop-form-note/"},{"categories":["Operation","note"],"content":"操作环境 红色粗字体字为修改后内容，蓝色粗体字为特别注意内容 操作系统：Win10 64bit 工具(ProcessExplorer)下载地址 ","date":"2021-08-28","objectID":"/win-locate-pop-form-note/:1:0","tags":["Windows","Windows10","WinForm","PopForm"],"title":"Win10根据弹窗定位窗口进程（程序）","uri":"/win-locate-pop-form-note/"},{"categories":["Operation","note"],"content":"分析 如今，使用电脑上网的时候，经常遇到广告插件，对于这些插件一般做法是：定位进程-》定位可执行文件位置-》删掉，即可去掉广告插件。 但是有时候，我们经常遇到一个莫名其妙的广告窗口，但打开任务管理器未发现可疑进程，这时候我们往往束手无策。 现在，我们找到一个简单的方法就能很快定位进程，进而定位可执行程序的位置，但前提是该广告有弹出式窗口。 ","date":"2021-08-28","objectID":"/win-locate-pop-form-note/:2:0","tags":["Windows","Windows10","WinForm","PopForm"],"title":"Win10根据弹窗定位窗口进程（程序）","uri":"/win-locate-pop-form-note/"},{"categories":["Operation","note"],"content":"方法 打开软件，可以看到如下界面： 界面上部分是进程列表，选中某一项，下面会列出该进程所加载的所有dll库。 整个软件使用起来非常简单，只需要用鼠标点住①处箭头指向的圆形图标(Find Window’s Process)，拖动到任何窗口上，即可定位与该窗口相关的进程。 ","date":"2021-08-28","objectID":"/win-locate-pop-form-note/:3:0","tags":["Windows","Windows10","WinForm","PopForm"],"title":"Win10根据弹窗定位窗口进程（程序）","uri":"/win-locate-pop-form-note/"},{"categories":["Operation","note"],"content":"记录Linux SSH相关操作教程的笔记","date":"2021-08-27","objectID":"/linux-ssh-note/","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"版本说明 本章内容基于CentOS6.5（32位） ","date":"2021-08-27","objectID":"/linux-ssh-note/:1:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"Linux使用SCP进行文件传输 scp就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证 。 scp不需要安装额外的软件，使用起来简单方便，安全可靠且支持限速参数但是它不支持排除目录 为了学习SCP命令我创建了3个Linux虚拟机，其ip地址分别位 192.168.132.130、192.168.132.132、192.168.132.133 ","date":"2021-08-27","objectID":"/linux-ssh-note/:2:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"scp命令格式 scp [参数] \u003c源地址（用户名@IP地址或主机名）\u003e:\u003c文件路径\u003e \u003c目的地址（用户名 @IP 地址或主机名）\u003e:\u003c文件路径\u003e 这里的参数有 -r 传输文件夹 -v 展示传输详情 ","date":"2021-08-27","objectID":"/linux-ssh-note/:3:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"在源服务器传输文件夹 (包括文件夹本身) 在130服务器上将文件夹dai传输到132服务器的根目录 这里的 -r 代表传输文件夹 (包括文件夹本身)，命令输入后需要输入132服务器的密码 scp -r /dai root@192.168.132.132:/ ","date":"2021-08-27","objectID":"/linux-ssh-note/:4:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"在源服务器传输文件 将130服务器上的jdk-7u55-linux-i586.tar.gz传到132服务器的根目录 这里我们如果把/dai/soft/jdk-7u55-linux-i586.tar.gz替换成/dai/soft/*，就代表传输路径/dai/soft下的所有文件 scp /dai/soft/jdk-7u55-linux-i586.tar.gz root@192.168.132.132:/ 可以看到132服务器根目录成功接受到 jdk-7u55-linux-i586.tar.gz文件 ","date":"2021-08-27","objectID":"/linux-ssh-note/:5:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"在源服务器传输文件并重命名 还是刚才的文件，在130服务器上再传一次，不过这次要给它重命名为changename.tar.gz scp /dai/soft/jdk-7u55-linux-i586.tar.gz root@192.168.132.132:/changename.tar.gz 这时的132服务器上可以看到传过去的changename.tar.gz ","date":"2021-08-27","objectID":"/linux-ssh-note/:6:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"在目标服务器下载文件夹及文件 和在源服务器传输文件的命令类似，将130服务器上的/dai/soft文件夹下载到本地132服务器根目录，这里要输入130服务器的密码，下载文件的话就去除参数-r scp -r root@192.168.132.130:/dai/soft / ","date":"2021-08-27","objectID":"/linux-ssh-note/:7:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Operation","note"],"content":"使用第三台服务器进行两台服务器之间文件的传输 登陆到第三台服务器133执行命令，这里执行传输命令后要同时输入两台服务器的密码 scp -r root@192.168.132.130:/dai/soft root@192.168.132.132:/ 参考文章 https://blog.csdn.net/qw_xingzhe/article/details/80167888 https://www.cnblogs.com/gudongcheng/p/8064808.html ","date":"2021-08-27","objectID":"/linux-ssh-note/:8:0","tags":["Linux","SSH"],"title":"Linux SSH相关操作教程","uri":"/linux-ssh-note/"},{"categories":["Back","note"],"content":"记录SpringBoot的笔记","date":"2021-08-26","objectID":"/springboot-note/","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"SpringBoot Controller接收参数的几种常用方式 ","date":"2021-08-26","objectID":"/springboot-note/:1:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"第一类：请求路径参数 1、@PathVariable 获取路径参数。即 _url/{id}_这种形式。 2、@RequestParam 获取查询参数。即 _url?name=_这种形式 例子 GET http://localhost:8080/demo/123?name=suki_rong 对应的java代码： @GetMapping(\"/demo/{id}\") public void demo(@PathVariable(name = \"id\") String id, @RequestParam(name = \"name\") String name) { System.out.println(\"id=\"+id); System.out.println(\"name=\"+name); } 输出结果： id=123 name=suki_rong ","date":"2021-08-26","objectID":"/springboot-note/:1:1","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"第二类：Body参数 因为是POST请求，这里用Postman的截图结合代码说明 1、@RequestBody 例子 对应的java代码： @PostMapping(path = \"/demo1\") public void demo1(@RequestBody Person person) { System.out.println(person.toString()); } 输出结果： name:suki_rong;age=18;hobby:programing 也可以是这样 @PostMapping(path = \"/demo1\") public void demo1(@RequestBody Map person) { System.out.println(person.get(\"name\")); } 输出结果： suki_rong 2、无注解 例子 对应的java代码： @PostMapping(path = \"/demo2\") public void demo2(Person person) { System.out.println(person.toString()); } 输出结果： name:suki_rong;age=18;hobby:programing Person类 public class Person { private long id; private String name; private int age; private String hobby; @Override public String toString(){ return \"name:\"+name+\";age=\"+age+\";hobby:\"+hobby; } } ","date":"2021-08-26","objectID":"/springboot-note/:1:2","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"第三类：请求头参数以及Cookie 2、@CookieValue 例子 java代码： @GetMapping(\"/demo3\") public void demo3(@RequestHeader(name = \"myHeader\") String myHeader, @CookieValue(name = \"myCookie\") String myCookie) { System.out.println(\"myHeader=\" + myHeader); System.out.println(\"myCookie=\" + myCookie); } 也可以这样 @GetMapping(\"/demo3\") public void demo3(HttpServletRequest request) { System.out.println(request.getHeader(\"myHeader\")); for (Cookie cookie : request.getCookies()) { if (\"myCookie\".equals(cookie.getName())) { System.out.println(cookie.getValue()); } } } ","date":"2021-08-26","objectID":"/springboot-note/:1:3","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"SpringBoot 重定向携带数据 RedirectAttributes 当controller层需要重定向到指定页面时,如何携带数据? 传统使用session 使用RedirectAttributes. (利用session原理) 优点: 提供了addFlashAttribute 等方法.确保数据只能被使用一次后删除 ","date":"2021-08-26","objectID":"/springboot-note/:2:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"RedirectAttributes的使用 public interface RedirectAttributes extends Model { RedirectAttributes addAttribute(String var1, @Nullable Object var2); RedirectAttributes addAttribute(Object var1); RedirectAttributes addAllAttributes(Collection\u003c?\u003e var1); RedirectAttributes mergeAttributes(Map\u003cString, ?\u003e var1); RedirectAttributes addFlashAttribute(String var1, @Nullable Object var2); RedirectAttributes addFlashAttribute(Object var1); Map\u003cString, ?\u003e getFlashAttributes(); } 直接在Controller的参数中添加RedirectAttributes. addFlashAttribute会在重定向到下一个页面取出这个数据以后,将session里面的数据删除\\ addFlashAttribute 方法会将数据存储在session中,访问一次后失效 @PostMapping(\"/regist\") public String register(RedirectAttributes attribdatautes){ int data = 1; attributes.addFlashAttribute(\"data\",data); return \"redirect:http://auth.gulimail.com/reg.html\"; } addAttribute 方法会将数据拼接在url后(get的形式) @GetMapping(\"/addToCartSuccess.html\") public String addToCartSuccessPagez(@RequestParam(\"skuId\") Long skuId,Model model){ CartItem cartItem = cartService.selectCartItemInfo(skuId); model.addAttribute(\"item\",cartItem); return \"success\"; } ","date":"2021-08-26","objectID":"/springboot-note/:2:1","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"@Scheduled @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Repeatable(Schedules.class) public @interface Scheduled { String CRON_DISABLED = ScheduledTaskRegistrar.CRON_DISABLED; String cron() default \"\"; String zone() default \"\"; long fixedDelay() default -1; String fixedDelayString() default \"\"; long fixedRate() default -1; String fixedRateString() default \"\"; long initialDelay() default -1; String initialDelayString() default \"\"; } 这些具体配置信息的含义如下： cron：通过cron表达式来配置执行规则，spring 3.0 后只支持 “6个参数”的cron，否则会报错 zone：cron表达式解析时使用的时区 fixedDelay：上一次执行结束到下一次执行开始的间隔时间（单位：ms，下全同） fixedDelayString：上一次任务执行结束到下一次执行开始的间隔时间，使用java.time.Duration#parse解析 fixedRate：以固定间隔执行任务，即上一次任务执行开始到下一次执行开始的间隔时间（单位：ms），若在调度任务执行时，上一次任务还未执行完毕，会加入worker队列，等待上一次执行完成后立即执行下一次任务 fixedRateString：与fixedRate逻辑一致，只是使用java.time.Duration#parse解析 initialDelay：首次任务执行的延迟时间 initialDelayString：首次任务执行的延迟时间，使用java.time.Duration#parse解析 ","date":"2021-08-26","objectID":"/springboot-note/:3:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"logging level级别 日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。 static Level DEBUG : DEBUG Level指出细粒度信息事件对调试应用程序是非常有帮助的,一般认为比较重要的方法执行需要详细查看运行情况的则开启debug。 static Level INFO INFO level表明消息在粗粒度级别上突出强调应用程序的运行过程，只需要了解该方法是否运行的可以使用INFO static Level WARN WARN level表明会出现潜在错误的情形。 static Level ERROR ERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。一般异常处理等情况都需要ERROR static Level FATAL FATAL level指出每个严重的错误事件将会导致应用程序的退出。 另外，还有两个可用的特别的日志记录级别: static Level ALL ALL Level是最低等级的，用于打开所有日志记录。 static Level OFF OFF Level是最高等级的，用于关闭所有日志记录。 日志记录器（Logger）的行为是分等级的： 分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级 从高到低分别是 ERROR、WARN、INFO、DEBUG。 通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别， 则应用程序中所有DEBUG级别的日志信息将不被打印出来。 优先级高的将被打印出来。项目上生产环境时候建议把debug的日志级别重新调为warn或者更高，避免产生大量日志。 ","date":"2021-08-26","objectID":"/springboot-note/:4:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"SpringBoot如何注入多个类型相同的Bean ","date":"2021-08-26","objectID":"/springboot-note/:5:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"声明 @Bean(autowire = Autowire.BY_NAME,value = \"kaptchaProducer\") public Producer kaptchaProducer() { Properties kaptchaProperties = new Properties(); kaptchaProperties.put(\"kaptcha.border\", \"no\"); kaptchaProperties.put(\"kaptcha.textproducer.char.length\",\"4\"); kaptchaProperties.put(\"kaptcha.image.height\",\"50\"); kaptchaProperties.put(\"kaptcha.image.width\",\"150\"); kaptchaProperties.put(\"kaptcha.obscurificator.impl\",\"com.google.code.kaptcha.impl.ShadowGimpy\"); kaptchaProperties.put(\"kaptcha.textproducer.font.color\",\"black\"); kaptchaProperties.put(\"kaptcha.textproducer.font.size\",\"40\"); kaptchaProperties.put(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.NoNoise\"); //kaptchaProperties.put(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.DefaultNoise\"); kaptchaProperties.put(\"kaptcha.textproducer.char.string\",\"acdefhkmnprtwxy2345678\"); Config config = new Config(kaptchaProperties); return config.getProducerImpl(); } @Bean(autowire = Autowire.BY_NAME,value = \"kaptchaProducerH5\") public Producer kaptchaProducerH5() { Properties kaptchaProperties = new Properties(); kaptchaProperties.put(\"kaptcha.border\", \"no\"); kaptchaProperties.put(\"kaptcha.textproducer.char.length\",\"4\"); kaptchaProperties.put(\"kaptcha.image.height\",\"50\"); kaptchaProperties.put(\"kaptcha.image.width\",\"150\"); kaptchaProperties.put(\"kaptcha.obscurificator.impl\",\"com.google.code.kaptcha.impl.ShadowGimpy\"); kaptchaProperties.put(\"kaptcha.textproducer.font.color\",\"black\"); kaptchaProperties.put(\"kaptcha.textproducer.font.size\",\"40\"); kaptchaProperties.put(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.NoNoise\"); //kaptchaProperties.put(\"kaptcha.noise.impl\",\"com.google.code.kaptcha.impl.DefaultNoise\"); kaptchaProperties.put(\"kaptcha.textproducer.char.string\",\"0123456789\"); Config config = new Config(kaptchaProperties); return config.getProducerImpl(); } ","date":"2021-08-26","objectID":"/springboot-note/:5:1","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"调用 @Resource(name = \"kaptchaProducer\") private Producer kaptchaProducer; @Resource(name = \"kaptchaProducerH5\") private Producer kaptchaProducerH5; ","date":"2021-08-26","objectID":"/springboot-note/:5:2","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"Bean中的Autowire-Candidate又是干什么的？ ","date":"2021-08-26","objectID":"/springboot-note/:6:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"autowire-candidate做什么事情的？ 上一篇文章Spring系列第10篇：primary可以解决什么问题？中遇到的问题我们再来回顾一下，当容器中某种类型的bean存在多个的时候，此时如果我们从容器中查找这种类型的bean的时候，会报下面这个异常： org.springframework.beans.factory.NoUniqueBeanDefinitionException 原因：当从容器中按照类型查找一个bean对象的时候，容器中却找到了多个匹配的bean，此时spring不知道如何选择了，处于懵逼状态，就会报这个异常。 这种异常主要出现在2种场景中： 场景1 从容器容器中查找符合指定类型的bean，对应BeanFactory下面的方法： \u003cT\u003e T getBean(Class\u003cT\u003e requiredType) throws BeansException; 场景2 自动注入方式设置为byType的时候，如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\"\u003e \u003cbean id=\"serviceA\" class=\"com.javacode2018.lesson001.demo8.SetterBean$ServiceA\"/\u003e \u003cbean id=\"serviceB\" class=\"com.javacode2018.lesson001.demo8.SetterBean$ServiceB\"/\u003e \u003cbean id=\"setterBean\" class=\"com.javacode2018.lesson001.demo8.SetterBean\" autowire=\"byType\" /\u003e \u003c/beans\u003e setterBean的autowire设置的是byType，即按setter方法的参数类型自动注入，SetterBean的setService的类型是IService，而IService类有2个实现类：ServiceA和ServiceB，而容器容器中刚好有这2个实现类的bean：serviceA和serviceB，所以上面代码会报错，不知道注入的时候选择那个对象注入。 我们可以通过primary属性来指定一个主要的bean，当从容器中查找的时候，如果有多个候选的bean符合查找的类型，此时容器将返回primary=“true\"的bean对象。 spring还有一种方法也可以解决这个问题，可以设置某个bean是否在自动注入的时候是否为作为候选bean，通过bean元素的autowire-candidate属性类配置，如下： \u003cbean id=\"serviceA\" class=\"com.javacode2018.lesson001.demo8.SetterBean$ServiceA\" autowire-candidate=\"false\"/\u003e autowire-candidate：设置当前bean在被其他对象作为自动注入对象的时候，是否作为候选bean，默认值是true。 来举例说明一下，以上面的setter注入的案例先来说一下注入的过程： 容器在创建setterBean的时候，发现其autowire为byType，即按类型自动注入，此时会在SetterBean类中查找所有setter方法列表，其中就包含了setService方法，setService方法参数类型是IService，然后就会去容器中按照IService类型查找所有符合条件的bean列表，此时容器中会返回满足IService这种类型并且autowire-candidate=“true\"的bean，刚才有说过bean元素的autowire-candidate的默认值是true，所以容器中符合条件的候选bean有2个：serviceA和serviceB，setService方法只需要一个满足条件的bean，此时会再去看这个列表中是否只有一个主要的bean（即bean元素的primary=“ture”的bean），而bean元素的primary默认值都是false，所以没有primary为true的bean，此时spring容器懵了，不知道选哪个了，此时就报错了，抛出NoUniqueBeanDefinitionException异常 从上面过程中可以看出将某个候选bean的primary置为true就可以解决问题了。 或者只保留一个bean的autowire-candidate为true，将其余的满足条件的bean的autowire-candidate置为false，此时也可以解决这个问题，下面我们使用autowire-candidate来解决上面问题看一下效果： SetterBean.java package com.javacode2018.lesson001.demo9; public class SetterBean { public interface IService {} //@1 public static class ServiceA implements IService {} //@2 public static class ServiceB implements IService {} //@3 private IService service; public void setService(IService service) { this.service = service; } @Override public String toString() { return \"SetterBean{\" + \"service=\" + service + '}'; } } autowireCandidateBean.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\"\u003e \u003cbean id=\"serviceA\" class=\"com.javacode2018.lesson001.demo9.SetterBean$ServiceA\" autowire-candidate=\"false\"/\u003e \u003cbean id=\"serviceB\" class=\"com.javacode2018.lesson001.demo9.SetterBean$ServiceB\"/\u003e \u003cbean id=\"setterBean\" class=\"com.javacode2018.lesson001.demo9.SetterBean\" autowire=\"byType\" /\u003e \u003c/beans\u003e 上面我们将serviceA的autowire-candidate置为false了，serviceA在被其他bean自动按照类型注入的时候，将不再放入候选名单中 测试用例 package com.javacode2018.lesson001.demo9; import com.javacode2018.lesson001.demo5.IocUtils; import com.javacode2018.lesson001.demo8.NormalBean; import com.javacode2018.lesson001.demo8.PrimaryBean; import org.junit.Test; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.util.Arrays; import java.util.Map; /** * 公众号：路人甲Java，工作10年的前阿里P7分享Java、算法、数据库方面的技术干货！坚信用技术改变命运，让家人过上更体面的生活! * bean元素的autowire-candidate可以设置当前bean是否作为其他bean自动注入的候选bean */ public class AutowireCandidateTest { @Test public void setterBean() { String beanXml = \"classpath:/com/javacode2018/lesson001/demo9/autowireCandidateBean.xml\"; ClassPathXmlApplicationContext context = IocUtils","date":"2021-08-26","objectID":"/springboot-note/:6:1","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"autowire-candidates属性解析源码 beans元素是xml中定义bean的根元素，beans元素有个default-autowire-candidates属性，用于定义哪些bean可以作为候选者，default-autowire-candidates的值是个通配符如： default-autowire-candidates=\"*Service\" 再来说一下bean元素的autowire-candidate属性，这个属性有3个可选值： default：这个是默认值，autowire-candidate如果不设置，其值就是default true：作为候选者 false：不作为候选者 spring中由beans元素的default-autowire-candidates和bean元素的autowire-candidate来决定最终bean元素autowire-candidate的值，我们来看一下bean元素autowire-candidates的解析源码： 源码位置：org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionAttributes 主要代码如下： //获取bean元素的autowire-candidate元素，autowire-candidate如果不设置，其值就是default String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); //判断bean元素的autowire-candidate元素是否等于\"default\"或者是否等于\"\" if (isDefaultValue(autowireCandidate)) { //获取beans元素default-autowire-candidates属性值 String candidatePattern = this.defaults.getAutowireCandidates(); //判断获取beans元素default-autowire-candidates属性值是否为空，default-autowire-candidates默认值就是null if (candidatePattern != null) { //判断bean的名称是否和default-autowire-candidates的值匹配，如果匹配就将bean的autowireCandidate置为true，否则置为false String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern); bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName)); } }else { //判断bean的autowire-candidate的值是否等于\"true\" bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate)); } 如果上面判断都没有进去，autowireCandidate属性默认值就是true，这个在下面定义的： org.springframework.beans.factory.support.AbstractBeanDefinition#autowireCandidate private boolean autowireCandidate = true; 所有的bean元素最后都会被解析为spring中的org.springframework.beans.factory.config.BeanDefinition对象，关于BeanDefinition以后我们会细说。 ","date":"2021-08-26","objectID":"/springboot-note/:6:2","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"问题 对上面的案例做个扩展，SetterBean类中加个方法： public void setService1(List\u003cIService\u003e service) {//@0 System.out.println(service); //@1 } @0：需要注入一个IService的集合，判断一下**@1输出的是容器中的serviceA，还是serviceB，还是2个都有呢？为什么？** ","date":"2021-08-26","objectID":"/springboot-note/:6:3","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"案例源码 链接：https://pan.baidu.com/s/1p6rcfKOeWQIVkuhVybzZmQ 提取码：zr99 ","date":"2021-08-26","objectID":"/springboot-note/:6:4","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"Spring Boot 的 banner 换成了美女，老板说工作不饱和，建议安排加班 SpringBoot的banner竟然可以用美女图片在线制作，难以相信 ","date":"2021-08-26","objectID":"/springboot-note/:7:0","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"一：banner.txt 在SpringBoot项目的resources目录下新建一个banner.txt文本文件，然后将启动Banner粘贴到此文本文件中，启动项目即可。 SpringBoot的banner竟然可以用美女图片在线制作，难以相信 ","date":"2021-08-26","objectID":"/springboot-note/:7:1","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"二：在线制作banner 很多公司的banner为自己公司的名称或者产品名称，所以通过文本获取banner是必要的，这里介绍几个在线制作banner的网站： 1. http://patorjk.com/software/taag/ Big字体 Doom字体 2. https://www.bootschool.net/ascii 3. http://www.network-science.de/ascii/ 4. https://www.degraeve.com/img2txt.php 这个网站就非常牛逼了，可以根据图片转为为文本。 既然图片能转文本，那我就随便找一张图来玩玩。 https://uploadfile.huiyi8.com/2014/0719/20140719100527496.jpg 大家来看一下结果，我和我的小伙伴都惊呆了，还是彩色。 ","date":"2021-08-26","objectID":"/springboot-note/:7:2","tags":["Java","SpringBoot"],"title":"SpringBoot笔记","uri":"/springboot-note/"},{"categories":["Back","note"],"content":"记录Spring Cloud Stream详细教程的笔记","date":"2021-08-26","objectID":"/springcloud-stream-note/","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"引言 TIPS 本文基于Spring Cloud Stream 2.2.0.RC1，包含其新特性。 内容稍微有点乱，但这毕竟是个人学习笔记分享，不是从0到1的手把手系列博客，望知悉。 Spring Cloud Stream比较优秀，它屏蔽了各种MQ的差异，统一了编程模型（可以类比成基于MQ通信圈的”Spring Data”）；其次个人实体书《Spring Cloud 与 Docker 微服务架构实战》没有包含这部分内容也是一大遗憾；更重要的是，这货细节其实挺多，而且上手是稍微有一点曲线的。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:1:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"概念 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:2:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"group By default, when a group is not specified, Spring Cloud Stream assigns the application to an anonymous and independent single-member consumer group that is in a publish-subscribe relationship with all other consumer groups. 组内只有1个实例消费。如果不设置group，则stream会自动为每个实例创建匿名且独立的group——于是每个实例都会消费。 组内单次只有1个实例消费，并且会轮询负载均衡。 In general, it is preferable to always specify a consumer group when binding an application to a given destination. 通常，在将应用程序绑定到给定目标时，最好始终指定使用者组。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:2:1","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"partition One or more producer application instances send data to multiple consumer application instances and ensure that data identified by common characteristics are processed by the same consumer instance. 一个或多个生产者将数据发送到多个消费者，并确保有共同特征标识的数据由同一个消费者处理。默认是对消息进行hashCode，然后根据分区个数取余，所以对于相同的消息，总会落到同一个消费者上。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:2:2","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"destination binder 与外部消息系统通信的组件，为构造 Binding提供了 2 个方法，分别是 bindConsumer 和 bindProducer ，它们分别用于构造生产者和消费者。Binder使Spring Cloud Stream应用程序可以灵活地连接到中间件，目前spring为kafka、rabbitmq提供binder。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:2:3","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"destination binding Binding 是连接应用程序跟消息中间件的桥梁，用于消息的消费和生产，由binder创建。 Applying the @EnableBinding annotation to one of the application’s configuration classes defines a destination binding. 使用@EnableBinding即可定义destination binding ","date":"2021-08-26","objectID":"/springcloud-stream-note/:2:4","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"注解 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"@Input(“inboundOrders”) Aside from generating channels for each binding and registering them as Spring beans, for each bound interface, Spring Cloud Stream generates a bean that implements the interface. public interface Barista { @Input(\"inboundOrders\") SubscribableChannel orders();} Input注解作用 为每个binding生成channel实例 指定channel名称 在spring容器中生成一个名为inboundOrders，类型为SubscribableChannel的bean 在spring容器中生成一个类，实现Barista接口。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:1","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"@InboundChannelAdapter 示例： @Bean @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = \"10\", maxMessagesPerPoll = \"1\")) public MessageSource\u003cString\u003e test() { return () -\u003e new GenericMessage\u003c\u003e(\"Hello Spring Cloud Stream\"); } 作用：表示定义的方法能产生消息。用InboundChannelAdapter注解的方法上即使有参数也没用。 fixedDelay：多少毫秒发送1次 maxMessagesPerPoll：一次发送几条消息。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:2","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"ServiceActivator @ServiceActivator(inputChannel = Sink.INPUT, outputChannel = Source.OUTPUT) public String transform(String payload) { return payload.toUpperCase(); } 表示方法能够处理消息或消息有效内容，监听input消息，用方法体的代码处理，然后输出到output中。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:3","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"@Transformer 和ServiceActivator差不多，表示方法能够转换消息，消息头，或消息有效内容 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:4","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"@StreamListener(target = Sink.INPUT, condition = “headers[‘type’]==’bogey’”) In order to be eligible to support conditional dispatching, a method must satisfy the follow conditions: It must not return a value. It must be an individual message handling method (reactive API methods are not supported). condition的作用：符合条件，才走处理方法。 condition起作用的两个条件： 注解的方法没有返回值 方法是一个独立方法，不支持Reactive API 代码示例： @StreamListener(value = Sink.INPUT, condition = \"headers['type']=='dog'\") public void handle(String body) { System.out.println(\"Received: \" + body); } @Bean @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = \"1000\", maxMessagesPerPoll = \"2\")) public MessageSource\u003cString\u003e test() { return () -\u003e { Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(1); map.put(\"type\", \"dog\"); return new GenericMessage\u003c\u003e(\"abcdef\", map); }; } ","date":"2021-08-26","objectID":"/springcloud-stream-note/:3:5","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"PollableMessageSource 作用：允许消费者控制消费速率。 @SpringBootApplication @EnableBinding({ConsumerApplication.PolledProcessor.class}) @EnableSchedulingpublic class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class, args); } @Autowired private PolledProcessor polledProcessor; @Scheduled(fixedDelay = 5_000) public void poll() { polledProcessor.input().poll(message -\u003e { byte[] bytes = (byte[]) message.getPayload(); String payload = new String(bytes); System.out.println(payload); }); } public interface PolledProcessor { @Input PollableMessageSource input(); @Output MessageChannel output(); } @Bean @InboundChannelAdapter(value = \"output\", poller = @Poller(fixedDelay = \"1000\", maxMessagesPerPoll = \"1\")) public MessageSource\u003cString\u003e test() { return () -\u003e { Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(1); map.put(\"type\", \"dog\"); return new GenericMessage\u003c\u003e(\"adfdfdsafdsfa\", map); }; } } 如果不想自己进行byte数组转换，可以添加配置： spring:cloud:stream:bindings:output:# 指定content-type content-type:text/plain 相关文章 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:4:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"错误处理 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"应用处理 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:1","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"方式1：处理指定channel 配置： spring:cloud:stream:bindings:input:destination:my-destinationgroup:my-groupoutput:destination:my-destination 代码： @Slf4j @SpringBootApplication @EnableBinding({Processor.class}) @EnableSchedulingpublic class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class, args); } @StreamListener(value = Processor.INPUT) public void handle(String body) { throw new RuntimeException(\"x\"); } @ServiceActivator(inputChannel = \"my-destination.my-group.errors\") public void handleError(ErrorMessage message) { Throwable throwable = message.getPayload(); log.error(\"截获异常\", throwable); Message\u003c?\u003e originalMessage = message.getOriginalMessage(); assert originalMessage != null; log.info(\"原始消息体 = {}\", new String((byte[]) originalMessage.getPayload())); } @Bean @InboundChannelAdapter(value = Processor.OUTPUT, poller = @Poller(fixedDelay = \"1000\", maxMessagesPerPoll = \"1\")) public MessageSource\u003cString\u003e test() { return () -\u003e new GenericMessage\u003c\u003e(\"adfdfdsafdsfa\"); } } ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:2","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"方式2：处理所有channel @StreamListener(value = Processor.INPUT) public void handle(String body) { throw new RuntimeException(\"x\"); } @StreamListener(\"errorChannel\") public void error(Message\u003c?\u003e message) { ErrorMessage errorMessage = (ErrorMessage) message; System.out.println(\"Handling ERROR: \" + errorMessage); } ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:3","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"系统处理 系统处理方式，因消息中间件不同而异。如果应用没有配置错误处理器，那么error将会被传播给binder，binder将error回传给消息中间件。消息中间件可以丢弃消息、requeue（重新排队，从而重新处理）或将失败的消息发送给DLQ(死信队列)。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:4","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"丢弃 默认情况下，错误消息将被丢弃。虽然在某些情况下可以接受，但这种方式一般不适用于生产。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:5","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"DLQ 配置： spring:cloud:stream:bindings:input:destination:my-destinationgroup:my-groupoutput:destination:my-destinationrabbit:bindings:input:consumer:auto-bind-dlq:true 代码： @StreamListener(value = Processor.INPUT) public void handle(String body) { throw new RuntimeException(\"x\"); } @Bean @InboundChannelAdapter(value = Processor.OUTPUT, poller = @Poller(fixedDelay = \"1000\", maxMessagesPerPoll = \"1\")) public MessageSource\u003cString\u003e test() { return () -\u003e new GenericMessage\u003c\u003e(\"adfdfdsafdsfa\"); } 这样，消息消费失败后，就会放入死信队列。在控制台操作一下，即可将这些消息放回消息队列。客户端就可以重新处理。 如果想获取原始错误的异常堆栈，可添加如下配置： spring:cloud:stream:rabbit:bindings:input:consumer:republish-to-dlq:true ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:6","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"requeue Rabbit/Kafka的binder依赖RetryTemplate实现重试，从而提升消息处理的成功率。然而，如果设置了spring.cloud.stream.bindings.input.consumer.max-attempts=1 ，那么RetryTemplate则不再重试。此时可通过requeue方式处理异常。 添加如下配置： # 默认是3，设为1则禁用重试 spring.cloud.stream.bindings.\u003cinput channel名称\u003e.consumer.max-attempts=1 # 表示是否要requeue被拒绝的消息(即：requeue处理失败的消息) spring.cloud.stream.rabbit.bindings.input.consumer.requeue-rejected=true 这样，失败的消息将会被重新提交到同一个handler进行处理，直到handler抛出 AmqpRejectAndDontRequeueException 异常为止。 ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:7","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"RetryTemplate ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:8","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"配置方式 RetryTemplate重试也是错误处理的一种手段。 spring:cloud:stream:bindings:\u003cinput channel名称\u003e:consumer:# 最多尝试处理几次，默认3maxAttempts:3# 重试时初始避退间隔，单位毫秒，默认1000backOffInitialInterval:1000# 重试时最大避退间隔，单位毫秒，默认10000backOffMaxInterval:10000# 避退乘数，默认2.0backOffMultiplier:2.0# 当listen抛出retryableExceptions未列出的异常时，是否要重试defaultRetryable:true# 异常是否允许重试的map映射retryableExceptions:java.lang.RuntimeException:truejava.lang.IllegalStateException:false 测试代码： @StreamListener(value = Processor.INPUT) public void handle(String body) { throw new RuntimeException(body); } private AtomicInteger count = new AtomicInteger(0); @Bean @InboundChannelAdapter(value = Processor.OUTPUT, poller = @Poller(fixedDelay = \"1000\", maxMessagesPerPoll = \"1\")) public MessageSource\u003cString\u003e test() { return () -\u003e new GenericMessage\u003c\u003e(count.getAndAdd(1) + \"\"); } ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:9","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"编码方式 多数场景下，使用配置方式定制重试行为都是可以满足需求的，但配置方式可能无法满足一些复杂需求。此时可使用编码方式配置RetryTemplate： @Configurationclass RetryConfiguration { @StreamRetryTemplate public RetryTemplate sinkConsumerRetryTemplate () { RetryTemplate retryTemplate = new RetryTemplate(); retryTemplate.setRetryPolicy(retryPolicy()); retryTemplate.setBackOffPolicy(backOffPolicy()); return retryTemplate; } private ExceptionClassifierRetryPolicy retryPolicy () { BinaryExceptionClassifier keepRetryingClassifier = new BinaryExceptionClassifier(Collections.singletonList(IllegalAccessException.class)); keepRetryingClassifier.setTraverseCauses(true); SimpleRetryPolicy simpleRetryPolicy = new SimpleRetryPolicy(3); AlwaysRetryPolicy alwaysRetryPolicy = new AlwaysRetryPolicy(); ExceptionClassifierRetryPolicy retryPolicy = new ExceptionClassifierRetryPolicy(); retryPolicy.setExceptionClassifier(classifiable -\u003e keepRetryingClassifier.classify(classifiable) ? alwaysRetryPolicy : simpleRetryPolicy); return retryPolicy; } private FixedBackOffPolicy backOffPolicy () { final FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy(); backOffPolicy.setBackOffPeriod(2); return backOffPolicy; } } 然后添加配置： spring.cloud.stream.bindings.\u003cinput channel名称\u003e.consumer.retry-template-name=myRetryTemplate 注： Spring Cloud Stream 2.2才支持设置retry-template-name ","date":"2021-08-26","objectID":"/springcloud-stream-note/:5:10","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Back","note"],"content":"动态绑定目标 这是Spring Integration原生的API，建议有时间了解下Spring Integration相关文档。 代码示例： @EnableBinding @Controllerpublic class SourceWithDynamicDestination { @Autowired private BinderAwareChannelResolver resolver; @Autowired @Qualifier(\"sourceChannel\") private MessageChannel localChannel; @RequestMapping(path = \"/\", method = POST, consumes = \"*/*\") @ResponseStatus(HttpStatus.ACCEPTED) public void handleRequest(@RequestBody String body, @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) { localChannel.send(MessageBuilder.createMessage(body, new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType)))); } @Bean(name = \"sourceChannel\") public MessageChannel localChannel() { return new DirectChannel(); } @Bean @ServiceActivator(inputChannel = \"sourceChannel\") public ExpressionEvaluatingRouter router() { ExpressionEvaluatingRouter router = new ExpressionEvaluatingRouter(new SpelExpressionParser().parseExpression(\"payload.id\")); router.setDefaultOutputChannelName(\"default-output\"); router.setChannelResolver(resolver); return router; } //Following sink is used as test consumer. It logs the data received through the consumer. @EnableBinding(Sink.class) static class TestSink { private final Log logger = LogFactory.getLog(getClass()); @StreamListener(Sink.INPUT1) public void receive(String data) { logger.info(\"Data received from customer-1...\" + data); } @StreamListener(Sink.INPUT2) public void receiveX(String data) { logger.info(\"Data received from customer-2...\" + data); } } interface Sink { String INPUT1 = \"input1\"; String INPUT2 = \"input2\"; @Input(INPUT1) SubscribableChannel input1(); @Input(INPUT2) SubscribableChannel input2(); } ","date":"2021-08-26","objectID":"/springcloud-stream-note/:6:0","tags":["Java","SpringCloud","Stream"],"title":"Spring Cloud Stream详细教程","uri":"/springcloud-stream-note/"},{"categories":["Front"],"content":"记录Vue执行Npm Install 报错no such file or directory的方法","date":"2021-08-26","objectID":"/vue-npm-install-no-file-dir-error/","tags":["Vue","Npm","Error"],"title":"Vue执行Npm Install 报错no such file or directory","uri":"/vue-npm-install-no-file-dir-error/"},{"categories":["Front"],"content":"报错 下载别人项目执行 npm install 报错 npm WARN saveError ENOENT: no such file or directory ","date":"2021-08-26","objectID":"/vue-npm-install-no-file-dir-error/:1:0","tags":["Vue","Npm","Error"],"title":"Vue执行Npm Install 报错no such file or directory","uri":"/vue-npm-install-no-file-dir-error/"},{"categories":["Front"],"content":"解决 清空npm缓存 npm cache clean -f 在执行install即可 ","date":"2021-08-26","objectID":"/vue-npm-install-no-file-dir-error/:2:0","tags":["Vue","Npm","Error"],"title":"Vue执行Npm Install 报错no such file or directory","uri":"/vue-npm-install-no-file-dir-error/"},{"categories":["Back"],"content":"记录Spring的笔记","date":"2021-08-25","objectID":"/spring-note/","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"BeanUtils工具类中的copyProperties方法使用 1、两个包下的BeanUtils.copyProperties对比 BeanUtils是开发中常用到的工具类，而获取这一工具类主要是通过导入org.springframework.beans.BeanUtils或者org.apache.commons.beanutils.BeanUtils包来获取，但是不同的包中BeanUtils的方法使用是不一样的，接下来就对这两个包中的copyProperties方法进行对比。 先来看一下这两个包中的copyProperties方法的定义： //org.springframework.beans.BeanUtils public static void copyProperties(Object source, Object target){....} //org.apache.commons.beanutils.BeanUtils public static void copyProperties(Object dest,Object orig){....} 由定义可知，在org.springframework.beans.BeanUtils包下的copyProperties第一个参数是被copy的对象，而org.apache.commons.beanutils.BeanUtils中是第二个参数，所以使用时不要弄混。 1）接下来定义两个实体类Student和Teacher，用来模拟目标对象（target/dest）中包含被copy的对象（source/orig）的所有字段时 @Data public class Student { private String id; private String name; private String age; public Student(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } } @Data public class Teacher { private String id; private String name; private String age; private String sex; public Teacher() {} public Teacher(String id, String name, String age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; } } 先使用org.springframework.beans.BeanUtils下的copyProperties来进行测试，执行代码如下： import org.springframework.beans.BeanUtils; public static void main(String[] args) throws Exception { Student student = new Student(UUID.randomUUID().toString(), \"zhangsan\", \"19\"); Teacher teacher = new Teacher(); System.out.println(student.toString()); BeanUtils.copyProperties(student,teacher); System.out.println(teacher.toString()); } 执行结果如下： Student(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19) Teacher(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19, sex=null) 当将引入的包改为org.apache.commons.beanutils.BeanUtils时，将上述中的执行代码进行如下修改： BeanUtils.copyProperties(teacher,student); //因为apache包下被copy的参数在第二个位置 执行结果如下： Student(id=900d0b93-1913-4022-b86b-127682cd9f5c, name=zhangsan, age=19) Teacher(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19, sex=null) 小结：当目标对象（target/dest）中包含被copy的对象（source/orig）的所有字段时，两种包下的copyProperties方法均可以执行成功。 2）对上述中说到的实体类进行修改，即目标对象（target/dest）中不包含被copy的对象（source/orig）的所有字段时，修改后的内容如下： @Data public class Student { private String id; private String name; private String age; public Student(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } } @Data public class Teacher { private String id; private String name; public Teacher() {} public Teacher(String id, String name) { this.id = id; this.name = name; } } 执行代码与1）中的一样这里就不写了，先使用org.apache.commons.beanutils.BeanUtils中的copyProperties方法，执行结果如下： Student(id=6f6711ef-fa2f-420d-b0b3-b76998356533, name=zhangsan, age=19) Exception in thread \"main\" java.lang.NoClassDefFoundError: org/apache/commons/collections/FastHashMap at org.apache.commons.beanutils.PropertyUtilsBean.getPropertyDescriptor(PropertyUtilsBean.java:964) at org.apache.commons.beanutils.PropertyUtilsBean.isWriteable(PropertyUtilsBean.java:1479) at org.apache.commons.beanutils.BeanUtilsBean.copyProperties(BeanUtilsBean.java:280) at org.apache.commons.beanutils.BeanUtils.copyProperties(BeanUtils.java:135) at com.learn.controller.BeanController.main(BeanController.java:39) Caused by: java.lang.ClassNotFoundException: org.apache.commons.collections.FastHashMap at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 5 more 接下来使用org.springframework.beans.BeanUtils下的copyProperties方法，执行结果如下： Student(id=87665c46-9a6f-4936-9c9d-1513e29f2bca, name=zhangsan, age=19) Teacher(id=87665c46-9a6f-4936-9c9d-1513e29f2bca, name=zhangsan) 小结：目标对象（target/dest）中不包含被copy的对象（source/orig）的所有字段时，应选用org.springframework.beans.BeanUtils下的copyProperties方法 3）基于2）中的实体类来看下另外一种情况，修改下执行代码，实体类不变： public static void main(String[] args) throws Exception { Student student = new Student(U","date":"2021-08-25","objectID":"/spring-note/:1:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"Spring integration学习总结 Spring integration是一个企业应用集成系统。主要通过消息、通道、消息端点等概念完成不同系统之间的集成。 ","date":"2021-08-25","objectID":"/spring-note/:2:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.1 消息（Message） 消息包括header（头）和payload（负载） message的header一般是id，时间戳或者目的地址什么的，比如如果你发的消息是个文件，那么header应该存放文件的名称，消息头可以根据需要修改。Payload就是负载，也就睡消息的主要内容，主要通过这个进行通信。 ","date":"2021-08-25","objectID":"/spring-note/:2:1","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.2 消息通道（Message channel） 消息传输的通道。分两种，一种是point-to-point点对点的，一种是publish-subscribe发布订阅形式的。如果是点对点的channel，至少会有一个消费者consumer能收到发送的message，另一种订阅发布的channel，spring integration试图去用广播的形式发布message给那些订阅者subscriber。 主要实现如下： PublishSubscribeChannel：将消息广播给所有的订阅者。 QueueChannel：可以缓存消息，在缓存消息没有达到上限时，消息发送者将消息发送到该通道后立即返回。如果缓存消息数量达到设定的容量，则消息发送者发送消息后会被阻塞，直到消息队列中有空间为止或者超时。对于消息接收者正好相反，尝试获取消息时，如果队列中有消息会立即返回，如果队列中没有消息则会一直阻塞直到超时（需要设定超时时间，不设定的话一直阻塞）。 PriorityChannel：一个排序队列。默认是根据消息头中的\"priority\"属性值进行排序，也可以通过实现Comparator\u003cMessage\u003c?\u003e\u003e接口的逻辑来进行排序。 RendezvousChannel：类似于QueueChannel，只是容量为0。也就是发送者发送消息时，接受者必须将其接收才会返回，否则一直被阻塞。接受者也是一样。 DirectChannel：用于点对点场景，但实现的是PublishSubscribeChannel接口，因此该通道会将消息直接分发给接收者，和PublishSubscribeChannel的区别就是，接收者只有一个。除此之外，DirectChannel还有一个最重要的特点就是发送和接收双方处于一个线程当中，如下：发送者发送消息-\u003e接收者接收消息并触发处理操作-\u003e返回。Spring Integration中的缺省的通道就是DirectChannel。例如\u003cint:channel id=\"xxxx\"/\u003e。 ExecutorChannel：用于点对点场景，和DirectChannel的配置相同，但主要的区别是ExecutorChannel将消息分发的操作委派给一个TaskExecutor的实例来进行，因此发送消息时不会进行阻塞。 Scoped Channel：暂不理解。 ","date":"2021-08-25","objectID":"/spring-note/:2:2","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3 消息端点（Message Endpoint） 可以对消息进行处理的地方。包括如下的主要构件： ","date":"2021-08-25","objectID":"/spring-note/:2:3","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.1 Transformer 可以对消息的内容或者结构进行修改，最常见的是修改消息内容的格式，或者对消息头的内容进行添加、修改和删除。用法如下： \u003cint:transformer id=\"testTransformer\" ref=\"testTransformerBean\" input-channel=\"inChannel\" method=\"transform\" output-channel=\"outChannel\"/\u003e \u003cbeans:bean id=\"testTransformerBean\" class=\"org.foo.TestTransformer\" /\u003e 决定一个消息是否被过滤掉，只有没有被过滤掉的消息才发送到输出通道上。filter多用于publish subscribe模式中，很多consumer消费者可以收到相同的message并且可以用filter来接收指定类型的消息并将其加工处理。 \u003cint:filter input-channel=\"input\" output-channel=\"output\" ref=\"exampleObject\" method=\"someBooleanReturningMethod\"/\u003e \u003cbean id=\"exampleObject\" class=\"example.SomeObject\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:4","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.3 Router 路由器，通常是一个输入通道，多个输出通道。根据消息头或者消息体的内容，决定将消息转发到哪个输出通道上。 \u003cint:router input-channel=\"drinks\" ref=\"drinkRouter\" method=\"route\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:5","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.4 Splitter 对应一个输入通道，多个输出通道。Splitter把消息从输入通道上分割发送到它的输出通道上。比如用于把一个复合型的payload负载分割成很多子负载payloads，发送到多个输出通道上。 \u003cint:splitter input-channel=\"orders\" ref=\"orderSplitter\" method=\"split\" output-channel=\"drinksTransform\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:6","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.5 Aggregator 集合器，和splitter对应。用于把多种message组合成一个单一的message。事实上aggregator比splitter要复杂一些，因为它需要维持message的状态，决定什么时候提供组合,什么时候超时timeout，甚至可以将一个局部的结果放弃，并发送到一个隔离的channel里。Spring integration提供了一个CompletionStrategy来配置timeout超时，是否在超时的时候发送一个结果并且废弃这个channel（这里应该是说消息废弃这个channel）。Aggregator在聚合时，会将消息头中消息ID相同的消息进行聚合。 \u003cint:aggregator input-channel=\"preparedDrinks\" method=\"prepareDelivery\" output-channel=\"deliveries\"\u003e \u003cbeans:bean class=\"com.abc.springintegration.cafe.xml.Waiter\"/\u003e \u003c/int:aggregator\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:7","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.6 Service Activator 用来连接应用的接口和message framework消息框架的组件，一个输入的频道input message channel必须被设定，一个service activator的方法被执行并且返回了一个值，那么可以提供一个输出频道output message channel（如果消息提供自己的返回地址，那么这是可选的）。这个规则适用于所有的consumer endpoints。输入从input channel到service activator再到message handler，然后返回output message到service activator到output message channel。归根结底：被继承组件的主要对外接口。 \u003cint:service-activator input-channel=\"coldDrinks\" ref=\"barista\" method=\"prepareColdDrink\" output-channel=\"preparedDrinks\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:8","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.7 Channel Adapter 连接一个消息通道和其他实体之间的对象。channel adapter也分inbound内绑定和outbound外绑定。 Inbound通道适配：通常的作用是将一个外部系统的资源进行转换，通过消息通道输送到系统中，用于进行后续的处理。 Outbound通道适配：将系统中的资源通过消息通道发送给Outbound通道适配，然后该“Outbound通道适配”将其转换为外部的资源。 举例：\u003cfile:inbound-channel-adapter\u003e的作用，将文件系统中的文件进行读取，将文件对象或者文件内容发送到消息通道中。 \u003cfile:outbound-channel-adapter\u003e的作用，将处理好的文件资源输出到文件系统中。 Spring Integration目前支持的常用channel-adapter如下： File FTP/FTPS HTTP JDBC SFTP Mail XML 等等 ","date":"2021-08-25","objectID":"/spring-note/:2:9","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3 使用经验 ","date":"2021-08-25","objectID":"/spring-note/:3:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.1 重复下载远程服务器上的文件 Spring Integration下载远程服务器可以使用其工作原理是监控远程服务器上的文件，一旦有新的文件就会首先下载到本地，然后将文件对象装载到channel中。在测试的过程中发现，这两步是各自独立进行的，也就是说，下载部分只下载远程服务器上存在但本地目录不存在的文件，将文件对象装载到channel的操作是监控本地目录中的文件，如果没有装载过就进行处理。有时候远程服务器上的相同文件名的文件是定期更新的，需要客户端定期下载，这种情况下的默认处理就有问题了： 1） 下载一次后，如果本地文件已经存在，就不会重复下载。 2） 即使将本地文件进行删除，此时虽然会下载，但下载到本地后不会将文件对象装载到channel中进行后续的处理。 Spring社区中也没有好的处理办法，这种情况下，可以使用下载到本地后对文件进行改名的方法进行规避，使用方法如下，见红色部分： \u003cint-sftp:inbound-channel-adapter id=\"sftpInboundAdapter\" session-factory=\"sftpSessionFactory\" remote-directory=\"/srv/data/stc/crm/\" local-directory=\"file:///srv/data/stc/crm/upload\" local-filename-generator-expression=\"substring(0,lastIndexOf('.')) + '_' + T(java.lang.System).currentTimeMillis() + substring(lastIndexOf('.'))\" channel=\"downloadFileChannel\" delete-remote-files=\"true\" auto-startup=\"true\" filter=\"entryListFilter\"\u003e \u003cint:poller max-messages-per-poll=\"1\" cron=\"0/1 * * * * * \" /\u003e \u003c/int-sftp:inbound-channel-adapter\u003e 进行了上面的配置后，下载下来的文件名会变成原来的文件名中加上了时间戳，这样就规避了上述的问题，如果也许需要还原原来的文件名，可以在进入channel后的后续的处理中再进行处理。 ","date":"2021-08-25","objectID":"/spring-note/:3:1","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.2 如何控制inbound-channel-adapter类的对象是否工作 context = new FileSystemXmlApplicationContext(\"/conf/stc-job.xml\"); SourcePollingChannelAdapter adapter = context.getBean(\"sftpInboundAdapter\", SourcePollingChannelAdapter.class); adapter.stop(); //停止工作 adapter.start(); //开始工作 ","date":"2021-08-25","objectID":"/spring-note/:3:2","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.3 Spring Integration 触发 Spring batch 的 job Spring Integration的配置如下： \u003cfile:inbound-channel-adapter directory=\"file:///srv/data/stc/crm\" channel=\"inputFileChannel\" filename-pattern=\"*.csv\"\u003e \u003cint:poller max-messages-per-poll=\"1\" cron=\"0/1 * * * * * \" /\u003e \u003c/file:inbound-channel-adapter\u003e \u003cint:service-activator input-channel=\"inputFileChannel\" output-channel=\"jobLaunchRequestChannel\" ref=\"fileToJobLaunchRequestAdapter\" method=\"adapt\"/\u003e \u003cint:service-activator input-channel=\"jobLaunchRequestChannel\" output-channel=\"jobExecutionChannel\"\u003e \u003cbeans:bean class=\"org.springframework.batch.integration.launch.JobLaunchingMessageHandler\"\u003e \u003cbeans:constructor-arg ref=\"jobLauncher\" /\u003e \u003c/beans:bean\u003e \u003c/int:service-activator\u003e \u003cbeans:bean id=\"fileToJobLaunchRequestAdapter\" class=\"com.abc.job.FileToJobLaunchRequestAdapter\"\u003e \u003cbeans:property name=\"job\" ref=\"stcJob\"/\u003e \u003c/beans:bean\u003e \u003c!--其中，红色stcJob为Spring batch的job名称，需要做如下的配置：--\u003e \u003cjob id=\"stcJob\"\u003e …… \u003c/job\u003e 对于Spring Job的触发类FileToJobLaunchRequestAdapter，代码如下： public class FileToJobLaunchRequestAdapter implements InitializingBean{ private Job job; public void setJob(Job job){ this.job = job; } public void afterPropertiesSet() throws Exception{ Assert.notNull(job, \"A Job must be provided\"); } @ServiceActivator public JobLaunchRequest adapt(File file) throws NoSuchJobException{ String fileName = file.getAbsolutePath(); if (!fileName.startsWith(\"/\")){ fileName = \"/\" + fileName; } fileName = \"file://\" + fileName; String outPutPath = \"file:///srv/smartcare/export/\"; String outPutFilePath = outPutPath + file.getName(); String outPutTmpFilePath = outPutFilePath; JobParameters jobParameters = new JobParametersBuilder().addString(\"input.file.path\", fileName) .addString(\"output.file.path\", outPutTmpFilePath) .addString(\"file.src\", outPutTmpFilePath) .addString(\"file.original.name\", file.getName()) .addString(\"file.dst\", outPutFilePath) .addLong(\"time.stamp\", System.currentTimeMillis()) .toJobParameters(); //确保job多次执行时，通过让jobParameters发生变化，从而区分job if (job.getJobParametersIncrementer() != null){ jobParameters = job.getJobParametersIncrementer() .getNext(jobParameters); } return new JobLaunchRequest(job, jobParameters); } public void output(File file){ System.out.println(\"receive file = \" + file.getName() + \", path = \" + file.getPath()); return; } } ","date":"2021-08-25","objectID":"/spring-note/:3:3","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.4 JAVA 代码中发消息给 Spring Integration 的 channel Java代码： Message\u003cFile\u003e message = MessageBuilder.withPayload(file).build(); sftpChannel.send(message); **sftpChannel**为Spring integration的channel名称。 在Spring Integration的配置文件中，做如下的配置： \u003cint-sftp:outbound-channel-adapter id=\"sftpOutboundAdapter\" session-factory=\"sftpSessionFactory\" channel=\"outFileChannel\" charset=\"UTF-8\" temporary-file-suffix=\".uploading\" remote-directory=\"/srv\"/\u003e 其中，**sftpChannel的名称等于outFileChannel**就可以了。 ","date":"2021-08-25","objectID":"/spring-note/:3:4","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back","note"],"content":"记录Mysql事务的笔记","date":"2021-08-25","objectID":"/mysql-transact/","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"脏读、不可重复读、幻读 ","date":"2021-08-25","objectID":"/mysql-transact/:1:0","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"一、分析 1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 例如： 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。 与此同时， 事务B正在读取张三的工资，读取到张三的工资为8000。 随后， 事务A发生异常，而回滚了事务。张三的工资又回滚为5000。 最后， 事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。 2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 例如： 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。 与此同时， 事务B把张三的工资改为8000，并提交了事务。 随后， 在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 例如： 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。 此时， 事务B插入一条工资也为5000的记录。 这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 4、提醒 不可重复读的重点是修改： 同样的条件，你读取过的数据，再次读取出来发现值不一样了 幻读的重点在于新增或者删除： 同样的条件，第 1 次和第 2 次读出来的记录数不一样 5、第一类丢失更新 A事务撤销时，把已经提交的B事务的更新数据覆盖了。例如： 这时候取款事务A撤销事务，余额恢复为1000，这就丢失了更新。 6、第二类丢失更新 A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失 ","date":"2021-08-25","objectID":"/mysql-transact/:1:1","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"二、如何解决 为了解决上述问题，数据库通过 锁机制解决并发访问的问题。根据锁定对象不同：分为行级锁和表级锁；根据并发事务锁定的关系上看：分为共享锁定和独占锁定，共享锁定会防止独占锁定但允许其他的共享锁定。而独占锁定既防止共享锁定也防止其他独占锁定。为了更改数据，数据库必须在进行更改的行上施加行独占锁定，insert、update、delete和selsct for update语句都会隐式采用必要的行锁定。 但是直接使用锁机制管理是很复杂的，基于锁机制，数据库给用户提供了不同的 事务隔离级别，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的锁。 不同的隔离级别对并发问题的解决情况如图： 注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低。 ","date":"2021-08-25","objectID":"/mysql-transact/:1:2","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"什么是数据库ACID? 事务在当今的企业系统无处不在，即使在高并发环境下也可以提供数据的完整性。一个事务是一个只包含所有读/写操作成功的集合。如下图： 一个事务本质上有四个特点ACID： Atomicity原子性 Consistency一致性 Isolation隔离性 Durability耐久性 ","date":"2021-08-25","objectID":"/mysql-transact/:2:0","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"原子性 原子性任务是一个独立的操作单元，是一种要么全部是，要么全部不是的原子单位性的操作。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:1","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"一致性 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。 一致性有下面特点： 如果一个操作触发辅助操作（级联，触发器），这些也必须成功，否则交易失败。 如果系统是由多个节点组成，一致性规定所有的变化必须传播到所有节点（多主复制）。如果从站节点是异步更新，那么我们打破一致性规则，系统成为\"最终一致性\"。 一个事务是数据状态的切换，因此，如果事务是并发多个，系统也必须如同串行事务一样操作。 在现实中，事务系统遭遇并发请求时，这种串行化是有成本的， Amdahl法则描述如下：它是描述序列串行执行和并发之间的关系。 “一个程序在并行计算情况下使用多个处理器所能提升的速度是由这个程序中串行执行部分的时间决定的。” 大多数数据库管理系统选择（默认情况下）是放宽一致性，以达到更好的并发性。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:2","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"隔离性 事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:3","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"耐久性 一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。 尽管一些数据库系统提供多版本并发控制 MVCC, 他们的并发控制都是通过锁完成，因此，锁会增加执行的串行性，影响并发性。 SQL标准规定了四个隔离水平： READ_UNCOMMITTED READ_COMMITTED REPETABLE_READ SERIALIZABLE 隔离级别 脏读 非重复读 Phantom read READ_UNCOMMITTED allowed allowed allowed READ_COMMITTED prevented allowed allowed REPETABLE_READ prevented prevented allowed SERIALIZABLE prevented prevented prevented ","date":"2021-08-25","objectID":"/mysql-transact/:2:4","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"脏读 脏读发生在：当一个事务允许读取一个被其他事务改变但是未提交的状态时，这是因为并没有锁阻止读取，如上图，你看到第二个事务读取了一个并不一致的值，不一致的意思是，这个值是无效的，因为修改这个值的第一个事务已经回滚，也就是说，第一个事务修改了这个值，但是未提交确认，却被第二个事务读取，第一个事务又放弃修改，悔棋了，而第二个事务就得到一个脏数据。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:5","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"非重复读 反复读同一个数据却得到不同的结果，这是因为在反复几次读取的过程中，数据被修改了，这就导致我们使用了stale数据，这可以通过一个共享读锁来避免。这是隔离级别READ_COMMITTED会导致可重复读的原因。设置共享读锁也就是隔离级别提高到REPETABLE_READ。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:6","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"Phantom 读 当第二个事务插入一行记录，而正好之前第一个事务查询了应该包含这个新纪录的数据，那么这个查询事务的结果里肯定没有包含这个刚刚新插入的数据，这时幻影读发生了，通过变化锁和predicate locking避免。 下图是主流数据库的默认隔离级别： Database Default isolation Level Oracle READ_COMMITTED MySQL REPETABLE_READ Microsoft SQL Server READ_COMMITTED PostgreSQL READ_COMMITTED DB2 CURSOR STABILITY (a.k.a READ_COMMITTED) READ_COMMITED 是正确的选择，因为SERIALIZABLE虽然能在不同事务发生时避免stale数据，也就是避免上述丢失刚刚修改的数据，但是性能是最低的，因为是一种最大化的串行。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:7","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Net","note"],"content":"记录HTTP教程的笔记","date":"2021-08-25","objectID":"/http/","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net","note"],"content":"HTTP状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 ","date":"2021-08-25","objectID":"/http/:1:0","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net","note"],"content":"HTTP状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1 信息，服务器收到请求，需要请求者继续执行操作 2 成功，操作被成功接收并处理 3 重定向，需要进一步的操作以完成请求 4 客户端错误，请求包含语法错误或无法完成请求 5 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 笑谈 程序员最想看到的：200-OK。 程序员不想看到的：500-Internal-Server-Error。 用户不想看到的：401-Unauthorized、403-Forbidden、408-Request-Time-out。 ","date":"2021-08-25","objectID":"/http/:2:0","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net"],"content":"记录GET和POST两种基本请求方法的区别","date":"2021-08-25","objectID":"/http-get-post-diff/","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"引言 GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:1:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"w3schools\"标准答案\" GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:2:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"对比 GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 解释w3schools答案 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 参数大小限制 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案\"里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:3:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"其他讨论 GET和POST还有一个重大区别 简单的说 GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼\"嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:4:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Software","note"],"content":"记录解决chrome浏览器图标缓存问题的笔记","date":"2021-08-25","objectID":"/chrome-favicon/","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Software","note"],"content":"一、先解决图标缓存问题 尝试解决 清空浏览器缓存，无效 直接访问图片地址，无效 删除本地favicon缓存文件，有效 C:\\Users\\xxxxxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default 其中xxxxxx为用户名 **删除Favicons文件** 你可以将Favicons文件移到其他位置，如果直接删除Favicons文件，会出现以前添加的书签都没有图标，除此之外没有其他影响，当你重新访问网站图标会重新加载出来缓存进Favicons文件，如图，建议先将Favicons移动其他位置 ","date":"2021-08-25","objectID":"/chrome-favicon/:1:0","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Software","note"],"content":"二、修改网站图标 vue项目修改网站图标，方法①是html通用的，有如下两种方法 我的图标位置 ①、vue项目直接修改全局 index.html 文件，其他项目可以根据你的页面布局添加，通过 link 标签引入图标 \u003clink rel=\"shortcut icon\" href=\"/static/favicon.ico\"\u003e \u003clink rel=\"shortcut icon\" type=\"image/x-icon\" href=\"/static/ico1.jpg\"\u003e ②、仅支持vue项目，针对开发环境，发布环境类似，修改 webpack.dev.conf.js 文件，找到 new HtmlWebpackPlugin 添加 favicon: ‘./static/favicon.ico’，你的图标路径，注意有个点 打开网站可以看到图标 方法① 方法② 注意： 发现一个问题，方法②比方法①优先级高 方法①②都设置，以先加载的那个为准，方法②先加载 推荐一个好用的网站 我的网站图标就是用工具生成的 ","date":"2021-08-25","objectID":"/chrome-favicon/:2:0","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Operation","note"],"content":"记录Git仓库之间交互指令教程的笔记","date":"2021-08-25","objectID":"/git-mutual-note/","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Push ","date":"2021-08-25","objectID":"/git-mutual-note/:1:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"目标 当远程仓库仅有一个且本地和远程都只有一个分支时可以省略主机名、本地分支名、远程分支名 git push 当远程仓库仅有一个且本地分支和远程分支同名时，将本地[branch]分支推送至origin主机的对应分支 git push origin [branch] 将本地mybranch1与origin主机的对应分支建立管道，以后允许使用git push省略提交。 两条指令小小的区别为-u在origin主机没有对应分支时会创建分支完成提交，但是时下面那条指令是不能完成提交的，仅仅在远程存在对应分支的情况下允许提交。 git push -u origin mybranch1 git branch --set-upstream-to=origin/mybranch1 mybranch1 ","date":"2021-08-25","objectID":"/git-mutual-note/:1:1","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"范围 提交所有本地分支到远程对应分支 git push --all ","date":"2021-08-25","objectID":"/git-mutual-note/:1:2","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"条件 强制推送，不考虑版本迭代，特别是允许旧版本覆盖新版本从而导致之前提交内容丢失。官方文档仅建议我们最多强制推送一个分支 git push [-f | --force] git push origin [branch] [-f | --force] # 官方建议 删除所有提交，等于在当前分支前加: git push [-d | --delete | :[branch]] ","date":"2021-08-25","objectID":"/git-mutual-note/:1:3","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Remote 显示所有的远程仓库 git remote -v 显示某个远程仓库信息 git remote show [remote] 添加远程版本库，shortname类似Id git remote add [shortname] [url] 删除 git remote rm name # 删除远程仓库 修改 git remote rename old_name new_name # 修改仓库名 ","date":"2021-08-25","objectID":"/git-mutual-note/:2:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Fork 一般在别人仓库页面如Gitee/Github/Gitlab复制一份代码到自己的仓库页面 ","date":"2021-08-25","objectID":"/git-mutual-note/:3:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Fetch 从远程仓库获取代码 git fetch [shortname] ","date":"2021-08-25","objectID":"/git-mutual-note/:4:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Merge 将shortname主机的branch分支代码合并到当前本地开发分支 git merge [shortname]/[branch] ","date":"2021-08-25","objectID":"/git-mutual-note/:5:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Pull 等价于Fetch+Merge，但是不推荐使用，不能清晰查看分支间变更。 git pull origin [branch] ","date":"2021-08-25","objectID":"/git-mutual-note/:6:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Clone 将仓库代码完成克隆一份到本地 git clone [-b][branch] [url] -b参数不加为克隆默认分支（default）加 上-b 可以在后面添加分支名称，克隆特定分支代码 ","date":"2021-08-25","objectID":"/git-mutual-note/:7:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Software","note"],"content":"记录Intellij IDEA教程的笔记","date":"2021-08-25","objectID":"/idea-note/","tags":["Ide","Idea","Java"],"title":"Intellij IDEA教程","uri":"/idea-note/"},{"categories":["Software","note"],"content":"使用Intellij IDEA的Bookmarks 今天用idea的时候，无意按了什么，发现了了一个小功能，叫做BookMark 然后去查阅了一下文档，主要功能也就是可以清晰的看到自己标的书签附近的代码，比如我们在第11行 按一下F11插入一个书签，就会有一个小钩子。 我们可以按 Shift+F11就可以直接看到11行附近的代码 如果有多个书签，在打开这个书签管理的时候，可以完全使用键盘进行控制：按上下键进行选择,Enter键跳转到所选的书签那，Esc关闭窗口，Alt+上/下可以在这个列表将某个书签以Y轴移动。 我们还可以使用以（ 助记符）数字作为书签，在所在行按快捷键 Ctrl+Shift+任意数字，就可以插入一个标签了，要将光标跳转到某个书签，只需要 Ctrl+对应的标签数字。实在是很方便。 ","date":"2021-08-25","objectID":"/idea-note/:1:0","tags":["Ide","Idea","Java"],"title":"Intellij IDEA教程","uri":"/idea-note/"},{"categories":["Software","note"],"content":"Idea多级目录与单级目录切换 ","date":"2021-08-25","objectID":"/idea-note/:2:0","tags":["Ide","Idea","Java"],"title":"Intellij IDEA教程","uri":"/idea-note/"},{"categories":["Software","note"],"content":"记录IntelliJ IDEA统计代码行数插件教程的笔记","date":"2021-08-25","objectID":"/idea-count-lines-note/","tags":["Idea","Plugin"],"title":"IntelliJ IDEA统计代码行数插件教程","uri":"/idea-count-lines-note/"},{"categories":["Software","note"],"content":"安装步骤 第一步首先需要知道idea统计项目代码行数，主要是使用Statistic插件来统计，点击File-\u003eSettings，如下图所示： 第二步进去Settings界面之后，点击Plugins，然后点击下方正中间的Browse repositories，如下图所示： 第三步进去插件应用之后，搜索Statistic，选中之后，点击右侧的Install进行安装插件，如下图所示： 第四步等待几秒钟，插件就安装成功了，点击close，如下图所示： 第五步返回上一界面，可以看到Statistic插件，点击OK之后，会要求重启idea，如下图所示： 第六步重启idea之后，在左下方可以看到Statistic，点击，可以看到项目代码的行数，如下图所示： ","date":"2021-08-25","objectID":"/idea-count-lines-note/:1:0","tags":["Idea","Plugin"],"title":"IntelliJ IDEA统计代码行数插件教程","uri":"/idea-count-lines-note/"},{"categories":["Software","note"],"content":"详解 ​ 1）名称解释： ​ Refresh 对当前项目代码统计 ​ Refresh on selection 对当前打开文件的代码统计 ​ Setting 配置项 ​ 2）Overview 全局统计 ​ Extension 按扩展名分类 ​ Count 文件数 ​ Size SUM 文件大小，单位KB ​ Size MIN 最小文件大小 ​ Size MAX 最大文件大小 ​ Size AVG 平均文件大小 ​ Lines 代码行数（包含注释和空行） ​ Lines MIN 最小行数 ​ Lines MAX 最大行数 ​ Lines AVG 平均行数 ​ Lines CODE 代码行数（不包含注释和空行） ​ 3）指定的文件，比如java/xml等 ​ Source File 文件名称 ​ Total Lines 总行数（包含注释和空行） ​ Source Code Lines 源代码行数（不包含注释和空行） ​ Source Code Lines[%] 源代码占比 ​ Comment Lines 注释行数 ​ Comment Lines[%] 空行占比 ​ Blank Lines 空行数 ​ Blank Lines[%] 空行占比 ​ 4）Settings ​ 纳入统计范围的文件，按后缀区分。 ","date":"2021-08-25","objectID":"/idea-count-lines-note/:2:0","tags":["Idea","Plugin"],"title":"IntelliJ IDEA统计代码行数插件教程","uri":"/idea-count-lines-note/"},{"categories":["Software"],"content":"记录Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包的解决办法","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Software"],"content":"报错 如图 Cannot resolve xxx package ","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/:1:0","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Software"],"content":"解决 请教同事后要求切换Idea自带的Maven，自己安装的Maven不行 ","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/:2:0","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Back"],"content":"记录Idea格式化Xml后替换换行符接口提交报错的解决办法","date":"2021-08-24","objectID":"/xml-idea-format-error/","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"现象 使用Swagger或者Postman访问均报错500 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:1:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"分析 流程是在Idea中将Xml写好，使用Idea带正则的替换，将\\n替换为空，改变为一行，再放到Swagger中进行执行。 由于程序是部署的怀疑参数问题，换了几种xml，发现部分会报错，认为是xml问题，检查后发现端倪 如图二者多了一个换行，遥想学习汇编时老师所讲的回车和换行是两回事。于是拿出根本方法Winhex二进制对比。发现二进制下确实多了0A，但是\\n只替换了换行，回车还在，才造成了后台500的问题 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:2:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"解决 格式化代码后再换成一行再替换就好了，\\s慎用，应为Xml头信息属性间还是有空格的，所以还是换成一行替换\\n比较好 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:3:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Software"],"content":"记录win10报错“无法编辑写该值的新内容时出错”的解决办法","date":"2021-08-24","objectID":"/reg-auth-error/","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Software"],"content":"问题 注册表无法修改删除，提示：无法编辑写该值的新内容时出错的提示 ","date":"2021-08-24","objectID":"/reg-auth-error/:1:0","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Software"],"content":"步骤 1、在无法编辑的注册表键值上右键，菜单中选择\"权限\"； 2、点击\"高级\"按钮； 3、点击所有者后面的\"更改\"按钮； 4、在选择用户或组窗口，点击\"高级\"-“立即查找”； 5、在搜索结果中点击选中搜索结果中的当前用户名（一个头的头像就是），然后点击\"确定\"-“确定”； 6、点击勾选\"Administrator的权限\"项目下面\"完全控制\"后面\"允许\"，然后点击底部\"确定\"即可。 ","date":"2021-08-24","objectID":"/reg-auth-error/:2:0","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Software","note"],"content":"记录Dell新版BIOS教程的笔记","date":"2021-08-24","objectID":"/dell-bios-note/","tags":["System","BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"Dell进入BIOS 开机按F2，和联想的一致，且F12都是进入启动项修改界面 ","date":"2021-08-24","objectID":"/dell-bios-note/:1:0","tags":["System","BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"BIOS永久修改启动项 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:0","tags":["System","BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"Legacey DELL bios操作一次 点击security, PPT security关闭ptt，把ptt on 勾去掉，点击apply （必须点） secure boot 右边打钩. advanced boot option 先选择右侧的第一个勾，点击apply 之后 第二个灰色的那个勾才可以变成可打勾的 ，然后打勾之后在点击apply 建议用–AMpe工具箱_Win10PE//WIN7PE 工具箱V4.0//WePE_32_V2.0 其中BIOS设置中，有两种让他启动进入系统的方法，分别是为UEFI和Legacey 两种模式分别对应的硬盘分区格式： 在Legacy启动模式中，硬盘分区格式应该为MBR格式； 在UEFI启动模式中，硬盘分区格式应该为GUID（GPT）格式。 开机未进入系统是DEL/F2，进入BIOS 在 BIOS 的Boot菜单下，将Secure Boot 改为 Disabled 将Boot List Option 改为 Legacy (BIOS切换到Legacy时：就是USB装系统时使用， BIOS切换到UEFI时：选择“开启(Enable)”;正常win10。) 保存后，重新开机敲击F12，即可看到开机启动选项了。 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:1","tags":["System","BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"UEFI 1、首先笔记本开机，按F2进入BIOS界面。按照图示点开Secure Boot，选中Secure Boot Enable，在右侧取消勾选Secure Boot Enable。 2、在右下角点击Apply保存，重启电脑，再次按F2进入BIOS。按照图示选中Advanced Boot Options，右侧勾选Enable Legacy Option ROMs。 3、再选择图示1处：Boot Sequence，右侧选择Legacy，在图示3处出现U盘选项，将U盘选项上移到第一选项。 4、U盘设置为第一选项后，再次选择UEFI模式，此时，图示3处显示UEFI模式U盘启动，点击Apply保存，插入U盘启动盘，重启电脑即可。 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:2","tags":["System","BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"记录浏览器首页被恶意劫持的解决办法","date":"2021-08-24","objectID":"/browser-hijacked/","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Software","note"],"content":"方法/步骤 当我们打开浏览器时就跳转到下图页面。但实际这并不是出发跳转的页面。 我们打开浏览器选项查看是否被修改。此处没有被恶意修改,那么问题就可能出在注册表中。 按win键-运行-输入\"regedit。exe\" 运行注册表编辑器 “编辑\"菜单—“查找”,输入跳转页面网址,搜索。 下图是搜索到的结果,我们找到罪魁祸首了。 右键–修改—输入你要替换该网址例如:about:blank 当然你也可以直接删除该键值 下图是处理完毕后再次打开浏览器。就可以看到自己要的页面了 ","date":"2021-08-24","objectID":"/browser-hijacked/:1:0","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Software","note"],"content":"其他办法 可以通过360安全卫士或腾讯安全卫士锁定IE首页 浏览网页时注意安全使用 ","date":"2021-08-24","objectID":"/browser-hijacked/:2:0","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Back","note"],"content":"记录SpringCloud使用spring-test进行单元测试教程的笔记","date":"2021-08-23","objectID":"/springcloud-unittset/","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"步骤 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:0","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"1、 新建项目sc-test，对应的pom.xml文件如下 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemalocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelversion\u003e4.0.0\u003c/modelversion\u003e \u003cgroupid\u003espring-cloud\u003c/groupid\u003e \u003cartifactid\u003esc-test\u003c/artifactid\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003cname\u003esc-test\u003c/name\u003e \u003curl\u003ehttp://maven.apache.org\u003c/url\u003e \u003cparent\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-parent\u003c/artifactid\u003e \u003cversion\u003e2.0.4.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003cdependencymanagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.cloud\u003c/groupid\u003e \u003cartifactid\u003espring-cloud-dependencies\u003c/artifactid\u003e \u003cversion\u003eFinchley.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencymanagement\u003e \u003cproperties\u003e \u003cproject.build.sourceencoding\u003eUTF-8\u003c/project.build.sourceencoding\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-data-redis\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.apache.commons\u003c/groupid\u003e \u003cartifactid\u003ecommons-pool2\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-web\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-test\u003c/artifactid\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e --\u003e \u003c/dependencies\u003e \u003c/project\u003e 说明：只要使用spring-boot-starter-test即可，该jar已经包含spring-boot-test ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:1","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"2、 新建spring boot启动类 package sc.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } } 备注：如果没有该类，spring-test启动将报错，见下图 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:2","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"3、 新建操作redis的配置类 package sc.test.config; import java.io.Serializable; import org.springframework.boot.autoconfigure.AutoConfigureAfter; import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration @AutoConfigureAfter(RedisAutoConfiguration.class) public class RedisCacheAutoConfiguration { @Bean public RedisTemplate\u003cString, Serializable\u003e redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) { RedisTemplate\u003cString, Serializable\u003e template = new RedisTemplate\u003c\u003e(); //键的序列化方式 template.setKeySerializer(new StringRedisSerializer()); //值的序列化方式 template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; } } ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:3","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"4、 新建配置文件application.yml server:port:9005spring:application:name:sc-redisredis:host:127.0.0.1password:port:6379timeout:10000# 连接超时时间（毫秒）database:0# Redis默认情况下有16个分片，这里配置具体使用的分片，默认是0lettuce:pool:max-active:8# 连接池最大连接数（使用负值表示没有限制） 默认 8max-wait:-1# 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1max-idle:8# 连接池中的最大空闲连接 默认 8min-idle:0# 连接池中的最小空闲连接 默认 0 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:4","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"5、 新建测试类TestRedis.java package sc.test.unit; import java.io.Serializable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.stream.IntStream; import org.junit.Test; import org.junit.runner.RunWith; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.test.context.junit4.SpringRunner; import sc.test.model.User; @RunWith(SpringRunner.class) @SpringBootTest public class TestRedis { private static final Logger log = LoggerFactory.getLogger(TestRedis.class); @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate\u003cString, Serializable\u003e redisCacheTemplate; @Test public void get() { // 测试线程安全 // ExecutorService executorService = Executors.newFixedThreadPool(1000); // IntStream.range(0, 1000).forEach(i -\u003e // executorService.execute(() -\u003e stringRedisTemplate.opsForValue().increment(\"kk\", 1)) // ); stringRedisTemplate.opsForValue().set(\"key\", \"{'name':'huangjinjin', 'age':30}\"); final String value = stringRedisTemplate.opsForValue().get(\"key\"); log.info(\"[字符缓存结果] - [{}]\", value); String key = \"manage:user:1\"; User u = new User(); u.setId(1L); u.setAge(30); u.setPosition(\"cto\"); u.setUserName(\"good boy\"); redisCacheTemplate.opsForValue().set(key, u); //从缓存获取User对象 final User user = (User) redisCacheTemplate.opsForValue().get(key); log.info(\"[对象缓存结果] - userName={}, age={}, position={}\", // user.getUserName(), user.getAge(), user.getPosition()); } } ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:5","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"6、 进行测试 （1） reids server没有启动时，运行TestRedis.java（右键选择Junit Test） 接不上Reids server异常 （2） reids server启动后时，运行TestRedis.java，出现绿条说明执行代码成功 日志中打印相关数据，说明数据也存贮到redis server中 7、 使用redis-cli验证数据是否正在存档redis server中 有了spring-boot-starter-test，就可以不使用restful接口对spring boot写的接口进行单元测试了。不但可以测试redis，也可以测试数据库的增删查改。可以使用spring中的各种注解，注入对象。 源码：https://gitee.com/hjj520/spring-cloud-2.x ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:6","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["documentation","note"],"content":"记录Office使用教程的笔记","date":"2021-08-23","objectID":"/office-note/","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"新版本Office（2016或更新）制作渐变色艺术字效果 ","date":"2021-08-23","objectID":"/office-note/:1:0","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"引言 我们在需要艺术字的时候，一般都会想到使用PS来制作，如果电脑上没有安装PS，或是只是做几个简单点的艺术字的话，那就直接使用word2016吧，word2016也可以制作出漂亮的艺术字哦，下面我们就一起来看一下如何使用word2016制作艺术字吧。 ","date":"2021-08-23","objectID":"/office-note/:1:1","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"步骤 1、首先在word2016中输入要制作的艺术字，本文就以\" 百度经验\"为例来进行说明吧，输入后选中刚刚输入的字，然后在弹出的菜单中把字体设置为\" 黑体\"，字号设置的大一点，如72 2、接下来点击开始菜单工具栏上的\" 字体颜色“下拉按钮，在弹出菜单中选择” 渐变“菜单项 3、这时会弹出渐变菜单，在弹出的菜单中选择” 其它渐变“菜单项 4、在右侧弹出的” 设置文本效果格式“菜单中，选择” 渐变填充“一项 5、接下来在” 预设渐变“右侧的下拉菜单中选择一个渐变样式 6、接着在类型与方向的下拉菜单中分别设置好，这个过程中可以看一下输入的文本，会随着设置的变化而自动变化，直到我们满意为止 7、接下来就是要设置” **渐变光圈\"**了，渐变光圈的作用就是设置渐变的颜色与渐变的位置，选中第一个渐变光圈，然后在下面的\" 颜色“下拉菜单中设置好颜色 8、这时就可以看到原来输入的文本已变化了，变成了我们设置的第一个渐变光圈的颜色 9、接下来我们设置剩余的渐变光圈颜色、位置、透明度与亮度等等，如果感觉渐变光圈不够用的话，可以手工添加渐变光圈的个数 10、设置好后，我们可以看一下新生产的渐变字，是不是已经有点PS差不多的效果了啊 11、另外我们也可以点击下面的” 文本边框“一项，设置渐变色的边框，可以根据我们的需要通过下面的各项进行设置就可以了，同时可以随时查看左侧渐变字的效果，随意调整。 12、最后我们看一下生成的渐变艺术字吧，是不是很漂亮啊，几乎与PS的效果是一样的哦。 ","date":"2021-08-23","objectID":"/office-note/:1:2","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"Word标题中的文字底色图案如何去掉 ","date":"2021-08-23","objectID":"/office-note/:2:0","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"对于标题 选中后右键修改样式去图案 ","date":"2021-08-23","objectID":"/office-note/:2:1","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"对于全局 选中后页面布局-\u003e边框 页面底纹 ","date":"2021-08-23","objectID":"/office-note/:2:2","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"记录Markdown让文字居中和带颜色的笔记","date":"2021-08-23","objectID":"/md-font-center-size/","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"1.说明 本文主要叙述如何写出更加优美的markdown文档。在我们观看文档的过程中，良好的格式将会带来很大的收益。对于不同颜色的字体也并不会显得花里胡哨，只会让我们表达的内容更加的清晰。下面来具体的看一下操作的流程。 ","date":"2021-08-23","objectID":"/md-font-center-size/:1:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"2. 文字的居中 对于标准的markdown文本，是不支持居中对齐的。还好markdown支持html语言，所以我们采用html语法格式即可。 \u003ccenter\u003e这一行需要居中\u003c/center\u003e 下面就是排版后的结果 这一行需要居中\r","date":"2021-08-23","objectID":"/md-font-center-size/:2:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.文字的字体及颜色 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.1 字体更换 同样我们也需要遵照其标准的语法格式 \u003cfont face=\"黑体\"\u003e我是黑体字\u003c/font\u003e 下面是测试结果 我是黑体字 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:1","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.2 大小更换 大小为size \u003cfont face=\"黑体\" size=10\u003e我是黑体字\u003c/font\u003e 我是黑体字 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:2","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.3 颜色替换 对于html语音中，颜色是用color来表示，所以可以表示如下 \u003cfont color=red size=72\u003e颜色\u003c/font\u003e 效果如下 颜色 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:3","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"4 总结 善用markdown语法，记住markdown语法是兼容html预言的，这很重要。 ","date":"2021-08-23","objectID":"/md-font-center-size/:4:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["Back","note"],"content":"记录Java中的包装类(Wrapper Class in Java )的笔记","date":"2021-08-23","objectID":"/java-auto-pkg-note/","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"包装类型的继承结构图 包装类型的继承结构图\r","date":"2021-08-23","objectID":"/java-auto-pkg-note/:1:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是包装类型，包装类型的作用是什么？ Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。 我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:2:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"包装类的应用场景 1、集合类泛型只能是包装类； // 编译报错 List\u003cint\u003e list1 = new ArrayList\u003c\u003e(); // 正常 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(); 2、成员变量不能有默认值； private int status; 基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。 3、方法参数允许定义空值； private static void test1(int status){ System.out.println(status); } 看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:3:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"自动装箱、拆箱机制 在Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:4:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是自动装箱？ 自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。 Integer i1 = new Integer(8); Integer i2 = Integer.valueOf(8); // 自动装箱 Integer i3 = 8; 以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。 其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:5:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是自动拆箱？ 自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。 // 自动拆箱 int i4 = i3; int i5 = i3.intValue(); 继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。 自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。 需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。 参考链接：深入浅出 Java 中的包装类 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:6:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Net","note"],"content":"记录URL汉字编码问题（及乱码解决）的笔记","date":"2021-08-23","objectID":"/url-code-note/","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"一、问题的由来 URL就是网址，只要上网，就一定会用到。 一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。比如，世界上有英文字母的网址 “http://www.abc.com”，但是没有希腊字母的网址\"http://www.aβγ.com\"（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC 1738 ;做了硬性规定： “…Only alphanumerics [0-9a-zA-Z], the special characters “$-.+!*'(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.” “只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-.+!*'(),\"[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。\" 这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致\"URL编码\"成为了一个混乱的领域。 下面就让我们看看，“URL编码\"到底有多混乱。我会依次分析四种不同的情况，在每一种情况中，浏览器的URL编码方法都不一样。把它们的差异解释清楚之后，我再说如何用Javascript找到一个统一的编码方法。 ","date":"2021-08-23","objectID":"/url-code-note/:1:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"二、情况1：网址路径中包含汉字 打开IE（我用的是8.0版），输入网址” http://zh.wikipedia.org/wiki/春节 “。注意，“春节\"这两个字此时是网址路径的一部分。 查看HTTP请求的头信息，会发现IE实际查询的网址是” http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82 “。也就是说，IE自动将\"春节\"编码成了”%E6%98%A5%E8%8A%82”。 我们知道，“春\"和\"节\"的utf-8编码分别是\"E6 98 A5\"和\"E8 8A 82”，因此，\"%E6%98%A5%E8%8A%82\"就是按照顺序，在每个字节前加上%而得到的。（具体的转码方法，请参考我写的《字符编码笔记》。） 在Firefox中测试，也得到了同样的结果。所以， 结论1就是，网址路径的编码，用的是utf-8编码。 ","date":"2021-08-23","objectID":"/url-code-note/:2:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"三、情况2：查询字符串包含汉字 在IE中输入网址\" http://www.baidu.com/s?wd=春节 “。注意，“春节\"这两个字此时属于查询字符串，不属于网址路径，不要与情况1混淆。 查看HTTP请求的头信息，会发现IE将\"春节\"转化成了一个乱码。 切换到十六进制方式，才能清楚地看到，“春节\"被转成了\"B4 BA BD DA”。 我们知道，“春\"和\"节\"的GB2312编码（我的操作系统\"Windows XP\"中文版的默认编码）分别是\"B4 BA\"和\"BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。 Firefox的处理方法，略有不同。它发送的HTTP Head是\"wd=%B4%BA%BD%DA”。也就是说，同样采用GB2312编码，但是在每个字节前加上了%。 所以， 结论2就是，查询字符串的编码，用的是操作系统的默认编码。 ","date":"2021-08-23","objectID":"/url-code-note/:3:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"四、情况3：Get方法生成的URL包含汉字 前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。 如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。 举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词\"春节”，生成的查询字符串是不一样的。 百度生成的是%B4%BA%BD%DA，这是GB2312编码。 Google生成的是%E6%98%A5%E8%8A%82，这是UTF-8编码。 所以， 结论3就是，GET和POST方法的编码，用的是网页的编码。 ","date":"2021-08-23","objectID":"/url-code-note/:4:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"五、情况4：Ajax调用的URL包含汉字 前面三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用。还是根据吕瑞麟老师的文章，在这种情况下，IE和Firefox的处理方式完全不一样。 举例来说，有这样两行代码： url = url + “?q=” +document.myform.elements[0].value; // 假定用户在表单中提交的值是\"春节\"这两个字 http_request.open(‘GET’, url, true); 那么，无论网页使用什么字符集，IE传送给服务器的总是\"q=%B4%BA%BD%DA\"，而Firefox传送给服务器的总是\"q=%E6%98 %A5%E8%8A%82\"。也就是说， 在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。这就是我们的结论4。 ","date":"2021-08-23","objectID":"/url-code-note/:5:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"六、Javascript函数：escape() 好了，到此为止，四种情况都说完了。 假定前面你都看懂了，那么此时你应该会感到很头痛。因为，实在太混乱了。不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果。如果程序员要把每一种结果都考虑进去，是不是太恐怖了？有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？ 回答是有的，就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。 Javascript语言用于编码的函数，一共有三个，最古老的一个就是escape()。虽然这个函数现在已经不提倡使用了，但是由于历史原因，很多地方还在使用它，所以有必要先从它讲起。 实际上，escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如\"春节\"的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春\"是第6625个（十六进制）字符，“节\"是第8282个（十六进制）字符。 它的具体规则是，除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码。在\\u0000到\\u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是 unescape()。 所以，“Hello World\"的escape()编码就是\"Hello%20World”。因为空格的Unicode值是20（十六进制）。 还有两个地方需要注意。 首先，无论网页的原始编码是什么，一旦被Javascript编码，就都变为unicode字符。也就是说，Javascipt函数的输入和输出，默认都是Unicode字符。这一点对下面两个函数也适用。 其次，escape()不对”+“编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 ","date":"2021-08-23","objectID":"/url-code-note/:6:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"七、Javascript函数：encodeURI() encodeURI()是Javascript中真正用来对URL编码的函数。 它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ \u0026 = + $ , #\"，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。 它对应的解码函数是decodeURI()。 需要注意的是，它不对单引号’编码。 ","date":"2021-08-23","objectID":"/url-code-note/:7:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"八、Javascript函数：encodeURIComponent() 最后一个Javascript编码函数是encodeURIComponent()。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。 因此，\"; / ? : @ \u0026 = + $ , #\"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。 它对应的解码函数是decodeURIComponent()。 ","date":"2021-08-23","objectID":"/url-code-note/:8:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"PS1 网页里的form编码其实不完全取决于网页编码，form标记中有一个accept-charset属性，在非ie浏览器种，如果将其赋值(比如 accept-charset=“UTF-8”)，则表单会按照这个值表示的编码方式进行提交。 在ie下，我的兼容解决办法是： form1.onsubmit=function(){ document.charset=this.getAttribute(‘accept-charset’); } ","date":"2021-08-23","objectID":"/url-code-note/:9:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"PS2 字符编码笔记：ASCII，Unicode和 UTF-8 1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从 0000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。 ASCII码一共规定了128个字符的编码，比如空格\"SPACE\"是32（二进制00100000），大写的字母A是65（二进制 01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 2、非ASCII编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和 UTF-8是毫无关系的。 3.Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 4. Unicode的问题 需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode 在很长一段时间内无法推广，直到互联网的出现。 5.UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF- 16和UTF-32，不过在互联网上基本不用。 重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 2）对于n字节的符号（n\u003e1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ——————–+——————————————— 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 下面，还是以汉字\"严\"为例，演示如何实现UTF-8编码。 已知\"严\"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此\"严\"的UTF-8编码需要三个字节，即格式是\"1110xxxx 10xxxxxx 10xxxxxx\"。然后，从\"严\"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严\"的UTF-8编码是 “11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 6. Unicode与UTF-8之间的转换 通过上一节的例子，可以看到\"严\"的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击\"文件\"菜单中的\"另存为\"命令，会跳出一个对话框，在最底部有一个\"编码\"的下拉条。 里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。 1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。 2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。 3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。 4）UTF-8编码，也就是上一节谈到的编码方法。 选择完\"编码方式\"后，点击\"保存\"按钮，文件的编码方式就立刻转换好了。 7. Little endian和Big endian 上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字\"严\"为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big- Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 因此，第一个字节在前，就是\"大头方式”（Big endian），第二个字节在前就是\"小头方式\"（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 8. 实例 下面，举一个实例。 打开\"记事本\"程序Notepad.exe，新建一个文本文件，内容就是一个\"严\"字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。 1）ANSI：文件的编码就是两个字节\"D1 CF\"，这正是\"严\"的GB2312编码，这也暗示GB2312是采用大头方式存储的。 2）Unicode：编码是四个字节\"FF FE 25 4E\"，其中\"FF FE\"表明是小头方式存储，","date":"2021-08-23","objectID":"/url-code-note/:10:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Back"],"content":"记录URL含中文时后代码重定向时中文接收不到的解决办法","date":"2021-08-23","objectID":"/url-zh-cn-code-error/","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"问题 Url的中文接收不到 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:1:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"分析 Url中不能直接存在中文，需要进行编码，使用源码。程序中使用的是编码的中文 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:2:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"解决 重定向前将中文使用utf-8进行编码 tableName = URLEncoder.encode(tableName,\"utf-8\");//首先通过utf-8进行编码 在被重定向的接口使用utf-8解码 tableName = URLDecoder.decode(tableName,\"utf-8\");//再用utf-8解码，我的页面使用的utf-8编码 问题完美解决 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:3:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["documentation","note"],"content":"记录Csdn转换为Markdown工具使用教程的笔记","date":"2021-08-23","objectID":"/csdn-download-markdown-note/","tags":["Csdn","Markdown"],"title":"Csdn转换为Markdown工具使用教程","uri":"/csdn-download-markdown-note/"},{"categories":["documentation","note"],"content":"推荐 ➹ Clean-mark, 这是一个很棒的工具，针对你的需求；它可以将博客文章转换为干净的Markdown文本文件。 安装： npm install clean-mark --global 使用: clean-mark \"http://some-website.com/fancy-article\" 示例： clean-mark \"https://jeffjade.com/2017/12/31/136-talk-about-nicelinks-site/\" 更多特质可参见：https://github.com/croqaz/clean-mark#why- 。 ","date":"2021-08-23","objectID":"/csdn-download-markdown-note/:0:0","tags":["Csdn","Markdown"],"title":"Csdn转换为Markdown工具使用教程","uri":"/csdn-download-markdown-note/"},{"categories":["Front"],"content":"记录nfound 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details的区别错误的办法","date":"2021-08-23","objectID":"/vue-install-error/","tags":["JavaScript","Js","Vue","Error"],"title":"found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details","uri":"/vue-install-error/"},{"categories":["Front"],"content":"报错 npm 安装包之后，如果出现类似下面的信息 found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details 如果 npm audit fix，之后还是有问题，可能是不能自动 fix，尽量不要 --force 强制 fix。 可以先 npm update，然后 npm audit 查看详情，再手动安装相关库。 ","date":"2021-08-23","objectID":"/vue-install-error/:1:0","tags":["JavaScript","Js","Vue","Error"],"title":"found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details","uri":"/vue-install-error/"},{"categories":["Back","note"],"content":"记录Spring Boot Actuator的笔记","date":"2021-08-23","objectID":"/springboot-actuator-note/","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"简介 Spring Boot Actuator可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。 Actuator同时还可以与外部应用监控系统整合，比如 Prometheus, Graphite, DataDog, Influx, Wavefront, New Relic等。这些系统提供了非常好的仪表盘、图标、分析和告警等功能，使得你可以通过统一的接口轻松的监控和管理你的应用。 Actuator使用Micrometer来整合上面提到的外部应用监控系统。这使得只要通过非常小的配置就可以集成任何应用监控系统。 我将把Spring Boot Actuator教程分为两部分： 第一部分(本文)教你如何配置Actuator和通过Http endpoints来进入这些特征。 第二部分教你如何整合Actuator和外部应用监控系统。 ","date":"2021-08-23","objectID":"/springboot-actuator-note/:1:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"创建一个有Actuator的Spring Boot工程 首先让我们建一个依赖acutator的简单应用。 你可以使用Spring Boot CLI创建应用： spring init -d=web,actuator -n=actuator actuator 或者，你可以使用Spring Initializr网站来创建应用： Spring initialzr.png\r","date":"2021-08-23","objectID":"/springboot-actuator-note/:2:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"增加Spring Boot Actuator到一个存在的应用 你可以增加spring-boot-actuator模块到一个已经存在的应用，通过使用下面的依赖。 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 对于Gradle，依赖如下： dependencies { compile(\"org.springframework.boot:spring-boot-starter-actuator\") } ","date":"2021-08-23","objectID":"/springboot-actuator-note/:3:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"使用Actuator Endpoints来监控应用 Actuator创建了所谓的endpoint来暴露HTTP或者JMX来监控和管理应用。 举个例子，有一个叫/health的endpoint，提供了关于应用健康的基础信息。/metricsendpoints展示了几个有用的度量信息，比如JVM内存使用情况、系统CPU使用情况、打开的文件等等。/loggersendpoint展示了应用的日志和可以让你在运行时改变日志等级。 值得注意的是，每一给actuator endpoint可以被显式的打开和关闭。此外，这些endpoints也需要通过HTTP或者JMX暴露出来，使得它们能被远程进入。 让我们运行应用并且尝试进入默认通过HTTP暴露的打开状态的actuator endpoints。之后，我们将学习如何打开更多的endpoints并且通过HTTP暴露它们。 在应用的根目录下打开命令行工具运行以下命令： mvn spring-boot:run 应用默认使用8080端口运行。一旦这个应用启动了，你可以通过http://localhost:8080/actuator来展示所有通过HTTP暴露的endpoints。 {\"_links\":{\"self\":{\"href\":\"http://localhost:8080/actuator\",\"templated\":false},\"health\":{\"href\":\"http://localhost:8080/actuator/health\",\"templated\":false},\"info\":{\"href\":\"http://localhost:8080/actuator/info\",\"templated\":false}}} 打开http://localhost:8080/actuator/health，则会显示如下内容: {\"status\":\"UP\"} 状态将是UP只要应用是健康的。如果应用不健康将会显示DOWN,比如与仪表盘的连接异常或者缺水磁盘空间等。下一节我们将学习spring boot如何决定应用的健康和如何修复这些健康问题。 infoendpoint(http://localhost:8080/actuator/info)展示了关于应用的一般信息，这些信息从编译文件比如META-INF/build-info.properties或者Git文件比如git.properties或者任何环境的property中获取。你将在下一节中学习如何改变这个endpoint的输出。 默认，只有health和info通过HTTP暴露了出来。这也是为什么/actuator页面只展示了health和infoendpoints。我们将学习如何暴露其他的endpoint。首先，让我们看看其他的endpoints是什么。 以下是一些非常有用的actuator endpoints列表。你可以在official documentation上面看到完整的列表。 Endpoint ID Description auditevents 显示应用暴露的审计事件 (比如认证进入、订单失败) info 显示应用的基本信息 health 显示应用的健康状态 metrics 显示应用多样的度量信息 loggers 显示和修改配置的loggers logfile 返回log file中的内容(如果logging.file或者logging.path被设置) httptrace 显示HTTP足迹，最近100个HTTP request/repsponse env 显示当前的环境特性 flyway 显示数据库迁移路径的详细信息 liquidbase 显示Liquibase 数据库迁移的纤细信息 shutdown 让你逐步关闭应用 mappings 显示所有的@RequestMapping路径 scheduledtasks 显示应用中的调度任务 threaddump 执行一个线程dump heapdump 返回一个GZip压缩的JVM堆dump ","date":"2021-08-23","objectID":"/springboot-actuator-note/:4:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"打开和关闭Actuator Endpoints 默认，上述所有的endpints都是打开的，除了shutdown endpoint。 你可以通过设置management.endpoint.\u003cid\u003e.enabled to true or false(id是endpoint的id)来决定打开还是关闭一个actuator endpoint。 举个例子，要想打开shutdown endpoint，增加以下内容在你的application.properties文件中： management.endpoint.shutdown.enabled=true ","date":"2021-08-23","objectID":"/springboot-actuator-note/:5:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"暴露Actuator Endpoints 默认，素偶偶的actuator endpoint通过JMX被暴露，而通过HTTP暴露的只有health和info。 以下是你可以通过应用的properties可以通过HTTP和JMX暴露的actuator endpoint。 通过HTTP暴露Actuator endpoints。 # Use \"*\" to expose all endpoints, or a comma-separated list to expose selected ones management.endpoints.web.exposure.include=health,info management.endpoints.web.exposure.exclude= 通过JMX暴露Actuator endpoints。 # Use \"*\" to expose all endpoints, or a comma-separated list to expose selected ones management.endpoints.jmx.exposure.include=* management.endpoints.jmx.exposure.exclude= 通过设置management.endpoints.web.exposure.include为*，我们可以在http://localhost:8080/actuator页面看到如下内容。 {\"_links\":{\"self\":{\"href\":\"http://localhost:8080/actuator\",\"templated\":false},\"auditevents\":{\"href\":\"http://localhost:8080/actuator/auditevents\",\"templated\":false},\"beans\":{\"href\":\"http://localhost:8080/actuator/beans\",\"templated\":false},\"health\":{\"href\":\"http://localhost:8080/actuator/health\",\"templated\":false},\"conditions\":{\"href\":\"http://localhost:8080/actuator/conditions\",\"templated\":false},\"configprops\":{\"href\":\"http://localhost:8080/actuator/configprops\",\"templated\":false},\"env\":{\"href\":\"http://localhost:8080/actuator/env\",\"templated\":false},\"env-toMatch\":{\"href\":\"http://localhost:8080/actuator/env/{toMatch}\",\"templated\":true},\"info\":{\"href\":\"http://localhost:8080/actuator/info\",\"templated\":false},\"loggers\":{\"href\":\"http://localhost:8080/actuator/loggers\",\"templated\":false},\"loggers-name\":{\"href\":\"http://localhost:8080/actuator/loggers/{name}\",\"templated\":true},\"heapdump\":{\"href\":\"http://localhost:8080/actuator/heapdump\",\"templated\":false},\"threaddump\":{\"href\":\"http://localhost:8080/actuator/threaddump\",\"templated\":false},\"prometheus\":{\"href\":\"http://localhost:8080/actuator/prometheus\",\"templated\":false},\"metrics-requiredMetricName\":{\"href\":\"http://localhost:8080/actuator/metrics/{requiredMetricName}\",\"templated\":true},\"metrics\":{\"href\":\"http://localhost:8080/actuator/metrics\",\"templated\":false},\"scheduledtasks\":{\"href\":\"http://localhost:8080/actuator/scheduledtasks\",\"templated\":false},\"httptrace\":{\"href\":\"http://localhost:8080/actuator/httptrace\",\"templated\":false},\"mappings\":{\"href\":\"http://localhost:8080/actuator/mappings\",\"templated\":false}}} ","date":"2021-08-23","objectID":"/springboot-actuator-note/:6:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"解析常用的actuator endpoint ","date":"2021-08-23","objectID":"/springboot-actuator-note/:7:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"/health endpoint health endpoint通过合并几个健康指数检查应用的健康情况。 Spring Boot Actuator有几个预定义的健康指标比如DataSourceHealthIndicator, DiskSpaceHealthIndicator, MongoHealthIndicator, RedisHealthIndicator, CassandraHealthIndicator等。它使用这些健康指标作为健康检查的一部分。 举个例子，如果你的应用使用Redis，RedisHealthindicator将被当作检查的一部分。如果使用MongoDB，那么MongoHealthIndicator将被当作检查的一部分。 你也可以关闭特定的健康检查指标，比如在prpperties中使用如下命令： management.health.mongo.enabled=false 默认，所有的这些健康指标被当作健康检查的一部分。 显示详细的健康信息 health endpoint只展示了简单的UP和DOWN状态。为了获得健康检查中所有指标的详细信息，你可以通过在application.yaml中增加如下内容： management: endpoint: health: show-details: always 一旦你打开上述开关，你在/health中可以看到如下详细内容： {\"status\":\"UP\",\"details\":{\"diskSpace\":{\"status\":\"UP\",\"details\":{\"total\":250790436864,\"free\":27172782080,\"threshold\":10485760}}}} health endpoint现在包含了DiskSpaceHealthIndicator。 如果你的应用包含database(比如MySQL)，health endpoint将显示如下内容： { \"status\":\"UP\", \"details\":{ \"db\":{ \"status\":\"UP\", \"details\":{ \"database\":\"MySQL\", \"hello\":1 } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":100330897408, \"threshold\":10485760 } } } } 如果你的MySQL server没有启起来，状态将会变成DOWN： { \"status\":\"DOWN\", \"details\":{ \"db\":{ \"status\":\"DOWN\", \"details\":{ \"error\":\"org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30006ms.\" } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":100324585472, \"threshold\":10485760 } } } } 创建一个自定义的健康指标 你可以通过实现HealthIndicator接口来自定义一个健康指标，或者继承AbstractHealthIndicator类。 package com.example.actuator.health; import org.springframework.boot.actuate.health.AbstractHealthIndicator; import org.springframework.boot.actuate.health.Health; import org.springframework.stereotype.Component; @Component public class CustomHealthIndicator extends AbstractHealthIndicator { @Override protected void doHealthCheck(Health.Builder builder) throws Exception { // Use the builder to build the health status details that should be reported. // If you throw an exception, the status will be DOWN with the exception message. builder.up() .withDetail(\"app\", \"Alive and Kicking\") .withDetail(\"error\", \"Nothing! I'm good.\"); } } 一旦你增加上面的健康指标到你的应用中去后，health endpoint将展示如下细节: { \"status\":\"UP\", \"details\":{ \"custom\":{ \"status\":\"UP\", \"details\":{ \"app\":\"Alive and Kicking\", \"error\":\"Nothing! I'm good.\" } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":97949245440, \"threshold\":10485760 } } } } ","date":"2021-08-23","objectID":"/springboot-actuator-note/:7:1","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"/metrics endpoint metrics endpoint展示了你可以追踪的所有的度量。 { \"names\": [ \"jvm.memory.max\", \"http.server.requests\", \"process.files.max\", ... \"tomcat.threads.busy\", \"process.start.time\", \"tomcat.servlet.error\" ] } 想要获得每个度量的详细信息，你需要传递度量的名称到URL中，像 http://localhost:8080/actuator/metrics/{MetricName} 举个例子，获得systems.cpu.usage的详细信息，使用以下URLhttp://localhost:8080/actuator/metrics/system.cpu.usage。它将显示如下内容: { \"name\": \"system.cpu.usage\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 0 } ], \"availableTags\": [] } ","date":"2021-08-23","objectID":"/springboot-actuator-note/:7:2","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"/loggers endpoint loggers endpoint，可以通过访问http://localhost:8080/actuator/loggers来进入。它展示了应用中可配置的loggers的列表和相关的日志等级。 你同样能够使用http://localhost:8080/actuator/loggers/{name}来展示特定logger的细节。 举个例子，为了获得root logger的细节，你可以使用http://localhost:8080/actuator/loggers/root： { \"configuredLevel\":\"INFO\", \"effectiveLevel\":\"INFO\" } 在运行时改变日志等级 loggers endpoint也允许你在运行时改变应用的日志等级。 举个例子，为了改变root logger的等级为DEBUG ，发送一个POST请求到http://localhost:8080/actuator/loggers/root，加入如下参数 { \"configuredLevel\": \"DEBUG\" } 这个功能对于线上问题的排查非常有用。 同时，你可以通过传递null值给configuredLevel来重置日志等级。 ","date":"2021-08-23","objectID":"/springboot-actuator-note/:7:3","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"/info endpoint info endpoint展示了应用的基本信息。它通过META-INF/build-info.properties来获得编译信息，通过git.properties来获得Git信息。它同时可以展示任何其他信息，只要这个环境property中含有infokey。 你可以增加properties到application.yaml中，比如： # INFO ENDPOINT CONFIGURATION info: app: name: @project.name@ description: @project.description@ version: @project.version@ encoding: @project.build.sourceEncoding@ java: version: @java.version@ 注意，我使用了Spring Boot的Automatic property expansion 特征来扩展来自maven工程的properties。 一旦你增加上面的properties，info endpoint将展示如下信息： { \"app\": { \"name\": \"actuator\", \"description\": \"Demo project for Spring Boot\", \"version\": \"0.0.1-SNAPSHOT\", \"encoding\": \"UTF-8\", \"java\": { \"version\": \"1.8.0_161\" } } } ","date":"2021-08-23","objectID":"/springboot-actuator-note/:7:4","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"使用Spring Security来保证Actuator Endpoints安全 Actuator endpoints是敏感的，必须保障进入是被授权的。如果Spring Security是包含在你的应用中，那么endpoint是通过HTTP认证被保护起来的。 如果没有， 你可以增加以下以来到你的应用中去： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e 接下去让我们看一下如何覆写spring security配置，并且定义你自己的进入规则。 下面的例子展示了一个简单的spring securiy配置。它使用叫做EndPointRequest 的ReqeustMatcher工厂模式来配置Actuator endpoints进入规则。 package com.example.actuator.config; import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest; import org.springframework.boot.actuate.context.ShutdownEndpoint; import org.springframework.boot.autoconfigure.security.servlet.PathRequest; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; @Configuration public class ActuatorSecurityConfig extends WebSecurityConfigurerAdapter { /* This spring security configuration does the following 1. Restrict access to the Shutdown endpoint to the ACTUATOR_ADMIN role. 2. Allow access to all other actuator endpoints. 3. Allow access to static resources. 4. Allow access to the home page (/). 5. All other requests need to be authenticated. 5. Enable http basic authentication to make the configuration complete. You are free to use any other form of authentication. */ @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .requestMatchers(EndpointRequest.to(ShutdownEndpoint.class)) .hasRole(\"ACTUATOR_ADMIN\") .requestMatchers(EndpointRequest.toAnyEndpoint()) .permitAll() .requestMatchers(PathRequest.toStaticResources().atCommonLocations()) .permitAll() .antMatchers(\"/\") .permitAll() .antMatchers(\"/**\") .authenticated() .and() .httpBasic(); } } 为了能够测试以上的配置，你可以在application.yaml中增加spring security用户。 # Spring Security Default user name and password spring: security: user: name: actuator password: actuator roles: ACTUATOR_ADMIN 你可以在Github上看到完整的代码。 ","date":"2021-08-23","objectID":"/springboot-actuator-note/:8:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"更多学习资源 Spring Boot Actuator: Production-ready features Micrometer: Spring Boot 2’s new application metrics collector ","date":"2021-08-23","objectID":"/springboot-actuator-note/:9:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back","note"],"content":"翻译源 Spring Boot Actuator: Health check, Auditing, Metrics gathering and Monitoring ","date":"2021-08-23","objectID":"/springboot-actuator-note/:10:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/springboot-actuator-note/"},{"categories":["Back"],"content":"记录数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function的解决办法","date":"2021-08-23","objectID":"/sql-group-by-error/","tags":["Java","Database","Error"],"title":"数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function","uri":"/sql-group-by-error/"},{"categories":["Back"],"content":"分析 用了聚集函数 前面要select的列必须出现在聚集函数或者groupby里，不然它不知道怎么分配 查询大于平均WEIGHT的零件，列出他们的供应商代码（SNO），零件代码（PNO），工程代码（JNO），供应数量（QTY） insertintoP(Pno,Pname,color,weight)values('P1','螺母','红',12),('P2','螺栓','绿',17),('P3','螺丝刀','蓝',14),('P4','螺丝刀','红',14),('P5','凸轮','蓝',40),('P6','齿轮','红',30);insertintoSPJ(Sno,Pno,Jno,QTY)values('S1','P1','J1',200),('S1','P1','J3',100),('S1','P1','J4',700),('S1','P2','J2',100),('S2','P3','J1',400),('S2','P3','J2',200),('S2','P3','J4',500),('S2','P3','J5',400),('S2','P5','J1',400),('S2','P5','J2',100),('S3','P1','J1',200),('S3','P3','J1',200),('S4','P5','J1',100),('S4','P6','J3',300),('S4','P6','J4',200),('S5','P2','J4',100),('S5','P3','J1',200),('S5','P6','J2',200),('S5','P6','J4',500); 1）查询大于平均WEIGHT的零件，列出他们的供应商代码（SNO），零件代码（PNO），工程代码（JNO），供应数量（QTY） selectsno,spj.pno,jno,qtyfromspj,pwherespj.pno=p.pnoandweight\u003e(selectavg(weight)fromp)selectsno,pno,jno,qtyfromspjwherepnoin(selectpnofrompwhereweight\u003e(selectavg(weight)fromp)) 错误 selectsno,spj.pno,jno,qtyfromspj,pwherespj.pno=p.pnohavingweight\u003e(selectavg(weight)fromp) 错 having要和group by 一起用 ","date":"2021-08-23","objectID":"/sql-group-by-error/:1:0","tags":["Java","Database","Error"],"title":"数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function","uri":"/sql-group-by-error/"},{"categories":["Back"],"content":"记录new与newInstance()的区别","date":"2021-08-23","objectID":"/repository-dao-diff/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"分开解释 Repository：对象仓库。用于对象全部管理，贯穿整个对象的声明周期。 DAO（Data Access Object) ：数据访问对象是一个面向对象的数据库接口，负责对数据库的CRUD。 ","date":"2021-08-23","objectID":"/repository-dao-diff/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"基本关系 Repository通过DAO进行数据库的对象的管理 ","date":"2021-08-23","objectID":"/repository-dao-diff/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"高阶讨论 使用了持久化框架如Hibernate、Mybatis（Plus）等，无需区分Repository与DAO Repository是对象的仓库，也就是保存对象的地方，这个仓库就是我们普通意义的仓库，一个真正OO系统，业务层是围绕活动的对象进行，活动的对象是从仓库中获取的，也是通过交给仓库进行对象长久保管，也就是持久化意思，说白了，就是保存到数据库。 而DAO则没有如此OO概念，DAO是Data access Object，DAO中有数据概念，还是没有摆脱数据库的影子。 所以，Repository替代DAO，是OO深入的趋势，但是在具体处理中，由于性能或设计不够周到或者一些事情把握不定，DAO还会继续存在一段时间，属于过渡式消失。 Repository和DAO两个概念比较中发现，Repository是相对对象而言，而DAO是相对数据库而言，只要我们还是使用关系数据库保存对象，也可能这两者都同时存在，因为侧重点不一样，但是可以肯定的是，业务层应该直接和Repository打交道，而不是DAO. Repository=对象管理（对象工厂+对象缓存+…）+DAO，JiveJdon3中将缓存放在DAO中现在觉得不恰当 Repository的对象可以对外进行解释，如专业人员认为的订单，商品等， DAO更偏于开发人员为了实现开发目的而产生的对象，如外键关系、包含关系等。 DAO是对象访问接口类 接口类=方法的管理类 就是操作数据库的具体方法的类 User UserDAOImpl 就是管理怎么把User对象存进取出数据库的具体方法的类 repository是对象仓库类 仓库类=对象的管理类 User UserRepository 就是管理怎么样才能有效的访问User类的类 UserRepository在必要的时候才调用UserDAOImpl去操作数据库 你也可以吧UserRepository理解为UserCache,当然Repository不仅仅是cache的功能 简单的例子就是如果你有一个Model Object包含着一些Value Object，那么每个Object都回有相应的一个DAO，因为DAO都已经告诉你叫作Data access object，所以，每一个object都需要一个dao来做数据库等地层数据处理。 Reposirtory是对每一个Model Object来说的，一个Reposirtory基本上对应一个Model Object. 比如Person 包含一些Value Object比如address, work 等等，那么 Person就有一个Reposirtory，它里面有相关的方法比如，只是单纯的取出一个Person，然后Load相关的address和work在需要的时候，因为，有时候你不需要一次把所有的Value Object在一个Model Object提取的时候都一次性提出来，那样子叶增加系统负担也会造成资源浪费。 说白了就是Model Object有Reposirtory而Value Object没有，Value Object的基本操作可以用Dao而DDD有明确说明一般所有的对象操作都要面向的是Model Object。 Reposirtory提供对象管理， 管理对象可以通过DAO写入数据库或读取数据库组装对象，或者放入缓存等，这些业务层都不需要知道，业务层只对Reposirtory要求对象管理。 DAO就是数据库访问层，提供数据库CRUD操作。被包含在Reposirtory之内。 如果业务层直接调用DAO层，那么系统设计应该趋向数据库设计。 Repository 是放在BLL的，作为BL访问存取的地方。 而DAO可看成DAL提供BLL的接口，是放在DAL的 至于DAO是不是取消，就看DAL的设计了 业务是只管从仓库（Repository）中取出他所需要的对象，而不关心是从哪里存取，这些是Repository 的事情，Repository 可能通过DAO将数据完成持久化 repository是domain概念，dao是program概念。主要是看问题的角度和层次不同。 ","date":"2021-08-23","objectID":"/repository-dao-diff/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"记录Swagger发请求报错Cannot deserialize value of type java.util.Date的解决办法","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"报错内容 Swagger前台报400 Java后台报错如上图 ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:1:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"分析 时间格式化问题，后台限制了json的格式 格式化实体类日期字段 public class DateT { @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\") Date date; } ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:2:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"解决 按照图片更改即可 ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:3:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Software"],"content":"记录Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]的解决办法","date":"2021-08-23","objectID":"/maven-dump-file-error/","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"原因 使用maven进行打包 install package时报错 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:1:0","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:0","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决一：临时手动操作 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:1","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决二：pom.xml配置 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e\u003c!--编译跳过测试文件检查的生命周期--\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cskip\u003etrue\u003c/skip\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003cresources\u003e \u003c!--如果pro和xml文件放在源码java包下，也需要编译--\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:2","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software","note"],"content":"记录IDEA如何离线使用maven仓库？的笔记","date":"2021-08-23","objectID":"/idea-maven-offline-note/","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Software","note"],"content":"步骤 第一步，将相关的maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压： 第二步，将maven的配置文件settings.xml拷贝一份出来，在localRepository中配置本地仓库的地址。例如我刚才拷贝出来的仓库放在D:/repository下，然后配置下本地的镜像，本地仓库的地址一定要配置正确。 D:/repository下，然后配置下本地的镜像，本地仓库的地址一定要配置正确。 不需要配置localRepository标签，配置一个本地mirror即可 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csettings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"\u003e \u003c!-- \u003clocalRepository\u003eD:/repository\u003c/localRepository\u003e --\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003ecentral\u003c/id\u003e \u003cname\u003ecentral\u003c/name\u003e \u003c!-- 将镜像地址设置为本地maven地址 --\u003e \u003curl\u003efile://D:/repository\u003c/url\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e 第三步，打开IDEA的maven设置：file-\u003esettings搜索maven。注意要将maven设置为Work offline（离线模式），然后将User settings file配置成上一步拷贝的settings.xml的地址，点击OK。 这个时候就已经完成maven的离线配置了。如果还不行可以刷新一下maven的依赖，点击reimport，然后依赖就可以导入进来了。如果还是红色的线，可以尝试点击启动项目，看是不是报错，有的时候可能是没有及时刷新导致的。 ","date":"2021-08-23","objectID":"/idea-maven-offline-note/:1:0","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Software","note"],"content":"番外 另外分享一个maven离线打包的命令:mvn -o，此命令是在maven打包的时候不去下载仓库的依赖，非常有用。 mvn clean package -o -DskipTest // 或者使用这种方式跳过测试 mvn clean package -o -Dmaven.test.skip=true ","date":"2021-08-23","objectID":"/idea-maven-offline-note/:2:0","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Back"],"content":"记录flyway中sql脚本修改导致的错误的解决方法","date":"2021-08-23","objectID":"/flyway-script-change-error/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"简介 flyway是一个简单开源数据库版本控制器（约定大于配置），主要提供migrate、clean、info、validate、baseline、repair等命令（Flyway java基本知识：https://blog.csdn.net/tanghin/article/details/51264795）。 使用该工具，配置好数据库脚本，在项目运行的时候即可将数据库脚本执行到数据库中，同时会在数据库表schema_version中增加相应的记录（若第一次执行，则会创建该表）。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"报错1 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"分析1 那么这段话表示什么意思呢？ 看这句话： Caused by:ori.flywaydb.core.api.FlywayException:Validate failed:migration checksum mismatch for migration 1.15.0 -\u003eApplied to database: 37561532 -\u003eResolved locally : -351684334 Flyway中的checksum值应当是-351684334，但是实际上运行的值是37561532，而且这个错误是在运行SQL Script 1.15.0出现的！ 那么出现这个问题的原因是什么呢？ 这里涉及到flyway的一些基本常识，flyway 官方文档 常识1）：项目每次执行，都会调用数据库，会先运行SQL Script 要使用到Flyway，但是flyway查询数据时，会判断数据库的数据结构或者数据什么的是否改变，判断标准就是checksum。 如图所示：在1.15被执行之前，执行的版本是1.14，也是初始化，但是在项目中的SQLScript更新到1.15版本后，项目开始运行的话，会先执行1.15，如果1.15没有执行即第二行没有增加的话，那么，会执行1.15版本，然后会有个checksum，如果检测到有1.15版本的话，那么将会检测自己的checksum后数据库里面的checksum是否相等，如果相等，那么就不会报错，但是，如果不相等的话，就会报出上面的异常；如果没有1.15版本的话，就会成功进行数据操作，最后生成1.15的记录。 常识2）Github管理项目，由于项目开发不是一个人，运行项目的版本可能不相同，但是数据库只有一个，每个项目运行都会用到flyway，进行数据操作。 总结：Github下，运行的版本不一样，有的使用的Sql Script 版本是1.14，但是有的是1.15，如果版本不进行及时更新的话，就会出现错误。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"解决1 如何解决这个问题： 将上面数据表格中的对应的数据元删掉，然后运行最新的版本。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"报错2 今天重新导入了项目，在运行项目的时候报错： org.springframework.beans.factory.BeanCreationException: Errorcreating bean with name 'flyway' defined in URL[file:/E:/gerp/war/target/gerp/WEB-INF/classes/spring/spring-jdbc.xml]:Invocation of init method failed; nested exception isorg.flywaydb.core.api.FlywayException: Validate failed: Detected appliedmigration not resolved locally: 18.616 之类的。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:5:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"解决2 通过查找资料发现，Flyway执行脚本的时候会检查脚本是否有改动，并对其进行校验。若改动，则会校验错误，报错。 后尝试把数据库表中的schema_version删除，但虽然能够执行脚本，但若存在一些不能重复操作的sql（如：建表语句），依然会报错。 最终需要把schema_version与其相对应才能正常使用 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:6:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"记录SpringBoot报错This primary key of 'id' is primitive !不建议如此请使用包装类 in Class解决办法","date":"2021-08-23","objectID":"/wrapper-class-not-recommended-error/","tags":["Java","SpringBoot","Error"],"title":"SpringBoot报错：不建议如此请使用包装类","uri":"/wrapper-class-not-recommended-error/"},{"categories":["Back"],"content":"原因及解决 报错原因：用idea自动导入实体类的时候 ，默认为long 实际应为Long，再次启动 不出现警告。 @Data public class ProgressVo { private long id; private String employeeNo; private String name; private String progress; private String created; private long pid; } ","date":"2021-08-23","objectID":"/wrapper-class-not-recommended-error/:1:0","tags":["Java","SpringBoot","Error"],"title":"SpringBoot报错：不建议如此请使用包装类","uri":"/wrapper-class-not-recommended-error/"},{"categories":["Back","note"],"content":"记录RESTful风格接口使用Json传递数据教程的笔记","date":"2021-08-23","objectID":"/restful-json-note/","tags":["RESTful","Json"],"title":"RESTful风格接口使用Json传递数据教程","uri":"/restful-json-note/"},{"categories":["Back","note"],"content":"JsonIgnore JSONField(serialize = false) JsonIgnore 相对 ObjectMapper objectMapper = new ObjectMapper(); String ttt2 =objectMapper.writeValueAsString(user); ObjectMapper对有注解jsonIgnore的不会返回，其它全部返回 JSONField(serialize = false) String ttt = JSONObject.toJSONString(user); JSONObject对有JSONField(serialize = false)的不会返回，null的也不返回 ","date":"2021-08-23","objectID":"/restful-json-note/:1:0","tags":["RESTful","Json"],"title":"RESTful风格接口使用Json传递数据教程","uri":"/restful-json-note/"},{"categories":["Back","note"],"content":"记录MybatisPlus访问PostgreSql教程的笔记","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"自定义TypeHnadler的使用 自定义的TypeHandler主要是转换Jsonb和array等类型 ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"如果是使用mybatisplus的内置方法,则需要在实体字段加上@TableField注解,并且需要在类名上启动@TableName(autoResultMap = true) // autoResultMap = true 必须写,否则无法识别 @TableName(autoResultMap = true) public class BlogUser implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String name; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private LocalDateTime createTime; private Integer version; // 使用类型转换,否则无法增删改查 @TableField(typeHandler= JsonTypeHandler.class) private Map\u003cString,Object\u003e relation; } ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:1","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"如果是写在xml里面,则必须在对应字段注明转换器class: \u003cinsert id=\"addxml\" parameterType=\"com.hou.postgresql.blog.entity.po.BlogUser\"\u003e INSERT INTO blog_user (name, relation, fans, birthday, points, login_time, write_interval, numbers, adult, address, weight) VALUES (#{name}, /*必须显式的指明转换器,否则编译过程就会报错,主要是List,map这种数组,jsonb对应的实体类型*/ #{relation,typeHandler=com.hou.postgresql.handler.JsonTypeHandler}, #{fans,typeHandler=com.hou.postgresql.handler.ArrayTypeHandler}, #{birthday}, #{points}, #{loginTime}, #{writeInterval}::interval, #{numbers,typeHandler=com.hou.postgresql.handler.ArrayTypeHandler}, #{adult}, #{address}, #{weight}) \u003c/insert\u003e ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:2","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"column is of type jsonb but expression is of type character varying问题 即使写了转换器,查询的时候没问题,但是插入的时候依然会报这个错,这时需要在连接的url后面加上参数stringtype=unspecified就可以正常添加了 url: jdbc:postgresql://192.168.1.11:5432/postgres?currentSchema=sys\u0026stringtype=unspecified ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:2:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"所有数据类型参数格式 url后面加上stringtype=unspecified就可以使用任意格式插入了,除了json和array之外,其他的特殊类型,比如地址,间隔,时间等都可以使用string 参数如下: { \"address\": \"192.168.1.70\", // inet \"adult\": false, // boolean \"birthday\": \"1994-12-16\", // date \"fans\": [\"zhangpeng\",\"zhouhang\",\"pengle\"], \"loginTime\": \"09:12\", // time \"name\": \"侯征\", \"numbers\": [12,56,42], // array \"points\": 10.522, // numeric \"relation\": { // jsonb \"key\": \"value\" }, \"weight\": \"[45,50]\", // 区间 \"writeInterval\": \"800\" // 时间间隔,单位秒 } ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:3:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back"],"content":"记录详细使用说明的笔记","date":"2021-08-22","objectID":"/springfox-swagger-note/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"1.spring-boot依赖 \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-08-22","objectID":"/springfox-swagger-note/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"2.swagger 配置 swagger文档默认访问地址：/swagger-ui.html swagger文档默认访问地址：/swagger-ui.html @Configuration @EnableSwagger2 //开启swagger，自动生成文档 public class SwaggerConfig { //一个Docket是一个组，组的划分可以通过paths()或apis()来实现，组名称可以作为api搜索条件。组包含多个tags，tag可以包含多个api； @Bean public Docket api() { //apiInfo():配置文档描述 //apis():api过滤规则，可以自定义为那些接口生成文档 //useDefaultResponseMessages():是否使用默认的响应信息 //paths()::可以根据请求路径过滤api //globalResponseMessage():：所有接口统一定义响应信息 //produces(): 为所有接口设置响应类型 //consumes():(): 为所有接口设置请求类型 //protocols(): 为所有接口设置支持的协议 //groupName（）：组名称 //tags：设置标签 Tag tag = new Tag(\"订单导出api\", \"订单相关导出api描述\"); ResponseMessage error = new ResponseMessageBuilder().code(500).message(\"系统异常\").build(); return new Docket(DocumentationType.SWAGGER_2) .useDefaultResponseMessages(false) .globalResponseMessage(RequestMethod.GET, Lists.newArrayList(error)) .apiInfo(apiInfo()) .groupName(\"订单导出api\") .protocols(Sets.newHashSet(\"http\", \"https\")) .consumes(Sets.newHashSet(MediaType.APPLICATION_JSON_VALUE)) .produces(Sets.newHashSet(MediaType.APPLICATION_JSON_VALUE)) .tags(tag) .select() .apis((RequestHandlerSelectors.basePackage(\"com.zhen.export\")) .paths(PathSelectors.any()).build(); } private ApiInfo apiInfo() { //title:文档标题 //description：文档的描述 //termsOfServiceUrl:文档的服务条款说明网址 //version:版本号 //contact：文档的联系人信息 //license:文档版权信息 //licenseUrl:版权信息超链接 return new ApiInfoBuilder() .title(\"珍品导出系统API文档\") .description(\"珍品导出系统API文档\") .contact(new Contact(\"moon\", \"www.baidu.com\", \"moon@zhen.com\")) .license(\"license-moon\"). .licenseUrl: 版权信息超链接(\"license-moon-url\") .termsOfServiceUrl(\"http://www.zhen.com\").version(\"2.0\").build(); } ","date":"2021-08-22","objectID":"/springfox-swagger-note/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"3.相关注解使用和说明 3.相关注解使用和说明 @RestController @RequestMapping(\"/orders\") @Api(tags = \"订单导出api\") public class OrderExportController { @ApiOperation(value = \" 订单导出任务-对象请求\", notes = \"订单导出任务详细描述\", httpMethod = \"GET\", produces = MediaType.APPLICATION_JSON_VALUE) @ApiImplicitParams({ @ApiImplicitParam(paramType = \"query\", name = \"test\", value = \"测试字段\", required = true, dataType = \"String\") }) @ApiResponses({ @ApiResponse(code = 500, message = \"系统异常\") }) @RequestMapping(value = \"/doExportTaskToOperationOnObject.json\", method = RequestMethod.GET) public EgResponse doExportTaskToOperationOnObject(OrderDetailRequest req, @ApiIgnore String test, HttpServletRequest request) throws Exception { return EgResponse.success(new OrderInfo()); } OrderDetailRequest：接口的请求对象，不需要格外注解，可以自动识别展示在文档中，可以用ApiModelProperty注解定义对象字段在文档中的展示 @ApiIgnore：可以用在controller类，方法参数上，使其不展示在文档中 @api：为功能模块添加说明信息，不是必须的，所有匹配的controller都会自动生成文档 属性名 说明 tags 接口的标签名，可用于分组，不能设置tag的描述，只能在swagger配置时设置组描述。每个controller都会生成默认的标签 produces 支持的响应类型，mime类型，多个值逗号分隔 consumes 入参类型值，mime类型，多个值逗号分隔 authorizations 获取此操作的授权列表 protocols 支持的传输协议，如http。多个协议逗号分隔 hidden 是否隐藏该模块 @ApiImplicitParams：描述方法参数的集合包含多个ApiImplicitParam注解 @ApiImplicitParam：描述方法参数信息 属性名 说明 value 参数描述 name 参数名称 defaultValue 参数默认值 allowableValues 参数允许的取值集合 required 是否必填 allowMultiple 是否可以传多个 dataType 参数值的类型 dataTypeClass 参数值得java类型 paramType 参数的类型，可选值path, query, body, header,form example 参数值例子，paramType!=body时有效 examples paramType=body时有效 allowEmptyValue 是否可以传递空值 @ApiOperation：模块中每个接口定义，不是必须的，spring会自动扫描所有的接口。 属性名 说明 value 接口名称 httpMethod 接口使用http方法，可选值 “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS”,“PATCH”。如果未指定则使用除\"PATH\"之外的其它所有 produces 支持的响应类型，mime类型，多个值逗号分隔 consumes 入参类型值，mime类型，多个值逗号分隔 notes 接口的详细描述 response 接口的响应类型。文档的响应信息结构可以根据方法的返回值自动处理。 protocols 支持的传输协议，如http。多个协议逗号分隔 hidden 是否在文档中展示改接口 responseHeaders http响应头信息描述 authorizations 获取此操作的授权列表 code HTTP返回状态码 nickname 第三方工具使用operationId来唯一表示此操作 tags 接口所属标签，默认为controller标签 extensions 扩展属性描述 @ApiResponses：响应信息集合，包含多个ApiResponse注解 @ApiResponse：定义不同http响应码的相关相关响应信息 属性名 说明 code http响应码 message 响应码描述 response 响应实体类 examples 响应例子 examples 响应例子 public class OrderDetailRequest { @ApiModelProperty(value = \"平台编码\", required = true, example = \"70\") private String platformCode; @ApiModelProperty(value = \"平台订单号\", required = true, example = \"sn20201029\") private String platformOrderSn; @ApiModelProperty(value = \"订单状态\", example = \"0\", allowableValues = \"0,1,2,3,4\") private Integer status; @ApiModelProperty(value = \"特殊字段\", example = \"0\", hidden = true) private BigDecimal special; @ApiModelProperty(value = \"开始时间 格式：yyyy-MM-dd HH:mm:ss\") private String startTime; } @ApiModel(value = \"response\", description = \"用于通用响应\") public class EgResponse { @ApiModelProperty(value = \"响应码\", example = \"200\") private String code; @ApiModelProperty(value = \"响应码描述\", example = \"成功\") private String message; @ApiModelProperty(\"响应数据\") private T data; } @ApiModel：实体的描述，主要用于响应实体，不是必须的 属性名 说明 value 实体名称 description 实体说明 parent 设置父类型 subTypes 设置子类型 @ApiModelProperty：实体中字段的描述 属性名 说明 value 字段描述 name 字段名称，会覆盖默认名称 allowableValues 允许的取值范围，主要用于请求实体中 description 实体说明 example 字段样例值。对于请求实体，该值在测试时自动填充入请求参数中；对于响应实体，则会展示在响应例子中 dataType 字段类型 required 是否必填 position 字段的顺序 hidden 是否在文档中隐藏该字段 allowEmptyValue 是否允许传递空置 ","date":"2021-08-22","objectID":"/springfox-swagger-note/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"4.对应关系 ","date":"2021-08-22","objectID":"/springfox-swagger-note/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"表示接口过时了 Warning: Deprecated 在该接口的方法上添加@Deprecated @Deprecated简单来讲就是，若某类或某方法加上该注解之后，表示此方法或类不再建议使用，调用时也会出现删除线，但并不代表不能用，只是说，不推荐使用，因为还有更好的方法可以调用。 在swagger中的使用： @ApiOperation(value = \"通过站点id查询栏目列表\") @Deprecated @RequestMapping(value = \"findByTerminalId\", method = RequestMethod.POST) public AjaxResponse\u003cSelectOutputBean\u003cAppNavigationInternalOutputBean\u003e\u003e findByTerminalId( @RequestBody @Validated @ApiParam(required = true) ConditionOfSiteModel model) { SelectOutputBean\u003cAppNavigationInternalOutputBean\u003e result = getService().findByTerminalId(model); return AjaxResponse.success(result); } 效果： ","date":"2021-08-22","objectID":"/springfox-swagger-note/:5:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back","note"],"content":"记录PageHelper笔记和示例","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"PageHelper是什么东西？ PageHelper是一个Mybatis的分页插件，其原理利用Mybatis提供的Interceptor接口创建了其实现类PageInterceptor类来实现分页功能。使用起来很方便，只需要简单的引入包，并且附加一行代码就可以实现在使用Mybatis时自动分页查询 ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:1:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"如何使用PageHelper? 导入依赖的包，我这里使用的是spring boot starter的包, maven代码: \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.2.13\u003c/version\u003e \u003c/dependency\u003e 在代码中需要分页时，直接在mapper方法调用前，插入一行PageHelper类的分页method即可 PageHelper.startPage(taskPageVo.getPageNum(), taskPageVo.getPageSize()); //多种分页方法，具体查看PageHelper类 List\u003cSaTask\u003e saTasks = saTaskMapper.findTasks(userIds, taskPageVo.getStatus(), null, null); ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:2:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"使用PageHelper处理多个不同类型数据库数据源 上面的方法在单个数据源中或多个相同类型的数据库数据源中使用没有任何问题，但是在多个数据源中使用就会有问题。原因是不同的数据库分页的sql语句不一样，譬如mysql使用limit，sqlserver使用top，oracle使用rownum等等。而PageHelper为我们提供了方便，只要配置属性autoRuntimeDialect为true就可以完全支持不同类型数据库数据源分页了 针对上面的问题该如何解决，网上搜索了一下，大概有三种方式 方式一，在定义sessionFactory的时候，不同的数据源使用不同的PageInterceptor过滤 //mysql @Bean(name = \"masterSqlSessionFactory\") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier(\"masterDataSource\") DataSource masterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(masterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDataSourceConfig.MAPPER_LOCATION)); sessionFactory.getObject().getConfiguration().setMapUnderscoreToCamelCase(true);//配置驼峰映射 sessionFactory.getObject().getConfiguration().setLogImpl(StdOutImpl.class); //分页插件 Interceptor interceptor = new PageInterceptor(); Properties properties = new Properties(); //分页数据库方言为mysql properties.setProperty(\"helperDialect\", \"mysql\"); //是否为分页数据库多个数据配置 properties.setProperty(\"autoRuntimeDialect\", \"true\"); //是否分页合理化 properties.setProperty(\"reasonable\", \"false\"); interceptor.setProperties(properties); sessionFactory.setPlugins(new Interceptor[] {interceptor}); return sessionFactory.getObject(); } //sqlserver @Bean(name = \"clusterSqlSessionFactory\") public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(\"clusterDataSource\") DataSource clusterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(clusterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(SqlserverDataSourceConfig.MAPPER_LOCATION)); // sessionFactory.getObject().getConfiguration().setMapUnderscoreToCamelCase(true);//配置驼峰映射 sessionFactory.getObject().getConfiguration().setLogImpl(StdOutImpl.class); //分页插件 Interceptor interceptor = new PageInterceptor(); Properties properties = new Properties(); //分页数据库方言为sqlserver properties.setProperty(\"helperDialect\", \"sqlserver\"); //是否为分页数据库多个数据配置 properties.setProperty(\"autoRuntimeDialect\", \"true\"); //是否分页合理化 properties.setProperty(\"reasonable\", \"false\"); interceptor.setProperties(properties); sessionFactory.setPlugins(new Interceptor[] {interceptor}); return sessionFactory.getObject(); } 方式二：统一配置PageHelper Config类，实际上也就是统一配置PageInterceptor @Configuration public class PageHelperConfig { @Bean PageInterceptor pageInterceptor() { PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.setProperty(\"offsetAsPageNum\", \"false\"); properties.setProperty(\"rowBoundsWithCount\", \"false\"); properties.setProperty(\"pageSizeZero\", \"true\"); properties.setProperty(\"reasonable\", \"false\"); properties.setProperty(\"supportMethodsArguments\", \"false\"); properties.setProperty(\"returnPageInfo\", \"none\"); properties.setProperty(\"autoRuntimeDialect\", \"true\"); //处理多数据源数据库 pageInterceptor.setProperties(properties); return pageInterceptor; } } 方式三：在application.yml文件中配置PageHelper的属性支持多数据源 pagehelper:autoRuntimeDialect:true ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:3:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"在不同类型数据库的数据源情况下，正确的在spring boot 中使用PageHelper 使用方式一，看网络上的朋友，需要根据对应的sessionFactory创建SqlSessionTemplate，并且在Mapper上加分页参数，我没有测试过，但是感觉麻烦。 使用方式二，则可能简单方便点。但是方式一和方式二都有共同的问题，就是除非直接导入的依赖包是非spring boot starter包，而是直接导入pagehelper包，如： \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003c/dependency\u003e 否则都会出现一个问题，第一次使用某个类型的数据库分页查询正确，后面使用的其他类型数据库分页 查询都会失败。 使用方式三可以完全的使用PageHelper解决不同类型数据库数据源的分页问题。 方式一和方式二出现问题的根本原因是autoRuntimeDialect属性没有被设置上导致的。因为使用spring boot starter包时，每次服务器启动的时候spring容器都会去实例化PageHelperAutoConfiguration类，在这个类里会去读取yml文件中配置pagehelper属性，如果没有在yml中配置pagehelper.autoRuntimeDialect=true，那么它的值就为null，到时候PageHelper类就自动认为不是多数据源。HelperDialect 方言永远是第一次查询时的方言。 源码分析（由于篇幅有限，简单的截图说明） ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:4:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Learning","note"],"content":"记录编程语言抽象笔记","date":"2021-08-22","objectID":"/lang-common-note/","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"动态语言和静态语言的本质区别是什么？ ","date":"2021-08-22","objectID":"/lang-common-note/:1:0","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"静态语言 静态类型语言 如果在编译时知道变量的类型，则该语言是静态类型的。我们经常说道的Java、C、C++在写代码的时候必须指定每个变量的类型。 优点就是编译器可以执行各种检查，也就是程序还没跑起来就能找到一些小错误，也就是是在compile-time检查出错误的。 ","date":"2021-08-22","objectID":"/lang-common-note/:1:1","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"动态语言 动态类型语言 一般是脚本语言，比如说Perl、Ruby、Python、PHP、JavaScript，可以更快地编写代码，不必每次都指定类型，做type checking是在run-time的时候去做的。优点是可能代码开发快，但是维护难（但是脚本语言平常写的代码量应该不太多，还比较好debug和修改） ","date":"2021-08-22","objectID":"/lang-common-note/:1:2","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"编译执行和解释执行 这个是看Python的时候，发现的一个问题，Python是脚本语言，解释执行。Java是静态语言，编译执行。但是java在运行时，JVM普遍采用混合模式。 ","date":"2021-08-22","objectID":"/lang-common-note/:2:0","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"一、编译和解释 编译：将源代码一次性转换成目标代码的过程 类似英语中的全文翻译。 执行编译过程的程序叫做编译器。 解释：将源代码逐条转换成目标代码同时逐条运行的过程。 类似英语中的同声传译。 执行解释过程的程序叫做解释器。 编译过程只进行一次，所以，编译过程的速度并不是关键，目标代码的运行速度是关键。因此，编译器一般都集成尽可能多的优化技术，使生成的目标代码具备更好的执行效率。 解释则在每次程序运行时都需要解释器和源代码，不能集成太多优化技术，因为代码优化技术会消耗运行时间，使整个程序的执行速度受到影响。 高级语言 高级语言按照计算机执行方式的不同可分为两类：静态语言和脚本语言。 这里所说的执行方式是指计算机执行一个程序的过程，也就是编译执行和解释执行。 静态语言：使用编译执行的编程语言，比如C/C++、Java（这里我还有话说，等会儿后面说）等。 脚本语言：使用解释执行的编程语言，比如Python语言，JavaScript、PHP等。 ","date":"2021-08-22","objectID":"/lang-common-note/:2:1","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"执行方式不同，二者的优势各有不同 静态语言（编译方式）：编译器一次性生成目标代码，优化更充分，程序运行时速度更快。 1）对于相同的源代码，编译所产生的的目标代码执行速度更快。 2）目标代码不需要编译器就可以运行，在同类操作系统上使用灵活。 脚本语言（解释方式）：执行程序时需要源代码，维护更加灵活。 1）解释执行需要保留源代码，程序纠错和维护十分方便。 2）只要存在解释器，源代码可以在任何操作系统上运行，可移植性好。 （有的企业有时候开发一个大型的应用程序，用静态语言，可能过个五六年，就只有功能还在，源程序都找不到了，但是使用脚本语言就不会出现源程序找不到的问题。） ","date":"2021-08-22","objectID":"/lang-common-note/:2:2","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Learning","note"],"content":"二、Java的解释执行和编译执行 上面根据计算机执行方式的不同，把高级语言分为两类，静态语言和脚本语言。 但是，在前面的博客里我也写过Java语言的执行是有解释执行和编译执行两种的。 Java在编译时期，通过将源代码编译成.class ，配合JVM这种跨平台的抽象，屏蔽了底层计算机操作系统和硬件的区别，实现了“一次编译，到处运行” 。 而在运行时期，目前主流的JVM 都是混合模式（-Xmixed），即解释运行 和编译运行配合使用。解释器的优势在于不用等待，编译器则在实际运行当中效率更高。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，从而提高运行效率。 注：Python语言是一种被广泛使用的高级通用脚本编程语言，虽然采用解释执行方式，但是它的解释器也保留了编译器的部分功能，随程序运行，解释器也会生成一个完整的目标代码。这种将解释器和编译器结合的新解释器是现代脚本语言为了提升计算机性能的一种有益演进。 这是《Python程序设计语言》第二版里的话，可以参考理解 高级语言按照计算机执行方式的分类和他们在执行过程中实际采用的执行方式不太一致的问题吧。 ps:希望有大佬看见了能够解释的更详细，或者指出错误。 ps2:这个图我很想知道有没有什么简单的方法能够缩小鸭~感激不尽OTZ ","date":"2021-08-22","objectID":"/lang-common-note/:2:3","tags":["Language"],"title":"编程语言抽象笔记","uri":"/lang-common-note/"},{"categories":["Front"],"content":"记录JS error : split is not a function报错的解决办法","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"JS报错 如图 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:1:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"问题所在 split 只能是字符串才能执行，其他类型参数需要转换类型，否则报错 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:2:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"解决 转换为str类型 var a = 123 (a+\"\").split(\"\") 解决了 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:3:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Net","note"],"content":"记录Gmail的Host解决方案","date":"2021-08-22","objectID":"/gmail-host-note/","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"原因 Gmail 在国内可用google.cn的 Host来改进连接速度，避免被GFW干扰，经测试联通 网络打开Gmail速度飞快，特共享之！ 由于公布的Host地址很快会被GFW强奸，所以google.cn服务器的IP地址会经常变化， 那么只要我们能找到变化的IP地址，经常更新host文件便可以解决这个问题。 ","date":"2021-08-22","objectID":"/gmail-host-note/:1:0","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"办法 ","date":"2021-08-22","objectID":"/gmail-host-note/:2:0","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"1 在运行里敲击cmd，然后敲击如下代码： nslookup www.google.cn 8.8.8.8 ","date":"2021-08-22","objectID":"/gmail-host-note/:2:1","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"2 （补充：如果不行，可将命令中的“www.google.cn\" 换成”www.google.com.hk\"或者“www.google.com\" 试下） 返回得到的IP地址取任意一个来替换203.208.46.X，然后保存host文件即可。 203.208.46.X maps.google.com 203.208.46.X mail.google.com 203.208.46.X maps-api-ssl.google.com 203.208.46.X images1-focus-opensocial.googleusercontent.com 203.208.46.X images2-focus-opensocial.googleusercontent.com 203.208.46.X www.google.com 203.208.46.X encrypted.google.com 203.208.46.X chrome.google.com 203.208.46.X clients1.google.com 203.208.46.X clients2.google.com 203.208.46.X clients3.google.com 203.208.46.X clients4.google.com 203.208.46.X clients5.google.com 203.208.46.X clients6.google.com 203.208.46.X clients7.google.com 203.208.46.X clients1.googleusercontent.com 203.208.46.X clients2.googleusercontent.com 203.208.46.X clients3.googleusercontent.com 203.208.46.X clients4.googleusercontent.com 203.208.46.X clients5.googleusercontent.com 203.208.46.X clients6.googleusercontent.com 203.208.46.X clients7.googleusercontent.com 203.208.46.X profiles.google.com 203.208.46.X plus.google.com 203.208.46.X talkgadget.google.com 203.208.46.X picasaweb.google.com 203.208.46.X lh1.ggpht.com 203.208.46.X lh2.ggpht.com 203.208.46.X lh3.ggpht.com 203.208.46.X lh4.ggpht.com 203.208.46.X lh5.ggpht.com 203.208.46.X lh6.ggpht.com 203.208.46.X lh6.googleusercontent.com 203.208.46.X lh5.googleusercontent.com 203.208.46.X lh4.googleusercontent.com 203.208.46.X lh3.googleusercontent.com 203.208.46.X lh2.googleusercontent.com 203.208.46.X lh1.googleusercontent.com 203.208.46.X spreadsheets.google.com 203.208.46.X docs.google.com 203.208.46.X pop.gmail.com 203.208.46.X scholar.l.google.com 203.208.46.X news.google.com 203.208.46.X video.google.com 203.208.46.X translate.google.com ","date":"2021-08-22","objectID":"/gmail-host-note/:2:2","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Front","note"],"content":"记录Html笔记和相关示例","date":"2021-08-16","objectID":"/html-note/","tags":["Html"],"title":"Html笔记","uri":"/html-note/"},{"categories":["Front","note"],"content":"如何让button变成\u003ca href='链接'\u003e\u003c/a\u003e效果 其实就是一行代码，不过网上老有人拿错误代码来误导，不知道是不是以前的语法有不一样，下面放正确方法 在原窗口跳转到新网址 \u003cbutton onclick=\"window.location.href='http://www.baidu.com'\"\u003e链接\u003c/button\u003e 打开新窗口跳转到新网址 \u003cbutton onclick=\"window.open('http://www.baidu.com')\"\u003e链接\u003c/button\u003e 这两个方法不一样，看清楚，切记切记。 ","date":"2021-08-16","objectID":"/html-note/:1:0","tags":["Html"],"title":"Html笔记","uri":"/html-note/"},{"categories":["Total","note"],"content":"记录Jsp相关笔记合示例","date":"2021-08-16","objectID":"/jsp-note/","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"jsp fmt标签详解 JSTL标签提供了对国际化（I18N）的支持，它可以根据发出请求的客户端地域的不同来显示不同的语言。同时还提供了格式化数据和日期的方法。实现这些功能需要I18N格式标签库（I18N-capable formation tags liberary）。引入该标签库的方法为： \u003c%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %\u003e I18N格式标签库提供了11个标签，这些 标签从功能上可以划分为3类如下： （1）数字日期格式化。formatNumber标签、formatData标签、parseNumber标签、parseDate标签、timeZone标签、setTimeZone标签。 （2）读取消息资源。bundle标签、message标签、setBundle标签。 （3）国际化。setlocale标签、requestEncoding标签。 接下将详细介绍这些标签的功能和使用方式。 ","date":"2021-08-16","objectID":"/jsp-note/:1:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.1 数字日期格式化 数字日期格式化标签共有6个，用来将数字或日期转换成设定的格式。 1．\u003cfrm:formatNumber/\u003e标签 该标签依据特定的区域将数字改变为不同的格式来显示。 【语法1】： \u003cfrm:formatNumber value=”被格式化的数据”[type=”number|currency|percent”][pattern=”pattern”] [currencyCode=”code”][currencySymbol=”symbol”][groupingUsed=”true|false”] [maxIntergerDigits=”maxDigits”][minIntergerDigits=”minDigits”][maxFractionDigits=”maxDigits”] [minFractionDigits=”minDigits”][var=”name”][scope=page|request|session|application]/\u003e 【语法2】： \u003cfrm:formatNumber [type=”number|currency|percent”][pattern=”pattern”][currencyCode=”code”] [currencySymbol=”symbol”][groupingUsed=”true|false”][maxIntergerDigits=”maxDigits”] [minIntergerDigits=”minDigits”][maxFractionDigits=”maxDigits”][minFractionDigits=”minDigits”] [var=”name”][scope=page|request|session|application]\\\u003e \u003cfmt:formatNumber\u003e标签参数说明: 名称 说明 EL 类型 必须 默认值 value 要格式化的数据 是 String 是 无 type 指定类型（单位、货币、百分比等）见表 是 String 否 number pattern 格式化的数据样式 是 String 否 无 currencyCode 货币单位代码 是 String 否 无 cuttencySymbol 货币符号（$、￥） 是 String 否 无 groupingUsed 是否对整数部分进行分组如（9，999） 是 boolean 是 true maxIntergerDigits 整数部分最对显示多少位数 是 int 否 无 minIntergerDigits 整数部分最少显示多少位 是 int 否 无 maxFractionDigits 小数部分最多显示多少位 是 int 否 无 minFractionDigits 小数部分最少显示多少位 是 int 否 无 var 存储格式化后的数据 否 String 否 无 scope var的JSP范围 否 String 否 page Type属性的类型应用:. 类型 说明 示例 number 数字格式 0.8 currency 当地货币 ￥0.80 percent 百分比格式 80% 【示例代码】：实现了对数字的格式化、货币的格式、货币的格式化。使用\u003cfrm:formatNumber\u003e的各种属性的设定。 \u003ctable border=1 cellpadding=\"0\" cellspacing=\"0\" align=\"center\"\u003e \u003ctr align=\"center\"\u003e \u003ctd width=\"100\"\u003e类型 \u003c/td\u003e \u003ctd width=\"100\"\u003e使用数据\u003c/td\u003e \u003ctd width=\"100\"\u003e结果\u003c/td\u003e \u003ctd width=\"300\"\u003e说明\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e108.75\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" pattern=\"###.#\"\u003e108.75\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用pattern可以定义显示的样式。本例设定为###.#小数部分将使用四舍五入法。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" pattern=\"#.####E0\"\u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用科学计数法。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" \u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003c/td\u003e \u003ctd\u003e使用默认分组。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" groupingUsed=\"false\" \u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e不使用分组。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" maxIntegerDigits=\"3\"\u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用位数限定，根据指定的位数显示，其他数字忽略。例如：9不被显示。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e百分比格式化\u003c/td\u003e\u003ctd\u003e0.98\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"percent\"\u003e0.98\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e用百分比形式显示一个数据。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e货币格式化\u003c/td\u003e\u003ctd\u003e188.88\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"currency\" \u003e188.8\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e将一个数据转化为货币形式输出。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e存储数据\u003c/td\u003e\u003ctd\u003e188.88\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"currency\" var=\"money\"\u003e188.8\u003c/fmt:formatNumber\u003e \u003cc:out value=\"${money}\"\u003e\u003c/c:out\u003e \u003c/td\u003e \u003ctd\u003e存储的money的值为${money} \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 【代码说明】： （1）从应用角度可以把属性分为三类：数字格式化、货币格式化、百分比格式化。使用type指定类型。 （2）应用于数字格式化的属性有：partten属性、maxIntegerDigits属性、minIntegerDigits属性、maxFractionDigits属性和minFactionDigits属性。其中partten属性在设定格式化样式时会比较准确如：四舍五入、科学计数法的使用。而使用maIntegerDirgits等属性时，只把设定位数以外的数字舍去。 （3）货币格式化可以使用数字格式化的所有属性。如果有必要建议使用partten属性。currencyCode属性和currencySymbol只用于货币格式化。 （4）百分比格式化使用到的属性为type属性、partten属性，设定type属性的类型为percent即可。 （5）使用var属性时，会将格式化后的值存在JSP的某个范围内（一个String类型的字符串包括符号等）。\u003cfrm:forNumber\u003e将不再输出格式化后的值可以使用EL表达式输出。 （6）通用属性：type属性、partten属性、var属性和scope属性。 2．\u003cfrm:parseNumber\u003e标签 将格式化后的数字、货币、百分比都转化为数字类型。 【语法1】： \u003cfmt:parseNumber value=\"number\" [type=”number|currency|percent”][pattern=”pattern”] [parseLocale=”locale”][intergerOnly=”true|false”][scope=”page|request|session|application”]/\u003e 【语法2】： \u003cfmt:parseNumber [type=”number|currency|percent”][pattern=”pattern”] [parseLocale=”locale”] [intergerOnly=”true|false”][scope=”page|request|session|application”]\\\u003e Number \u003c/fmt:parseNumber \u003cfmt:parseNumber\u003e标签参数说明: 名称 说明 EL 类型 是否必须 默认值 value 被解析的字符串 是 String 是 无 type 指定单位（数字、货币、百分比） 是 String 是 number pattern 格式样式 是 String 否 无 parseLocale 用来替代默认区域的设定 是 String，Java.util.Locale 是 默认本地样式 var 存储已经格式化的数据 否 String 否 无 scope var变量的作用域 否 String 是 page \u003cfmt:pars","date":"2021-08-16","objectID":"/jsp-note/:1:1","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.2 读取消息资源 读取消息资源用到的标签主要有4个：\u003cfmt:message\u003e标签、\u003cfmt:param\u003e标签、\u003cfmt:bundle\u003e标签和\u003cfmt:setBundle\u003e标签。主要用于从资源文件中读取信息。 1．\u003cfmt:bundle\u003e标签 该标签主要用于将资源文件绑定于它的标签体中的显示。 【语法】： \u003cfmt:bundle basename=”name”[prefix=”prefix”]\u003e ….标签主题 \u003c/fmt:bundle\u003e \u003cfmt:bundle\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 basename 指定使用的资源文件的名称 是 String 是 无 prefix 前置关键字 是 String 否 无 2．\u003cfmt:setBundle\u003e标签 该标签主要用于绑定资源文件或者把资源文件保存在指定的JSP范围内。 【语法】： \u003cfmt:setBundle basename=”name” [var=”name”][scope=”page|request|session|application”]\\\u003e \u003cfmt:setBundle\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 basename 指定使用的资源文件的名称 是 String 是 无 var 指定将资源文件保存的名称 否 String 否 无 scope 设定将资源文件保存的JSP范围 否 String 否 page 3．\u003cfmt:message\u003e标签 该标签主要负责读取本地资源文件，从指定的消息文本资源文件中读取键值，并且可以将键值保存在指定的JSP范围内。 【语法1】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]/\u003e 【语法2】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]\\\u003e \u003cfmt:param/\u003e \u003c/fmt:message 【语法3】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]\\\u003e key \u003cfmt:param/\u003e … \u003c/fmt:message\u003e \u003cfmt:message\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 key 指定键值的名称（索引） 是 String 是 无 bundle 指定消息文本的来源 是 LocalizationContext 否 无 var 指定存储键值的变量名 否 String 否 无 scope 指定var的作用域 否 String 否 page 提示：建议此处的bundle使用EL表达式，因为属性bundle的类型为LocalizationContext，而不是一个String类型的URL。 【示例代码】：实现从指定的资源文件中读取对应key的值。 首先编写一个资源文件内容下 name=olive password=01234 使用标签从资源文件中读取相应的值。 \u003cfmt:bundle basename=\"message\"\u003e \u003cc:out value=\"从message资源文件中得到的key为name的值为：\"\u003e\u003c/c:out\u003e \u003cfmt:message key=\"name\" \u003e\u003c/fmt:message\u003e \u003c/fmt:bundle\u003e \u003chr\u003e \u003cfmt:setBundle basename=\"message\" var=\"m\"/\u003e \u003cfmt:message key=\"password\" bundle=\"${m}\"\u003e\u003c/fmt:message ${m} 【代码解析】： （1）使用\u003cfmt:bundle\u003e标签指定从message.properties文件中读取值。 （2）使用\u003cfmt:message\u003e标签读取资源文件中key为name的值。\u003cfmt:message\u003e标签放在\u003cfmt:bundle\u003e标签体内使用。 （3）使用\u003cfmt:setBundle\u003e标签在page范围绑定一个配置文件，以m为参数名存储。 （4）使用\u003cfmt:message\u003e标签得到key为password的值，此处指定资源文件的方式为使用\u003cfmt:message\u003e标签的bundle属性来设定。 （5）输出参数m的值，加深对bundle的理解。 \u003cfmt:bundle\u003e标签中有一个prefix属性，该标签用来指明前缀。例如配置文件内容如下： org.person.name=olive org.personpassword=01234 如果不使用prefix标签，在取值是要指明前缀。例如： \u003cfmt:bundle basename=”message”\u003e \u003cfmt:message key=”org.person.name”\u003e\u003c/fmt:message\u003e \u003cfmt:message key=”org.person.password”\u003e\u003c/fmt:message\u003e \u003c/fmt:bundle 使用prefix属性可以简化取值时的代码。 \u003cfmt:bundle basename=”message” prefix=”org.person”\u003e \u003cfmt:message key=”name”\u003e\u003c/fmt:message\u003e \u003cfmt:message key=”password”\u003e\u003c/fmt:message\u003e \u003c/fmt:bundle\u003e 4．\u003cfmt:param\u003e标签 该标签主要用于当\u003cfmt:message\u003e中资源文件中获得键值时，动态的为资源文件中的变量赋值。 【语法1】： \u003cfmt:param value=”value”/\u003e 【语法2】： \u003cfmt:param \u003e …标签主体 \u003c/fmt:param\u003e 【示例代码】： （1）创建资源文件。在message.properties文件中增加一个key和value。 news={0} welcome to out website! \u003cbr\u003etoday is :{1,date} 表达的含义是键news对应的是一个字符串，字符串中还有动态变量{0}表示第一个动态变量，{1,date}表示第二个动态变量并且该变量是一个日期类型的对象。 （2）通过标签从资源文件中取出键值，并给动态变量赋值显示在页面。 \u003cfmt:bundle basename=\"message\"\u003e \u003cfmt:message key=\"news\"\u003e \u003cfmt:param value=\"olive\" /\u003e \u003cfmt:param value=\"${date}\"/\u003e \u003c/fmt:message\u003e \u003c/fmt:bundle\u003e 【代码解析】： （1）使用\u003cfmt:bundle\u003e标签把资源文件绑定在标签体内。 （2）在\u003cfmt:bundle\u003e标签体内使用\u003cfmt:message\u003e得到键值。 （3）使用\u003cfmt:param\u003e为资源文件中的动态变量赋值。 ","date":"2021-08-16","objectID":"/jsp-note/:1:2","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.3 国际化 国际化这个分类中共包含两个标签：用于设定语言地区\u003cfmt:setLocale/\u003e和用于设定请求的字符编码的\u003cfmt:requestEncoding\u003e标签。 1．\u003cfmt:setLocale/\u003e标签 \u003cfmt:setLocale\u003e标签用来设定用户语言区域。 【语法】： \u003cfmt:setLocale value=”locale”[variant=”variant”][scope=”page|request|session|application”]\u003e fmt:setLocale标签属性说明： 参数名 说明 EL 类型 必须 默认值 value 指定区域代码 是 Stringjava.util.Locale 是 无 variant 操作系统的类型 是 String 是 无 scope 设定时区的作用范围 否 String 是 page value属性用来指定使用的语言代码，可以从浏览器的【工具】—【Internet选项】—【语言】—【添加】中查看浏览器支持的语言种类及语言代码。例如：中文（zh_cn）、台湾（zh_tw）、香港（zh_mo）等。 【示例代码】：实现了设定不同的区域代码，根据不同的区域代码浏览将显示不同格式的日期。 \u003cfmt:setLocale value=\"en_us\" /\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e \u003chr\u003e \u003cfmt:setLocale value=\"zh_cn\" /\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e \u003chr\u003e \u003cfmt:setLocale value=\"zh_TW\"/\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e 【代码解析】： （1）浏览器默认跟您使用的操作系统的语言相同，因此默认值zh_cn。使用fmt:setLocale/标签设置使用的语言为en_us（英语）。使用fmt:formateDate格式化输出的时间字符串，该标签会根据不同的语言输出不同的日期格式。 （2）使用的语言修改为zh_cn，再次用格式化输出。 （3）使用语言修改为zh_TW，输出格式化后的时间。 2．\u003cfmt:requestEncoding\u003e标签 该标签用于设定请求的编码格式。功能同servletRequest.setCharacterEncoding()方法相同。 【语法】： \u003cfmt:requestEncoding [value=”charEncoding”]/\u003e 【参数说明】： value属性用来指定使用的编码集例如：gbk、gb2312等。当没有给出value的值时将会自动搜索取寻找合适的编码方式，因此能够很好的解决中文乱码问题。 ","date":"2021-08-16","objectID":"/jsp-note/:1:3","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSP 标准标签库（JSTL） JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 根据JSTL标签所提供的功能，可以将其分为5个类别。 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 ","date":"2021-08-16","objectID":"/jsp-note/:2:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL 库安装 Apache Tomcat安装JSTL 库步骤如下： 从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 本站下载地址：jakarta-taglibs-standard-1.1.2.zip 下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。 接下来我们在 web.xml 文件中添加以下配置： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003cjsp-config\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/fmt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/fmt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/fmt-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/fmt-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/core\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/c.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/core-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/c-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/sql\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/sql.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/sql-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/sql-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/x\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/x.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/x-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/x-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003c/jsp-config\u003e \u003c/web-app\u003e 使用任何库，你必须在每个 JSP 文件中的头部包含 标签。 ","date":"2021-08-16","objectID":"/jsp-note/:2:1","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"核心标签 核心标签是最常用的 JSTL标签。引用核心标签库的语法如下： \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e 标签 描述 用于在JSP中显示数据，就像\u003c%= … \u003e 用于保存数据 用于删除数据 用来处理产生错误的异常状况，并且将错误信息储存起来 与我们在一般程序中用的if一样 本身只当做\u003cc:when\u003e和\u003cc:otherwise\u003e的父标签 \u003cc:choose\u003e的子标签，用来判断条件是否成立 \u003cc:choose\u003e的子标签，接在\u003cc:when\u003e标签后，当\u003cc:when\u003e标签判断为false时被执行 检索一个绝对或相对 URL，然后将其内容暴露给页面 基础迭代标签，接受多种集合类型 根据指定的分隔符来分隔内容并迭代输出 用来给包含或重定向的页面传递参数 重定向至一个新的URL. 使用可选的查询参数来创造一个URL ","date":"2021-08-16","objectID":"/jsp-note/:2:2","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"格式化标签 JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下： \u003c%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %\u003e 标签 描述 使用指定的格式或精度格式化数字 解析一个代表着数字，货币或百分比的字符串 使用指定的风格或模式格式化日期和时间 解析一个代表着日期或时间的字符串 绑定资源 指定地区 绑定资源 指定时区 指定时区 显示资源配置文件信息 设置request的字符编码 ","date":"2021-08-16","objectID":"/jsp-note/:2:3","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"SQL标签 JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： \u003c%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %\u003e 标签 描述 指定数据源 运行SQL查询语句 运行SQL更新语句 将SQL语句中的参数设为指定值 将SQL语句中的日期参数设为指定的java.util.Date 对象值 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 ","date":"2021-08-16","objectID":"/jsp-note/:2:4","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"XML 标签 JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下： \u003c%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %\u003e 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的\u003cTomcat 安装目录\u003e\\lib下: XercesImpl.jar 下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar 下载地址： http://xml.apache.org/xalan-j/index.html 标签 描述 与\u003c%= … \u003e,类似，不过只用于XPath表达式 解析 XML 数据 设置XPath表达式 判断XPath表达式，若为真，则执行本体中的内容，否则跳过本体 迭代XML文档中的节点 \u003cx:when\u003e和\u003cx:otherwise\u003e的父标签 \u003cx:choose\u003e的子标签，用来进行条件判断 \u003cx:choose\u003e的子标签，当\u003cx:when\u003e判断为false时被执行 将XSL转换应用在XML文档中 与\u003cx:transform\u003e共同使用，用于设置XSL样式表 ","date":"2021-08-16","objectID":"/jsp-note/:2:5","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL函数 JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下： \u003c%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %\u003e 函数 描述 fn:contains() 测试输入的字符串是否包含指定的子串 fn:containsIgnoreCase() 测试输入的字符串是否包含指定的子串，大小写不敏感 fn:endsWith() 测试输入的字符串是否以指定的后缀结尾 fn:escapeXml() 跳过可以作为XML标记的字符 fn:indexOf() 返回指定字符串在输入字符串中出现的位置 fn:join() 将数组中的元素合成一个字符串然后输出 fn:length() 返回字符串长度 fn:replace() 将输入字符串中指定的位置替换为指定的字符串然后返回 fn:split() 将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回 fn:startsWith() 测试输入字符串是否以指定的前缀开始 fn:substring() 返回字符串的子集 fn:substringAfter() 返回字符串在指定子串之后的子集 fn:substringBefore() 返回字符串在指定子串之前的子集 fn:toLowerCase() 将字符串中的字符转为小写 fn:toUpperCase() 将字符串中的字符转为大写 fn:trim() 移除首尾的空白符 ","date":"2021-08-16","objectID":"/jsp-note/:2:6","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL 1.1 与 JSTL 1.2 之间的区别？如何下载 JSTL 1.2? JSTL 1.2 中不要求 standard.jar 包。 您可以在 Maven 中央仓库中找到它们。 http://repo2.maven.org/maven2/javax/servlet/jstl/ http://repo2.maven.org/maven2/taglibs/standard/ 由于JSTL 1.1已经过时，Apache已将其置于存档中。选择jakarta-taglibs-standard-current.zip文件。但是，如果您正在运行Servlet 2.5兼容容器并且web.xml声明为至少Servlet 2.5，那么您应该能够使用新的JSTL 1.2。需要注意的是JSTL 1.2并没有要求standard.jar。 ","date":"2021-08-16","objectID":"/jsp-note/:3:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Operation","note"],"content":"记录Linux进程管理的笔记和相关示例","date":"2021-08-16","objectID":"/linux-proc-mange-note/","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"查看Linux端口占用，并kill掉相关进程 话不多说，本文介绍Linux常规操作：查看端口占用进程，根据PID kill掉相关进程。另外补充：根据程序名查看进程PID。 首先，两条命令，lsof命令和netstat命令。 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:0","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"方式一：lsof命令 1、查看占用端口进程的PID： lsof -i:{端口号} 2、根据PID kill掉相关进程： kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:1","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"方式二：netstat命令 1、查看占用端口进程的PID： netstat -tunlp|grep {port} 2、kill方法如上。 kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:2","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"补充1：根据程序名查看对应的PID 1、用ps命令（zb专用）： ps -ef | grep {programName} kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 查看详细内存占用 ps aux -u root | grep {programName} 2、用pgrep命令： pgrep命令的p表明了这个命令是专门用于进程查询的grep。 pgrep {programName} kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:3","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"补充2：根据PID查看对应的进程 ps -aux |grep -v grep|grep {$PID} ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:4","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"查找进程执行的文件 ps aux | grep 4874 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:2:0","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"确定进程所在的目录 ll /proc/4874； 其他对应信息 ls -l /proc/4847 # 以下是/proc目录中进程4847的信息 # /proc/4847 pid为N的进程信息 # /proc/4847/cmdline 进程启动命令 # /proc/4847/cwd 链接到进程当前工作目录 # /proc/4847/environ 进程环境变量列表 # /proc/4847/exe 链接到进程的执行命令文件 # /proc/4847/fd 包含进程相关的所有的文件描述符 # /proc/4847/maps 与进程相关的内存映射信息 # /proc/4847/mem 指代进程持有的内存，不可读 # /proc/4847/root 链接到进程的根目录 # /proc/4847/stat 进程的状态 # /proc/4847/statm 进程使用的内存的状态 # /proc/4847/status 进程状态信息，比stat/statm更具可读性 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:3:0","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Back"],"content":"记录学习Spring-Integration笔记","date":"2021-07-28","objectID":"/spring-integration/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"一、what ​ 首先，什么是spring-integration？研究之初，对这根管道有些迷惑，这是队列？这个activeMQ有啥区别？待研究了一段时间之后，才发现，spring-integration越来越像曾经做过的esb组件。那么spring-integration到底是什么呢？ ​ 官网给出的解释是，spring-integration是一个功能强大的EIP(Enterprise Integration Patterns)，即企业集成模式。对，spring-integration是一个集大成者。就我自己的理解，集成了众多功能的它，是一种便捷的事件驱动消息框架用来在系统之间做消息传递的。 ","date":"2021-07-28","objectID":"/spring-integration/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"二、why ​ 那么，我们为什么用它呢？spring-integration的官网上，给出了以下说法 ​ spring-integration的目标 提供一个简单的模型来实现复杂的企业集成解决方案 为基于spring的应用添加异步的、消息驱动的行为 让更多的Spring用户来使用他 看这种解释，我的直观感觉是：啥玩意？不懂啊！接着看到spring-integration的原则 组件之间应该是松散的，模块性的易测的 应用框架应该强迫分离业务逻辑和集成逻辑 扩展节点应该有更好的抽象和可以再使用的能力 感觉，这个应该说的是解耦吧。另外看了下其他人的理解，如果你的系统处在各个系统的中间，需要JMS交互，又需要Database/Redis/MongoDB，还需要监听Tcp/UDP等，还有固定的文件转移，分析。还面对着时不时的更改需求的风险。那么，它再适合不过了。 ","date":"2021-07-28","objectID":"/spring-integration/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"三、how ​ 那么，重点来了，如何使用呢？在介绍之前，先简单的介绍几个名词。 ","date":"2021-07-28","objectID":"/spring-integration/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"1.Message ​ Message是它的基础构件和核心，所有的流程都围绕着Message运转，如图所示 Message，就是所说的消息体，用来承载传输的信息用的。Message分为两部分，header和payload。header是头部信息，用来存储传输的一些特性属性参数。payload是用来装载数据的，他可以携带的任何Object对象，放什么都行，随你 。 ","date":"2021-07-28","objectID":"/spring-integration/:3:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"2.MessageChannel ​ 消息管道，生产者生产一个消息到channel，消费者从channel消费一个消息，所以channel可以对消息组件解耦，并且提供一个方便的拦截功能和监控功能。 ​ 对于MessageChannel，有以下几种 （1）.PublishSubscribeChannel ​ 发布订阅式通道形式，多用于消息广播形式，发送给所有已经订阅了的用户。在3.x版本之前，订阅者如果是0，启动会报错或者发送的时候报错。在4.x版本后，订阅者是0，则仍然会返回true。当然，可以配置最小订阅者数量（min-subscribers） （2）.QueueChannel ​ 队列模式通道，最常用的形式。与发布订阅通道不同，此通道实现点对点式的传输方式，管道内部是队列方式，可以设置管道的容量，如果内部的消息已经达到了最大容量，则会阻塞住，直到队列有时间，或者发送的消息被超时处理。 （3）.PriorityChannel ​ 优先级队列通道，我的理解为QueueChannel的升级版，可以无视排队，根据设置的优先级直接插队。（壕无人性） （4）.RendezvousChannel ​ 前方施工，禁止通行！这个是一个强行阻塞的通道，当消息进入通道后，通道禁止通行，直到消息在对方通道receive()后，才能继续使用。 （5）.DirectChannel ​ 最简单的点对点通道方式，一个简单的单线程通道。是spring-integration的默认通道类型 （6）.ExecutorChannel ​ 多线程通道模式，开启多线程执行点对点通道形式。这个通道博主还未研究，不敢多说…….. ","date":"2021-07-28","objectID":"/spring-integration/:3:2","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"3.Message Endpoint ​ 消息的终点，或者我称他为消息节点，在channel你不能操作消息，只能在endpoint操作。对于常用的消息节点，有以下几种 （1）.Transformer ​ 解释者，转换者，翻译者，怎么理解都可以。作用是可以将消息转为你想要的类型。可以将xml形式转换成string类型。 \u003c!-- Filter过滤器 --\u003e \u003cint:channel id=\"filterAChannel\"/\u003e \u003cint:filter input-channel=\"filterAChannel\" output-channel=\"filterBChannel\" expression=\"payload.name.equals('haha')\"/\u003e \u003cint:channel id=\"filterBChannel\"/\u003e \u003cint:service-activator input-channel=\"filterBChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"/\u003e （2）.Filter ​ 过滤器，顾名思义，过滤用的，用来判断一个消息是否应该被传输。用我的理解看，他就是spring-integration里面的if语句。 \u003c!-- transformer转换器 --\u003e \u003cint:channel id=\"transformerInChannel\"/\u003e \u003cint:transformer input-channel=\"transformerInChannel\" output-channel=\"transformerOutChannel\" expression=\"payload.name.toUpperCase() + '- [' + T(java.lang.System).currentTimeMillis() + ']'\"/\u003e \u003cint:channel id=\"transformerOutChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"transformerOutChannel\" ref=\"receiveServiceImpl\" method=\"helloTransformer\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e （3）.Router ​ 路由器，用来管理一个消息应该被发送到哪个channel中。相当于JAVA里面的switch case语句吧。判断条件很多，可是使用header里面的参数具体值（比如header里面有个定义为testRouter的参数，数值为A，那么消息经过路由会发送到判断为A的通道内，后面使用中再详细讲解） （4）.Service Activator ​ 我称他为服务激活器，是一个连接服务实例到消息系统的通用端点。对于服务激活器，可能是因为我理解的不够全面，我总是将他和通道适配器搞混，因为我自己测试发现，激活器和适配器都可以作为一个消息出通道的节点。 （5）.Channel Adapter ​ 通道适配器是将消息通道连接到某个其他系统或传输的端点。通道适配器可以是入站或出站。通常情况下，通道适配器将在消息与从其他系统（文件，HTTP请求，JMS消息等）接收或发送的任何对象或资源之间进行映射。 （6）.Channel Bridge ​ 通道桥梁，用来作为管道之间进行通信使用的，常用情景为：在一个输入管道，将管道的内容发送到另外N个管道输出，配置方式如下 \u003c!-- bridge --\u003e \u003cint:channel id=\"bridgeSendChannel\"/\u003e \u003cint:bridge input-channel=\"bridgeSendChannel\" output-channel=\"bridgeReceiveAChannel\"/\u003e \u003cint:channel id=\"bridgeReceiveAChannel\"/\u003e \u003cint:bridge input-channel=\"bridgeReceiveAChannel\" output-channel=\"bridgeReceiveBChannel\"/\u003e \u003cint:channel id=\"bridgeReceiveBChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"bridgeReceiveBChannel\" expression=\"@receiveServiceImpl.helloBridge(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e ​ 另外还有Splitter（分解器），Aggregator（聚合器）等。对于其他的消息节点，博主还没有做过多研究，就不再次误人子弟了。后续会将未研究到的一一补上。 ","date":"2021-07-28","objectID":"/spring-integration/:3:3","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"4.Channel Interceptor ​ 管道拦截器，能够以非常优雅，非常温柔的方式捕获管道传递之间的节点。对于拦截器，spring-integration给了我们六种节点 ​ 分别是发送前，邮寄后，发送成功后，接收前，接收后，接受成功后。可以分别在不同的节点进行操作。 ","date":"2021-07-28","objectID":"/spring-integration/:3:4","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"四、use（demo地址在本文最后） 下面使用到的Test类为 import lombok.Data; /** * 普通测试dto * @author lin */ @Data public class Test { private String name; private String age; } ","date":"2021-07-28","objectID":"/spring-integration/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（1）普通方式 ​ xml配置，这里配置了一个通道helloWorldChannel，配置了个接收激活点，即接收方的地址为helloServiceImpl里面的hello方法。（其中ref指对应接收的类名，method指类里面接收的方法） \u003c!-- 测试dto模式传输 --\u003e \u003cint:channel id=\"testChannel\"/\u003e \u003cint:service-activator input-channel=\"testChannel\" ref=\"receiveServiceImpl\" method=\"hello\"/\u003e ​ 发送方Service里面 /** * 测试传输dto */ @Override public void testDto() { System.out.println(\"testDto方法\"); Test test = new Test(); test.setName(\"testDto\"); test.setAge(\"18\"); testChannel.send(MessageBuilder.withPayload(test).build()); } ​ 接收方Service里面 @Override public void hello(Test test) { System.out.println(test.getName() + \" \" + test.getAge()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（2）普通多参数方式 ​ xml配置，这里通过获取payload里面的具体参数来传参的形式 \u003c!-- 测试多参数传递 --\u003e \u003cint:channel id=\"moreParamChannel\"/\u003e \u003cint:service-activator input-channel=\"moreParamChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"/\u003e ​ 发送方Service里面，将所有的参数通过Map形式装载到payload里面 /** * 测试多参数传输 */ @Override public void moreParamm() { System.out.println(\"greetMoreParam方法\"); HashMap\u003cString, String\u003e map = new HashMap(); map.put(\"name\", \"moreParam\"); map.put(\"age\", \"18\"); helloWorldMoreParamChannel.send(MessageBuilder.withPayload(map).build()); } ​ 接收方Service里面 @Override public void helloMoreParam(String name, String age) { System.out.println(name + \" \" + age); } ","date":"2021-07-28","objectID":"/spring-integration/:4:2","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（3）JMS方式 ​ xml配置，这里配置了个MQ，将消息放入mq中进行传递 \u003c!-- 测试Mq配置--\u003e \u003cint:channel id=\"topicChannel\"/\u003e \u003cbean id=\"jmsConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"\u003e \u003cproperty name=\"brokerURL\"\u003e \u003cvalue\u003etcp://127.0.0.1:61616?trace=true\u0026keepAlive=true\u003c/value\u003e \u003c/property\u003e \u003cproperty name=\"useAsyncSend\" value=\"true\"/\u003e \u003c/bean\u003e \u003cint-jms:outbound-channel-adapter channel=\"topicChannel\" destination-name=\"topic.myTopic\" pub-sub-domain=\"true\"/\u003e \u003cint:channel id=\"listenerChannel\"/\u003e \u003cint-jms:message-driven-channel-adapter id=\"messageDrivenAdapter\" channel=\"listenerChannel\"destination-name=\"topic.myTopic\" pub-sub-domain=\"true\"/\u003e \u003cint:service-activator input-channel=\"listenerChannel\" ref=\"messageListenerImpl\" method=\"processMessage\"/\u003e ​ 发送方Service里面 /** * 使用mq进行传输发送方法 */ @Override public void send() { HashMap\u003cString,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\",\"MqService\"); map.put(\"age\",\"18\"); topicChannel.send(MessageBuilder.withPayload(map).build()); } ​ 接收方Service里面 public void processMessage(HashMap\u003cString,Object\u003e map) { System.out.println(\"MessageListener::::::Received message: \" + map.toString()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:3","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（4）订阅方式 ​ xml配置，这里配置了两个订阅者，订阅者分别是两个方法 \u003c!-- 测试订阅发布 --\u003e \u003c!--min-subscribers=\"\"参数为预期最小订阅者，如果必须有订阅者，则这里填写最少数；默认值为0--\u003e \u003cint:publish-subscribe-channel id=\"pubsubChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"pubsubChannel\" ref=\"receiveServiceImpl\" method=\"helloReceiveOne\"\u003e \u003c/int:outbound-channel-adapter\u003e \u003cint:outbound-channel-adapter channel=\"pubsubChannel\" ref=\"receiveServiceImpl\" method=\"helloReceiveTwo\"\u003e \u003c/int:outbound-channel-adapter\u003e ​ 发送方Service里面 @Override public void pubsubSend() { Test test = new Test(); test.setName(\"pubsubSend\"); test.setAge(\"18\"); publishSubscribeChannel.send(MessageBuilder.withPayload(test).build()); } ​ 接收方Service里面 @Override public void helloReceiveOne(Test test){ System.out.println(\"One:\"+test.getName()+\" \"+test.getAge()); } @Override public void helloReceiveTwo(Test test){ System.out.println(\"Two:\"+test.getName()+\" \"+test.getAge()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:4","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（5）router方式 ​ xml配置，这里配置了一个入口通道，当消息进入入口后，通过判断header里面的’tsetHeader’参数的值，如果值为A，则进入routerAChannel通道，如果为B则进入routerBChannel通道。进入通道后分别进入两者的接收方法中。其中两种方法用了传递类，和多参数传递的形式。 \u003c!-- 测试路由 --\u003e \u003c!-- 路由入口 --\u003e \u003cint:channel id=\"routingChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003c!-- 路由器 --\u003e \u003cint:header-value-router input-channel=\"routingChannel\" header-name=\"testHeader\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003cint:mapping value=\"A\" channel=\"routerAChannel\"/\u003e \u003cint:mapping value=\"B\" channel=\"routerBChannel\"/\u003e \u003c/int:header-value-router\u003e \u003c!-- 路由出口 --\u003e \u003cint:channel id=\"routerAChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"routerAChannel\" ref=\"receiveServiceImpl\" method=\"helloRouterTest\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e \u003cint:channel id=\"routerBChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"routerBChannel\" expression=\"@receiveServiceImpl.helloRouterMap(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e ​ 发送方Service里面 @Override public void routerA(String name, String age) { Test test = new Test(); test.setAge(age); test.setName(name); routingChannel.send(MessageBuilder.withPayload(test).setHeader(\"testHeader\", \"A\").build()); } @Override public void routerB(String name, String age) { HashMap\u003cString,String\u003e map = new HashMap\u003c\u003e(); map.put(\"name\", name); map.put(\"age\", age); routingChannel.send(MessageBuilder.withPayload(map).setHeader(\"testHeader\", \"B\").build()); } ​ 接收方Service里面 @Override public void helloRouterTest(Test test){ System.out.println(\"routerA方法\"); System.out.println(\"helloRouterTest:\"+test.getName()+\" \"+test.getAge()); } @Override public void helloRouterMap(String name,String age){ System.out.println(\"routerB方法\"); System.out.println(\"helloRouterMap:\"+name+\" \"+age); } ","date":"2021-07-28","objectID":"/spring-integration/:4:5","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（6）网关方式 ​ xml配置，在这里面配置了一个接口类，当调用这个接口的方法时，就会进入网关配置的通道 \u003c!-- 网关通道口模式，dto --\u003e \u003cint:channel id=\"getWayChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:gateway service-interface=\"com.lin.integration.service.interfaces.UseGetWaySender\" id=\"helloGetWaySender\" default-request-channel=\"getWayChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"getWayChannel\" ref=\"receiveServiceImpl\" method=\"hello\"\u003e \u003cint:poller fixed-delay=\"0\"\u003e\u003c/int:poller\u003e \u003c/int:outbound-channel-adapter\u003e \u003c!-- 网关通道口模式，多参数传递 --\u003e \u003cint:channel id=\"getWayMoreParamChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:gateway service-interface=\"com.lin.integration.service.interfaces.MoreParamSender\" id=\"getWayMoreParamSender\" default-request-channel=\"getWayMoreParamChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"getWayMoreParamChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"\u003e\u003c/int:poller\u003e \u003c/int:outbound-channel-adapter\u003e ​ 网关interface里面 public interface UseGetWaySender { void sendMessage(Test test); } public interface MoreParamSender { void sendMessage(Map map); } ​ 发送方Service里面 /** * 测试网关dto */ @Override public void getWay() { Test test = new Test(); test.setAge(\"18\"); test.setName(\"getWay\"); useGetWaySender.sendMessage(test); } /** * 测试网关多参数 */ @Override public void getWayMoreParam() { HashMap\u003cString, String\u003e map = new HashMap(); map.put(\"name\", \"getWayMoreParam\"); map.put(\"age\", \"18\"); moreParamSender.sendMessage(map); } ","date":"2021-07-28","objectID":"/spring-integration/:4:6","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（7）全局拦截器 ​ 拦截器中，将需要拦截的管道进行拦截，拦截之后就会对这个管道的发送端，接收端进行拦截，拦截的接口在上文已经提到过，拦截的配置如下 \u003c!-- 全局拦截器 --\u003e \u003cint:channel-interceptor pattern=\"testInterceptorChannel\" order=\"3\" ref=\"countingChannelInterceptor\"\u003e \u003c/int:channel-interceptor\u003e \u003cint:channel id=\"testInterceptorChannel\"/\u003e \u003cint:service-activator input-channel=\"testInterceptorChannel\" ref=\"receiveServiceImpl\" method=\"hello\"/\u003e ​ 对于近期的spring-integration研究，这些只是“初探”，如此好的一个框架模式，我也将在今后进行深入研究，会将文章进行补充，希望各位对于我文章里面的不足与错误的地方进行批评指出，从而能互相交流研究，多谢。 参考文献： https://docs.spring.io/spring-integration/docs/5.0.4.RELEASE/reference/html/ https://www.aliyun.com/jiaocheng/301276.html https://blog.csdn.net/xiayutai1/article/details/53302652?locationNum=4\u0026fps=1 http://www.iteye.com/topic/744524 https://blog.csdn.net/slivefox/article/details/3740541 https://my.oschina.net/zhzhenqin/blog/86586 http://www.importnew.com/16538.html demo码云地址（10.21更新，增加了java dsl）： https://gitee.com/doubletreelin/spring-integration-mydemo.git ","date":"2021-07-28","objectID":"/spring-integration/:4:7","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Learning","note"],"content":"转载别人翻译大佬文章，请不要在“微服务”的狂热中迷失自我！","date":"2021-07-28","objectID":"/intellect-in-microservices/","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"引言 2017年是“微服务”疯狂的一年，如同股灾前的狂欢，各种不同行业的技术团队都在宣讲着自己微服务实践的道路。然而大家是否有反思过自己真的在玩“微服务”吗？您真的在“微服务”中受益了吗？还是为了凑这波的热点，而被折腾的疲惫不堪？ 下面的内容是《The Death of Microservice Madness in 2018》一文的翻译，本文很好地阐述了“微服务”在带来诸多优势的同时也对技术团队增加的复杂度所带来的挑战。各个技术团队Leader们，是时候好好思考一下，在这一波的疯狂中，您的团队是否都做到位了？还是又充当了一回“时髦架构师”？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:1:0","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"正文 原文：The Death of Microservice Madness in 2018 链接 微服务在过去几年一直是一个非常热门的话题（附录1）。何为“微服务的疯狂”，举个例子： 众所周知，Netflix在DevOps上的表现非常棒。Netfix可以做微服务。因此：如果我做微服务，我也将非常擅长DevOps。 很多情况下，我们盲目的投入巨大的努力来接入微服务模式，然而往往却很少去考虑接入的成本和收益能否有效的帮我们解决当前我们正面临的痛点。 下面，我将详细描述微服务是什么，以及为什么这种模式这么吸引人，最后再聊一聊一些微服务正面临的一些关键挑战。 如果你正在考虑微服务是否适合你，是否能帮你解决当前面临的问题？那继续往下看，我会用一系列简单的问题来帮你走出你的困惑。这一系列“问题”在文章的最后。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:0","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"什么是微服务，为什么微服务如此受欢迎？ 来来来，老司机带你从基础走一波。一个例子：下面这张图是一个假想的视频共享平台的实现方式，左侧是用一个“整体服务”来实现，右侧是多个微服务的形式来实现： [Monolith与微服务视频共享平台的比较\r两种系统设计的区别在于左侧是一个整体的大而全的服务。右侧是一组小而多，但每个都是一个具体的服务，每个服务都有特定的角色。 当从系统细节层面来绘制图表时，很容易看出微服务的很多潜在的好处，简单从几个方面来说一下： 独立开发：小型独立组件可由小型独立团队构建。一个小组可以改变“Upload”服务，而不会干扰“Transcode”服务，甚至都不需要知道这个服务。了解组件的时间大大减少，开发新功能也更容易。 独立部署：每个单独的组件都可以独立部署。这样可以以更快的速度和更少的风险发布新功能。比如：“Streaming”组件的修复或功能可以部署，而不需要部署其他组件。 独立的可伸缩性：每个组件可以彼此独立地进行缩放。在需求多并发同时需要发布新的版本时，可以放大“Download”组件，以处理增加的负载，而不必扩大每个组件，这使得弹性缩放更加可行并降低了成本。 可重用性：组件实现一个小的，特定的功能。这意味着它们可以更容易地适用于其他系统、服务或产品。“Transcode”组件可以被其他业务部门使用，甚至可以变成一个新的业务，或者为其他组提供Transcode服务。 从细节层面上来看，微服务模型较之于整体模型的好处显而易见。但是问题来了，如果真的是这样的话 - 为什么微服务模式最近几年才流行？我一生都快走完了（尴尬，貌似暴露年龄了），它才出现？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:1","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"如果这微服务这么好，为什么之前大家没有这样做呢？ 这个问题有两种答案。其一是，它强依赖我们最好的技术能力，另一个是最近的技术进步，促使我们能够把它带到一个新的高度。 当我开始写软文来回答这个问题的时候，发现这将会是一个很长的描述，所以从实际的角度出发，我将把它拆成两篇文章，稍后再发表2。第1篇文章，我将跳过一些内容，比如：从单个程序到多个程序的过程，忽略ESB和面向服务的体系结构，组件设计和有限的上下文等等。 感兴趣的朋友可以稍后阅读更多关于journey的信息。尽管，在很多方面我们已经这样做了一段时间，但是随着最近容器技术（特别是Docker）和编排技术（如Kubernetes、Mesos、Consul等等）的普及，从技术的角度来看，微服务模式变得更加可行。 因此，如果我们想要实施微服务的话，我们最好仔细慎重考虑是否真的需要。我们已经看到了高大上的“理论效益”，但值得一提的是，未知的挑战又是什么？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:2","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"微服务有什么问题呢？ 微服务如此强大、完美，哪里还会有什么挑战？这是目前我见过的最大的问题。 开发的复杂性增加 对于开发者来说事情会变得更加困难。在开发人员想要在远程工作的情况下，或者可能跨越许多服务的功能的情况下，开发人员必须在他们的机器上运行它们，或者连接到它们。这通常比简单地运行单个程序更复杂。 这个挑战可以通过工具（附录3）得到部分缓解，但随着构成系统的服务数量的增加，开发人员在整个系统运行时面临的挑战也会越来越多。 运维的复杂性增加 对于不开发服务但维护服务的团队来说，潜在的复杂性是一个巨大的挑战。他们不是管理几个正在运行的服务，而是管理数十，数百或数千个正在运行的服务。服务越多，沟通越多，潜在的失败风险就越多。 DevOps的复杂性增加 阅读以上两点，可能会发现运维和开发是分开处理的，尤其是考虑到DevOps作为一种实践的普及（我是DevOps的真爱粉）。DevOps难道不能缓解这一痛点？ 目前面临的挑战是，许多组织仍然依靠独立的开发和运营团队来运行 - 而一些组织则更倾向于采用微服务。 对于已经采用了DevOps的组织来说，这仍然很难。既是开发者又是运维者，已经非常艰难（但是要建立好的软件却很关键），但是也必须了解容器编排系统的细微差别，特别是快速发展的系统是非常困难的。这使我想到了下一点。 没专业知识？别玩微服务 当很多事情都由专家完成时，最终的结果也将是极好的。但想象一下，一个机构或组织使用单一的整体系统并不总是可以很顺利的运行。那做些什么能够来改善并让这些事情变得更好呢？通过增加系统服务的数量？但同时也会增加运行的复杂性。 不可否认，通过有效的自动化、监控和编排等，这一切都可以改善。但挑战很少是技术本身——真正的挑战其实是找到能够有效使用技术的人。恰恰目前这些技能需求非常高，可能很难找到符合你需求的人。 现实世界的系统往往界限不清 在我们用来描述微服务的好处的所有例子中，我们都谈到了独立的组件。但是在很多情况下，组件并不是完全独立的。正所谓“纸上得来终觉浅，绝知此事要躬行”，某些领域可能看起来有限，但是当你陷入冗繁的细节时，你会发现他们比你预期的更具挑战性。 这是事情变得非常复杂的地方。事实上，如果你的边界没有明确定义，那么会发生什么情况呢？即使理论上的服务可以单独部署，你会发现，由于服务之间的相互依赖关系，你必须部署一系列微服务作为一个组服务。 这意味着你需要管理协同工作的版本，这些版本的服务在联调时会经过验证和测试，你实际上没有可独立部署的系统，因为要部署新功能，你需要仔细编排许多服务的同时去部署。 状态的复杂性往往被忽略 在前面的例子中，我提到一个功能部署可能需要同时部署多个版本的许多服务。假设合理的部署技术将缓解这种情况，例如蓝/绿部署（大多数服务编排平台很少原生支持这种功能），或者并行运行多个版本的服务，以及决定使用哪个版本的消费通道。 如果服务是无状态的，这些技术可以缓解大量的挑战。但是无国界的服务非常坦率，容易处理。事实上，如果你有无状态的服务，那么我会倾向于考虑跳过微服务，并考虑使用无服务器模型。 实际上，许多服务需要管理。我们的视频共享平台的一个例子可能是订阅服务。订阅服务的新版本可以以不同形状将数据存储在订阅数据库中。如果你同时运行这两个服务，则一次运行两个模式的系统。如果您进行了蓝／绿部署，而其他服务依赖于新形状中的数据，则必须同时更新这些数据，并且如果订阅服务部署失败并回滚，则可能还需要使用级联回滚。 同样，可能你会说，在NoSQL数据库中，这些架构问题会消失，但事实并非如此。不强制执行模式的数据库无法连接无模式系统——这意味着模式往往是在应用程序级而不是数据库级进行管理的。理解数据结构以及如何流转的根本性问题并不能被消除。 沟通的复杂性往往被忽略 当你建立一个相互依赖的大型服务网络时，可能会有很多的服务间通信。这导致了一些挑战。首先，有很多事情可能会失败。我们必须假设网络call可能会失败，这意味着当一个服务call另一个服务时，它应该至少需要重试几次。现在当一个服务可能调用很多服务时，我们最终会遇到一个更加复杂的情况。 用户上传视频共享服务中的视频。我们可能需要运行upload服务，将数据传递到transcode服务，更新订阅，更新建议等等。所有这些调用都需要一定程度的协调，如果过程中任何部分失败，我们都需要重试。 这个重试逻辑可能难以管理。试图同步做事往往会导致站不住脚，失败点太多。在这种情况下，更可靠的解决方案是使用异步模式来处理通信。这里面临的挑战是异步模式本身往往会使系统具有状态性。如前所述，分布式状态系统和有状态系统很难处理。 当一个微服务系统使用消息队列进行服务内通信时，你基本上需要有一个大的数据库（消息队列或代理）将这些服务组合在一起。同样，虽然起初看起来似乎不是一个挑战，但你懂的——出来混迟早都是要还的。X版本的服务可能会写入某种格式的消息，当发送服务更改发送的消息的详细信息时，依赖于该消息的服务也将需要更新。 当然，可以有许多不同格式的消息处理服务，但这很难管理。现在，在部署新版本的服务时，你可能会有两个不同版本的服务尝试处理来自同一队列的消息，甚至可能是由不同版本的发送服务发送的消息。这可能会导致复杂的边缘情况。为了避免这些边缘情况，仅允许特定版本的消息存在可能更容易，这意味着你需要将一组服务的版本作为一个整体来部署，以确保先前版本的消息被正确地屏蔽。 这再次突出表明，独立部署的想法可能不会像预期的那样顺利。 版本控制可能很难 为了缓解前面提到的挑战，版本控制需要非常谨慎的管理。再说一下，看起来貌似有一种趋势——假设遵循像Semver[4]这样的标准或许将可以解决这个问题。然而事实并非完全如此。虽然Semver是一个合理的使用惯例，但是你仍然需要持续的跟踪那些可以一起工作的服务和API的版本。 这可能会使事情变得非常具有挑战性，并且很多时候可能会让你感到困惑——哪些版本的服务可以一起正常工作。 在软件系统中管理依赖关系是非常困难的，无论是节点模块，Java模块，C库还是其他。当一个实体消费独立组件之间的冲突的挑战是很难处理的。 当依赖关系是静态的时候，这些挑战是很难处理的。虽然可以进行修补、更新、编辑等，但是如果依赖关系本身是实时服务，那么你可能根本无法更新它们——你可能需要运行许多版本（上面已经描述过这些挑战），或者直到整个系统得到修复。 分布式事务 在需要跨操作交易完整性的情况下，微服务可能会非常痛苦。分布式状态很难处理，很多小的单位可能会很难进行编排交易。 试图通过使操作幂等性，提供重试机制等来避免这个问题可能听起来很诱人，而且在很多情况下确实可能起作用。但可能有一些场景，你只需要一个事务失败或成功，而不想它处于中间状态。解决这个问题或者在微服务模型中实现它的代价可能是非常高的。 微服务可能是变相的庞然大物 显然，单独的服务和组件可能是孤立部署的，但是在大多数情况下，你将不得不运行某种编排平台，比如Kubernetes。如果你使用的是托管服务，例如Google的GKE 5或Amazon的EKS 6，则会为你处理管理群集的大量复杂性。 但是，如果你要自己管理集群，那么你正在管理一个庞大而复杂的关键任务系统。尽管单个服务可能具有前面所述的所有优点，但你需要非常小心地管理群集。这个系统的部署可能很难，更新可能很难，故障转移可能也很困难等等。 在许多情况下，总体收益仍然存在，但重要的是不要轻视或低估管理另一个庞大而复杂系统的额外复杂性。托管服务可能会有所帮助，但在很多情况下，这些服务都是新兴的不稳定的（例如，Amazon EKS直到在2017年底才宣布）——谁用谁知道。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:3","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"微服务疯狂之死！ 只有通过仔细考虑才能避免为微服务而微服务的疯狂。为了帮助解决这个问题，我想了一些你可能想问自己的问题，以及可能的答案： 在考虑微服务时问自己的问题 你可以在这里下载PDF副本：microservice-questions.pdf ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:4","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"最后的想法：不要混淆微服务和架构 我故意避免这篇文章中的“a”字。但是，我的朋友Zoltan在校对这篇文章的时候提到了一个很好的观点。 没有微服务体系结构。微服务只是组件的另一种模式或实现，无他。无论是否存在于系统中，都不意味着系统的体系结构得到了解决。 微服务在许多方面与打包和运维的技术过程有关，而不是系统的固有设计。组件的适当边界仍然是工程系统中最重要的挑战之一。 无论你的服务是否在Docker容器中，你总是需要仔细考虑如何将系统放在一起。没有唯一的答案，只有更多的选择。 我希望你看完这篇文章觉得有趣！一如既往，如果你有任何疑问或想法，请在下面评论即可。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:5","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"附录：进一步阅读 以下链接可能有用： Martin Fowler - Bounded Context - 马丁的文章是很棒的，我极力推荐这一篇。 Martin Fowler - 微服务 - 这篇着重介绍微服务的模式。 微服务 - 好还是坏？ - 阅读这篇文章，你将了解BjörnFrantzén对微服务的看法。 什么时候不要做微服务 - 来自于Christian Posta的话题中的优秀帖子 Dave Kerr -微服务整体架构 - 微服务世界中CI / CD和DevOps的实用技巧 - 最近一次关于微服务的devops会议演示。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:6","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"参考 [https://trends.google.com/trends/explore?date=today 5-y\u0026q=microservice](https://trends.google.com/trends/explore?date=today 5-y\u0026q=microservice) 如果你不想错过这篇文章，你可以订阅RSS源，或者在LinkedIn或Twitter上关注我。 Docker Compose是一个很好的解决方案，Fuge非常聪明，在MiniKube这种情况下，也可以选择在本地运行编排。 https://semver.org/ 谷歌Kubernetes引擎，一个从谷歌云平台诞生Kubernetes托管服务：https://cloud.google.com/kubernetes-engine/ 亚马逊弹性容器服务（已支持Kubernetes），一个从亚马逊Web服务诞生的Kubernetes托管服务：https://aws.amazon.com/eks/ 原文链接：The Death of Microservice Madness in 2018（翻译：王杰） ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:7","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning"],"content":"银行跑批业务的初步理解（批量批量.....流水账）","date":"2021-07-28","objectID":"/run-batch/","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"一、初步理解 白天的柜台交易, 实时的 对帐户进行操作。 晚上 批量 , 比如 一些报表的生成 , 定期储蓄到期的自动转存 , 行内行外业务清分清算 ， 有时还可能赶上利息计算……. 当然 不是所有的数据都是实时操作 , 因此跑批就是为此诞生。 ","date":"2021-07-28","objectID":"/run-batch/:1:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"二、逐渐深入 批量是相对来说，并不一定是在晚上，白天也有批量，主要是完成业务处理的。 批量的核心功能是进行 核算，如总分核对、试算平衡 等，这样保证全行的帐务没有偏差。 一般，为提高交易的 反应时间，一些 对帐清算 等不需要实时入账的功能 也由批量完成；同时，还有一些为了减少柜员工作量和减少高峰时期资源争夺的交易，如待收代付等，也归入批量完成的功能。一些特殊业务，如记息记提等。还有一块批量就是为了统计和管理的需要而出的一些报表。 ","date":"2021-07-28","objectID":"/run-batch/:2:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"三、跑批… 跑批 最主要就是产生总帐, 进行总分核对。或者 是进行大批量交易，如:结息,计提,代收付等(这一步可以在各分布平台做)。或者 是生成报表,导出流水数据等。简单来讲就是每天结算几次，一般是在10点到12点左右。 ","date":"2021-07-28","objectID":"/run-batch/:3:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"四、更深入的理解 每天系统需要跑批一次，将所有分行还有办事处的信息录入到总的计算机内，进行分析、运算。然后将第二天需要的事情发布出去（比如卡函的打印，账单的答应） ","date":"2021-07-28","objectID":"/run-batch/:4:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Back","note"],"content":"记录MyBatis-Plus使用的笔记","date":"2021-07-28","objectID":"/mybatisplus-note/","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 通用BaseMapper使用介绍 详细见快速开始 拥有 Java 开发环境以及相应 IDE 熟悉 Spring Boot 熟悉 Maven 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 其对应的数据库 Schema 脚本如下： DROPTABLEIFEXISTSuser;CREATETABLEuser(idBIGINT(20)NOTNULLCOMMENT'主键ID',nameVARCHAR(30)NULLDEFAULTNULLCOMMENT'姓名',ageINT(11)NULLDEFAULTNULLCOMMENT'年龄',emailVARCHAR(50)NULLDEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(id)); 其对应的数据库 Data 脚本如下： DELETEFROMuser;INSERTINTOuser(id,name,age,email)VALUES(1,'Jone',18,'test1@baomidou.com'),(2,'Jack',20,'test2@baomidou.com'),(3,'Tom',28,'test3@baomidou.com'),(4,'Sandy',21,'test4@baomidou.com'),(5,'Billie',24,'test5@baomidou.com'); ::: danger Question 如果从零开始用 MyBatis-Plus 来实现该表的增删改查我们需要做什么呢？ ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"初始化工程 创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示） ::: tip 可以使用 Spring Initializer 快速初始化一个 Spring Boot 工程 ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"添加依赖 引入 Spring Boot Starter 父工程： \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003espring-latest-version\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e 引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、h2 依赖： Latest Version: \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003eLatest Version\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"配置 在 application.yml 配置文件中添加 H2 数据库的相关配置： # DataSource Configspring:datasource:driver-class-name:org.h2.Driverschema:classpath:db/schema-h2.sqldata:classpath:db/data-h2.sqlurl:jdbc:h2:mem:testusername:rootpassword:test 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： @SpringBootApplication @MapperScan(\"com.baomidou.mybatisplus.samples.quickstart.mapper\") public class Application { public static void main(String[] args) { SpringApplication.run(QuickStartApplication.class, args); } } ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:3","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"编码 编写实体类 User.java（此处使用了 Lombok 简化代码） @Data public class User { private Long id; private String name; private Integer age; private String email; } 编写Mapper类 UserMapper.java public interface UserMapper extends BaseMapper\u003cUser\u003e { } ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:4","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"开始使用 添加测试类，进行功能测试： @SpringBootTest public class SampleTest { @Autowired private UserMapper userMapper; @Test public void testSelect() { System.out.println((\"----- selectAll method test ------\")); List\u003cUser\u003e userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); } } ::: tip UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件 ::: 控制台输出： User(id=1, name=Jone, age=18, email=test1@baomidou.com) User(id=2, name=Jack, age=20, email=test2@baomidou.com) User(id=3, name=Tom, age=28, email=test3@baomidou.com) User(id=4, name=Sandy, age=21, email=test4@baomidou.com) User(id=5, name=Billie, age=24, email=test5@baomidou.com) ::: tip 完整的代码示例请移步：Spring Boot 快速启动示例 | Spring MVC 快速启动示例 ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:5","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 但 MyBatis-Plus 的强大远不止这些功能，想要详细了解 MyBatis-Plus 的强大功能，请继续学习 ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:6","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 通用IService使用介绍 ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"一、引言 MP除了通用的Mapper还有通用的Servcie层，这也减少了相对应的代码工作量，把通用的接口提取到公共。其实按照MP的这种思想，可以自己也实现一些通用的Controller。 由于官网文档没有IService的使用教程，快速开始仅仅有Mapper的教程，故写了本文 ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"二、IService使用 Service Service层需要继承IService，当然实现层也要继承对应的实现类。 /** * \u003cp\u003e * 用户 服务类 * \u003c/p\u003e * * @author IT贱男 * @since 2019-06-14 */ public interface UserService extends IService\u003cUser\u003e { } /** * \u003cp\u003e * 用户 服务实现类 * \u003c/p\u003e * * @author IT贱男 * @since 2019-06-14 */ @Service public class UserServiceImpl extends ServiceImpl\u003cUserMapper, User\u003e implements UserService { } 这里基本的增删改查就不一一演示了，演示几个特殊一点的方法。 getOne()，这个是方法返回结果不止一条则会抛出异常，如果想默认取第一条结果，可以给这方法传第二个参数为false。 @Test public void getOne() { User one = userService.getOne(Wrappers.\u003cUser\u003elambdaQuery().eq(User::getAge, 31),false); System.out.println(one); } saveOrUpdateBatch()，批量新增或者修改方法,判断ID是否存在，如果ID不存在执行新增，如果ID存在先执行查询语句，查询结果为空新增，否则修改。 @Test public void saveOrUpdateBatch() { User user1 = new User(); user1.setName(\"兔子\"); user1.setAge(18); User user2 = new User(); user2.setId(1088250446457389060L); user2.setName(\"乌龟\"); user2.setAge(18); List\u003cUser\u003e users = Arrays.asList(user1, user2); boolean b = userService.saveOrUpdateBatch(users); System.out.println(b); } 接下来说一下基于lambda的相关操作 /** * lombda查询 */ @Test public void lambdaQuery(){ List\u003cUser\u003e list = userService.lambdaQuery().eq(User::getAge, 18).list(); list.forEach(System.out::println); } /** * lombda修改 */ @Test public void lambdaUpdate(){ boolean update = userService.lambdaUpdate().eq(User::getAge, 18).set(User::getAge, 31).update(); System.out.println(update); } /** * lombda删除 */ @Test public void lambdaRemoce(){ boolean remove = userService.lambdaUpdate().eq(User::getAge, 18).remove(); System.out.println(remove); } ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"Maybatis-Plus lambdaQuery和mapper中EQ、NE、GT、LT、GE、LE的对时间的用法及详解 ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"1.等于当前时间 taskFlowService.lambdaQuery().eq(TaskFlow::getCreateTime,DateUtil.now()) ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"2.不等于当前时间 taskFlowService.lambdaQuery().ne(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"3.大于当前时间 taskFlowService.lambdaQuery().gt(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:3","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"4.小于当前时间 taskFlowService.lambdaQuery().lt(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:4","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"5.大于等于当前时间 taskFlowService.lambdaQuery().ge(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:5","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"6.小于等于当前时间 taskFlowService.lambdaQuery().le(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:6","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"7.2个时间段是否相交 if((!start1.after(end2))\u0026\u0026(!end1.before(start2))){ System.out.println(\"时间重叠\"); } ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:7","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 更新操作示例 @Component public class UserMapperUpdateTest extends MybatisPlusSamplesChapter1ApplicationTests { @Resource private UserMapper userMapper; @Test public void updateById() { User user = new User(); user.setId(1087982257332887553L); user.setEmail(\"gblfy@163.com\"); user.setAge(22); int rows = userMapper.updateById(user); System.out.println(\"影响记录数:\" + rows); } //UPDATE user SET age=?, email=? WHERE id=? /** * 根据 whereEntity 条件，更新记录 * * @param entity 实体对象 (set 条件值,可以为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） */ @Test public void updateByWrapper() { UpdateWrapper\u003cUser\u003e updateWrapper = new UpdateWrapper\u003c\u003e(); updateWrapper.eq(\"name\", \"李艺伟\") .eq(\"age\", 28); User user = new User(); user.setEmail(\"gblfy2@sino.com\"); user.setAge(22); int rows = userMapper.update(user, updateWrapper); System.out.println(\"影响记录数:\" + rows); } //UPDATE user SET age=?, email=? WHERE name = ? AND age = ? /** * 当表中字段很多,只更新少量字段的值（建议使用） */ @Test public void updateByWrapper2() { UpdateWrapper\u003cUser\u003e updateWrapper = new UpdateWrapper\u003c\u003e(); updateWrapper.eq(\"name\", \"李艺伟\") .eq(\"age\", 28) .set(\"age\", 30); int rows = userMapper.update(null, updateWrapper); System.out.println(\"影响记录数:\" + rows); //UPDATE user SET age=?, email=? WHERE name = ? AND age = ? } @Test public void updateByWrapperLambda() { LambdaUpdateWrapper\u003cUser\u003e lambdaUpdateWrapper = Wrappers.\u003cUser\u003elambdaUpdate(); lambdaUpdateWrapper.eq(User::getName, \"李艺伟\") .eq(User::getAge, 28) .set(User::getAge, 30); int rows = userMapper.update(null, lambdaUpdateWrapper); System.out.println(\"影响记录数:\" + rows); } @Test public void updateByWrapperLambdaChain() { boolean sign = new LambdaUpdateChainWrapper\u003cUser\u003e(userMapper) .eq(User::getName, \"李艺伟\") .eq(User::getAge, 22) .set(User::getAge, 30).update(); System.out.println(sign); } //UPDATE user SET age=? WHERE name = ? AND age = ? ","date":"2021-07-28","objectID":"/mybatisplus-note/:4:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 分页查询示例 IPage封装了各种分页的信息，包括不限于总页数，当前页数，总个数，是否有上一页或下一页等 @GetMapping(\"/user/allpage\") public IPage\u003cPrimaryUser\u003e getAllIP() { IPage\u003cPrimaryUser\u003e primaryUserPage = primaryUserMapper.selectPage(new Page\u003c\u003e(1,2),null); return primaryUserPage; } ","date":"2021-07-28","objectID":"/mybatisplus-note/:5:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 模糊查询及QueryWrapper\u003c\u003e常用条件方法介绍 【通用条件：】 【比较大小： ( =, \u003c\u003e, \u003e, \u003e=, \u003c, \u003c= )】 eq(R column, Object val); // 等价于 =，例: eq(\"name\", \"老王\") ---\u003e name = '老王' ne(R column, Object val); // 等价于 \u003c\u003e，例: ne(\"name\", \"老王\") ---\u003e name \u003c\u003e '老王' gt(R column, Object val); // 等价于 \u003e，例: gt(\"name\", \"老王\") ---\u003e name \u003e '老王' ge(R column, Object val); // 等价于 \u003e=，例: ge(\"name\", \"老王\") ---\u003e name \u003e= '老王' lt(R column, Object val); // 等价于 \u003c，例: lt(\"name\", \"老王\") ---\u003e name \u003c '老王' le(R column, Object val); // 等价于 \u003c=，例: le(\"name\", \"老王\") ---\u003e name \u003c= '老王' 【范围：（between、not between、in、not in）】 between(R column, Object val1, Object val2); // 等价于 between a and b, 例： between(\"age\", 18, 30) ---\u003e age between 18 and 30 notBetween(R column, Object val1, Object val2); // 等价于 not between a and b, 例： notBetween(\"age\", 18, 30) ---\u003e age not between 18 and 30 in(R column, Object... values); // 等价于 字段 IN (v0, v1, ...),例: in(\"age\",{1,2,3}) ---\u003e age in (1,2,3) notIn(R column, Object... values); // 等价于 字段 NOT IN (v0, v1, ...), 例: notIn(\"age\",{1,2,3}) ---\u003e age not in (1,2,3) inSql(R column, Object... values); // 等价于 字段 IN (sql 语句), 例: inSql(\"id\", \"select id from table where id \u003c 3\") ---\u003e id in (select id from table where id \u003c 3) notInSql(R column, Object... values); // 等价于 字段 NOT IN (sql 语句) 【模糊匹配：（like）】 like(R column, Object val); // 等价于 LIKE '%值%'，例: like(\"name\", \"王\") ---\u003e name like '%王%' notLike(R column, Object val); // 等价于 NOT LIKE '%值%'，例: notLike(\"name\", \"王\") ---\u003e name not like '%王%' likeLeft(R column, Object val); // 等价于 LIKE '%值'，例: likeLeft(\"name\", \"王\") ---\u003e name like '%王' likeRight(R column, Object val); // 等价于 LIKE '值%'，例: likeRight(\"name\", \"王\") ---\u003e name like '王%' 【空值比较：（isNull、isNotNull）】 isNull(R column); // 等价于 IS NULL，例: isNull(\"name\") ---\u003e name is null isNotNull(R column); // 等价于 IS NOT NULL，例: isNotNull(\"name\") ---\u003e name is not null 【分组、排序：（group、having、order）】 groupBy(R... columns); // 等价于 GROUP BY 字段, ...， 例: groupBy(\"id\", \"name\") ---\u003e group by id,name orderByAsc(R... columns); // 等价于 ORDER BY 字段, ... ASC， 例: orderByAsc(\"id\", \"name\") ---\u003e order by id ASC,name ASC orderByDesc(R... columns); // 等价于 ORDER BY 字段, ... DESC， 例: orderByDesc(\"id\", \"name\") ---\u003e order by id DESC,name DESC having(String sqlHaving, Object... params); // 等价于 HAVING ( sql语句 )， 例: having(\"sum(age) \u003e {0}\", 11) ---\u003e having sum(age) \u003e 11 【拼接、嵌套 sql：（or、and、nested、apply）】 or(); // 等价于 a or b， 例：eq(\"id\",1).or().eq(\"name\",\"老王\") ---\u003e id = 1 or name = '老王' or(Consumer\u003cParam\u003e consumer); // 等价于 or(a or/and b)，or 嵌套。例: or(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e or (name = '李白' and status \u003c\u003e '活着') and(Consumer\u003cParam\u003e consumer); // 等价于 and(a or/and b)，and 嵌套。例: and(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e and (name = '李白' and status \u003c\u003e '活着') nested(Consumer\u003cParam\u003e consumer); // 等价于 (a or/and b)，普通嵌套。例: nested(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e (name = '李白' and status \u003c\u003e '活着') apply(String applySql, Object... params); // 拼接sql（若不使用 params 参数，可能存在 sql 注入），例: apply(\"date_format(dateColumn,'%Y-%m-%d') = {0}\", \"2008-08-08\") ---\u003e date_format(dateColumn,'%Y-%m-%d') = '2008-08-08'\") last(String lastSql); // 无视优化规则直接拼接到 sql 的最后，可能存若在 sql 注入。 exists(String existsSql); // 拼接 exists 语句。例: exists(\"select id from table where age = 1\") ---\u003e exists (select id from table where age = 1) 【QueryWrapper 条件：】 select(String... sqlSelect); // 用于定义需要返回的字段。例： select(\"id\", \"name\", \"age\") ---\u003e select id, name, age select(Predicate\u003cTableFieldInfo\u003e predicate); // Lambda 表达式，过滤需要的字段。 lambda(); // 返回一个 LambdaQueryWrapper 【UpdateWrapper 条件：】 set(String column, Object val); // 用于设置 set 字段值。例: set(\"name\", null) ---\u003e set name = null etSql(String sql); // 用于设置 set 字段值。例: setSql(\"name = '老李头'\") ---\u003e set name = '老李头' lambda(); // 返回一个 LambdaUpdateWrapper 我们直接创建测试类进行展示 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); 在QueryWrapper\u003c\u003e中，有很多已经编译好的方法，我们可以直接进行调用， @Test void test4(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.likeRight(\"name\",\"K\"); // .likeRight(\"email\",4); 右查询 左%e%右 List\u003cMap\u003cString,Object\u003e\u003em","date":"2021-07-28","objectID":"/mybatisplus-note/:6:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"SpringBoot连接使用PostgreSQL数据库","date":"2021-07-28","objectID":"/postgresql-note/","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"一、介绍 此次更新时间：2020-10-28，现在是上班时间，偷更一下。其实使用IDEA的话无需配置Maven什么的，如果你们公司不是强制要求使用Eclipse的话，只需要有个JDK的环境即可，IDEA自带了一个版本的Maven，还是挺新的，目前IDEA最新版2.2.3的版本。我们也不用按照下面这个步骤去下载Spring Initializr，我们在IDEA中新建项目选择到Maven就行了，干净简洁。 目前在Resources目录下的application大多数是使用yml语法了。现在已经太长时间没有接触过 postgresql了，长期使用MySQL，只要数据量在几百万，加加索引，优化SQL工作量还是不大，而且外面的公司还是比较愿意使用MySQL的，我面试别人的时候，也不会问什么乱七八糟的数据库，考虑到公司的业务和生成报表相关，对于SQL优化非常重视，所以数据库只问MySQL。 这篇文章是初次接触 PostgreSQL 时所写，从MyBatis 1.3.2 的版本大家也能看的出来，本来写了个简单的CRUD的DEMO，结果时间太久找不到了。 ","date":"2021-07-28","objectID":"/postgresql-note/:1:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"1、情况说明 在这里我使用SpringBoot配置JPA连接到PostgreSql数据库的。源码也会提供给大家（此文末尾），效果如下 数据库： 运行效果： ","date":"2021-07-28","objectID":"/postgresql-note/:1:1","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"2、安装软件及依赖包 完整搭建SpringBoot及依赖包：https://blog.csdn.net/qq_41647999/article/details/83214100 需要的SpringBoot代码从Spring官网下载：https://start.spring.io/ Mybaits官网：http://www.mybatis.org/mybatis-3/ 最关键的地方是在依赖包那里，需要引用Mybaits和PostgreSql的包。 什么是JPA 和 Mybaits? 两者都是基于JDBC做了连接持久化的两个开源框架，jdbc不陌生吧，每次连接都要创建实例，执行完sql之后还要关闭连接实例，做了持久化之后，就会大大降低IO的开销。JPA不用自己写SQL，mybatis按理来说是需要自己写SQL的（使用通用Mapper或者Mybatis plus 也能不写SQL），各有各的好处。 将下载的项目解压出来。 ","date":"2021-07-28","objectID":"/postgresql-note/:1:2","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"二、配置 如果您的环境配置和我搭建SpringBoot的博文一样的话，用eclipse打开项目。 连接数据库 resources //数据库的地址以及端口号 spring.datasource.url=jdbc:postgresql://localhost:5432/postgres //账号（默认为postgres） spring.datasource.username=postgres //密码 spring.datasource.password=123456ok spring.datasource.driverClassName=org.postgresql.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.hbm2ddl.auto=update yml spring:datasource:# primary:url:jdbc:postgresql://localhost:5432/postgres# url: jdbc:mysql://localhost:3306/springboot?useSSL=false# jdbc-url: jdbc:mysql://localhost:3306/springboot?useSSL=falseusername:postgrespassword:********# username: root# password: ********driver-class-name:org.postgresql.Driver# driver-class-name: com.mysql.cj.jdbc.Driver 其他情况 当然如果您的项目是按照上面的链接搭建的，也可以通过在pom.xml中添加代码，如图。 这里需要注意的一点是，要清楚您使用的Mybaits的依赖包是否符合！ \u003cdependency\u003e \u003cgroupId\u003eorg.postgresql\u003c/groupId\u003e \u003cartifactId\u003epostgresql\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2021-07-28","objectID":"/postgresql-note/:2:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"重置自增序列 分为从43开始、从43开始、从42开始 SELECTsetval('myseq',42);#Nextnextvalwillreturn43SELECTsetval('myseq',42,true);#SameasaboveSELECTsetval('myseq',42,false);#Nextnextvalwillreturn42altersequencedataset_id_seqstartwith1;#只能增大不能减小 ","date":"2021-07-28","objectID":"/postgresql-note/:3:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"schemas问题 PGSql默认的是public,如果用MybatisPlus的内置方法的话,是需要指定连接的CurrentSchema的,否则只会默认查询public,自己写Sql可以在前面加上schemas 但是使用内置方法没有,必须在连接url指定schemsa,否则会报ERROR: relation “item” does not exist表不存在 ","date":"2021-07-28","objectID":"/postgresql-note/:4:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"postgresql—-IN\u0026\u0026EXISTS ","date":"2021-07-28","objectID":"/postgresql-note/:5:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"一.IN \u0026\u0026 NOT IN WHERE expression IN (subquery) 右边圆括号内是返回一个字段的子查询结果集，左边的表达式（或字段）对查询结果每一行进行一次运算和比较，如果结果集中存在相等的行，则IN结果为’TRUE'，否则为’FALSE'; WHERE expression NOT IN (subquery) NOT IN与IN正相反，如果结果集中不存在相等的行结果为’TRUE'，否则为’FALSE'。 测试表： test=# \\d tbl_test Table \"public.tbl_test\" Column | Type | Modifiers --------+---------+----------- f | integer | test=# \\d tbl_insert Table \"public.tbl_insert\" Column | Type | Modifiers --------+-----------------------+----------- a | integer | b | integer | c | character varying(12) | test=# select * from tbl_test ; f --- 1 3 5 (3 rows) test=# select * from tbl_insert; a | b | c ---+---+------- 1 | 1 | 11 2 | 2 | 22 3 | 3 | 33 4 | 4 | 44 5 | 5 | 51 6 | 6 | 1 6 | 6 | 61 6 | 6 | 661 7 | 7 | 3%1 8 | 8 | 3%_1 8 | 8 | 3_%_1 7 | 7 | abc 7 | 7 | ABc 7 | 7 | aBC (14 rows) 示例1.查询tbl_insert表,且a字段值在tbl_test表字段f中的行 test=# select * from tbl_insert where a in (select f from tbl_test); a | b | c ---+---+---- 1 | 1 | 11 3 | 3 | 33 5 | 5 | 51 (3 rows) 示例2.查询tbl_insert表,且a字段值比tbl_test表字段f小1的行 test=# select * from tbl_insert where a+1 in (select f from tbl_test); a | b | c ---+---+---- 2 | 2 | 22 4 | 4 | 44 (2 rows) 示例3.查询tbl_insert表,且a字段值不在tbl_test表字段f中的行 test=# select * from tbl_insert where a not in (select f from tbl_test); a | b | c ---+---+------- 2 | 2 | 22 4 | 4 | 44 6 | 6 | 1 6 | 6 | 61 6 | 6 | 661 7 | 7 | 3%1 8 | 8 | 3%_1 8 | 8 | 3_%_1 7 | 7 | abc 7 | 7 | ABc 7 | 7 | aBC (11 rows) 示例4.查询tbl_insert表,且a字段值等于5或7的行 test=# select * from tbl_insert where a in (5,7); a | b | c ---+---+----- 5 | 5 | 51 7 | 7 | 3%1 7 | 7 | abc 7 | 7 | ABc 7 | 7 | aBC (5 rows) ","date":"2021-07-28","objectID":"/postgresql-note/:5:1","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"二.XISTS \u0026\u0026 NOT EXISTS WHERE EXISTS (subquery) 括号内同样是一个子查询，如果子查询有返回结果，则EXISTS结果为’TRUE'，否则为’FALSE'。 WHERE NOT EXISTS(subquery) NOT EXISTS与EXISTS正好相反，如果子查询没有返回结果，为’TRUE'，否则’FALSE'。 示例1.查询tbl_insert表,且a字段值在tbl_test表字段f中的行 test=# select * from tbl_insert where exists (select null from tbl_test where tbl_test.f=tbl_insert.a); a | b | c ---+---+---- 1 | 1 | 11 3 | 3 | 33 5 | 5 | 51 (3 rows) 示例2.查询tbl_insert表,且a字段值不在tbl_test表字段f中的行 test=# select * from tbl_insert where not exists (select null from tbl_test where tbl_test.f=tbl_insert.a); a | b | c ---+---+------- 2 | 2 | 22 4 | 4 | 44 6 | 6 | 1 6 | 6 | 61 6 | 6 | 661 7 | 7 | 3%1 8 | 8 | 3%_1 8 | 8 | 3_%_1 7 | 7 | abc 7 | 7 | ABc 7 | 7 | aBC (11 rows) PS:NOT IN的效率非常低，如果可以的话建议使用NOT EXISTS。 ","date":"2021-07-28","objectID":"/postgresql-note/:5:2","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"PostgreSql 查看退出 Replication Slot 查看Replication Slot： SELECT*FROMpg_replication_slots; 删除一个Replication Slot： selectpg_drop_replication_slot('debezium'); ","date":"2021-07-28","objectID":"/postgresql-note/:6:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"PostgreSql 查询所有表名 SELECTtablenameFROMpg_tablesWHEREtablenameNOTLIKE'pg%'ANDtablenameNOTLIKE'sql_%'ORDERBYtablename; 或 selecttablenamefrompg_tableswhereschemaname='public' ","date":"2021-07-28","objectID":"/postgresql-note/:7:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"PostgreSql数据库表实现ID自增 postgresql数据库可以创建主键，但是没有像mysql那样直接指定主键自增的auto_increment关键字，因此如果在postgresql中创建表指定主键自增使用auto_increment会报错。那么如何实现主键自增，postgresql通过序列来实现。序列可以实现自动增长，而且表字段可以指定默认值，因此可以通过指定默认值的方式来实现主键自增。 postgresql提供了三种serial类型：smallserial,serial,bigserial，他不是真正的类型，而是在创建唯一标识符列的标志以方便使用。bigserial会创建一个bigint类型的自增，serial用以创建一个int类型的自增，依次类推。 下面通过实例演示自增ID的实现： 通过建表语句，可以看到，因为使用了serial类型，所以会创建一个关联的sequece，名为aaa_id_seq。 接着查看表结构，并向表中插入数据： 表aaa实现了id自增功能，表的id默认值是nextval(‘aaa_id_seq’::regclass)。 按照这个思路，我们可以这么来干，一般的主键表，没有使用serial类型，那么我们可以通过创建序列，并修改表ID默认值字段，指定默认值字段为序列的nextval。 我们创建一个普通的int类型ID，并设置为主键。建表不会出现创建序列的notice内容。 这个表的插入，如果不指定id,那么就会出现错误： 接着我们创建一个序列： createsequencebbb_id_seqstartwith1incrementby1nominvaluenomaxvaluecache1; 设置表bbb的ID字段的默认值为nextval(bbb_id_seq) altertablebbbaltercolumnidsetdefaultnextval('bbb_id_seq'); 再次向bbb中插入记录，这次不用关心ID字段了。 通过查看表结构，看看两种方式产生的表： postgresql查找索引的方法也是和mysql不一样，postgresql查看索引的语法是： select*frompg_indexeswheretablename='bbb'; 或者 select*frompg_statio_all_indexeswhererelname='bbb'; 可以看到，postgresql默认索引也是通过btree来创建的。 最后再补充一点内容，查看序列和查看表结构是一样的，都是使用\\d来查看，比如\\d aaa_id_seq。 ","date":"2021-07-28","objectID":"/postgresql-note/:8:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"pg_catalog.“default\"作用 字段使用lc_collate作为排序标准 查看default collate SHOWlc_collate; 创建表时修改collate CREATETABLEcollate_test(default_collatetext,--Default collation custom_collatetextCOLLATEpg_catalog.\"C\"--Custom collation ); 文档 The collation feature allows specifying the sort order and character classification (…) ","date":"2021-07-28","objectID":"/postgresql-note/:9:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back"],"content":"记录Springboot Mybatis Plus解决多数据源的几种办法","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"目标 在开发中经常会遇到一个程序需要调用多个数据库的情况，总得来说分为下面的几种情况： 一个程序会调用不同结构的两个数据库。 读写分离，两个数据结构可能一样高，但是不同的操作针对不同的数据库。 混合情况，既有不同的结构的数据库，也可能存在读写分离的情况。 下面针对第一种情况，提供一个解决方案。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:1:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路1 因为两个数据库的功能和结构不一样，所以可以根据功能和结构把DAO分为两个package。然后再mapperscan中指定不同的package对接不同的数据源，即可达到多个数据源的共存。 配置yml中的数据源设置 spring:datasource:emanage:#SpringBoot 1.xurl:jdbc:mysql://127.0.0.1:3306/emanage?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=true#SpringBoot 2.x# jdbc-url: jdbc:mysql://127.0.0.1:3306/emanage?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=trueusername:rootpassword:******driver-class-name:com.mysql.cj.jdbc.Driverehr:#SpringBoot 1.xurl:jdbc:mysql://127.0.0.1:3306/ehr?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=true#SpringBoot 2.x# jdbc-url: jdbc:mysql://127.0.0.1:3306/ehr?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=trueusername:rootpassword:********driver-class-name:com.mysql.cj.jdbc.Driver 为了不必要的干扰，我把druid数据源的配置部分给删除了。 数据源配置注意事项 多数据源配置的时候，与单数据源不同点在于spring.datasource之后多设置一个数据源名称primary和secondary来区分不同的数据源配置，这个前缀将在后续初始化数据源的时候用到。 数据源连接配置2.x和1.x的配置项是有区别的：2.x使用spring.datasource.secondary.jdbc-url，而1.x版本使用spring.datasource.secondary.url。如果你在配置的时候发生了这个报错java.lang.IllegalArgumentException: jdbcUrl is required with driverClassName.，那么就是这个配置项的问题。 可以看到，不论使用哪一种数据访问框架，对于数据源的配置都是一样的。 建立两个datasource的配置 datasource1的 配置 @Configuration @MapperScan(basePackages = {\"com.emanage.ehr.mapper.emanage\"},sqlSessionTemplateRef = \"sqlTemplate1\") public class DataSourceConfig1 { @Bean(name = \"datasource1\") @ConfigurationProperties(prefix = \"spring.datasource.emanage\") public DruidDataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"sqlFactory1\") public SqlSessionFactory sqlSessionFactory(@Qualifier(\"datasource1\") DruidDataSource dataSource) throws Exception { MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); factoryBean.setMapperLocations(resolver.getResources(\"classpath*:mapper/emanage/**Mapper.xml\")); return factoryBean.getObject(); } @Bean(name = \"sqlTemplate1\") public SqlSessionTemplate sqlSessionTemplate(@Qualifier(\"sqlFactory1\") SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } datasource2的配置 @Configuration @MapperScan(basePackages = {\"com.emanage.ehr.mapper.ehr\"},sqlSessionTemplateRef = \"sqlTemplate2\") public class DataSourceConfig2 { @Bean(name = \"datasource2\") @ConfigurationProperties(prefix = \"spring.datasource.ehr\") public DataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"sqlFactory2\") public SqlSessionFactory sqlSessionFactory(@Qualifier(\"datasource2\") DataSource dataSource) throws Exception { MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); factoryBean.setMapperLocations(resolver.getResources(\"classpath*:mapper/ehr/**Mapper.xml\")); return factoryBean.getObject(); } @Bean(name = \"sqlTemplate2\") public SqlSessionTemplate sqlSessionTemplate(@Qualifier(\"sqlFactory2\") SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } 两个datasource的配置基本上一样。就是建立datasource,sqlsessionFactory，sqlSessionTemplate的注入。然后通过mapperscan来指定具体什么包采用什么数据源。然后再对应包里就和以前单数据源一样操作即可。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"注意事项 如果用myBatis, SqlSessionFactory 部分可以使用SqlSessionFactoryBean来生成。但是如果用mybatis plus一定要用MybatisSqlSessionFactoryBean 来生成SqlSessionFactory。否则会报错 ，无法直接通过BaseMapper去调用查询。 如果要再不同的包中混合上XML进行调用。需要在SqlSessionFactory的配置中设置factoryBean.setMapperLocations(resolver.getResources(“classpath*:mapper/ehr/**Mapper.xml”)); ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"优缺点 优点：简单，通过简单的设置。就可以满足大多数的情况。 缺点：只适合多个数据源的结构完全不一样，通过package可以分来的方式来调用，不能灵活的在一个package下面随心所欲的调用数据源。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:2","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路2 总config和各自的config分开，总config用于导入配置数据源，各自config用于Service、Dao层链接数据库使用 总数据源，初始化数据源与MyBatis-Plus配置 完成多数据源的配置信息之后，就来创建个配置类来加载这些配置信息，初始化数据源，以及初始化每个数据源要用的MyBatis配置。 这里我们继续将数据源与框架配置做拆分处理： 单独建一个多数据源的配置类，比如下面这样： @Configuration public class DataSourceConfiguration { @Primary @Bean @ConfigurationProperties(prefix = \"spring.datasource.primary\") public DataSource primaryDataSource() { return DataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.secondary\") public DataSource secondaryDataSource() { return DataSourceBuilder.create().build(); } } 通过@Configuration可以知道这两个数据源分别加载了spring.datasource.primary.*和spring.datasource.secondary.*的配置。@Primary注解指定了主数据源，就是当我们不特别指定哪个数据源的时候，就会使用这个Bean真正差异部分在下面的JPA配置上。 第一个数据源，分别创建两个数据源的MyBatis配置。 Primary数据源的JPA配置： @Configuration @MapperScan( //这里如果单数据源只需写到mysql，会自动寻找mapper，多数据源要写到mapper文件夹否则报错 basePackages = \"cn.edu.hubu.lhy.multiplydatabase.mysql.mapper\", sqlSessionFactoryRef = \"sqlSessionFactoryPrimary\", sqlSessionTemplateRef = \"sqlSessionTemplatePrimary\") public class PrimaryConfig { private DataSource primaryDataSource; public PrimaryConfig(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource) { this.primaryDataSource = primaryDataSource; } @Bean public SqlSessionFactory sqlSessionFactoryPrimary() throws Exception { // SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); MybatisSqlSessionFactoryBean bean = new MybatisSqlSessionFactoryBean(); bean.setDataSource(primaryDataSource); return bean.getObject(); } @Bean public SqlSessionTemplate sqlSessionTemplatePrimary() throws Exception { return new SqlSessionTemplate(sqlSessionFactoryPrimary()); } } 第二个数据源，Secondary数据源的JPA配置： @Configuration @MapperScan( //这里如果单数据源只需写到postgresql，会自动寻找mapper，多数据源要写到mapper文件夹否则报错 basePackages = \"cn.edu.hubu.lhy.multiplydatabase.postgresql.mapper\", sqlSessionFactoryRef = \"sqlSessionFactorySecondary\", sqlSessionTemplateRef = \"sqlSessionTemplateSecondary\") public class SecondaryConfig { private DataSource secondaryDataSource; public SecondaryConfig(@Qualifier(\"secondaryDataSource\") DataSource secondaryDataSource) { this.secondaryDataSource = secondaryDataSource; } @Bean public SqlSessionFactory sqlSessionFactorySecondary() throws Exception { // SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); MybatisSqlSessionFactoryBean bean = new MybatisSqlSessionFactoryBean(); bean.setDataSource(secondaryDataSource); return bean.getObject(); } @Bean public SqlSessionTemplate sqlSessionTemplateSecondary() throws Exception { return new SqlSessionTemplate(sqlSessionFactorySecondary()); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:3:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"注意事项 说明与注意： 配置类上使用@MapperScan注解来指定当前数据源下定义的Entity和Mapper的包路径；另外需要指定sqlSessionFactory和sqlSessionTemplate，这两个具体实现在该配置类中类中初始化。 配置类的构造函数中，通过@Qualifier注解来指定具体要用哪个数据源，其名字对应在DataSourceConfiguration配置类中的数据源定义的函数名。 配置类中定义SqlSessionFactory和SqlSessionTemplate的实现，注意具体使用的数据源正确（如果使用这里的演示代码，只要第二步没问题就不需要修改）。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:3:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路3 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"基础的配置 数据源的yml配置和上一结一样，就不在赘述了。 建立一个枚举类来标识两个数据源 public enum DataSourceType { emanage,ehr } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"建立一个线程和数据源之间的关联类 public class DataBaseContextHolder { private static final ThreadLocal\u003cDataSourceType\u003e contextHolder = new ThreadLocal\u003c\u003e(); public static void setDataSourceType(DataSourceType type) { if(type == null) { throw new NullPointerException(); } contextHolder.set(type); } public static DataSourceType getDataSourceType() { DataSourceType type = contextHolder.get(); if(type == null) { //确定一个默认数据源 return DataSourceType.emanage; } return type; } public static void clearDataSrouceType() { contextHolder.remove(); } } 代码比较简单。就是当我们设置一个Mapper是通过那个数据源去访问数据的时候，把设置的参数保存在contextHolder中，为了处理线程安全，采用ThreadLocal的方式。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:2","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"定义动态数据源 public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DataBaseContextHolder.getDataSourceType(); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:3","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"定义多数据源 @Configuration @MapperScan(\"com.emanage.ehr.mapper\") public class DataSourceConfig { @Autowired private Environment env; @Bean(name = \"datasource1\") @ConfigurationProperties(prefix = \"spring.datasource.emanage\") public DruidDataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"datasource2\") @ConfigurationProperties(prefix = \"spring.datasource.ehr\") public DruidDataSource druidDataSource2() { return DruidDataSourceBuilder.create().build(); } @Bean public DynamicDataSource dynamicDataSource(@Qualifier(\"datasource1\") DruidDataSource ds1, @Qualifier(\"datasource2\") DruidDataSource ds2) { Map\u003cObject, Object\u003e targetDataSource = new HashMap\u003c\u003e(); targetDataSource.put(DataSourceType.emanage, ds1); targetDataSource.put(DataSourceType.ehr, ds2); DynamicDataSource dataSource = new DynamicDataSource(); dataSource.setTargetDataSources(targetDataSource); dataSource.setDefaultTargetDataSource(ds1); return dataSource; } @Bean public SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDataSource) throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); // 指定数据源 bean.setDataSource(dynamicDataSource); bean.setMapperLocations(resolver.getResources(\"classpath*:mapper/**Mapper.xml\")); return bean.getObject(); } @Bean public DataSourceTransactionManager transactionManager(DynamicDataSource dynamicDataSource) { return new DataSourceTransactionManager(dynamicDataSource); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:4","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"使用数据源 在调用mapper之前，在service中执行以下代码，可以灵活的切换数据源。 DataBaseContextHolder.setDataSourceType(DataSourceType.emanage); DataBaseContextHolder.setDataSourceType(DataSourceType.ehr); ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:5","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"优化升级 感觉在sevrice中调用这些代码太过繁琐，可以自己定义两个注解。 public @interface DataSourceEmanage{} public @interface DataSourceEHr{} 然后建立一个aop类让在有些注解的mapper类执行之前，先执行相应的数据源切换。 @Aspect @Component public class DataSourceAop { @Before(\"@annotation(com.example.demo3.config.DataSourceEmanage)\") public void setEmanageDataSource() { DataBaseContextHolder.setDataSourceType(DataSourceType.emanage); } @Before(\"@annotation(com.example.demo3.config.DataSourceEhr)\") public void setEhrDataSource() { DataBaseContextHolder.setDataSourceType(DataSourceType.ehr); } } 只需要在mapper对应的方法上面设置注解，就可以很灵活的实现不同的方法调用不同的数据源。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:6","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"记录简单安装PostgreSQL(绿色版)","date":"2021-07-28","objectID":"/postgresql-install/","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"〇.概况 目前版本是PostgreSQL 9.6，它经过以下平台认证： 32位Windows Windows 7,8和10 Windows 2008 Server 64位Windows Windows 7,8和10 Windows 2012 Windows 2008 在windows下可以用安装版安装，也可以用免安装版安装，这里主要是演示免安装版 ","date":"2021-07-28","objectID":"/postgresql-install/:1:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"一.下载 选择免安装版zip版： https://www.postgresql.org/download/windows/ 然后选择你的系统环境，我的是win10 64位所以我选的如下图： https://www.enterprisedb.com/download-postgresql-binaries 点击链接下载 ","date":"2021-07-28","objectID":"/postgresql-install/:2:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"二.安装 1）把下好的zip包解压到你想放的地方： 我放的地方是 D:\\tools\\postgres\\pgsql 文件夹下 2）新建一个data文件夹，用来存放数据 3）初始化数据库 进入bin目录并执行初始化命令 initdb.exe -D D:\\tools\\postgres\\pgsql\\data -E UTF-8 --locale=chs -U postgres -W 注： -D ：指定数据库簇的存储目录D:\\tools\\postgres\\pgsql\\data -E ：指定DB的超级用户的用户名postgres –locale：关于区域设置（chinese-simplified-china） -U ：默认编码格式chs -W ：为超级用户指定密码的提示 期间会提示你输入你要配置的postgres用户的密码！ 4）启动数据库 pg_ctl -D D:\\tools\\postgres\\pgsql\\data -l logfile start 这样就可以简单的安装成功了 5）接下来用它自带的客户端访问： 点击bin目录下的pgAdmin3.exe文件 然后配置下就可以访问 6）注册为系统服务 现在可以用但是不是系统服务，每次启动都得手动起，比较麻烦所以接下来注册为系统服务 在bin目录下用管理员身份执行命令： pg_ctl register -N PostgreSQL -D D:\\tools\\postgres\\pgsql\\data 然后查看是否成功： 查看已经注册的服务：win+R在弹出的运行框中，输入：services.msc，如下： 这样就算在windows下简单安装postgresql成功了！ ","date":"2021-07-28","objectID":"/postgresql-install/:3:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"记录new与newInstance()的区别","date":"2021-07-28","objectID":"/new-newinstance-diff/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"简单测试 String st = (String)Class.forName(\"java.lang.String\").newInstance(); String st1=new String(); boolean bl=st.getClass()==st1.getClass(); System.out.println(bl); 返回为ture 这两种方法得到的结果是一样的 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"原因 分析下原因，第一种方法是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化 可以分解开 Class cla=Class.forName(\"java.lang.String\");//初始化 Object obj=cla.newInstance();//实例化为object类 String str=(String)obj;//向下转换回子类 //但 Class.forName();//有它自己的用法 通过 String str =\"\"； Class c = Class.forName(str); c.newInstance(); 可以动态的创建对象 Object st = (String)Class.forName(\"java.lang.String\").newInstance(); 这个方法返回的是一个类，可以强制转换成各种子类 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"主要作用 因此可以改变强制转换的类型与forName()的参数来创建不同类型的对象，只要他们是Object的子类 在连接数据库时，发现还可以这样用Class.forName(driver); 查找资料了解到，这个方法在使用时，JVM会查找并加载指定的类，也就是说JVM会执行该类的静态代码段 而使用new时，这个类可以没有被加载(是可以不是一定) 测试使用Driver dri=new Driver();一样加载了类 然后测试了下构造方法的调用 class ceshi{ int a=0; public ceshi(){ System.out.println(a); } } Class aaa=Class.forName(\"ceshi\");//没有调用构造方法 aaa.newInstance();//调用 new ceshi();//调用 如果想要调用构造方法，需要调用newInstance.forname()会导致类被初始化，newInstance()才会实例化，而new()初始化+实例化 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"总结 初始化和实例化的区别，另开一篇再做研究 相比较，new的语句简单，可以在创建时加入参数调用构造函数，而newInstance()把创建对象步骤分开，使得更灵活 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"记录PO,BO,VO和POJO的区别","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"PO persistent object 持久对象 1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。 2 ．在hibernate持久化框架中与insert/delet操作密切相关。 3 ．PO中不应该包含任何对数据库的操作。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:1:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"POJO plain ordinary java object 无规则简单java对象 一个中间对象，可以转化为PO、DTO、VO。 1 ．POJO持久化之后==〉PO （在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。） 2 ．POJO传输过程中==〉DTO 3 ．POJO用作表示层==〉VO PO 和VO都应该属于它。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:2:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"BO business object 业务对象 业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。 建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 这样处理业务逻辑时，我们就可以针对BO去处理。 封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。 关于BO主要有三种概念 1 、只包含业务对象的属性； 2 、只包含业务方法； 3 、两者都包含。 在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:3:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"VO value object 值对象 / view object 表现层对象 1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象。 2 ．可以和表对应，也可以不，这根据业务的需要。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:4:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"DTO（TO） Data Transfer Object 数据传输对象 1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。 2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:5:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"DAO data access object数据访问对象 1 ．主要用来封装对DB的访问（CRUD操作）。 2 ．通过接收Business层的数据，把POJO持久化为PO。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:6:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"简易的关系图 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:7:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"Windows安装驱动报错：无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","date":"2021-07-27","objectID":"/driver-install-kernel32-error/","tags":["Windows","Windows7","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"报错 今天，在电脑刚安装完Windows 7系统后准备打驱动，结果所有驱动都无法安装，报错**“无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll”** ","date":"2021-07-27","objectID":"/driver-install-kernel32-error/:1:0","tags":["Windows","Windows7","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"解决方法 去微软官网下载 windows6.1-kb2533623-x64.msu 补丁程序，安装完成后重启计算机即可，微软官网下载链接已挂，这里提供下载链接： 链接：https://pan.baidu.com/s/1B-TbJ7oJsAgZ_Zg_oBxbYQ 提取码：60j5 ","date":"2021-07-27","objectID":"/driver-install-kernel32-error/:2:0","tags":["Windows","Windows7","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"解决lombok时Mybaties报错 nested exception is org.apache.ibatis.executor.result.ResultMapException","date":"2021-07-27","objectID":"/mybatis-nested-exception/","tags":["Java","ORM","Mybaties","Error"],"title":"Mybaties报错 nested exception is org.apache.ibatis.executor","uri":"/mybatis-nested-exception/"},{"categories":["Back"],"content":"报错 nested exception is org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column ‘user_name’ from result set. Cause: java.lang.NumberFormatException: For input string: “shenzhenhytzb” 原因：使用lambok时使用了@Builder注解导致没有无参构造器，添加注解@NoArgsConstructor @AllArgsConstructor ","date":"2021-07-27","objectID":"/mybatis-nested-exception/:1:0","tags":["Java","ORM","Mybaties","Error"],"title":"Mybaties报错 nested exception is org.apache.ibatis.executor","uri":"/mybatis-nested-exception/"},{"categories":["Back"],"content":"SpringBoot2.0 报错：“jdbcUrl is required with driverClassName.”解决办法！","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"报错 Springboot 升级到2.0之后发现配置多数据源的时候报错 “jdbcUrl is required with driverClassName.”或者Cause: java.lang.IllegalArgumentException: dataSource or dataSourceClassName or jdbcUrl is required.] with root cause ","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/:1:0","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"原因 主要原因是在1.0 配置数据源的过程中主要是写成：spring.datasource.url 和spring.datasource.driverClassName。 而在2.0升级之后需要变更成：spring.datasource.jdbc-url和spring.datasource.driver-class-name即可解决！ ","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/:2:0","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"使用mybatisplus出现的问题 com.baomidou.mybatisplus.extension.service.IService cannot be inherited with different type arguments: com.sha.code.model.SysRoleEntity and com.sha.code.model.SysRoleMenuEntity","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back"],"content":"报错原因 'com.baomidou.mybatisplus.extension.service.IService' cannot be inherited with different type arguments: 'com.sha.code.model.SysRoleEntity' and 'com.sha.code.model.SysRoleMenuEntity' Error:(17, 8) java: 无法使用以下不同的参数继承com.baomidou.mybatisplus.extension.service.IService: \u003ccom.sha.code.model.SysRoleMenuEntity\u003e 和 \u003ccom.sha.code.model.SysRoleEntity\u003e ","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/:1:0","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back"],"content":"解决方式 SysRoleService.java中IService中参数写错 修改前 public interface SysRoleService extends IService\u003cSysRoleMenuEntity\u003e { } 修改后 public interface SysRoleService extends IService\u003cSysRoleEntity\u003e { } ","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/:2:0","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back","note"],"content":"记录学习Mybatis的笔记","date":"2021-07-27","objectID":"/mybatis-note/","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"MapperScan注解包含多个包 单个包 @MapperScan(\"com.mysiteforme.admin.dao\") 多个包 @MapperScan({\"com.mysiteforme.admin.dao\",\"com.zipon.tpf.dao\"}) ","date":"2021-07-27","objectID":"/mybatis-note/:1:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"实体类忽略映射字段 非数据库字段，如果不做处理，mybatis执行sql过程中会报错，Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘…’ in ‘field list’ 对非数据库字段使用注解@TableField(exist = false) @TableField(exist = false)//：表示该属性不为数据库表字段，但又是必须使用的。 @TableField(exist = true)//：表示该属性为数据库表字段。 Mybatis-Plus 插件有这个功能，可以看一下 @TableName//：数据库表相关 @TableId//：表主键标识 @TableField//：表字段标识 @TableLogic//：表字段逻辑处理注解（逻辑删除） ","date":"2021-07-27","objectID":"/mybatis-note/:2:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"script标签作用 1、用script标签包围，然后像xml语法一样书写 @Select({\"\u003cscript\u003e\", \"SELECT * FROM tbl_order\", \"WHERE 1=1\", \"\u003cwhen test='title!=null'\u003e\", \"AND mydate = #{mydate}\", \"\u003c/when\u003e\", \"\u003c/script\u003e\"}) 2、用Provider去实现SQL拼接，例如： public class OrderProvider { private final String TBL_ORDER = \"tbl_order\"; public String queryOrderByParam(OrderPara param) { SQL sql = new SQL().SELECT(\"*\").FROM(TBL_ORDER); String room = param.getRoom(); if (StringUtils.hasText(room)) { sql.WHERE(\"room LIKE #{room}\"); } Date myDate = param.getMyDate(); if (myDate != null) { sql.WHERE(\"mydate LIKE #{mydate}\"); } return sql.toString(); } } public interface OrderDAO { @SelectProvider(type = OrderProvider.class, method = \"queryOrderByParam\") List\u003cOrder\u003e queryOrderByParam(OrderParam param); } 注意：方式1有个隐患就是当传入参数为空的时候，可能会造成全表查询。 复杂SQL用方式2会比较灵活（当然，并不建议写复杂SQL），而且可以抽象成通用的基类，使每个DAO都可以通过这个基类实现基本的通用查询，原理类似Spring JDBC Template。 3、说明： 如果XML元素嵌入在\u003cscript\u003eXML元素中，则可以在注释值中为动态SQL使用XML元素： @Select(\"\u003cscript\u003eSELECT ...\u003c/script\u003e\") 但是使用\u003cinclude\u003e元素会触发SQL Mapper配置解析异常，由以下原因引起： org.apache.ibatis.builder.BuilderException: Unknown element in SQL statement. at org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.parseDynamicTags 如果nodeHandlers在课堂中检查方法org.apache.ibatis.builder.BuilderException，将注意到支持的元素有： trim where set foreach if choose when otherwise bind 然而，包括基于注释的查询中的片段是不可能的。 参考： https://segmentfault.com/q/1010000006875476（以上内容转自此篇回答） https://stackoverflow.com/questions/6685655/how-to-use-dynamic-sql-query-in-mybatis-with-annotationhow-to-use-selectprovide http://www.blogjava.net/dbstar/archive/2011/08/08/355825.html http://www.jianshu.com/p/03642b807688 https://stackoverflow.com/questions/33129344/is-there-a-way-to-reuse-sql-fragments-in-annotation-based-mybatis-ibatis ","date":"2021-07-27","objectID":"/mybatis-note/:3:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"\u003c![CDATA[ ]]\u003e的作用、使用、注意事项。 sql中字符串拼接 SELECT*FROMtableNameWHEREnameLIKECONCAT(CONCAT('%',#{text}),'%'); 使用 ${…} 代替 #{…} （不能防止sql注入 #{}—\u003e可以防止sql注入的问题） SELECT*FROMtableNameWHEREnameLIKE'%${text}%'; 程序中拼接 Java // or String searchText = \"%\" + text + \"%\"; String searchText = new StringBuilder(\"%\").append(text).append(\"%\").toString(); parameterMap.put(\"text\", searchText); SqlMap.xml SELECT*FROMtableNameWHEREnameLIKE#{text}; \u003c![CDATA[ ]]\u003e 标记避免Sql中与xml规范相冲突的字符对xml映射文件的合法性造成影响 如：\u003c![CDATA[price_from \u003e= #{price_from}]]\u003e ","date":"2021-07-27","objectID":"/mybatis-note/:4:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"limit参数 参数page=1,rows=3 错误写法： select*fromxxxlimit#{page},#{rows} 报错： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1','3'' at line 1 可以看出mybatis自动给我们的参数加了 引号 ' ‘,所以报错 解决方法：#{}改为${} 正确写法： select*fromxxxlimit${page},${rows} ","date":"2021-07-27","objectID":"/mybatis-note/:5:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"结果封装为List 1.结果封装为List 接口示例： 接口示例： public List\u003cMembers\u003e selectMembersListByName(String name); 配置文件示例： \u003cselect id=\"selectMembersListByName\" resultType=\"members\"\u003e select * from members where member_name like #{member_name} \u003c/select\u003e 运行结果： 运行结果： [Member [id=3, member_name=关云长, password=123456, age=54], Member [id=4, member_name=关云长, password=123456, age=54]] 返回值类型resultType还是对象类型并不是list，mybatis会自动将对象封装成list集合 ","date":"2021-07-27","objectID":"/mybatis-note/:6:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"将单条记录封装成Map\u003cString,Object\u003e，其中key就是表的列名，value就是对应的值 接口示例： public Map\u003cString, Object\u003e selectMembersByIdReturnMap(Integer id); 配置文件示例： 其中resultType是map，因为mybatis为常用类已经起了别名（typeAliases） \u003cselect id=\"selectMembersByIdReturnMap\" resultType=\"map\"\u003e select * from members where id = #{id} \u003c/select\u003e 运行结果： {pass_word=123456, id=1, member_name=张三, age=25} ","date":"2021-07-27","objectID":"/mybatis-note/:6:1","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"将多条记录封装成Map其中key是我们指定字段的名字，value是记录对象Map\u003cString,Members\u003e 接口示例： @MapKey就是指定map中key是什么 @MapKey(\"id\") public Map\u003cString, Members\u003e selectMembersByNameReturnMap(String name); 配置文件示例： 返回值类型还是对象 \u003cselect id=\"selectMembersByNameReturnMap\" resultType=\"members\"\u003e select * from members where member_name like #{member_name} \u003c/select\u003e 运行结果： {3=Member [id=3, member_name=关云长, password=123456, age=54], 4=Member [id=4, member_name=关云长, password=123456, age=54]} ","date":"2021-07-27","objectID":"/mybatis-note/:6:2","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"MyBatis动态传入表名 mybatis里#{}与${}的用法： 　在动态sql解析过程，#{}与${}的效果是不一样的： #{ } 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符。 　如以下sql语句 select*fromuserwherename=#{name}; 　会被解析为： select*fromuserwherename=?; 　可以看到#{}被解析为一个参数占位符？。 ${ } 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换 　如以下sql语句： select*fromuserwherename=${name}; 　当我们传递参数“sprite”时，sql会解析为： select*fromuserwherename=\"sprite\"; 　可以看到预编译之前的sql语句已经不包含变量name了。 　综上所得， ${ } 的变量的替换阶段是在动态 SQL 解析阶段，而 #{ }的变量的替换是在 DBMS 中。 #{}与${}的区别可以简单总结如下： #{}将传入的参数当成一个字符串，会给传入的参数加一个双引号 ${}将传入的参数直接显示生成在sql中，不会添加引号 #{}能够很大程度上防止sql注入，${}无法防止sql注入 　${}在预编译之前已经被变量替换了，这会存在sql注入的风险。如下sql select*from${tableName}wherename=${name} 　如果传入的参数tableName为user; delete user; –，那么sql动态解析之后，预编译之前的sql将变为： select*fromuser;deleteuser;-- where name = ?; 　–之后的语句将作为注释不起作用，顿时我和我的小伙伴惊呆了！！！看到没，本来的查询语句，竟然偷偷的包含了一个删除表数据的sql，是删除，删除，删除！！！重要的事情说三遍，可想而知，这个风险是有多大。 ${}一般用于传输数据库的表名、字段名等 能用#{}的地方尽量别用${} 　进入正题，通过上面的分析，相信大家可能已经对如何动态调用表名和字段名有些思路了。示例如下： \u003cselect id=\"getUser\" resultType=\"java.util.Map\" parameterType=\"java.lang.String\" statementType=\"STATEMENT\"\u003e select ${columns} from ${tableName} where COMPANY_REMARK = ${company} \u003c/select\u003e 　要实现动态调用表名和字段名，就不能使用预编译了，需添加statementType=“STATEMENT”\" 。 statementType：STATEMENT（非预编译），PREPARED（预编译）或CALLABLE中的任意一个，这就告诉 MyBatis 分别使用Statement，PreparedStatement或者CallableStatement。 默认：PREPARED。这里显然不能使用预编译，要改成非预编译。 　其次，sql里的变量取值是${xxx},不是#{xxx}。 　因为${}是将传入的参数直接显示生成sql，如${xxx}传入的参数为字符串数据，需在参数传入前加上引号，如： String name = \"sprite\"; name = \"'\" + name + \"'\"; ","date":"2021-07-27","objectID":"/mybatis-note/:7:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"@ Transient注解 ORM框架中是否和数据库的列做映射，帮助理解XmlTransient ","date":"2021-07-27","objectID":"/mybatis-note/:8:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"Mybatis传递多个参数的4种方式 现在大多项目都是使用Mybatis了，但也有些公司使用Hibernate。使用Mybatis最大的特性就是sql需要自己写，而写sql就需要传递多个参数。面对各种复杂的业务场景，传递参数也是一种学问。 下面给大家总结了以下几种多参数传递的方法。 方法1：顺序传参法 public User selectUser(String name, int deptId); \u003cselect id=\"selectUser\" resultMap=\"UserResultMap\"\u003e select * from user where user_name = #{0} and dept_id = #{1} \u003c/select\u003e #{}里面的数字代表你传入参数的顺序。 这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。 方法2：@Param注解传参法 public User selectUser(@Param(\"userName\") String name, int @Param(\"deptId\") deptId); \u003cselect id=\"selectUser\" resultMap=\"UserResultMap\"\u003e select * from user where user_name = #{userName} and dept_id = #{deptId} \u003c/select\u003e #{}里面的名称对应的是注解 @Param括号里面修饰的名称。 这种方法在参数不多的情况还是比较直观的，推荐使用。 方法3：Map传参法 public User selectUser(Map\u003cString, Object\u003e params); \u003cselect id=\"selectUser\" parameterType=\"java.util.Map\" resultMap=\"UserResultMap\"\u003e select * from user where user_name = #{userName} and dept_id = #{deptId} \u003c/select\u003e #{}里面的名称对应的是 Map里面的key名称。 这种方法适合传递多个参数，且参数易变能灵活传递的情况。 方法4：Java Bean传参法 public User selectUser(User params); \u003cselect id=\"selectUser\" parameterType=\"com.test.User\" resultMap=\"UserResultMap\"\u003e select * from user where user_name = #{userName} and dept_id = #{deptId} \u003c/select\u003e #{}里面的名称对应的是 User类里面的成员属性。 这种方法很直观，但需要建一个实体类，扩展不容易，需要加属性，看情况使用。 ","date":"2021-07-27","objectID":"/mybatis-note/:9:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"Mybatis使用in传入List的三种方法 1.非xml方式，使用注解传in，要使用 @Select(\"\u003cscript\u003e\" + \"SELECT count(DISTINCT member_id) as memberCount\\n\" + \"from member_analysis\\n\" + \"WHERE agent_id in \u003cforeach item='item' index='index' collection='memberIds' open='(' separator=',' close=')'\u003e\" + \"#{item}\" + \"\u003c/foreach\u003e\" + \"\u003c/script\u003e\") Integer getCountWithAgentId(@Param(\"memberIds\") List\u003cString\u003e memberIds); 其中的foreach的collection直接写成@param中的值即可。 2.在入参前进行字符串封装,拼成(,,,,)传值 @Select(\"SELECT count(DISTINCT member_id) as memberCount from member_analysis where access_pat_id in (#{memberIds})\") Integer getCountWithAgentId(@Param(\"memberIds\")String memberIds); 使用方法返回 public static String indexForm(List\u003cString\u003e s){ String content=\"\"; int i=0; for (String ss:s){ i++; if (i==s.size()){ content+=ss; }else { content+=ss+\",\"; } } return content; } 或者使用 StringUtils.join(memberIds.toArray(),\",\") 3.正常流程的xml方法 \u003cselect id=\"findByIds\" resultMap=\"BaseResultMap\"\u003e select * from dictionaries \u003cwhere\u003e dictionaries.key in \u003cforeach item=\"item\" index=\"index\" collection=\"memberTypes\" open=\"(\" separator=\",\" close=\" )\"\u003e #{item} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-07-27","objectID":"/mybatis-note/:10:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"type-aliases-package配置多个 ","date":"2021-07-27","objectID":"/mybatis-note/:11:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"问题 现在扫描的是com.ruoyi.project.domain这个路径，我想扫描多个路径，如：com.test.project.domain这个路径，该如何配置？ 我试了加逗号及空格都不行 typeAliasesPackage: com.ruoyi.project..domain,com.test.project..domain ","date":"2021-07-27","objectID":"/mybatis-note/:11:1","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"解决 typeAliasesPackage: com.ruoyi.project..domain,;com.test.project..domain,使用,; 详细讲解可以参考：type-aliases-package配置多个 ","date":"2021-07-27","objectID":"/mybatis-note/:11:2","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"记录SpringMVC不同注解及之间的区别","date":"2021-07-27","objectID":"/spring-mvc-annotation/","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"@Mapper和@Repository的区别 ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:1:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"前言 　@Mapper和 @Repository是常用的两个注解，两者都是用在dao上，两者功能差不多，容易混淆，有必要清楚其细微区别； ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:1:1","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"区别　 　@Repository需要在Spring中配置扫描地址，然后生成Dao层的Bean才能被注入到Service层中：如下，在启动类中配置扫描地址： @SpringBootApplication //添加启动类注解 @MapperScan(\"com.anson.dao\") //配置mapper扫描地址 public class application { public static void main(String[] args) { SpringApplication.run(application.class,args); } } 　@Mapper不需要配置扫描地址，通过xml里面的namespace里面的接口地址，生成了Bean后注入到Service层中。 　也就是@Repository多了一个配置扫描地址的步骤； ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:1:2","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"spring注解@service(“service”)括号中的service有什么用 service 是有用的相当于 xml配置中得bean id = service 也可以不指定 不指定相当于 bean id = com. service.service 就是这个类的全限定名,表示给当前类命名一个别名，方便注入到其他需要用到的类中；不加的话，默认别名就是当前类名，但是首字母小写 ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:2:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"Spring注解@Component、@Repository、@Service、@Controller区别 所以，如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释，而用 @Component 对那些比较中立的类进行注释。 在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 Spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cbeansxmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\" \u003e \u003ccontext:component-scan base-package=”com.eric.spring”\u003e \u003c/beans\u003e  其中base-package为需要扫描的包（含所有子包） @Service用于标注业务层组件，@Controller用于标注控制层组件（如struts中的action）,@Repository用于标注数据访问组件，即DAO组件，而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService{ } Repository public class VentorDaoImpl implements iVentorDao { }  getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的， 如果想改变，可以使用 @Service(“beanName”) @Scope(“prototype”)来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { }  注入方式： 把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到action中，注 入时不要new 这个注入的类，因为spring会自动注入，如果手动再new的话会出现错误，然后属性加上 @Autowired后不需要getter()和setter()方法，Spring也会自动注入。至于更具体的内容，等对注入的方式更 加熟练后会做个完整的例子上来。 注解： 在 spring的配置文件里面只需要加上\u003ccontext:annotation-config/\u003e和\u003ccontext:component-scanbase-package=\"需要实现注入的类所在包\"/\u003e， 可以使用base-package=\"*\"表示全部的类。 \u003c context:component-scan base-package=”com.eric.spring”\u003e 其中base-package为需要扫描的包（含所有子包） 在接口前面标上@Autowired和@Qualifier注释使得接口可以被容器注入，当接口存在两个实现类的时候必须指定其中一个来注入， 使用实现类首字母小写的字符串来注入，如： @Autowired @Qualifier(\"chinese\") private Man man; 否则可以省略，只写@Autowired 。 @Service服务层组件，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean， 例如Chinese实例化为chinese，如果需要自己改名字则:@Service(“你自己改的bean名”)。 @Controller用于标注控制层组件(如struts中的action) @Repository持久层组件，用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } getBean 的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”) 这样来指定，这种 bean默认是单例的，如果想改变，可以使用@Service(“beanName”)@Scope(“prototype”)来改变。 可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { } ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:3:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"Spring中@Autowired注解、@Resource注解的区别 Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Autowired 与@Resource的区别： @Autowired与@Resource都可以用来装配bean.都可以写在字段上,或写在setter方法上。 @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下： 1 @Autowired() @Qualifier(\"baseDao\") 2 private BaseDao baseDao; @Resource（这个注解属于J2EE的），默认安装名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 1 @Resource(name=\"baseDao\") 2 private BaseDao baseDao; 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。 ","date":"2021-07-27","objectID":"/spring-mvc-annotation/:4:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"SpringMVC不同注解及之间的区别","uri":"/spring-mvc-annotation/"},{"categories":["Back","note"],"content":"记录一些Spring学习的笔记","date":"2021-07-27","objectID":"/spring-annotation-note/","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"注解@service(“service”)括号中的service有什么用 service 是有用的相当于 xml配置中得bean id = service 也可以不指定 不指定相当于 bean id = com. service.service 就是这个类的全限定名,表示给当前类命名一个别名，方便注入到其他需要用到的类中；不加的话，默认别名就是当前类名，但是首字母小写 ","date":"2021-07-27","objectID":"/spring-annotation-note/:1:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"Spring注解@Component、@Repository、@Service、@Controller区别 所以，如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释，而用 @Component 对那些比较中立的类进行注释。 在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 Spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息： Java代码 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cbeansxmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\" \u003e \u003ccontext:component-scan base-package=”com.eric.spring”\u003e \u003c/beans\u003e \\6. 其中base-package为需要扫描的包（含所有子包） @Service用于标注业务层组件，@Controller用于标注控制层组件（如struts中的action）,@Repository用于标注数据访问组件，即DAO组件，而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService{ } Repository public class VentorDaoImpl implements iVentorDao { } getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的， 如果想改变，可以使用 @Service(“beanName”) @Scope(“prototype”)来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { } 注入方式： 把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到action中，注 入时不要new 这个注入的类，因为spring会自动注入，如果手动再new的话会出现错误，然后属性加上 @Autowired后不需要getter()和setter()方法，Spring也会自动注入。至于更具体的内容，等对注入的方式更 加熟练后会做个完整的例子上来。 注解： 在 spring的配置文件里面只需要加上\u003ccontext:annotation-config/\u003e和\u003ccontext:component-scanbase-package=\"需要实现注入的类所在包\"/\u003e， 可以使用base-package=\"*“表示全部的类。 \u003c context:component-scan base-package=”com.eric.spring”\u003e 其中base-package为需要扫描的包（含所有子包） 在接口前面标上@Autowired和@Qualifier注释使得接口可以被容器注入，当接口存在两个实现类的时候必须指定其中一个来注入， 使用实现类首字母小写的字符串来注入，如： @Autowired @Qualifier(\"chinese\") private Man man; 否则可以省略，只写@Autowired。 @Service服务层组件，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean， 例如Chinese实例化为chinese，如果需要自己改名字则:@Service(\"你自己改的bean名\")。 @Controller用于标注控制层组件(如struts中的action) @Repository持久层组件，用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } getBean 的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”) 这样来指定，这种 bean默认是单例的，如果想改变，可以使用@Service(“beanName”)``@Scope(“prototype”)来改变。 可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { } ","date":"2021-07-27","objectID":"/spring-annotation-note/:2:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"Spring中@Autowired注解、@Resource注解的区别 Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 \\1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 \\2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 \\3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 \\4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Autowired 与@Resource的区别： 1、 @Autowired与@Resource都可以用来装配bean.都可以写在字段上,或写在setter方法上。 2、 @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下： 1 @Autowired() @Qualifier(\"baseDao\") 2 private BaseDao baseDao; 3、@Resource（这个注解属于J2EE的），默认安装名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 1 @Resource(name=\"baseDao\") 2 private BaseDao baseDao; 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。 ","date":"2021-07-27","objectID":"/spring-annotation-note/:3:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"自定义Spring注解bean的命名策略 由于项目的需要spring的业务相关的bean不是写在xml文件中，因为项目是一个模块一个模块提交的，提交的时候不想修改xml文件，因此就用到了spring的注解Service。 例如： Java代码 @Service(\"TestService\") public class TestService { } 这等同于： \u003cbean id=\"TestService\" class=\"TestService\"/\u003e spring会在classpath里面扫描标记有TestService等标签的类，扫描组件的配置如下： Xml代码 \u003c!-- sdp-service主要是注入服务类 --\u003e \u003ccontext:component-scanbase-package=\"org.sdp\"/\u003e 加上以上的配置后，spring会自动的扫描org.sdp文件下的标记有注释的类。 以上的配置看似很“完美”，其实如果项目稍微大时就会出现问题，大家都知道spring的bean的id必须唯一，如果两个人同事写代码就有可以造成写同样的bean名称。 解决这个问题的一个思路是把bean的名称修改为 类的全路径，例如org.sdp.A 和com.bey.A 。 只要修改spring默认的bean命名策略就可以了。 AnnotationBeanNameGenerator是bean的默认命名策略，他实现了BeanNameGenerator接口。在Service里面，如果不写bean的名称，那么默认的名曾是类名，但是第一个字母是小写的。 例如： Html代码 com.xyz.FooServiceImpl -\u003e fooServiceImpl 观察spring的源代码发现，buildDefaultBeanName方法首先了bean名称小写的作用。 protected String buildDefaultBeanName (BeanDefinition definition){ String shortClassName = ClassUtils.getShortName(definition.getBeanClassName()); return Introspector.decapitalize(shortClassName); } 因此，可以写一个类继承自AnnotationBeanNameGenerator，重写buildDefaultBeanName方法。 public class SdpAnnotationBeanNameGenerator extends AnnotationBeanNameGenerator { @Override protected String buildDefaultBeanName(BeanDefinitiondefinition) { return definition.getBeanClassName(); } } 我的改下代码： @Override protected String buildDefaultBeanName(BeanDefinition definition) { String className = definition.getBeanClassName(); className = className.substring(className.lastIndexOf(\".\") + 1); if (className.toLowerCase().endsWith(\"impl\")) { className = className.substring(0, className.length() - 4); } if ((className.toLowerCase().endsWith(\"service\") || className.toLowerCase().endsWith(\"dao\")) == false) { return super.buildDefaultBeanName(definition); } className = className.substring(0, 1).toLowerCase() + className.substring(1); return className; } 在扫描配置中需要添加自己的命名策略类： \u003c!-- sdp-service主要是注入服务类 --\u003e \u003ccontext:component-scan base-package=\"org.sdp\" name-generator=\"org.sdp.spring.SdpAnnotationBeanNameGenerator\" /\u003e ","date":"2021-07-27","objectID":"/spring-annotation-note/:4:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back"],"content":"Idea中SpringBoot无法自动装配Could not autowire. No beans of 'UserMapper' type found. more...","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"报错 如上图 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:1:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案一 在自动转配的注解后面添加(required=false) @Autowired(required=false) public UserMapper userMapper; 当我们在使用@Autowired注解的时候，默认required=true,表示注入的时候bean必须存在，否则注入失败。 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:2:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案二 效果如图所示 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:3:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案三 在UserMapper上面添加 @Component(value =“userMapper”) 虽然能解决红线的问题， @Component注解，表明当需要创建类时，这个被注解的类是一个候选类。相当于类交给Spring管理，重新起个名字叫userMapper，但是并不推荐这样做。 在SpringBoot中集成MyBatis，可以在mapper接口上添加@Mapper注解，将mapper注入到Spring。但是如果每一给mapper都添加@mapper注解会很麻烦！！！ 这时可以使用@MapperScan注解来扫描包。 所以，一般在Application上面标注了MapperScan，如图所示。 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:4:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Software"],"content":"记录解决VSCode打开会一直黑屏无法使用的办法","date":"2021-07-27","objectID":"/vscode-open-black-error/","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Software"],"content":"问题 VSCode打开会一直黑屏无法使用。 我是黑屏 黑屏结束 ","date":"2021-07-27","objectID":"/vscode-open-black-error/:1:0","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Software"],"content":"解决 右击VSCode打开属性窗口并在【兼容性】标签页内勾上【以兼容模式运行这个程序】。 打次打开VSCode它就恢复正常了。 ","date":"2021-07-27","objectID":"/vscode-open-black-error/:2:0","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Back","note"],"content":"记录幂等性的笔记","date":"2021-07-27","objectID":"/idempotency-note/","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"幂等性 **就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。 在增删改查4个操作中，尤为注意就是增加或者修改，查询对于结果是不会有改变的，删除只会进行一次，用户多次点击产生的结果一样，修改在大多场景下结果一样，增加在重复提交的场景下会出现。 ","date":"2021-07-27","objectID":"/idempotency-note/:1:0","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"那么如何设计接口才能做到幂等呢？ ","date":"2021-07-27","objectID":"/idempotency-note/:2:0","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"方法一 单次支付请求，也就是直接支付了，不需要额外的数据库操作了，这个时候发起异步请求创建一个唯一的ticketId，就是门票，这张门票只能使用一次就作废，具体步骤如下： 1、异步请求获取门票 2、调用支付，传入门票 3、根据门票ID查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在，支付扣款，保存结果 4、返回结果到客户端 如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的. ","date":"2021-07-27","objectID":"/idempotency-note/:2:1","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"方法二 分布式环境下各个服务相互调用 这边就要举例我们的系统了，我们支付的时候先要扣款，然后更新订单，这个地方就涉及到了订单服务以及支付服务了。用户调用支付，扣款成功后，更新对应订单状态，然后再保存流水。而在这个地方就没必要使用门票ticketId了，因为会比较闲的麻烦（支付状态：未支付，已支付） 步骤： 1、查询订单支付状态 2、如果已经支付，直接返回结果 3、如果未支付，则支付扣款并且保存流水 4、返回支付结果 如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的 对于做过支付的朋友，幂等也可以称之为冲正，保证客户端与服务端的交易一致性，避免多次扣款。 以下为接口文档对于幂等的描述，通过请求id号来判断是否为同一个请求。 ","date":"2021-07-27","objectID":"/idempotency-note/:2:2","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"记录@EnableTransactionManagement的使用的笔记","date":"2021-07-20","objectID":"/springboot-enabletransactionmanagement/","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/springboot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"介绍 Spring Boot 使用事务非常简单，首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可。 关于事务管理器，不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果你添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager 实例。如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。 ","date":"2021-07-20","objectID":"/springboot-enabletransactionmanagement/:1:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/springboot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"方法 你可以在启动类中添加如下方法，Debug测试，就能知道自动注入的是 PlatformTransactionManager 接口的哪个实现类。 @EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 \u003ctx:annotation-driven /\u003e @SpringBootApplication public class ProfiledemoApplication { @Bean public Object testBean(PlatformTransactionManager platformTransactionManager){ System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\" + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 这些SpringBoot为我们自动做了，这些对我们并不透明，如果你项目做的比较大，添加的持久化依赖比较多，我们还是会选择人为的指定使用哪个事务管理器。 代码如下： @EnableTransactionManagement @SpringBootApplication public class ProfiledemoApplication { // 其中 dataSource 框架会自动为我们注入 @Bean public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean public Object testBean(PlatformTransactionManager platformTransactionManager) { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\" + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 在Spring容器中，我们手工注解@Bean 将被优先加载，框架不会重新实例化其他的 PlatformTransactionManager 实现类。 然后在Service中，被 @Transactional 注解的方法，将支持事务。如果注解在类上，则整个类的所有方法都默认支持事务。 对于同一个工程中存在多个事务管理器要怎么处理，请看下面的实例，具体说明请看代码中的注释。 @EnableTransactionManagement // 开启注解事务管理，等同于xml配置文件中的 \u003ctx:annotation-driven /\u003e @SpringBootApplication public class ProfiledemoApplication implements TransactionManagementConfigurer { @Resource(name=\"txManager2\") private PlatformTransactionManager txManager2; // 创建事务管理器1 @Bean(name = \"txManager1\") public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } // 创建事务管理器2 @Bean(name = \"txManager2\") public PlatformTransactionManager txManager2(EntityManagerFactory factory) { return new JpaTransactionManager(factory); } // 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器 @Override public PlatformTransactionManager annotationDrivenTransactionManager() { return txManager2; } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } @Component public class DevSendMessage implements SendMessage { // 使用value具体指定使用哪个事务管理器 @Transactional(value=\"txManager1\") @Override public void send() { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003eDev Send()\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\"); send2(); } // 在存在多个事务管理器的情况下，如果使用value具体指定 // 则默认使用方法 annotationDrivenTransactionManager() 返回的事务管理器 @Transactional public void send2() { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003eDev Send2()\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\"); } } ","date":"2021-07-20","objectID":"/springboot-enabletransactionmanagement/:2:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/springboot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"注 如果Spring容器中存在多个 PlatformTransactionManager 实例，并且没有实现接口 TransactionManagementConfigurer 指定默认值，在我们在方法上使用注解 @Transactional 的时候，就必须要用value指定，如果不指定，则会抛出异常。 对于系统需要提供默认事务管理的情况下，实现接口 TransactionManagementConfigurer 指定。 对有的系统，为了避免不必要的问题，在业务中必须要明确指定 @Transactional 的 value 值的情况下。不建议实现接口 TransactionManagementConfigurer，这样控制台会明确抛出异常，开发人员就不会忘记主动指定。 ","date":"2021-07-20","objectID":"/springboot-enabletransactionmanagement/:3:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/springboot-enabletransactionmanagement/"},{"categories":["Back"],"content":"记录@ApiImplicitParams、@ApiImplicitParam使用的笔记","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Back"],"content":"@ApiImplicitParam 作用在方法上，表示单独的请求参数 参数： \\1. name ：参数名。 \\2. value ： 参数的具体意义，作用。 \\3. required ： 参数是否必填。 \\4. dataType ：参数的数据类型。 \\5. paramType ：查询参数类型，这里有几种形式： 类型 作用 path 以地址的形式提交数据 query 直接跟参数完成自动映射赋值 body 以流的形式提交 仅支持POST header 参数在request headers 里边提交 form 以form表单的形式提交 仅支持POST 在这里我被坑过一次：当我发POST请求的时候，当时接受的整个参数，不论我用body还是query，后台都会报Body Missing错误。这个参数和SpringMvc中的@RequestBody冲突，索性我就去掉了paramType，对接口测试并没有影响。 ","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/:1:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Back"],"content":"@ApiImplicitParams 用于方法，包含多个 @ApiImplicitParam： 例： @ApiOperation(\"查询测试\") @GetMapping(\"select\") //@ApiImplicitParam(name=\"name\",value=\"用户名\",dataType=\"String\", paramType = \"query\") @ApiImplicitParams({ @ApiImplicitParam(name=\"name\",value=\"用户名\",dataType=\"string\", paramType = \"query\",example=\"xingguo\"), @ApiImplicitParam(name=\"id\",value=\"用户id\",dataType=\"long\", paramType = \"query\")}) public void select(){ } ","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/:2:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Back"],"content":"paramType 示例详解 path @RequestMapping(value = \"/findById1/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE) @PathVariable(name = \"id\") Long id body @ApiImplicitParams({ @ApiImplicitParam(paramType = \"body\", dataType = \"MessageParam\", name = \"param\", value = \"信息参数\", required = true) }) @RequestMapping(value = \"/findById3\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) @RequestBody MessageParam param 提交的参数是这个对象的一个json，然后会自动解析到对应的字段上去，也可以通过流的形式接收当前的请求数据，但是这个和上面的接收方式仅能使用一个（用@RequestBody之后流就会关闭了） header @ApiImplicitParams({ @ApiImplicitParam(paramType = \"header\", dataType = \"Long\", name = \"id\", value = \"信息id\", required = true) }) String idstr = request.getHeader(\"id\"); if (StringUtils.isNumeric(idstr)) { id = Long.parseLong(idstr); } Form @ApiImplicitParams({ @ApiImplicitParam(paramType = \"form\", dataType = \"Long\", name = \"id\", value = \"信息id\", required = true) }) @RequestMapping(value = \"/findById5\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE) ","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/:3:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Back"],"content":"总结 (1)对于@ApiImplicitParam的paramType：query、form域中的值需要使用@RequestParam获取， header域中的值需要使用@RequestHeader来获取，path域中的值需要使用@PathVariable来获取，body域中的值使用@RequestBody来获取，否则可能出错；而且如果paramType是body，name就不能是body，否则有问题，与官方文档中的“If paramType is “body”, the name should be “body\"不符。 @ApiImplicitParams：用在方法上包含一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 paramType：参数放在哪个地方 header–\u003e请求参数的获取：@RequestHeader query–\u003e请求参数的获取：@RequestParam path（用于restful接口）–\u003e请求参数的获取：@PathVariable body（不常用） form（不常用） name：参数名 dataType：参数类型 required：参数是否必须传 value：参数的意思 defaultValue：参数的默认值 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如\"请求参数没填好” response：抛出异常的类 以上这些就是最常用的几个注解了。 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import io.swagger.annotations.ApiResponse; import io.swagger.annotations.ApiResponses; @RestController @RequestMapping(\"/user\") @Api(\"userController相关api\") public class UserController { @Autowired private UserService userService; @ApiOperation(\"获取用户信息\") @ApiImplicitParams({ @ApiImplicitParam(paramType=\"header\",name=\"username\",dataType=\"String\",required=true,value=\"用户的姓名\",defaultValue=\"zhaojigang\"), @ApiImplicitParam(paramType=\"query\",name=\"password\",dataType=\"String\",required=true,value=\"用户的密码\",defaultValue=\"wangna\") }) @ApiResponses({ @ApiResponse(code=400,message=\"请求参数没填好\"), @ApiResponse(code=404,message=\"请求路径没有或页面跳转路径不对\") }) @RequestMapping(value=\"/getUser\",method=RequestMethod.GET) public User getUser(@RequestHeader(\"username\") String username, @RequestParam(\"password\") String password) { return userService.getUser(username,password); } } ","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/:4:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Back"],"content":"测试 启动服务，浏览器输入\"http://localhost:8080/swagger-ui.html\" 在上面案例中我们可以知道如果在request域中我们使用reques.getHeader()和使用@RequestHeader注解作用是一样的，其它内容类似。 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如”请求参数没填好” response：抛出异常的类 @ApiOperation(\"获取用户信息\") @ApiImplicitParams({@ApiImplicitParam(paramType=\"header\",name=\"name\",dataType=\"String\",required=true,value=\"用户的姓名\",defaultValue=\"zhaojigang\"), @ApiImplicitParam(paramType=\"query\",name=\"pwd\",dataType=\"String\",required=true,value=\"用户的密码\",defaultValue=\"wangna\") }) @ApiResponses({ @ApiResponse(code=400,message=\"请求参数没填好\"), @ApiResponse(code=404,message=\"请求路径没有或页面跳转路径不对\") }) @RequestMapping(value=\"/getUser\",method= RequestMethod.GET) public User getUser(@RequestHeader(\"name\") String name,@RequestParam(\"pwd\") String pwd) { System.out.println(name); System.out.println(pwd); return userRepository.getUserByNameAndPwd(name,pwd); } ","date":"2021-07-20","objectID":"/springcloud-apiimplicitparams/:5:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/springcloud-apiimplicitparams/"},{"categories":["Learning","note"],"content":"转载一篇Martin Flower写的微服务中文翻译文章","date":"2021-07-20","objectID":"/microservices-martin-flower/","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"声明 本文转载于《Microservices（微服务）》——Martin Flower 原文是 Martin Flower 于 2014 年 3 月 25 日写的《Microservices》。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:1:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务 “微服务架构（Microservice Architecture）”一词在过去几年里广泛的传播，它用于描述一种设计应用程序的特别方式，作为一套独立可部署的服务。目前，这种架构方式还没有准确的定义，但是在围绕业务能力的组织、自动部署（automated deployment）、端智能（intelligence in the endpoints）、语言和数据的分散控制，却有着某种共同的特征。 “微服务（Microservices）”——只不过在满大街充斥的软件架构中的一新名词而已。尽管我们非常鄙视这样的东西，但是这玩意所描述的软件风格，越来越引起我们的注意。在过去几年里，我们发现越来越多的项目开始使用这种风格，以至于我们身边的同事在构建企业级应用时，把它理所当然的认为这是一种默认开发形式。然而，很不幸，微服务风格是什么，应该怎么开发，关于这样的理论描述却很难找到。 简而言之，微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API。这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。 在开始介绍微服务风格（microservice style）前，比较一下整体风格（monolithic style）是很有帮助的：一个完整应用程序（monolithic application）构建成一个单独的单元。企业级应用通常被构建成三个主要部分：客户端用户界面（由运行在客户机器上的浏览器的 HTML 页面、Javascript 组成）、数据库（由许多的表构成一个通用的、相互关联的数据管理系统）、服务端应用。服务端应用处理 HTTP 请求，执行领域逻辑（domain logic），检索并更新数据库中的数据，使用适当的 HTML 视图发送给浏览器。服务端应用是完整的 ，是一个单独的的逻辑执行。任何对系统的改变都涉及到重新构建和部署一个新版本的服务端应用程序。 这样的整体服务（monolithic server）是一种构建系统很自然的方式。虽然你可以利用开发语基础特性把应用程序划分成类、函数、命名空间，但所有你处理请求的逻辑都运行在一个单独的进程中。在某些场景中，开发者可以在的笔计本上开发、测试应用，然后利用部署通道来保证经过正常测试的变更，发布到产品中。你也可以使用横向扩展，通过负载均衡将多个应用部署到多台服务器上。 整体应用程序（Monolithic applications）相当成功，但是越来越多的人感觉到有点不妥，特别是在云中部署时。变更发布周期被绑定了——只是变更应用程序的一小部分，却要求整个重新构建和部署。随着时间的推移，很难再保持一个好的模块化结构，使得一个模块的变更很难不影响到其它模块。扩展就需要整个应用程序的扩展，而不能进行部分扩展。 图 1 整理架构与微服务架构\r这导致了微服务架构风格（microservice architectural style）的出现：把应用程序构建为一套服务。事实是，服务可以独立部署和扩展，每个服务提供了一个坚实的模块边界，甚至不同的服务可以用不同的编程语言编写。它们可以被不同的团队管理。 **我们必须说，微服务风格不是什么新东西，它至少可以追溯到 Unix 的设计原则。**但是并没有太多人考虑微服务架构，如果他们用了，那么很多软件都会更好。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:2:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务风格的特性 微服务风格并没有一个正式的定义，但我们可以尝试描述一下微服务风格所具有的共同特点。并不是所有的微服务风格都要具有所有的特性，但我们期望常见的微服务都应该有这些特性。我们的意图是尝试描述我们工作中或者在其它我们了解的组件中所理解的微服务。特别是，我们不依赖于那些已经明确过的定义。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"组件化（Componentization ）与服务（Services） 自从我们开始软件行业以来，一直希望由组件构建系统，就像我们在物理世界所看到的一样。在过去的几十年里，我们已经看到了公共库的大量简编取得了相当的进步，这些库是大部分语言平台的一部分。 当我们谈论组件时，可能会陷入一个困境——什么是组件。我们的定义是，组件（component）是一个可独立替换和升级的软件单元。 微服务架构（Microservice architectures）会使用库（libraries），但组件化软件的主要方式是把它拆分成服务。我们把库（libraries）定义为组件，这些组件被链接到程序，并通过内存中函数调用（in-memory function calls）来调用，而服务（services ）是进程外组件（out-of-process components），他们利用某个机制通信，比如 WebService 请求，或远程过程调用（remote procedure call）。组件和服务在很多面向对象编程中是不同的概念。 把服务当成组件（而不是组件库）的一个主要原因是，服务可以独立部署。如果你的应用程序是由一个单独进程中的很多库组成，那么对任何一个组件的改变都将导致必须重新部署整个应用程序。但是如果你把应用程序拆分成很多服务，那你只需要重新部署那个改变的服务。当然，这也不是绝对的，有些服务会改变导致协调的服务接口，但是一个好的微服务架构的目标就是通过在服务契约（service contracts）中解耦服务的边界和进化机制来避免这些。 另一个考虑是，把服务当组件将拥有更清晰的组件接口。大多数开发语言都没有一个良好的机制来定义一个发布的接口（Published Interface）。发布的接口是指一个类向外公开的成员，比如 Java 中的声明为 Public 的成员，C# 中声明为非 Internal 的成员。通常只有在文档和规范中会说明，这是为了让避免客户端破坏组件的封装性，阻止组件间紧耦合。服务通过使用公开远程调用机制可以很容易避免这些。 像这样使用服务也有不足之处。远程调用比进制内调用更消耗资源，因此远程 API 需要粗粒度（coarser-grained），但这会比较难使用。如果你需要调整组件间的职责分配，当跨越进程边界时，这样做将会很难。 一个可能是，我们看到，服务可以映射到运行时进程（runtime processes）上，但也只是一个可能。服务可以由多个进程组成，它们会同时开发和部署，例如一个应用程序进程和一个只能由这个服务使用的数据库。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:1","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"围绕业务功能的组织 当寻找把一个大的应用程序拆分成小的部分时，通常管理都会集中在技术层面，UI团队、服务端业务逻辑团队和数据库团队。当使用这种标准对团队进行划分时，甚至小小的更变都将导致跨团队项目协作，从而消耗时间和预算审批。一个高效的团队会针对这种情况进行改善，两权相害取其轻。业务逻辑无处不在。实践中，这就是 Conway’s Law 的一个例子。 设计一个系统的任何组织（广义上）都会产生这样一种设计，其结构是组织交流结构的复制。 ——Melvyn Conway, 1967 Melvyn Conway 的意识是，像下图所展示的，设计一个系统时，将人员划分为 UI 团队，中间件团队，DBA 团队，那么相应地，软件系统也就会自然地被划分为 UI 界面，中间件系统，数据库。 图 2 实践中的 Conway's Law\r微服务（microservice ）的划分方法不同，它倾向围绕业务功能的组织来分割服务。这些服务实现商业领域的软件，包括用户界面，持久化存储，任何的外部协作。因此，团队是跨职能的（cross-functional），包含开发过程所要求的所有技能：用户体验（user-experience）、数据库（database）和项目管理（project management）。 图 3 通过团队边界强调服务边界\rwww.comparethemarket.com就是采用这种组织形式。跨职能的团队同时负责构建和运营每个产品，每个产品被分割成许多单个的服务，这些服务通过消息总线（Message Bus）通信。 大型的整体应用程序（monolithic applications）也可以按照业务功能进行模块化（modularized），尽管这样情况不常见。当然，我们可以敦促一个构建整体应用程序（monolithic application ）的大型团队，按业务线来分割自己。我们已经看到的主要问题是，这种组件形式会导致很多的依赖。如果整体应用程序（monolithic applications）跨越很多模块边界（modular boundaries ），那么对于团队的每个成员短期内修复它们是很困难的。此外，我们发现，模块化需要大量的强制规范。服务组件所要求的必需的更明确的分离使得保持团队边界清晰更加容易。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:2","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"产品不是项目 大部分的软件开发者都使用这样的项目模式：至力于提供一些被认为是完整的软件。交付一个他们认为完成的软件。软件移交给运维组织，然后，解散构建软件的团队。 微服务（Microservice ）的支持者认为这种做法是不可取的，并提议团队应该负责产品的整个生命周期。Amazon 理念是“你构建，你运维（you build, you run it）”，要求开发团队对软件产品的整个生命周期负责。这要求开发者每天都关注他们的软件运行如何，增加更用户的联系，同时承担一些售后支持。 产品的理念，跟业务能力联系起来。不是着眼于完成一套功能的软件，而是有一个持续的关系，是如何能够帮助软件及其用户提升业务能力。 为什么相同的方法不能用在整体应用程序（monolithic applications），但更小的服务粒度能够使创建服务的开发者与使用者之间的个人联系更容易。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:3","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"强化终端及弱化通道 当构建不同的进程间通信机制的时候，我们发现有许多的产品和方法能够把更加有效方法强加入的通信机制中。比如企业服务总线（ESB），这样的产品提供更有效的方式改进通信过程中的路由、编码、传输、以及业务处理规则。 微服务倾向于做如下的选择：强化终端及弱化通道。微服务的应用致力松耦合和高内聚：采用单独的业务逻辑，表现的更像经典Unix意义上的过滤器一样，接受请求、处理业务逻辑、返回响应。它们更喜欢简单的REST风格，而不是复杂的协议，如WS或者BPEL或者集中式框架。 有两种协议最经常被使用到：包含资源API的HTTP的请求-响应和轻量级消息通信协议。最为重要的建议为： 善于利用网络，而不是限制（Be of the web, not behind the web）。 ——Ian Robinson 微服务团队采用这样的原则和规范：基于互联网（广义上，包含Unix系统）构建系统。这样经常使用的资源几乎不用什么的代价就可以被开发者或者运行商缓存。 第二种做法是通过轻量级消息总线来发布消息。这种的通信协议非常的单一（单一到只负责消息路由），像RabbitMQ或者ZeroMQ这样的简单的实现甚至像可靠的异步机制都没提供，以至于需要依赖产生或者消费消息的终端或者服务来处理这类问题。 在整体工风格中，组件在进程内执行，进程间的消息通信通常通过调用方法或者回调函数。从整体式风格到微服务框架最大的问题在于通信方式的变更。从内存内部原始的调用变成远程调用，产生的大量的不可靠通信。因此，你需要把粗粒度的方法成更加细粒度的通信。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:4","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"分散治理 集中治理的一种好处是在单一平台上进行标准化。经验表明这种趋势的好处在缩小，因为并不是所有的问题都相同，而且解决方案并不是万能的。我们更加倾向于采用适当的工具解决适当的问题，整体式的应用在一定程度上比多语言环境更有优势，但也适合所有的情况。 把整体式框架中的组件，拆分成不同的服务，我们在构建它们时有更多的选择。你想用Node.js去开发报表页面吗？做吧。用C++来构建时时性要求高的组件？很好。你想以在不同类型的数据库中切换，来提高组件的读取性能？我们现在有技术手段来实现它了。 当然，你是可以做更多的选择，但也不意味的你就可以这样做，因为你的系统使用这种方式进行侵害意味着你已经有的决定。 采用微服务的团队更喜欢不同的标准。他们不会把这些标准写在纸上，而是喜欢这样的思想：开发有用的工具来解决开发者遇到的相似的问题。这些工具通常从实现中成长起来，并进行的广泛范围内分享，当然，它们有时，并不一定，会采用开源模式。现在开源的做法也变得越来越普遍，git或者github成为了它们事实上的版本控制系统。 Netfix就是这样的一个组织，它是非常好的一个例子。分享有用的、尤其是经过实践的代码库激励着其它的开发着也使用相似的方式来解决相似的问题，当然，也保留着根据需要使用不同的方法的权力。共享库更关注于数据存储、进程内通信以及我们接下来做讨论到的自动化等这些问题上。 微服务社区中，开销问题特别引人注意。这并不是说，社区不认为服务交互的价值。相反，正是因为发现到它的价值。这使得他们在寻找各种方法来解决它们。如Tolearant Reader和Consumer-Driven Contracts这样的设计模式就经常被微服务使用。这些模式解决了独立服务在交互过程中的消耗问题。使用Consumer-Driven Contracts增加了你的信心，并实现了快速的反馈机制。事实上，我们知道澳大利亚的一个团队致力使用Consumer-Drvien Contracts开发新的服务。他们使用简单的工程，帮助他们定义服务的接口。使得在新服务的代码开始编写之前，这些接口就成为自动化构建的一个部分。构建出来的服务，只需要指出这些接口适用的范围，一个优雅的方法避免了新软件中的’YAGNI ‘困境。这些技术和工具在使用过程中完善，通过减少服务间的耦合，限制了集中式管理的需求。 也许分散治理普及于亚马逊“编译它，运维它”的理念。团队为他们开发的软件负全部责任，也包含7*24小时的运行。全责任的方式并不常见，但是我们确实发现越来越多的公司在他们的团队中所推广。Netfix是另外一个接受这种理念的组件。每天凌晨3点被闹钟吵醒，因为你非常的关注写的代码质量。这在传统的集中式治理中这是一样多么不思议的事情呀。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:5","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"分散数据管理 对数据的分散管理有多种不同的表现形式。最为抽象层次，它意味着不同系统中的通用概念是不同的。这带来的觉问题是大型的跨系统整合时，用户使用不同的售后支持将得到不同的促销信息。这种情况叫做并没有给用户显示所有的促销手段。不同的语法确实存在相同的词义或者（更差）相同的词义。 应用之间这个问题很普遍，但应用内部这个问题也存在，特别是当应用拆分成不同的组件时。对待这个问题非常有用的方式为Bounded Context的领域驱动设计。DDD把复杂的领域拆分成不同上下文边界以及它们之间的关系。这样的过程对于整体架构和微服务框架都很有用，但是服务间存在着明显的关系，帮助我们对上下文边界进行区分，同时也像我们在业务功能中谈到的，强行拆分。 当对概念模式下决心进行分散管理时，微服务也决定着分散数据管理。当整体式的应用使用单一逻辑数据库对数据持久化时，企业通常选择在应用的范围内使用一个数据库，这些决定也受厂商的商业权限模式驱动。微服务让每个服务管理自己的数据库：无论是相同数据库的不同实例，或者是不同的数据库系统。这种方法叫Polyglot Persistence。你可以把这种方法用在整体架构中，但是它更常见于微服务架构中。 图 4 Polyglot Persistence\r微服务音分散数据现任意味着管理数据更新。处理数据更新的常用方法是使用事务来保证不同的资源修改数据库的一致性。这种方法通常在整体架构中使用。 使用事务是因为它能够帮助处理一至性问题，但对时间的消耗是严重的，这给跨服务操作带来难题。分布式事务非常难以实施，因此微服务架构强调服务间事务的协调，并清楚的认识一致性只能是最终一致性以及通过补偿运算处理问题。 选择处理不一致问题对于开发团队来说是新的挑战，但是也是一个常见的业务实践模式。通常业务上允许一定的不一致以满足快速响应的需求，但同时也采用一些恢复的进程来处理这种错误。当业务上处理强一致性消耗比处理错误的消耗少时，这种付出是值的的。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:6","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"基础设施自动化 基础设施自动化技术在过去几年中得到了长足的发展：云计算，特别是AWS的发展，减少了构建、发布、运维微服务的复杂性。 许多使用微服务架构的产品或者系统，它们的团队拥有丰富的持集部署以及它的前任持续集成的经验。团队使用这种方式构建软件致使更广泛的依赖基础设施自动化技术。下图说明这种构建的流程： 图 5 基本的构建流程\r尽管这不是介绍自动部署的文章，但我们也打算介绍一下它的主要特征。我们希望我们的软件应该这样方便的工作，因此我们需要更多的自动化测试。流程中工作的软件改进意味着我们能自动的部署到各种新的环境中。 整体风格的应用相当开心的在各种环境中构建、测试、发布。事实证明，一旦你打算投资一条整体架构应用自动化的的生产线，那么你会发现发布更多的应用似乎非不那么的可怕。记住，CD（持续部署）的一个目标在于让发布变得无趣，因此无论是一个还是三个应用，它都一样的无趣。 另一个方面，我们发现使用微服务的团队更加依赖于基础设施的自动化。相比之下，在整体架构也微服务架构中，尽管发布的场景不同，但发布工作的无趣并没有多大的区别。 图 6 模块化部署的区别 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:7","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"容错性设计 使用服务作为组件的一个结果在于应用需要有能容忍服务的故障的设计。任务服务可能因为供应商的不可靠而故障，客户端需要尽可能的优化这种场景的响应。跟整体构架相比，这是一个缺点，因为它带来的额外的复杂性。这将让微服务团队时刻的想到服务故障的情况下用户的体验。Netflix 的Simian Army可以为每个应用的服务及数据中心提供日常故障检测和恢复。 这种产品中的自动化测试可以让大部分的运维团队正常的上下班。这并不意味着整体构架的应用没有这么精巧的监控配置，只是在我们的经验中它并不常见。 由于服务可以随时故障，快速故障检测，乃至，自动恢复变更非常重要。微服务应用把实时的监控放在应用的各个阶段中，检测构架元素（每秒数据库的接收的请求数）和业务相关的指标（把分钟接收的定单数）。监控系统可以提供一种早期故障告警系统，让开发团队跟进并调查。 对于微服务框架来说，这相当重要，因为微服务相互的通信可能导致紧急意外行为。许多专家车称赞这种紧急事件的价值，但事实是这种紧急行为有时是灾难。监控是至关重要的，它能快速发现这种紧急不良行为，让我们迅速修复它。 整体架构，跟微服务一样，在构建时是通明的，实情上，它们就是这样子的。它们不同之处在于，你需要清楚的认识到不同进程间运行的服务是不相关的。库对于同一进程是透明的，也因此不那么重要了。 微服务团队期望清楚的监控和记录每个服务的配置，比如使用仪表盘显示上/下线状态、各种运维和业务相关的指标。对断路器（circuit breaker）状态、目前的吞吐量和时延细节，我们也会经常遇到。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:8","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"设计改进 微服务实践者，通常有不断改进设计的背景，他们把服务分解成进一步的工具。这些工具可以让应用开发者在不改变速度情况下，控制都他们的应用的需求变更。变更控制不意味首减少变更，而是使用适当的方式和工具，让它更加频繁，至少，很好让它变得可控。 不论如何，当你试图软件系统拆分成组件时，你将面临着如何拆分的问题。那么我们的决定拆分我们应用的原则是什么呢？首要的因素，组件可以被独立替换和更新的，这意味着我们寻找的关键在于，我们要想象着重写一个组件而不影响它们之前的协作关系。事实上，许多的微服务小组给它进一步的预期：服务应该能够报废的，而不是要长久的发展的。 Guardian网站就是这方面的一个优秀的例子，它初期被设计和构建成一个整体架构，但它已经向微服务的发展了。整体构架仍然是它网站的核心，但是他们使用微服务来增加那些使用整体架构API的新特性。这种方法增加这些临时的特性非常方便，比如运动新闻的特稿。这样站点的一个部分可以使用快速的开发语言迅速整合起来，当它过时后可以一次性移除。我们发现一家金融机构用相似的方法增加新的市场营销活动，数周或者几个月后把它撤销。 可代替是模块化开发中的一个特例，它是用模块来应对需要变更的。你希望让变更是相同模块，相同周期中进行变化而已。系统的某些很小做变更部分，也应该放在不同的服务中，这样它们更容易让它们消亡。如果你发现两个服务一直重复的变更时，这就是一个要合并它们的信号了。 把组件改成服务，增加了细化发布计划的一个机会。整体构架的任务变更需要整个应用的完整的构建和发布。然而，使用微服务，你只需要发布你要修改的服务就可以了。这将简化和加速你的发布周期。缺点是你需要为一个变更服务发布可能中断用户的体验而担心。传统的集成方法是使用版本来处理这些问题，但是微服务版本仅是最后的通告手段。我们需要在设计服务时尽可能的容忍供应商的变更，以避免提供多个版本。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:9","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务是未来吗？ 我们写这篇文章的主要目的在于解释微服务的主要思想和原则。但是发时间做这事的时候，我们清醒的认识到微服务构架风格是一个非常重要的想法：一个值得企业应用中认真考虑的东西。我们最近使用这种风格构建了几个系统，认识那些也使用和喜欢这种方法的爱好者。 我们认识的使用这种方式的先行者，包含亚马逊、Netflix、The Guardian、The UK Government Digital Service、realestate.com.au、Forward和comparethemarket.com。2013看的巡回会议充满了向正在想成为微服务一分子的公司，包含Travis CI。此外，大量的组件正在从事我们认为是微服务的事，只是没有使用微服务的名字而已。（通常，它们被打上SOA的标签，尽管，我们认为SOA有许多不同的地方。） 尽管有这些积极的经验，然后，我们也不急于确认微服务是未来软件架构方向。至今为止，我们的经验与整体风格的应该中相比出来的是有优势的，但是我们意识知这样的事实，我们并没有足够的时间来证明我们的论证。 你所使用的架构通常是你开发出来后，使用的几年的实际成果。我们看到这些工程是在一个优秀的团队，带着对模块化的强烈追求，使用在过去几年中已经衰退的整体架构构建出来的。许多人相信，这种衰退不太可能与微服务有关，因为服务边界是清晰的并且很难再完善的。然而，当我们还没看到足够多的系统运行足够长时间时，我们不能肯定微服务构架是成熟的。 当然，还有原因就是，有人期望微服务构架不够成熟。在组件化方面的任何努力，其成功都依赖于软件如何拆分成适合的组件。指出组件化的准确边界应该在那，这是非常困难的。改良设计要承认边界的权益困境和因此带来的易于重构的重要性。但是当你的组件是被远程通信的服务时，重构比进程内的库又要困难的多。服务边界上的代码迁移是困难的，任务接口的变更需要参与者的共同协作，向后兼容的层次需要被增加，测试也变更更加复杂。 另一个问题在于，如果组件并没有清晰的划分，你的工作的复杂性将从组件内部转向组件间的关系。做这事不仅要围绕着复杂，它也要面对着不清晰和更难控制的地方。很容易想到，当你在一个小的、简单的组件内找东西，总比在没有关系的混乱的服务间要容易。 最后，团队技能也是重要的因素。新的技术倾向于被掌握更多的技能的团队使用。但是掌握多技能的团队中使用的技巧在较少技能的团队中并不是必需的。我们发现大量的少技能的团队构建混乱的整合构架，但是它要发时间去证明使用微服务在这种情况下会发生什么。一个糟糕的团队通常开发糟糕的系统：很难说，微服务在这种情况下是否能帮助它们，还是破坏它们。 一个理性的争议在于，我们听说，你不应该从微服务构架开始做。最好从整体构架开发，做模块化开发，然后当整体构架出现问题是再把模块化拆分成服务。（尽管这种建议不是好主意，因为一个好的进程内接口并不是一个好的服务接口。） 因此我们持这种谨慎的乐观。到目前为止，我们还没有足够认识，关于微构架能否被大范围的推广。我们不能肯定的说，我们要终结什么，但是软件开发的挑战在于你只能在不完整的信息中决定你目前要处理的问题。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:4:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"其它 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务系统多大？ 尽管“微服务”一词在架构风格中越来越流行，它的名字很不辛让人关注它的服务大小，以及对“微”这个组成的争议。在我们与微服务实践者的谈话中，我们发现了服务的大小范围。被报道的最大团队遵循亚马逊Tow Pizaa团队理念（比如，一个团队吃两个比萨就可以了。），这意味着不超过20号（一打）人。我们发现最小配置是半打的团队支撑起一打的服务。 这也引发这样的考虑：规模为一个服务一打人到一个服务一个人的团队打上微服务的标签。此刻我们认为，它们是一样的，但是随着对这种风格的深入研究，也存在我们改变我们的想法的可能。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:1","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务与SOA 当前我们谈到微服务时，通常会问，这是不是我们20年前讨论的面向服务架构（SOA）。这是一个很好的观点，因为微服务风格也SOA所提倡的一些优势非常相似。尽管如此，问题在于SOA意味的太多不同的东西了，因此通常时候我们谈的所谓“SOA”时，它与我们谈论的风格不一至，因为它通常是指在整体风格应用中的ESB。 此外，我们发现面向服务的风格是这么的拙劣：从试图使用ESB隐藏复杂性， 到使用多年才认识到发费数百美元却没产生任务价值这样的失败，到集中治理模式抑制变更。而且这些问题往往很难发现。 可以肯定的时，微服务社区中使用的许多的技术都开发者是从大型机构的整合服务经验中发展来的。Tolerant Reader模式就是这样的一个例子。由于互联网的发展，利用简单的协议这种方法，让它从这些经验传达的出来。这是从已经很复杂的集中式标准中的一种反模式，坦白的说，真让人惊叹。（无论何时，当你需要用一个服务来管理你的所有的服务，你就知道这很麻烦。） SOA的这种常见行为让微服务的提倡者拒绝打上SOA的标签，尽管有人认为微服务是从SOA中发展而来的，或许面向服务是对的。无论如何，事实上SOA表达这么多的含义，它给一个团队清醒的认识到这种构架风格就已经值的了。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:2","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"多语言，多选择 JVM做为一个平台，它的增长就是一个平台中运行多语言的最大的例子。过去二十年中，它通常做为更高层次语言的壳，以达到更高层次的抽象。比如，研究它的内部结构，、使用低级的语言写更高效的代码。尽管如此，许多整体风格并不需要这种层次的性能优化或者在语法及高层次上的抽象，这很常见（让我们很失望）。此外整体构架通常意味着使用单一的语言，这也限制着使用技术的数量。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:3","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"实践标准和强制标准 它有点尴尬，微服务团队倾向于避免这种通常由企业架构队伍定制的僵硬的强制标准，但是它们却非常乐于甚至推广这些开放的标准，如HTTP、ATOM、其它微规范。 关键的不同在这些标准是怎么开发出来的，以及它们是怎么被推广的。标准被一些组件管理，如IETF认证标准，仅当它们在互联网上有几个在用的实现，通常源自于开源工程的成功应用。 这些标准单独分离出来，与那种在企业中通常有没有什么编码经验的或者没有什么影响力的厂商标准进行区别。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:4","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"让做对事更容易 一方面，我们发现在持续发布、部署越来越多的使用自动化，是很多有用的工具开发出来帮助开发者和运营商的努力结果。为打包、代码管理、支撑服务的工具，或者增加标准监控的记录的工具，现在都非常常见了。网络中最好的，可能就是Netflix’s的开源工具，但是包含Dropwizard在内的其它工具也被广泛的使用着。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:5","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"断路器(circuit breaker)和产品中现有的代码 断路器(circuit breaker)出现在《Realease It!》一书中，与Bulkhead和Timeout这样的模式放在一起。实施起来，这些模式用于构建通信应用时相当的重要。Netflix的博客在解释它们的应用时，做了大量的工作。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:6","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"同步是有害的 任务时候，你在服务间的调用使用同步的方法，都会遇到宕机时间的乘积效应。简单的说，你的系统宕机时间是你系统的单独组件的宕机时间的乘积。你面临的选择使用异步或者管理宕机时间。在www.guardian.co.uk中，它们在新平台中使用一种简单的规则来实现它：在Netflix中每次用户请求的同步调用，他们重新设计的平台API都会把它构建成异步的API来执行。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:7","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"参考资料 Martin Flower，Microservices infoQ，微服务架构解析 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:6:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Operation"],"content":"记录安装Windows系统报错无法继续安装的几种解决办法的笔记","date":"2021-07-19","objectID":"/win-install-error/","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"问题 今天在给朋友安装系统时遇到这样的问题“Windows无法完成安装，若要在此计算机上安装，请重新启动安装”，一看到这瞬间就蒙了，其实这种问题以前也遇到过，而且华硕的主板最多，网上看了下这华硕的主板有时候也不省心啊，真的应了那句2B的华硕主板，出现2B问题，用在了2B的Window7上。其实出现这种问题，很多时候并不是镜像的问题，当然也不排除。但是，其实我们完全有好几种方法可以解决的。下面先来看看具体的解决方法吧。 ","date":"2021-07-19","objectID":"/win-install-error/:1:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"1 ","date":"2021-07-19","objectID":"/win-install-error/:2:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法1 个人是比较懒的那种，能用快速方法解决，就绝不会拐弯抹角的，俗称直肠男。出现这种问题时，首先可以同时按住shift+f10，此时会弹出命令提示对话框。在对话框里输入cd oobe(中间有个空格哈)，此时就进入到了oobe这个目录了，我们再输入msoobe回车，只要等待几秒后就会看到安装在继续了，是不是很神奇呢。 ","date":"2021-07-19","objectID":"/win-install-error/:2:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理1 这是因为这个命令是自动跳过错误继续下一步安装的。如果安装完成后都没有报错能进系统的话那么恭喜你完美解决。 ","date":"2021-07-19","objectID":"/win-install-error/:2:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"2 ","date":"2021-07-19","objectID":"/win-install-error/:3:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法2 如果安装到最后一步还是弹出“Windows安装程序无法将Windows配置未在此计算机的硬件上运行。”，那么真的是躺着也中枪，很不辛，你得继续第二种方法了：修改注册表。继续按住shift+f10，在弹出的对话框里输入regedit回车，此时会弹出注册表。依次找到HKLOCAL MACHINE\\SYSTEM\\SETUP\\STATUS\\ChildCompletion把setup.exe的值从1改成3，然后关掉注册表和命令窗，点错误窗口的确定，重启。重启能进入系统的话那就没问题了，如果还是一样报错的话那就得憋大招了。 ","date":"2021-07-19","objectID":"/win-install-error/:3:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理2 单纯修改注册表配置解决系统问题 ","date":"2021-07-19","objectID":"/win-install-error/:3:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"3 ","date":"2021-07-19","objectID":"/win-install-error/:4:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法3 再次重启一直按delete进入BIOS（按键视主板而定），进入BIOS后找到系统启动项会发现多了一个“windows boot manager”开头的启动项，纠结了吧，什么时候跑出这么一个启动项来了。看来2B主板又在抽风了。不过没关系，他爱怎么抽就怎么抽，我把启动项修改下，改成硬盘为第一启动项再次开机没毛病。 ","date":"2021-07-19","objectID":"/win-install-error/:4:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理3 做系统启动项遗留导致 ","date":"2021-07-19","objectID":"/win-install-error/:4:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"4 ","date":"2021-07-19","objectID":"/win-install-error/:5:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法4 如果还是不行的话那就在BIOS里找到SATS Config这个选项里面把AHCI修改成IDE吧，同时禁用UEFI启动模式，改成只用legacy模式，问题基本都可以解决。或者直接用ghost版本的系统进行安装亦或者是用光驱安装绝对不会出现这种恶心的问题。 ","date":"2021-07-19","objectID":"/win-install-error/:5:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理4 硬盘在BIOS模式不同导致 ","date":"2021-07-19","objectID":"/win-install-error/:5:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"5 ","date":"2021-07-19","objectID":"/win-install-error/:6:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法5 最后还有一种办法，比较麻烦，但是还是在这里说下吧。首先到一台能上网的电脑上下载 INTEL F6驱动程序，去百度一搜 中关村就有下载，下载完成后 解 压，然后拷贝到U盘中，重新运行PE 把之前的系统盘格式化以后使用WIN7安装工具安装时，选择PNP驱动，点 击后把驱动路径指向 刚才U盘中的F6驱动程序，然后配置完成后提示 重启，重启以后就可以正常安装了。 ","date":"2021-07-19","objectID":"/win-install-error/:6:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理5 缺少驱动 ","date":"2021-07-19","objectID":"/win-install-error/:6:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Back"],"content":"SpringBoot报警告WARNING: An illegal reflective access operation has occurred","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"报警 警告如图所示，该警告是因为jdk版本太高（我用的是10.0，据说9.0的也会这样），具体的原理还没有研究，它不影响项目的正常运行，但是看着很糟心有木有~~~~ 解决方案是把项目jdk降低到1.8及以下，建议1.8。 ","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/:1:0","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"操作步骤 快捷键Ctrl+Alt+Shift+S 进入项目结构设置如图 修改为1.8 然后确认即可。 如果上述方法还没有解决，那请在上图中打开Modules，然后检查一下每一个模块的Dependencies 保证每一个模块的版本都在1.8及以下。 然后确认！ 到现在，问题应该就解决了。 ","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/:2:0","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"项目启动报错：Error creating bean with name 'flywayInitializer'...org.flywaydb.core.api.FlywayException...","date":"2021-07-19","objectID":"/creating-bean-with-name-error/","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"报错 项目启动报错： org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘flywayInitializer’ defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.FlywayException: Validate failed: Detected failed migration to version 1.0 (xxx yyy zzz) ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:1:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"解决 找到该项目数据库中flyway_schema_history表，没有就新建一个，有就清空表中所有信息 然后项目正常启动 ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:2:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"附件 新建表的字段SQL脚本 CREATETABLEflyway_schema_history(installed_rankINTNOTNULL,versionVARCHAR(50),descriptionVARCHAR(200)NOTNULL,typeVARCHAR(20)NOTNULL,scriptVARCHAR(1000)NOTNULL,checksumINT,installed_byVARCHAR(100)NOTNULL,installed_onTIMESTAMPDEFAULTCURRENT_TIMESTAMP,execution_timeINTNOTNULL,successTINYINT(1)NOTNULL,PRIMARYKEY(installed_rank),INDEXflyway_schema_history_s_idx(success))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4; ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:3:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"记录不同项目使用spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","date":"2021-07-19","objectID":"/springcloud-starter-netflix-eureka-server-diff/","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/springcloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"发现问题 在学习spring cloud时发现有的引入了spring-cloud-starter-eureka-server，有的引入了spring-cloud-starter-netflix-eureka-server。刚开始还看不懂，特意去查了一下做下总结 ","date":"2021-07-19","objectID":"/springcloud-starter-netflix-eureka-server-diff/:1:0","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/springcloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"区别 springcloud更新换代比较快； spring-cloud-starter-eureka-server是1.5以前的版本依赖； spring-cloud-starter-netflix-eureka-server是最新版本的依赖（推荐）。 ","date":"2021-07-19","objectID":"/springcloud-starter-netflix-eureka-server-diff/:2:0","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/springcloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"@EnableDiscoveryClient和@EnableEurekaClient这两个注解的区别","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Back"],"content":"他山之石 通过我们看 《springcloud @EnableDiscoveryClient注解作用》这篇文章（https://blog.csdn.net/zheng199172/article/details/82466139）我们看到 要想将一个微服务注册到Eureka Server（或其他服务发现组件，例如Zookeeper、Consul等），Eureka 2.0闭源之后，Consul慢慢会成为主流。 只需： 添加Eureka Client（或其他服务发现组件的Client）依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 写注解：在启动类上添加注解@EnableDiscoveryClient 或@EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ProviderUserApplication { public static void main(String[] args) { SpringApplication.run(ProviderUserApplication.class, args); } } 写配置： spring:application:name:microservice-provider-usereureka:client:serviceUrl:defaultZone:http://localhost:8761/eureka/ ","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/:1:0","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Back"],"content":"区别 重点来了！ @EnableDiscoveryClient和@EnableEurekaClient共同点就是：都是能够让注册中心能够发现，扫描到该服务。 不同点：@EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。 ","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/:2:0","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Hardware","note"],"content":"记录磁盘数据销毁的笔记","date":"2021-07-16","objectID":"/disk-clear-note/","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"今天的讨论 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:0","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"01 硬盘数据销毁乱象 当前数据存储最最常见的设备就是机械硬盘，很多公司单位及个人淘汰硬盘的时候都会对其中的敏感数据进行销毁，防止泄露造成损失。那么到底数据销毁应该怎么去做？本人认为对于数据销毁有过度消费的情况，而且趋势是越演越烈！ 大家都知道数据恢复公司，可能很少有人知道数据销毁公司。这些公司专门为各种有数据销毁需求的单位公司提供销毁数据的设备。 我记得N年前网上流传着一篇文章，大概内容就说的你的硬盘不安全，硬盘厂家可能留了后门偷数据，就算你把硬盘全盘覆盖十几次美国FBI也能找回数据。因此，为了保障你的数据不被泄露，必须要在“肉体”上对硬盘进行彻底毁灭，不然你的数据分分钟被泄露。 该文流传的之广，影响之大，毒害之深，直到现在很多人都对此深信不疑，还经常拿出来作为一些话题的佐证。在我看来这就是一篇不折不扣的伪科学文章，我严重怀疑就是那些数据销毁公司的软文，误导了太多的人。 我举个例子：某公司淘汰的硬盘首先是进行全盘清零，然后用消磁机消磁，再用锤子砸掉或者台钻钻孔对硬盘进行彻底的物理破坏。你不能说做错了，确实可以彻底的毁灭硬盘上的任何数据。但是做的太过了！ 纯属脱裤子打屁。 归根结底无非就是为了多争取点部门经费，把数据销毁工作渲染的玄之又玄。 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:1","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"02 硬盘会不会有后门? 如果是正规硬盘厂家出来的产品是不会有后门的。硬盘销售是不记名的，换句话说每个硬盘的去向厂家并不清楚。哪些硬盘装了有价值的数据，哪些硬盘装的只是爱情动作大片没人知道。只能没有明确目标的靠挨个入侵查找。每年硬盘厂家的销售量至少都是几千万个，要从这几千万个硬盘里面挖掘有价值的数据，这是一件多么浩大的工程，需要多大的人力物力财力和技术去做这种事情？硬盘厂家能得到什么的好处？ 有人说，几年前不是爆出一个新闻，说用户买回去的某品牌硬盘里面居然有病毒，严重侵犯了用户的隐私和危害数据安全。该厂家回应，这种事情绝无可能，要么是自身原因导致中毒，要么就是抹黑。这个事情估计就是硬盘有后门的出处。加上帝国主义亡我之心不死的调调，基本上就“坐实”了硬盘有后门的结论！ 其实事情再简单不过了，用户买到了拆机翻新盘。奸商一时大意忘记清除硬盘中的数据，导致用户买回去中毒。所以黑锅背到了厂家头上也算是躺枪了。 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:2","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"03 FBI的恢复手段有那么厉害？ 写到这里我不由自主的就笑了，现在伪科学实在太多了，什么硬盘覆盖十几次FBI都可以把最原始的数据恢复出来。难道宇宙间的物理规律在FBI手里立马失效？ 硬盘靠磁介质的极性翻转进行数据存储，假设存储数据000111，磁颗粒的极性排序SSSNNN。数据改写成010101磁颗粒则变成SNSNSN。排序完全变了（实际排序比这个复杂几十亿倍），请问FBI凭什么能恢复出原始的排序？FBI的人都是神仙？如果FBI真有这样的黑科技，为啥当初一个爱疯5的锁屏密码都解不开，还要威逼苹果解锁？ 人云亦云、以讹传讹的太多了，当真谎言重复一千次就是真理。在某些人的眼里，FBI是可以登陆太阳表面的…… ","date":"2021-07-16","objectID":"/disk-clear-note/:1:3","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"04 那些方式可以彻底销毁数据？ 数据的本质就是存储在硬盘中的一串0和1，他们不同的排序组合形成不同的数据类型和结构，从物理层面来说就是磁颗粒的极性变化。硬盘存储数据要经历三个层面：系统层—逻辑层—物理层。 系统层就很容易懂，就是咱们平时最常接触到的文件系统，数据是文本还是视频还是图片等等。物理层也容易理解，就是基本上的磁性介质，是它们的物理特性使得硬盘可以存储数据。那么逻辑层对大家来说相对就陌生了。 逻辑层用于衔接系统层和物理层。 系统层无法直接对物理层进行工作指派，必须要经过逻辑层的转换。逻辑层是由硬盘的固件来进行转换和控制。 一块硬盘要正常工作保存数据，那么首先是确认该硬盘的存储密度，0磁道的起始位置，扇区的数量以及容量的大小。 同时硬盘并不是铁板一块，而是被固件从逻辑上划分了很多个ZONE，每个ZONE有固定的范围和磁头读写参数还有表面缺陷扇区的坐标等。统称为硬盘的几何结构，每一块硬盘的几何结构都是独一无二的，正如世界上没有二个完全一样的人。 如果你想彻底毁灭硬盘里面的数据，那么直接破坏它的几何机构就行了。调用格式化固件区命令直接清空固件区里的所有信息，硬盘立马就变板砖，失去几何结构的硬盘数据绝无恢复的可能性。好比你把你的手机系统彻底抹掉，手机里的数据永远丢失。 如果你没办法通过技术手段来清空硬盘的固件区，那么可以使用MHDD调用硬盘本身内置的数据安全擦除的功能，这个功能先对硬盘进行加密，然后再进行内部擦除每一个扇区，运行这个功能之后，之前的数据荡然无存绝无恢复的可能性，而且不会破坏硬盘任何功能。我曾经做过试验，安全擦除过的硬盘使用任何手段均无法恢复出原来的数据。这个功能的缺点就是耗时比较长，视硬盘容量大小而定。 最后就是用物理方式对硬盘进行破坏，比如砸、钻、消磁。当然我并不否认这些方式对销毁数据有立竿见影的效果，但是绝非百分之百的安全。砸久了手要酸，人会累，会偷懒。如果硬盘数量很多那么必定有漏网之鱼。 我一个朋友买了一批国内某知名企业的消磁盘。经过挑选里面全好的硬盘占比最少四成，盈利最少过百万。说明了什么问题？ 外界很多关于数据销毁的言论大部分都是数据销毁公司人为的制造一些恐慌，你不买什么什么专业设备进行处理，你的数据就会泄露。就跟马爸爸演讲时经常说的：你不听我的什么什么，那么你公司就会死……如出一辙。 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:4","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"05 数据安全重不重要？ 当然重要。 但是要理性的、科学的去看待这个事情，不要人云亦云，不要迷信什么设备。 切莫去听信外面的一些人为制造的一些恐慌话题，从根本上理解硬盘存储数据的原理，一切困惑将迎刃而解。 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:5","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"06 尾声 我猜测很可能有人会在评论里讲：“前些年的方程式病毒不就是硬盘固件里面的后门吗？” 这里我引用卡巴斯基专家的说法： 卡巴斯基专家Costin Raiu对此警告说： “还有一种危险，即当磁盘被感染后，就无法对其固件进行扫描。简言之，大多数硬盘只能对其硬件固件区域进行写入，却不具备读取功能。这意味着，我们几乎对此一无所知，无法检测磁盘是否被该恶意软件所感染。”由于病毒在系统启动初始阶段就处于活动状态，它能够截取加密密码，并将其保存在磁盘的隐藏区域。 断网照样窃取信息 不仅如此，“方程式组织”还能够从隔离网络中获取数据，该组织使用的恶意软件Fanny使用了一种独特的基于USB的命令和控制机制，允许攻击者向来隔绝网络之外回传送数据。 具体来说，这是一个包含一个隐藏区域的U盘，它可以从未联网的计算机上收集基础系统信息；而当该U盘被插入到联网计算机上时，恶意软件Fanny会将收集到的系统信息发送至C\u0026C（命令和控制中心）。 感染各大品牌硬盘 卡巴斯基在报告中显示，很多大品牌硬盘可能均受影响，包括三星、西数、希捷、迈拓、东芝以及日立等公司。这些受到感染的硬盘使得攻击者可以持续的对受害者的计算机进行控制和数据窃取。 可以看出，所有品牌的硬盘都全军覆没，如果谁告诉我这些不同国家的硬盘厂家都合伙埋雷，我是不信的。 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:6","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"补充 1，如果硬盘厂家真的在产品中留了后门，那么在你使用硬盘的那一刻你的数据就已经开始泄露了，跟后期你如何销毁硬盘没有任何关系。 2，利用剩磁原理来恢复硬盘数据。如果对于上个世纪的低容量硬盘也许凑合，当今硬盘存储密度高到吓人，磁道之间的间隔不足10纳米，若采用剩磁效应来恢复数据，那个信噪比就已经彻底淹没你想要恢复的数据，可行性无限趋近于0。 3，对于相对绝密的单位，大公司过度销毁硬盘并非为了骗经费，而是一种管理方法。理论上确实把磁道重置为全0或者全1就能销毁，但是这个操作也需要人来执行，是人就无法避免出现背叛的情况。如果分三步(硬盘数据擦除+销磁+物理破坏)，这样三个操作就由不同的人完成，任意两个人出现背叛都不会有问题。说穿了就是用钱换冗余，和双机热备是一个道理。同时需求较小，分人甚至多人处理一个盘 3，当下清空硬盘，对于机械硬盘，在硬盘刚装上未写入数据时先开启bitlocker，销毁时低格一次足以,不行就随机数据填充一次.对于固态硬盘的种种特性比较麻烦,最好是一开始就全盘加密,删除时直接重置硬盘 4，硬盘外流被开盘取数据的可能性约等于剩磁的可能性 2，固件后门：一、二 ","date":"2021-07-16","objectID":"/disk-clear-note/:1:7","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"几种常见磁盘擦写算法 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:0","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"美国国防部 5220.22-M 资料争议，三次或七次。个人倾向于7次 美国国防部在 DoD 5220.22-M 规范中规定使用三次覆写算法。 Use this seven-pass method for tighter security. Different patterns of bytes are written to the disk as described in the table below. Using this method is probably even safer than using the simple method (with 6 passes). This method is described in the National Industrial Security Program Operating Manual (NISPOM a.k.a. DoD 5220.22-M) of the US Department of Defense (January 1995; chapter 8, section 3, 8-306. Maintenance). The free disk space is overwritten seven times: Pass Data 1 A random character, n = [0, 255] 2 A random character, n 3 Complement of previous character, ~n 4 A random character, n 5 A random character, n 6 Complement of previous character, ~n 7 A random character, n However, if you want to be absolutely sure of your data security, use the Gutmann method, below ","date":"2021-07-16","objectID":"/disk-clear-note/:2:1","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"美国：NAVSO P-5239-26 （RLL） 美国海军职员办公室发行物（NAVSO Pub）5239—《信息系统 安全（INFOSEC）计划指导原则》由美国海军信息 系统管理中心签发。磁盘控制器采用多种加密技术将计算机数据转换为 磁性数据存储媒体的适用格式。一般情况，ST506 类磁盘驱动器使用改进频率调制（MFM）加密。;SCSI 和 ATA/IDE驱动器使用 游程长度受限（RLL）加密方案。如果对驱动器加密技术不确定，请使用此模式。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:2","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"美国：NAVSO P-5239-26 （MFM） 美国海军职员办公室发行物（NAVSO Pub）5239—《信息系统 安全（INFOSEC）计划指导原则》由美国海军信息 系统管理中心签发。磁盘控制器采用多种加密技术将计算机数据转换为 磁性数据存储媒体的适用格式。一般情况，ST506类磁盘驱动器使用改进频率调制（MFM）；加密。SCSI 和 ATA/IDE 驱动器使用 游程长度受限（RLL）加密方案。该算法采用MFM模式。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:3","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"德国： VSITR 根据 $12 VSITR（指令 #11，1999 年 11 月 29 日）的规定（德国信息安全联邦办公室（BSI）签发），每个扇区都将被 00 和 FF 的三个不同模式覆写，最后一次为AA覆写。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:4","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"俄罗斯：GOST P50739-95 俄罗斯国家技术委员会（Russian State Technical Committee）规定须使 第 6 至第 4 保护类型扇区为零，并在第三至第一个内使用随机字符覆写。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:5","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"Peter Gutmann(古特曼) Peter Gutmann （奥克兰大学计算机科学 系）在第六届 USENIX 安全会议记录上发表了文章（加利福尼亚州圣何塞，1996 年 7 月 22-25 日）。他建议使用一系列方法，以尽可能使黑客很难对此类媒体进行数据 恢复。他提出了35次覆写算法。该算法速度较慢，但极为可靠。 Top Previous Next This method offers the most tight security for the whole range of disk drive types. You should use this method if your data is very valuable and you think your disk could possibly be scrutinized by expensive, specialized equipment. The method used by Clean Disk Security is based on that described in the paper Secure Deletion of Data from Magnetic and Solid-State Memory, by Peter Gutmann (Department of Computer Science University of Auckland. pgut001@cs.auckland.ac.nz), and is included in Clean Disk Security with his permission. The paper was first published in the Sixth USENIX Security Symposium Proceedings, San Jose, California, July 22-25, 1996. The first four and last four passes are pseudo-random data (created with additive congruential pseudo-random number generator) and other passes are made in random order. Overwrite Data PassNo. Data Written Encoding Scheme Targeted 1 Random 2 Random 3 Random 4 Random 5 01010101 01010101 01010101 0×55 (1,7) RLL MFM 6 10101010 10101010 10101010 0xAA (1,7) RLL MFM 7 10010010 01001001 00100100 0×92 0×49 0×24 (2,7) RLL MFM 8 01001001 00100100 10010010 0×49 0×24 0×92 (2,7) RLL MFM 9 00100100 10010010 01001001 0×24 0×92 0×49 (2,7) RLL MFM 10 00000000 00000000 00000000 0×00 (1,7) RLL (2,7) RLL 11 00010001 00010001 00010001 0×11 (1,7) RLL 12 00100010 00100010 00100010 0×22 (1,7) RLL 13 00110011 00110011 00110011 0×33 (1,7) RLL (2,7) RLL 14 01000100 01000100 01000100 0×44 (1,7) RLL 15 01010101 01010101 01010101 0×55 (1,7) RLL MFM 16 01100110 01100110 01100110 0×66 (1,7) RLL (2,7) RLL 17 01110111 01110111 01110111 0×77 (1,7) RLL 18 10001000 10001000 10001000 0×88 (1,7) RLL 19 10011001 10011001 10011001 0×99 (1,7) RLL (2,7) RLL 20 10101010 10101010 10101010 0xAA (1,7) RLL MFM 21 10111011 10111011 10111011 0xBB (1,7) RLL 22 11001100 11001100 11001100 0xCC (1,7) RLL (2,7) RLL 23 11011101 11011101 11011101 0xDD (1,7) RLL 24 11101110 11101110 11101110 0xEE (1,7) RLL 25 11111111 11111111 11111111 0xFF (1,7) RLL (2,7) RLL 26 10010010 01001001 00100100 0×92 0×49 0×24 (2,7) RLL MFM 27 01001001 00100100 10010010 0×49 0×24 0×92 (2,7) RLL MFM 28 00100100 10010010 01001001 0×24 0×92 0×49 (2,7) RLL MFM 29 01101101 10110110 11011011 0x6D 0xB6 0xDB (2,7) RLL 30 10110110 11011011 01101101 0xB6 0xDB 0x6D (2,7) RLL 31 11011011 01101101 10110110 0xDB 0x6D 0xB6 (2,7) RLL 32 Random 33 Random 34 Random 35 Random ","date":"2021-07-16","objectID":"/disk-clear-note/:2:6","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"Bruce Schneier Bruce Schneier 则在他的《应用 密码术》一书中提出使用七次覆写算法。第一次全部使用一，第二次全部为 零，接下来的五次使用密码安全性较高的假随机序列。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:7","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"快速（0填充） 最快但最不安全的数据销毁算法。一次性以“零”覆写所有数据。 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:8","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"Linux低级格式化 sudo dd if=/dev/random of=/dev/sdb bs=1000000 count=4000000 # 谨慎使用责任自负 ","date":"2021-07-16","objectID":"/disk-clear-note/:2:9","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Hardware","note"],"content":"磁盘的剩磁效应 ​ 计算机磁盘属于磁介质，所有磁介质都存在剩磁效应的问题，保存在磁介质中的信息会使磁介质不同程度地永久性磁化，所以磁介质上记载的信息在一定程度上是抹除不净的，使用高灵敏度的磁头和放大器可以将已抹除信息的磁盘上的原有信息提取出来。据一些资料介绍，即使磁盘已改写了12次，第一次写入的信息仍有可能复原出来。这使涉密和重要磁介质的管理、废弃磁介质的处理，都成为很重要的问题。国外甚至有这样的规定：记录绝密信息资料的磁盘只准用一次，不用时就必须销毁，不准抹后重录。 　磁盘是用于拷贝和存储文件的，它常被重新使用，有时要删除其中某些文件，有时又要拷贝一些文件进去。在许多计算机操作系统中，用DEL命令删除一个文件，仅仅是删除该文件的文件指针，也就是删除该文件的标记，释放了该文件的存储空间，而并没有真正将该文件删除或覆盖。在该文件的存储空间未被其他文件覆盖之前，该文件仍然原封不动地保留在磁盘上。计算机删除磁盘文件的这种方式，可提高文件处理的速度和效率，也可方便误删除文件的恢复，但却给窃密者留下了可乘之机。他只要查阅一下磁盘最近删除的文件目录，就可以轻而易举地找到和恢复对他有价值的信息。 　因此如果将曾经记载过秘密信息的磁盘留做它用，必须将原记载的信息彻底清除，具体的清除办法和技术有很多种，但实质上可分为直流消磁法和交流消磁法两种。 　直流消磁法是使用直流磁头将磁盘上原先记录信息的剩余磁通，全部以一种形式的恒定值所代替。通常，我们操作计算机用完全格式化方式格式化磁盘就是这种方法。 　交流消磁法是使用交流磁头将磁盘上原先记录信息的剩余磁通变得极小，这种方法的消磁效果比直流消磁法要好得多，消磁后磁盘上残留信息强度可比消磁前下降90分贝。实用中一般是使用大电流的交流强力消磁器进行的，对一些曾记载过较高密级的磁盘，必须使用这种消磁技术进行处理后，才能从保密环境中释放做其他使用。 　对一些经消磁后仍达不到保密要求的磁盘，或已经损坏需废弃的涉密磁盘，以及曾经记载过绝密级信息的磁盘，必须作销毁处理。磁盘销毁的方法是，将磁盘碾碎后放入焚化炉熔为灰烬和铝液。 ","date":"2021-07-16","objectID":"/disk-clear-note/:3:0","tags":["Disk"],"title":"磁盘数据销毁笔记","uri":"/disk-clear-note/"},{"categories":["Back"],"content":"记录@RequestMapping和@GetMapping的区别","date":"2021-07-16","objectID":"/reqmap-getmap-diff/","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"引言 在Spring4.3版本以后，提供了@GetMapping注解更方便了开发，那么@RequestMapping和@GetMapping有什么区别呢？ @RequestMapping和@GetMapping区别 @RequestMapping可以指定GET、POST请求方式 @GetMapping等价于@RequestMapping的GET请求方式 使用springboot搭建springmvc测试如下： ** * @auther KKKPJSKEY * @data 2018/7/16 0001上午 9:27 */ @RestController @RequestMapping public class HelloController { //@RequestMapping(value = \"hello\", method= RequestMethod.GET ) @GetMapping(\"hello\") public String hello() { return \"hello spring boot\"; } } ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:1:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"springboot搭建springMVC ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:2:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"步骤： maven的 pom.xml中引用springboot父工程、引入启动器web-starter 写main函数； \u003c!-- 父工程 --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.0.0.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003c!-- 引入 starter-web --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 写 main 函数： ** * @auther KKKPJSKEY * @data 2018/7/16 0001上午 9:27 */ @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } controller @RestController @RequestMapping public class HelloController { //@RequestMapping(value = \"hello\", method= RequestMethod.GET ) @GetMapping(\"hello\") public String hello() { return \"hello spring boot\"; } } 启动main函数，浏览器发请求 请求地址：http://localhost:8080/hello 请求结果如下： ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:2:1","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"小结 总结：@GetMapping 在限定使用get请求时候，更为简洁方便 如封面所示其他http方法均有对应的语法糖支持 ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:3:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back","note"],"content":"记录JPA @Id 和 @GeneratedValue 注解详解的笔记","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"解释 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"@Id @Id 标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。 @Id标注也可置于属性的getter方法之前。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"@GeneratedValue @GeneratedValue 用于标注主键的生成策略，通过strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer对应identity，MySQL 对应 auto increment。 在javax.persistence.GenerationType中定义了以下几种可供选择的策略： IDENTITY：采用数据库ID自增长的方式来自增主键字段，Oracle 不支持这种方式； AUTO： JPA自动选择合适的策略，是默认选项； SEQUENCE：通过序列产生主键，通过@SequenceGenerator 注解指定序列名，MySql不支持这种方式 TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"推荐的两种写法： ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"属性之上： @Table(name=\"CUSTOMERS\") @Entity public class Customer { @GeneratedValue(strategy=GenerationType.AUTO) @Id private Integer id; private String name; private String email; private int age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"getter方法之上： @Table(name=\"CUSTOMERS\") @Entity public class Customer { private Integer id; private String name; private String email; private int age; @GeneratedValue(strategy=GenerationType.AUTO) @Id public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"注意 但是不能某个注解在属性之上，某个注解在getter之上，将抛出异常，对其他注解也相同 @Table(name=\"CUSTOMERS\") @Entity public class Customer { @Id private Integer id; private String name; private String email; private int age; @GeneratedValue(strategy=GenerationType.AUTO) public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } 上面的写法是错误的 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"一、JPA通用策略生成器 通过annotation来映射hibernate实体的,基于annotation的hibernate主键标识为@Id, 其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法, JPA提供四种标准用法,由@GeneratedValue的源代码可以明显看出. Java代码 @Target({METHOD,FIELD}) @Retention(RUNTIME) public @interface GeneratedValue{ GenerationType strategy() default AUTO; String generator() default \"\"; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1、GenerationType: Java代码 @Id @GeneratedValue(strategy = GenerationType.TABLE, generator=\"payablemoney_gen\") @TableGenerator(name = \"pk_gen\", table=\"tb_generator\", pkColumnName=\"gen_name\", valueColumnName=\"gen_value\", pkColumnValue=\"PAYABLEMOENY_PK\", allocationSize=1 ) 这里应用表tb_generator，定义为 Sql代码 CREATETABLEtb_generator(idNUMBERNOTNULL,gen_nameVARCHAR2(255)NOTNULL,gen_valueNUMBERNOTNULL,PRIMARYKEY(id)) 插入纪录，供生成主键使用， Sql代码 INSERTINTOtb_generator(id,gen_name,gen_value)VALUES(1,PAYABLEMOENY_PK', 1); 在主键生成后，这条纪录的value值，按allocationSize递增。 @TableGenerator的定义： @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface TableGenerator { String name(); String table() default \"\"; String catalog() default \"\"; String schema() default \"\"; String pkColumnName() default \"\"; String valueColumnName() default \"\"; String pkColumnValue() default \"\"; int initialValue() default 0; int allocationSize() default 50; UniqueConstraint[] uniqueConstraints() default {}; } 其中属性说明： name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。 table属性表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。 catalog属性和schema具体指定表所在的目录名或是数据库名。 pkColumnName属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值 valueColumnName属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值 pkColumnValue属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。 initialValue表示主键初识值，默认为0。 allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 UniqueConstraint与@Table标记中的用法类似。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2、SEQUENCE Java代码 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=\"payablemoney_seq\") @SequenceGenerator(name=\"payablemoney_seq\", sequenceName=\"seq_payment\") @SequenceGenerator定义 Java代码 @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) **public** **@interface** SequenceGenerator { String name(); String sequenceName() **default** \"\"; **int** initialValue() **default** 0; **int** allocationSize() **default** 50; } name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。 sequenceName属性表示生成策略用到的数据库序列名称。 initialValue表示主键初识值，默认为0。 allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3、IDENTITY Java代码 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4、AUTO Java代码 @Id @GeneratedValue(strategy = GenerationType.AUTO) 在指定主键时，如果不指定主键生成策略，默认为AUTO。 Java代码 @Id 跟下面的定义是一样的。 Java代码 @Id @GeneratedValue(strategy = GenerationType.AUTO) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"二、hibernate主键策略生成器 hibernate提供多种主键生成策略，有点是类似于JPA，有的是hibernate特有： native: 对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server 采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）。 uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）。 hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为integer类型，名称是next_hi（比较少用）。 assigned: 在插入数据的时候主键由程序处理（很常用），这是 元素没有指定时的默认生成策略。等同于JPA中的AUTO。 identity: 使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。 等同于JPA中的INDENTITY。 select: 使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）。 sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用） increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 foreign: 使用另外一个相关联的对象的主键。通常和联合起来使用。 guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 uuid.hex: 看uuid，建议用uuid替换。 sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 hibernate提供了多种生成器供选择,基于Annotation的方式通过@GenericGenerator实现. hibernate每种主键生成策略提供接口org.hibernate.id.IdentifierGenerator的实现类,如果要实现自定义的主键生成策略也必须实现此接口. Java代码 public interface IdentifierGenerator { public static final String ENTITY_NAME = \"entity_name\"; public Serializable generate(SessionImplementor session, Object object) throws HibernateException; } IdentifierGenerator提供一generate方法,generate方法返回产生的主键. ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:4:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"三、@GenericGenerator 自定义主键生成策略，由@GenericGenerator实现。 hibernate在JPA的基础上进行了扩展，可以用一下方式引入hibernate独有的主键生成策略，就是通过@GenericGenerator加入的。 比如说，JPA标准用法 Java代码 @Id @GeneratedValue(GenerationType.AUTO) 就可以用hibernate特有以下用法来实现 Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"assigned\") @GenericGenerator的定义: Java代码 @Target({PACKAGE, TYPE, METHOD, FIELD}) @Retention(RUNTIME) **public** **@interface** GenericGenerator { String name(); String strategy(); Parameter[] parameters() **default** {}; } name属性指定生成器名称。 strategy属性指定具体生成器的类名。 parameters得到strategy指定的具体生成器所用到的参数。 对于这些hibernate主键生成策略和各自的具体生成器之间的关系,在org.hibernate.id.IdentifierGeneratorFacto ry中指定了, Java代码 **static** { GENERATORS.put(\"uuid\", UUIDHexGenerator.**class**); GENERATORS.put(\"hilo\", TableHiLoGenerator.**class**); GENERATORS.put(\"assigned\", Assigned.**class**); GENERATORS.put(\"identity\", IdentityGenerator.**class**); GENERATORS.put(\"select\", SelectGenerator.**class**); GENERATORS.put(\"sequence\", SequenceGenerator.**class**); GENERATORS.put(\"seqhilo\", SequenceHiLoGenerator.**class**); GENERATORS.put(\"increment\", IncrementGenerator.**class**); GENERATORS.put(\"foreign\", ForeignGenerator.**class**); GENERATORS.put(\"guid\", GUIDGenerator.**class**); GENERATORS.put(\"uuid.hex\", UUIDHexGenerator.**class**); //uuid.hex is deprecated GENERATORS.put(\"sequence-identity\", SequenceIdentityGenerator.**class**); } 上面十二种策略，加上native，hibernate一共默认支持十三种生成策略。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1、native Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"native\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2、uuid Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"uuid\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3、hilo Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"hilo\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4、assigned Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"assigned\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"5、identity Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"identity\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:5","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"6、select Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name=\"select\", strategy=\"select\", parameters = { @Parameter(name = \"key\", value = \"idstoerung\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:6","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"7、sequence Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"sequence\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:7","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"8、seqhilo Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"seqhilo\", parameters = { @Parameter(name = \"max_lo\", value = \"5\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:8","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"9、increment Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"increment\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:9","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"10、foreign Java代码 @GeneratedValue(generator = \"idGenerator\") @GenericGenerator(name = \"idGenerator\", strategy = \"foreign\", parameters = { @Parameter(name = \"property\", value = \"employee\") }) 注意：直接使用@PrimaryKeyJoinColumn 报错（?） Java代码 @OneToOne(cascade = CascadeType.ALL) @PrimaryKeyJoinColumn 例如 Java代码 @Entity **public** **class** Employee { @Id Integer id; @OneToOne @PrimaryKeyJoinColumn EmployeeInfo info; ... } 应该为 Java代码 @Entity **public** **class** Employee { @Id @GeneratedValue(generator = \"idGenerator\") @GenericGenerator(name = \"idGenerator\", strategy = \"foreign\", parameters = { @Parameter(name = \"property\", value = \"info\") }) Integer id; @OneToOne EmployeeInfo info; ... } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:10","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"11、guid Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"guid\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:11","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"12、uuid.hex Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"uuid.hex\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:12","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"13、sequence-identity Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"sequence-identity\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:13","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"四、通过@GenericGenerator自定义主键生成策略 如果实际应用中，主键策略为程序指定了就用程序指定的主键（assigned），没有指定就从sequence中取。 明显上面所讨论的策略都不满足，只好自己扩展了，集成assigned和sequence两种策略。 Java代码 **public** **class** AssignedSequenceGenerator **extends** SequenceGenerator **implements** PersistentIdentifierGenerator, Configurable { **private** String entityName; **public** **void** configure(Type type, Properties params, Dialect dialect) **throws** MappingException { entityName = params.getProperty(ENTITY_NAME); **if** (entityName==**null**) { **throw** **new** MappingException(\"no entity name\"); } **super**.configure(type, params, dialect); } **public** Serializable generate(SessionImplementor session, Object obj) **throws** HibernateException { Serializable id = session.getEntityPersister( entityName, obj ) .getIdentifier( obj, session.getEntityMode() ); **if** (id==**null**) { id = **super**.generate(session, obj); } **return** id; } } 实际应用中，定义同sequence。 Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"AssignedSequenceGenerator\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) 四种数据库的支持情况如下： 数据库名称 支持的id策略 mysql GenerationType.TABLEGenerationType.AUTOGenerationType.IDENTITY**不支持GenerationType.SEQUENCE* * oracle strategy=GenerationType.AUTOGenerationType.SEQUENCEGenerationType.TABLE**不支持GenerationType.IDENTITY* * postgreSQL GenerationType.TABLEGenerationType.AUTOGenerationType.IDENTITYGenerationType.*SEQUENCE都支持 * kingbase GenerationType.TABLEGenerationType.SEQUENCEGenerationType.IDENTITYGenerationType.AUTO**都支持 JPA的@GeneratedValue注解,在JPA中,@GeneratedValue注解存在的意义主要就是为一个实体生成一个唯一标识的主键(JPA要求每一个实体Entity,必须有且只有一个主键),@GeneratedValue提供了主键的生成策略。@GeneratedValue注解有两个属性,分别是strategy和generator,其中generator属性的值是一个字符串,默认为\"\",其声明了主键生成器的名称(对应于同名的主键生成器@SequenceGenerator和@TableGenerator)。 JPA为开发人员提供了四种主键生成策略,其被定义在枚举类GenerationType中,包括GenerationType.TABLE,GenerationType.SEQUENCE,GenerationType.IDENTITY和GenerationType.AUTO。下面分别介绍这四种主键生成策略。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1.GenerationType.TABLE 使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键,这种策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,所以不会优先使用。该策略一般与另外一个注解一起使用@TableGenerator,@TableGenerator注解指定了生成主键的表(可以在实体类上指定也可以在主键字段或属性上指定),然后JPA将会根据注解内容自动生成一张表作为序列表(或使用现有的序列表)。如果不指定序列表,则会生成一张默认的序列表,表中的列名也是自动生成,数据库上会生成一张名为sequence的表(SEQ_NAME,SEQ_COUNT)。序列表一般只包含两个字段:第一个字段是该生成策略的名称,第二个字段是该关系表的最大序号,它会随着数据的插入逐渐累加。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"roleSeq\") @TableGenerator(name = \"roleSeq\", allocationSize = 1, table = \"seq_table\", pkColumnName = \"seq_id\", valueColumnName = \"seq_count\") **private** Integer id; 在以上例子中,roleSeq唯一的标识了该生成器,在@GeneratedValue注解中的generator属性可以根据此标识来声明主键生成器。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2.GenerationType.SEQUENCE 在某些数据库中,不支持主键自增长,比如Oracle,其提供了一种叫做\"序列(sequence)“的机制生成主键。此时,GenerationType.SEQUENCE就可以作为主键生成策略。该策略的不足之处正好与TABLE相反,由于只有部分数据库(Oracle,PostgreSQL,DB2)支持序列对象,所以该策略一般不应用于其他数据库。类似的,该策略一般与另外一个注解一起使用@SequenceGenerator,@SequenceGenerator注解指定了生成主键的序列.然后JPA会根据注解内容创建一个序列(或使用一个现有的序列)。如果不指定序列,则会自动生成一个序列SEQ_GEN_SEQUENCE。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"menuSeq\") @SequenceGenerator(name = \"menuSeq\", initialValue = 1, allocationSize = 1, sequenceName = \"MENU_SEQUENCE\") **private** Integer id; 同样,在以上例子中,menuSeq唯一的标识了该生成器,@SequenceGenerator可以理解为将数据库中存在的序列进行了一个映射,在@GeneratedValue注解中的generator属性可以根据此标识来声明主键生成器。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3.GenerationType.IDENTITY 此种主键生成策略就是通常所说的主键自增长,数据库在插入数据时,会自动给主键赋值,比如MYSQL可以在创建表时声明\"auto_increment” 来指定主键自增长。该策略在大部分数据库中都提供了支持(指定方法或关键字可能不同),但还是有少数数据库不支持,所以可移植性略差。使用自增长主键生成策略是只需要声明strategy = GenerationType.IDENTITY即可。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) **private** Integer id; 需要注意的是,同一张表中自增列最多只能有一列。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4.GenerationType.AUTO 把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。此种主键生成策略比较常用,由于JPA默认的生成策略就是GenerationType.AUTO,所以使用此种策略时.可以显式的指定@GeneratedValue(strategy = GenerationType.AUTO)也可以直接@GeneratedValue 类似于 Java代码 @GeneratedValue(strategy = GenerationType.AUTO) **private** Integer id; 或 Java代码 @GeneratedValue **private** Integer id; 参考资料: http://xiaoyaocao.iteye.com/blog/1874412 http://www.ibm.com/developerworks/cn/java/j-lo-jpaprimarykey/ http://www.oracle.com/technetwork/cn/middleware/ias/toplink-jpa-annotations-100895-zhs.html# 测试实例 http://download.csdn.net/detail/u012493207/9456135 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back"],"content":"解决java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized的Error","date":"2021-07-15","objectID":"/mysql-server-time-error/","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"报错 如图报错信息 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:1:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"原因 程序端（访问端）和数据库的时时区不一样报错 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:2:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"解决办法 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"方法1 在语句\"jdbc:mysql://localhost:3366/test “后添加”?serverTimezone=GMT%2B8\": ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:1","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"方法2 更改MySQL中的系统时间 Linux 修改my.cnf实现永久修改 vi /etc/mysql/my.cnf # 然后在mysqld下边的配置中添加一行：[mysqld] [mysqld] default-time_zone = '+8:00' # 然后重启mysql service mysql restart Windows 修改my.ini实现永久修改 vi /c/mysql/my.cnf #Git Bash edit C:\\mysql\\my.cnf #CMD # 然后在mysqld下边的配置中添加一行：[mysqld] [mysqld] default-time_zone = '+8:00' # 然后重启mysql net mysql restart ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:2","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"解决Maven操作时Process terminated报错","date":"2021-07-15","objectID":"/maven-process-terminated-error/","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"原因 如图报错，检查报错文件发现xml文件有问题 ","date":"2021-07-15","objectID":"/maven-process-terminated-error/:1:0","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"XML文件报错原因及解决办法 原因 缩进或者空格不一致导致该问题 解决办法 格式化编辑好之后复制再粘贴过来就可以了( 👉XML 在线格式化) ","date":"2021-07-15","objectID":"/maven-process-terminated-error/:2:0","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"解决java.lang.NoClassDefFoundError: javax/validation/constraints/Min","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"原因 spring-boot-starter-parent版本不同，部分版本（2.3之后）不包含hibernate-validator，需要额外添加spring-boot-starter-validation依赖 ","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/:1:0","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"parent \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003c!-- 不包含hibernate-validator--\u003e \u003c!-- \u003cversion\u003e2.3.1\u003c/version\u003e--\u003e \u003c!-- 包含hibernate-validator--\u003e \u003cversion\u003e2.2.13.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e 不包含hibernate-validator需要额外添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-validation\u003c/artifactId\u003e \u003c/dependency\u003e 就不报错了 ","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/:1:1","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"解决Mysql closing inbound before receiving peer's close_notify 的Error","date":"2021-07-15","objectID":"/mysql-sslexception-error/","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"错误 EXCEPTION STACK TRACE: ** BEGIN NESTED EXCEPTION ** javax.net.ssl.SSLException MESSAGE: closing inbound before receiving peer's close_notify STACKTRACE: javax.net.ssl.SSLException: closing inbound before receiving peer's close_notify ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:1:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"原因 开启了userSSL ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:2:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"解决 在连接字符串后面拼接?useSSL=false spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:3:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"解决Mysql The last packet sent successfully to the server was 0 milliseconds ago.的Error","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"原因 我的是Mysql服务没启动 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:1:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"解决办法 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"控制台 net start mysql ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:1","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"手动 进入Window服务界面启动Mysql服务即可 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:2","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back","note"],"content":"记录Java学习路线的笔记","date":"2021-07-14","objectID":"/java-learn-path/","tags":["Java","Path"],"title":"Java学习路线笔记","uri":"/java-learn-path/"},{"categories":["Back","note"],"content":"路线 JavaSE –\u003e MySQL基础 –\u003e JDBC –\u003e JavaWeb –\u003e Spring5 –\u003e SpringMVC –\u003e MyBatis –\u003e Maven –\u003e Ssm框架整合案例 –\u003e Git/GitHub –\u003e Redis6 –\u003e MySQL高级优化 –\u003e MyBatisPlus –\u003e Spring注解驱动开发 –\u003e ZooKeeper –\u003e Dubbo –\u003e 消息中间件ActiveMQ –\u003e RabbitMQ –\u003e RocketMQ –\u003e SpringBoot2 –\u003e SpringCloud –\u003e 尚筹网项目 –\u003e 在线教育项目 –\u003e 谷粒商城项目 –\u003e 尚医通项目 –\u003e 尚融宝项目 –\u003e 高频面试题第一季 –\u003e 大厂面试题第二季 –\u003e 大厂面试题第三季 ","date":"2021-07-14","objectID":"/java-learn-path/:1:0","tags":["Java","Path"],"title":"Java学习路线笔记","uri":"/java-learn-path/"},{"categories":["Back","note"],"content":"视频教程 尚硅谷教程如何下载（每一步都有截图）: 学习尚硅谷教程遇到的各种常识性问题 详细Java学习路线图 一、Java基础阶段 1.尚硅谷Java基础教程：每章配备随堂练习，兼具Eclipse和IDEA环境、源码笔记资料齐全 2.尚硅谷MySQL核心技术教程：知识点详尽、全程笔记完备 3.尚硅谷JDBC教程教程：专业、实用，并配备多个课后习题 4.尚硅谷IDEA教程：从安装、设置入手，讲解创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等 5.尚硅谷Eclipse\u0026IDEA中Maven和Git快速配置及使用：从基本配置着手，详细讲述了在Eclipse和Idea中使用Maven和Git的过程 6.尚硅谷Java15新特性教程：全方位了解JDK15 二、JavaWEB阶段 1.尚硅谷JavaWeb教程（2020新版）： 课程涵盖：Servlet程序、Filter过滤器、Listener监听器、JSP页面、EL表达式、JSTL标签库、jQuery框架、Cookie技术、Session会话、JSON使用、Ajax请求等大量Web开发核心技术点 三、JavaEE框架阶段 1.尚硅谷Spring5教程：涵盖Spring5基础知识、IOC容器、AOP、JdbcTemplate、事务、Spring5新功能等 2.尚硅谷SpringMVC教程：内容涵盖全面，讲解细致深入 3.尚硅谷JPA教程： 4.尚硅谷Spring注解驱动开发教程：深入了解Spring原理机制，庖丁解牛式的源码学习 5.尚硅谷Spring Data教程： 6.尚硅谷Spring、SpringMVC、JPA、SpringData整合案例教程： 7.尚硅谷Shiro教程：涵盖 Shiro 认证、加密、授权、安全标签、安全注解、会话管理、缓存、Rememberme 等 8.尚硅谷通用Mapper教程：详细讲解常规增删改查操作、QBC查询之外，还包括逆向工程MBG工具、二级缓存@CacheNamespace注解、TypeHandler类型处理器、枚举类型映射方式等知识点 9.尚硅谷RBAC权限实战项目： 10.尚硅谷MyBatis教程（源码级讲授）:除对MyBatis日常基本使用示范外，还涉及诸多细节。以及较深入源码的讲解MyBatis运行原理、插件机制和一些企业实用场景 11.尚硅谷MyBatisPlus教程： 12.尚硅谷SSM整合视频教程：基于Maven+SpringMVC+Spring+MyBatis+Bootstrap的组合，快速开发一个完整的CRUD功能 13.尚硅谷SVN及SVN高级：手把手教你安装服务器端程序、配置版本库、操作客户端界面 14.尚硅谷Maven教程：了解 Maven 的作用，常用命令，如何配置依赖，以及依赖的范围、依赖的传递性、依赖的排除、生命周期等重要概念，以及继承、聚合这样的 Maven 配置 15.尚硅谷Git\u0026GitHub教程：囊括日常所用 三、微服务核心生态 1.尚硅谷Spring Boot 2教程： 本套教程基于SpringBoot2.3与2.4版本讲解，包含核心基础、Web原理、单元测试、数据访问、指标监控等章节，内容特点： Web原理章节：着重分析SpringBoot2.4在底层处理Web请求的原理与源码差异，包含请求参数处理原理、数据响应原理、内容协商原理、页面渲染原理、异常处理等 单元测试章节：讲解JUnit5测试场景，JUnit5在架构设计和使用上与JUnit4的区别，包含常用测试注解、断言机制、嵌套测试、参数化测试等 数据访问章节：讲整合MyBatisPlus+Druid数据源+数据源监控，完成CRUD小实验 指标监控章节：全面分析指标监控Endpoint机制、JMX+HTTP监控，以及自定义Endpoint，章节最后演示整合开源的第三方监控面板展示整个监控的效果 原理解析部分：源码层级剖析SpringBoot自动配置原理、Web原理、SpringBoot启动原理 2.尚硅谷好评如潮【Spring Boot】教程：雷神源码级别讲解 ①内容包含微服务概念、配置文件、日志框架的使用.web开发、Thymeleaf模板引擎.Docker容器技术、MyBatis、Spring Data、JPA、自定义starter ②内容包括：缓存（整合Redis）、消息中间件（整合RabbitMQ）、检索（整合ElasticSearch）、任务（异步任务，定时任务，邮件任务）、安全（整合SpringSecurity）、分布式（整合Zookeeper/dubbo，整合SpringCloud）、SpringBoot应用监管 3.尚硅谷Spring Cloud教程： 既有传统Eureka、Ribbon、OpenFeign、Hystrix、Config等技术的升级讲解，又有Consul、Gateway、Bus、Stream、Sleuth、zipkin和阿里巴巴新的的Nacos、Sentinel、Seata等技术，分享了服务降级、服务熔断、服务限流、hotkey控制、分布式统一配置管理、分布式全局事务控制、RabbitMQ与Stream整合、Nacos和Nginx配置高可用集群等技术 4.尚硅谷Sentinel教程：讲解了Sentinel核心工作流程与滑动时间窗限流算法 5.尚硅谷Jenkins教程：讲解了持续集成、持续部署、持续交付，还讲解了基于Jenkins搭建持续集成环境的操作过程 6.尚硅谷Docker教程：Docker快速上手，迅速入门 7.尚硅谷Kubernetes/k8s教程：完整演示真实项目从零开始部署到k8s集群，包括项目打包、制作镜像、部署过程 8.尚硅谷Dubbo教程：讲解了RPC原理，Dubbo基本使用、高可用场景以及原理 9.尚硅谷Nginx教程：讲解了Nginx基本概念、软件安装和基本的操作命令、Nginx各种应用场景配置、Nginx原理 10.尚硅谷JVM教程：内存与垃圾回收篇和字节码与类的加载篇均已更新，性能监控与调优篇待更 11.尚硅谷Spring Security教程：掌握Spring Security在各场景的使用，以及内部实现原理 12.尚硅谷Redis6教程：从Redis的基本概念开启讲解 13.尚硅谷Elasticsearch（ELK）教程：讲解Elasticsearch的开发应用、核心原理以及与其他经典数据分析引擎Spark、Flink的集成方式，带你玩转全文检索 14.尚硅谷MySQL高级教程：主要讲授针对 Java 开发所需的 MySQL 高级知识 15.尚硅谷消息中间件之ActiveMQ：从零基础入门到熟练掌握ActiveMQ 16.尚硅谷RabbitMQ教程：快速掌握MQ消息中间件 17.尚硅谷RocketMQ教程：深刻理解RocketMQ整体架构及其工作原理 18.尚硅谷Mycat教程：涵盖Mycat核心技术主要知识点，常用功能均有实战练习 19.尚硅谷ShardingSphere视频教程：ShardingSphere的基本概念、Sharding-JDBC、Sharding-Proxy 20.尚硅谷密码学教程：理解密码学基本概念，各种加密和解密方式，应用场景 五、企业级实战项目 一、尚硅谷入门项目–尚筹网项目教程： ①从单一架构到分布式架构的过渡阶段，适合学完Ssm框架后，需要通过项目巩固所学知识技能，并平滑过渡到分布式开发的小伙伴 ②前端会员系统是基于SpringBoot+SpringCloud的微服务架构，使用了SpringCloud的Eureka、Ribbon、Feign、Zuul等基本组件搭建了基础开发环境 ③后台管理系统是基于Ssm整合的单一架构，使用SpringSecurity进行权限控制、使用zTree实现树形结构数据在页面的显示，并通过MyBatis的PageHelper插件实现分页 二、.尚硅谷微服务项目 1.谷粒学苑项目教程： ①系统后端接口部分，使用目前流行的SpringBoot+SpringCloud进行微服务架构，使用Feign、Gateway、Hystrix，以及阿里巴巴的Nacos等组件搭建了项目的基础环境 ②系统前端部分，使用主流的前端框架Vue，使用Es6的开发规范，采用模块化的开发模式，搭建页面环境使用了Nuxt框架和vue-admin-template模板，使用Element-ui进行页面布局 2.尚医通视频教程： ①项目后端技术栈，采用主流的SpringBoot+SpringCloud微服务架构，全面使用了目前流行的NoSQL技术，使用Redis缓存数据，使用MongoDB实现高并发读写，整合消息中间件RabbitMQ提高订单的并发量，同时还整合了定时任务，实现就医提醒功能，综合应用了阿里云OSS，短信服务以及微信登录、微信支付，同时增加了微信退款功能。 ②项目前端技术栈，采用主流前端框架Vue，使用Nuxt和vue-admin-template模板搭建页面环境，采用Element-ui进行页面布局，Npm进行依赖管理，axios进行异步调用，使用ECharts进行图表显示，实现全栈开发。 3.尚融宝视频教程： ①项目介绍和前后端核心框架 介绍项目的技术栈、技术架构、功能及业务流程。 ②项目基本功能的实现 独立完成全栈项目的搭建，掌握项目的前后端如何进行独立开发及如何进行接口联调。 ③SpringCloud基础设施 整合nacos、Sentinel、gateway等微服务基础设施，搭建一个微服务项目。 ④核心业务流程的实现 针对尚融宝涉及的金融业务","date":"2021-07-14","objectID":"/java-learn-path/:2:0","tags":["Java","Path"],"title":"Java学习路线笔记","uri":"/java-learn-path/"},{"categories":["Total","note"],"content":"记录常用编程的缩写的笔记","date":"2021-07-14","objectID":"/conv-prog-abbr-note/","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"CGI 公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:1:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"EJB 是的Enterprise Java Beans技术的简称, 又被称为企业Java Beans。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:2:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ELT ELT，是英文 Extract-Load-Transform 的缩写。在ELT架构中，ELT只负责提供图形化的界面来设计业务规则，数据的整个加工过程都在目标和源的数据库之间流动，ELT协调相关的数据库系统来执行相关的应用，数据加工过程既可以在源数据库端执行，也可以在目标数据仓库端执行（主要取决于系统的架构设计和数据属性） ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:3:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ESB 企业服务总线，即ESB全称为Enterprise Service Bus ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:4:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ETL ETL，是英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:5:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"POJO（分类有详解，见这篇文章） （Plain Ordinary Java Object）简单的Java对象。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:6:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"IDC IDC一般指互联网数据中心。互联网数据中心（Internet Data Center，简称IDC）是指一种拥有完善的设备（包括高速互联网接入带宽、高性能局域网络、安全可靠的机房环境等）、专业化的管理、完善的应用的服务平台。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:7:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"IPsec IPsec（英语：Internet Protocol Security），是一个协议包，通过对IP协议的分组进行加密和认证来保护IP协议的网络传输协议族（一些相互关联的协议的集合）。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:8:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"RMI 英文全称是\"Remote Method Invocation\"，它的中文名称是\"远程方法调用\"。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:9:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"RPC 是\"Remote Procedure Call\"的缩写，也就是\"远程过程调用\"。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:10:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"SOA 面向服务的体系结构(Service-Oriented Architecture)是一个组件模型,它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:11:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"JMS JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:12:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"PWA PWA（Progressive Web App）是一种理念，使用多种技术来增强web app的功能，可以让网站的体验变得更好，能够模拟一些原生功能，比如通知推送。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:13:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"MIS 所谓MIS（管理信息系统–Management Information System）系统，主要指的是进行日常事务操作的系统。这种系统主要用于管理需要的记录，并对记录数据进行相关处理，将处理的信息及时反映给管理者的一套网络管理系统。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:14:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"IPO 首次公开募股（Initial Public Offering）是指一家企业第一次将它的股份向公众出售。通常，上市公司的股份是根据相应证监会出具的招股书或登记声明中约定的条款通过经纪商或做市商进行销售。一般来说，一旦首次公开上市完成后，这家公司就可以申请到证券交易所或报价系统挂牌交易。有限责任公司在申请IPO之前，应先变更为股份有限公司。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:15:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"OJ Online Judge系统（简称OJ）是一个在线的判题系统。用户可以在线提交程序多种程序（如C、C++、Pascal）源代码，系统对源代码进行编译和执行，并通过预先设计的测试数据来检验程序源代码的正确性。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:16:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ACM ACM (Association for Computing Machinery ) 中文国际计算机学会。ACM是一个世界性的计算机从业员专业组织，创立于1947年，是世界上第一个科学性及教育性计算机学会，在全世界130多个国家和地区拥有超过10万名的会员。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:17:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Front","note"],"content":"记录学习Npm的笔记","date":"2021-06-29","objectID":"/nodejs-npm-note/","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"Nodejs和Npm的关系 ","date":"2021-06-29","objectID":"/nodejs-npm-note/:1:0","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"名词解释 Chrome v8 Chrome提供的能把js语言编译成系统能够识别的语言的第八个版本；当然别的厂商也有不同的js编译器 Chrome v8功能 Chrome v8 能够独立运行，所以Node.js可以基于v8生成自己的运行环境；也可以在浏览器中进行js解析，因为Chrome v8 开源发展快，所以Chrome 对es6等新技术支持比较快； Npm是什么 Npm 全称是 Node Package Manager 包管理工具 当一个网站依赖的js代码越来越多，程序员发现这是一件很麻烦的事情： 去 Jquery 官网下载 Jquery 去 BootStrap 官网下载 BootStrap 去 Underscore 官网下载 Underscore …… 有些程序员就受不鸟了，于是Npm就出来了，全称是 Node Package Manager 包管理工具。 这一点和Maven、Gradle十分相似，只不过Maven、Gradle是用来管理Java Jar包的，而Npm是用来管理Js的。 Npm 的实现思路和Maven、Gradle是一样的： 1、有一个远程代码仓库（registry），在里面存放所有需要被共享的js代码，每个js文件都有自己唯一标识。 2、用户想使用某个js的时候，只需引用对应的标识，js文件会自动下载下来。 Npm的两层含义 Npm是一个第三方模块的托管网站，指的就是https://www.npmjs.com/; Npm 是Node的包管理工具（全名叫做Node Package Manager），在我们安装Node时候，就已经顺便也安装Npm这个管理工具; Node.js是什么 Node.js是基于Chrome v8 引擎的js运行环境 Node.js是一个Javascript运行环境(runtime environment)，不是一个js文件，实质是对Chrome V8引擎进行了封装。 Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python 等服务端语言平起平坐的脚本语言。 [1]Node.js提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 [2]Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。 Chrome浏览器和Node.js在解析javascript都使用了v8引擎： Npm和Node.js的发展 Npm作者已经将Npm开发完成，于是发邮件通知 Jquery、Bootstrap、Underscore 作者，希望他们把 Jquery、bootstrap 、 underscore 放到Npm远程仓库，但是没有收到回应，于是Npm的发展遇到了瓶颈。 Node.js作者也将Node.js开发完成，但是 Node.js 缺少一个包管理器，于是他和 Npm 的作者一拍即合、抱团取暖，最终 Node.js 内置了 Npm。 后来的事情大家都知道，Node.js 火了。随着 Node.js 的火爆，大家开始用 Npm 来共享 JS 代码了，于是 Jquery 作者也将 Jquery 发布到 Npm 了。所以现在，你可以使用 Npm install Jquery 来下载 Jquery 代码。现在用 Npm 来分享代码已经成了前端的标配。 总结 Npm是Node.js 内置的一套包管理工具，比如Jquery什么的，随着Node的火爆发展，Npm越来越庞大，插件越来越多 怎么理解Npm和Node的关系呢，Node.js相当于qq游戏大厅，Npm就是其中的小游戏； Node.js和Npm的安装 Node.js的安装这里就不再多说了。Npm由于内置在Node.js中，所以就一并安装了。有时候我们只想单独安装Npm，不想安装Node.js，这个好像是不行的。 ","date":"2021-06-29","objectID":"/nodejs-npm-note/:1:1","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"安装和卸载全局包 什么是全局的包:通过Npm install 包名 -g方式安装的包，都安装到了全局;一般全局的安装目录是 C:\\Users\\自己的用户文件夹\\AppDataRoaming\\Npm 带大家演示如何安装一个全局的包：npm install i5ting_toc -g，注意:这里的-g表示全局安装包的意思 注意：一般，只有一些工具，才有全局安装的必要性 如果要全局卸载某个包，比如要卸载i5ting toc了，直接运行’npm uniinstall i5ting_toc -g`就可以全局卸载包了! ","date":"2021-06-29","objectID":"/nodejs-npm-note/:2:0","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"node/npm如何查看安装过的模块或包 ","date":"2021-06-29","objectID":"/nodejs-npm-note/:3:0","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"QuickStart npm ls命令可以查看安装过的模块，这个命令使用的时候要注意是否为全局和注意层数。 查看当前项目的依赖模块如下： npm ls --depth 0 查看全局依赖模块命令如下： npm ls -g --depth 0 ","date":"2021-06-29","objectID":"/nodejs-npm-note/:3:1","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"详细介绍 在命令行输入npm ls，可以查看当前文件夹下安装的模块 这个结果和文件夹下面的node_modules目录是对应的 可以看见，这个文件夹下面的2个子文件夹名字和刚才的输出结果一模一样 但是这个命令会将模块依赖的模块也一并输出出来，最后在一个复杂项目里面的结果会十分庞大 现在我们可以加上 –depth 0，来限制结果的层数 执行 npm ls --depth 0 可以发现复制项目的输出结果也不会太长 加上 -g 可以输出全局模块，也可以和–depth 0并用 执行 npm ls -g --depth 0 试试 ","date":"2021-06-29","objectID":"/nodejs-npm-note/:3:2","tags":["Npm","Vue"],"title":"Npm笔记","uri":"/nodejs-npm-note/"},{"categories":["Software"],"content":"解决idea报错 “cannot access xxx”的解决办法","date":"2021-06-29","objectID":"/idea-cannot-access-xxx/","tags":["Idea","Environment","IDE","Error"],"title":"Idea报错 “cannot access xxx”","uri":"/idea-cannot-access-xxx/"},{"categories":["Software"],"content":"使用IEDA在项目中，偶尔会出现报错“cannot access xxx” 此时，执行IDEA重启，就不报错了，应该是IDEA本身的问题 ","date":"2021-06-29","objectID":"/idea-cannot-access-xxx/:0:0","tags":["Idea","Environment","IDE","Error"],"title":"Idea报错 “cannot access xxx”","uri":"/idea-cannot-access-xxx/"},{"categories":["Operation"],"content":"记录集中Windows环境下使用ADB调试AS虚拟机报错的解决办法","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"启动报错 安卓部分内容不能使用git bash，需要使用windows的控制台，android-tools、adb-shell ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:1:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"缺root权限 Permission denied 需要先使用su进行获取root权限 ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:2:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"su报错 关于/system/bin/sh: su: not found的解决办法（安卓模拟器运行） ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"现象 在了解关于数据库的创建时，无法在android Studio的模拟器运行的条件下运行cmd 窗口下adb shell 命令，adb shell之后su无法转到root权限,导致无法进入data/data/… ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:1","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"原因 Android Studio带(Google Play)的模拟器无法获得root权限安装 该换成为带(Google APIs)的模拟器即可，类似于这种 ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:2","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Software"],"content":"解决一种VM虚拟机Ping不通问题的办法","date":"2021-06-29","objectID":"/vm-ping-error/","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Software"],"content":"问题及解决思路 发现虚拟机可以ping百度，虚拟机可以ping本机，但是本机就是ping不通虚拟机 查阅很多资料了解到这是Win10的Bug，休眠睡眠关闭机盖等操作再启动，虚拟机的网卡gg ","date":"2021-06-29","objectID":"/vm-ping-error/:1:0","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Software"],"content":"解决办法 1、右键任务栏网络图标，单机{打开\"网络和Internet\"设置} 2、找到网络和共享中心，点击进入 3、找到更改适配器设置，点击进入 4、找到你用的VMware虚拟机网卡右键，先禁用 （我的是Nat模式，是VMnet8；桥接模式应该是是VMnet1，没试过请自行验证） 5、禁用完了长这样 6、同样，再右键启用即可 7、你试试，绝对不一定，和我一样的问题，应该可以ping通了。。。 ","date":"2021-06-29","objectID":"/vm-ping-error/:2:0","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Back","note"],"content":"记录Android_Java学习路线的笔记","date":"2021-06-29","objectID":"/android-learn-path-note/","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Java基础 泛型 作用于定义 通配符于嵌套 Rxjava中的泛型 注解 自定义注解与元注解 APT，编译时注解处理器 插桩 反射，运行时动态获取注解信息 Retrofit 并发线程 线程共享与实现实现 CAS原理 Android AsyncTask原理 Java虚拟机 Dalvik虚拟机 CG算法、机制 内存分配策略 Hook技术动态编程 动态代理模式 双亲委托机制 JavaIO体系 IO操作Dex加密 ","date":"2021-06-29","objectID":"/android-learn-path-note/:1:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"数据结构及算法 数据结构 栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） ","date":"2021-06-29","objectID":"/android-learn-path-note/:2:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"算法 分治算法 动态规划 贪心算法 分支限界法 ","date":"2021-06-29","objectID":"/android-learn-path-note/:3:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android基础 Android Activity生命周期 Application生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 ","date":"2021-06-29","objectID":"/android-learn-path-note/:4:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android开发高级 注： Android高级工程师招聘要求： 1.熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 2.有丰富的Android应用架构能力，能够独立主导并架构App； 3.Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多 种开发语言的优先考虑； 4.对Android性能优化，安全，软件加固，自动化测试有深刻认识; 5.博客，开源项目 ","date":"2021-06-29","objectID":"/android-learn-path-note/:5:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android技术难点 AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。 这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 ","date":"2021-06-29","objectID":"/android-learn-path-note/:6:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android框架层源码掌握 Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 ","date":"2021-06-29","objectID":"/android-learn-path-note/:7:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android进程通信以及多进程开发 Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制 Android绘图原理 Android页面恢复 Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState ：当Activity容易被系统销毁时，会触发该方法。具体的说： 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 ","date":"2021-06-29","objectID":"/android-learn-path-note/:8:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"混合开发及Android WebView应用 混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、* WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress ","date":"2021-06-29","objectID":"/android-learn-path-note/:9:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 \u0026 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 ","date":"2021-06-29","objectID":"/android-learn-path-note/:10:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"App启动加载过程 Android虚拟机 Android App运行的沙箱原则 ","date":"2021-06-29","objectID":"/android-learn-path-note/:11:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android架构 在Android源码中最重要的三个类：ActivityManagerService／PackageManagerService／View，推荐大家周末的时候可以去阅读下这部分的源码，阅读源码能提高我们今后设计架构自己代码的能力，同时也能从底层了解整个android系统的运行原理，其他一些比如主线程的消息循环、主线程如何和AMS如何跨进程交互、SystemServer进程中的各种Service的工作方式、AsyncTask的工作原理等。这些知识也是作为一个Android高级开发工程师必须掌握的，不能整天沉溺于ui和四大组件的交互，要站在更高的角度去考虑Android的有些问题。 MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） ","date":"2021-06-29","objectID":"/android-learn-path-note/:12:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"移动开发外围 服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术v：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 ","date":"2021-06-29","objectID":"/android-learn-path-note/:13:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"前端开发相关 前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 ","date":"2021-06-29","objectID":"/android-learn-path-note/:14:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 ","date":"2021-06-29","objectID":"/android-learn-path-note/:15:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Total"],"content":"解决Android runOnUiThread android.os.NetworkOnMainThreadException","date":"2021-06-29","objectID":"/android-runonuithread-error/","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"原因 跑老师的代码的时候报这个错，主要内容是编写Android项目时使用OKHttp3网络请求交互，但是老师向我展示了他的代码在他的机器上的正确性。我的就快乐的报错。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"分析 后面经过一定的相关知识进行学习发现，虚拟机的版本不同，导致了这个问题。同时在同学的低版本虚拟机上得到了验证。具体的版本规约并未查询到。我方进行试验的是AndroidStudio的虚拟机，Android11的是会报错或请求返回的body无法显示到ui上。Android7以下版本的虚拟机是可以正确将请求结果返回到ui界面上的 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:2:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"解决办法 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"不操作Android等ui 这是原来的代码 runOnUiThread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } }); 不使用runOnUiThread，改为一个新线程，并启动他 new Thread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } } }).start(); 就完事了。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:1","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"其他情况 一旦有其他内容需要显示到ui上，需要使用线程之间的通信技术，如Message+Bundle发送，(见我的另一篇博客：点我跳转)Hundle进行接收的办法，或者是同Intent+Bundle进行发送，Hundle进行接收等办法，将数据传输至主线程，主线程将他显示到界面上即可。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:2","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Back"],"content":"解决Android Java中The BC provider no longer provides for KeyPairGenerator.RSA.的错误","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"发生报错 使用网路相关框架时发生报错 java.lang.AssertionError: java.security.NoSuchAlgorithmException: The BC provider no longer provides an implementation for KeyPairGenerator.RSA. Please see https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html for more details. ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:1:0","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"解决方案 在AndroidManifest.xml文件中填写这段代码 仅需在元application添加配置即可，其他结构代码仅为application说明位置 \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.mypackage.mylibrary\"\u003e \u003capplication android:usesCleartextTraffic=\"true\" /\u003e \u003c/manifest\u003e ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:2:0","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Software","note"],"content":"解决Win系统下窗口跑到屏幕外移动不回来解决办法的笔记","date":"2021-06-29","objectID":"/win-window-out-screen/","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":" 在窗口标题栏右键，点击移动，就可以了 如果标题栏看不到就用下面的快捷键办法 ","date":"2021-06-29","objectID":"/win-window-out-screen/:0:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"切换 切换到那个窗口 ","date":"2021-06-29","objectID":"/win-window-out-screen/:1:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"使用快捷键 标题栏右键快捷键为 alt+space，然后按M ","date":"2021-06-29","objectID":"/win-window-out-screen/:2:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"移动 使用键盘上下左右移动即可 ","date":"2021-06-29","objectID":"/win-window-out-screen/:3:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Back"],"content":"Java安卓使用本地ip时报错java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":" java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy java.net.ConnectException: failed to connect to localhost/127.0.0.1 (port 8080) 以上两个错误 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:0:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"现象 android虚拟机中访问电脑本地url失败 当你启动Tomcat后，在浏览器中输入http：//127.0.1.1:8080/xxx.xx，你会发现你可以找打你要找的东西。但是当你在Eclipse或者android虚拟机中访问 会一直报出这样的错误： java.net.ConnectException: failed to connect to /127.0.1.1 (port 8080) ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:1:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"分析 原来模拟器默认把127.0.0.1和localhost当做本身了，在模拟器上可以用10.0.2.2代替127.0.0.1和localhost，另外如果是在局域网环境可以用 192.168.0.x或者192.168.1.x(根据具体配置)连接本机,这样应该就不会报错了。 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"解决方法 设置访问的ip为10.0.2.2（本机的网络ip） ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:3:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Total"],"content":"PrintWriter输出到Web页面中呈现乱码现象解决方案","date":"2021-06-28","objectID":"/java-printwriter-random-code/","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"一般情况只使用下面代码： PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:1:0","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"输出到页面上基本会呈现出乱码现象，解决方案如下： response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html; charset=utf-8\"); PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:2:0","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Back"],"content":"Java Android 子线程弹出Toast报错Can't toast on a thread that has not called Looper.prepare()解决办法","date":"2021-06-28","objectID":"/java-android-thread-toast-error/","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"前言 最近一段时间在忙着开发一款自己的APP，将自己常用的功能需求都加入进入，同时在GitHub上跟着大牛们学习新的技术，提升自己的技能，在开发的过程中不断的发现问题和解决问题。 在开发过程遇到了这样一个问题：Can’t toast on a thread that has not called Looper.prepare()，如果在一个线程中没有调用Looper.prepare(),就不能在该线程中创建Toast。这个问题是因为在子线程中弹出Toast导致的。 Android是不能直接在子线程中弹出Toast的，可是如果我们非要这么做，那该怎么办呢？下面就为大家讲解如何在子线程中弹出Toast，以及一些其他类似的子线程中操作的错误。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中调用Toast 在子线程中弹出Toast，会报错：java.lang.RuntimeException: Can’t toast on a thread that has not called Looper.prepare()。 解决方式：先调用Looper.prepare();再调用Toast.makeText().show();最后再调用Looper.loop(); public class ToastUtils { static Toast toast = null; public static void show(Context context, String text) { try { if(toast!=null){ toast.setText(text); }else{ toast= Toast.makeText(context, text, Toast.LENGTH_SHORT); } toast.show(); } catch (Exception e) { //解决在子线程中调用Toast的异常情况处理 Looper.prepare(); Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); Looper.loop(); } } } ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:2:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中更新UI 在子线程中更新UI，会报错：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 解决方式：在子线程中更新UI，一般使用Handler或者runOnUiThread()或者AsyncTask。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:3:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中创建Handler 在子线程中创建Handler，会报错：java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()。 解决方式： new Thread() { public void run() { Looper.prepare(); new Handler().post(runnable);//在子线程中直接去new 一个handler 　Looper.loop();　//这种情况下，Runnable对象是运行在子线程中的，可以进行联网操作，但是不能更新UI 　} }.start(); ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:4:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"写在最后 以上就是在子线程中更新UI、弹出Toast、创建Handler时会遇到的问题，及解决方式。 如果你在参考过程中遇到问题，可以在我的联系方式中给我提问。 后面会继续介绍，Android的相关知识，欢迎继续关注我博客的更新。 参考资源 在子线程中new Handler报错 Android – Looper.prepare()和Looper.loop() —深入版 Toast和Looper、Handler消息循环机制 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:5:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"运行别人的项目报错一些版本冲突问题的解决办法","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"Error:java: 无效的目标发行版: 11 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:0","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"问题 我们在使用Idea开发中如果遇到你的JDK版本有“无效的目标发行版: 11”冲突时，要修改以下JDK版本 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:1","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"解决 1项目Java版本 2模块Java版本 3 Idea设置中Java编译器对每个模块的版本 三个部分都不能高于 使用的java版本号，否则就报错 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:2","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"JDK版本过高，非法反射 上面第一部分的项目Java版本若过高，其他部分正常会导致下面的报错。处理办法与上面一致，调成Jdk8即可 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:2:0","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"报错信息 D:\\apache-tomcat-7.0.54\\bin\\catalina.batrun [2016-10-1402:26:31,540]Artifactink-balance-web:warexploded:Serverisnotconnected.Deployisnotavailable. Connectedtoserver [2016-10-1402:26:31,562]Artifactink-balance-web:warexploded:Artifactisbeingdeployed,pleasewait... UsingCATALINA_BASE:\"C:\\Users\\mrchen\\.IntelliJIdea2016.1\\system\\tomcat\\Unnamed_ink-parent\" UsingCATALINA_HOME:\"D:\\apache-tomcat-7.0.54\" UsingCATALINA_TMPDIR:\"D:\\apache-tomcat-7.0.54\\temp\" UsingJRE_HOME:\"C:\\Program Files\\Java\\jdk1.7.0_17\" UsingCLASSPATH:\"D:\\apache-tomcat-7.0.54\\bin\\bootstrap.jar;D:\\apache-tomcat-7.0.54\\bin\\tomcat-juli.jar\" 错误:代理抛出异常错误:java.rmi.server.ExportException:Portalreadyinuse:1099;nestedexceptionis:java.net.BindException:Addressalreadyinuse:JVM_Bind Disconnectedfromserver ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:1:0","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"容器启动报错处理方案 （1）：运行 cmd 之后输入 netstat -ano 之后会出现列表，在里面找到错误信息中的端口(这里是1099) （2）：找到这一行后 记下进程号：这里是55512，之后打开任务管理器，进入到详细信息页面，找到pid为55512的进程，选中 点右下角的结束任务即可 （3）、执行完以上步骤再重启容器，容器正常启动了，恭喜！ ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:2:0","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["SoftwareDesign"],"content":"用组合模式、策略模式、观察者模式结合来实现一个MVC","date":"2021-06-28","objectID":"/mvc-design-patterns/","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"1 MVC介绍 众所周知MVC不是设计模式，是一个比设计模式更大一点的模式，称作设计模式不合理，应该说MVC它是一种软件开发架构模式，它包含了很多的设计模式，最为密切是以下三种：Observer (观察者模式), Composite（组合模式）和Strategy（策略模式）。所以说MVC模式又称复合模式。MVC(Model-View-Controller) 模式的基本思想是数据，显示和处理相分离。模型(Model)负责数据管理，视图(View)负责数据显示，控制器(Controller)负责业务逻辑和响应策略。 从MVC的形成过程来看，最初只有模型和视图两个元素。模型封装了数据并提供操作接口，视图用来表现数据和接收用户请求。模型是独立的，而视图依赖于模型：从模型获取数据进行显示；向模型发送用户请求，并根据返回结果刷新自己。 需要用多个视图表现同一模型时，情况发生了变化：一个视图修改数据以后，不但本身要刷新，其他所有视图也要刷新。如果由该视图通知其他视图，它就需要知道其他所有视图，由于每个视图都可能发出修改，每个视图都要知道其他所有视图，这种关联过于复杂，不但难以维护，而且不便于增加新的视图。如果让模型通知所有视图更新，可能会影响模型的独立性。用观察者(Observer)模式 可以解决上述矛盾，从而实现：由模型通知视图，而模型不依赖于具体的视图，具体视图之间相互独立。 视图是用户请求的接收者，但不宜作为请求的处理者。因为界面是易变的，如果业务代码和界面代码放在一起，频繁的界面修改可能会破坏比较稳定的业务代码。将业务逻辑分离出来，由一个控制器负责，就是为了避免这种干扰。 模型，视图和控制器的基本协作关系如下图 模型在状态变化的时候，直接通知所有视图，视图向模型查询状态数据，然后刷新自身。当用户发出操作时，视图把消息发给控制器，控制器按照业务逻辑进行处理，需要查询或更新数据时，控制器会调用模型。下面是一个更详细的示意图 MVC架构把数据处理，程序输入输出控制及数据显示分离开来，并且描述了不同部件的对象间的通信方式。使得软件可维护性，可扩展性，灵活性以及封装性大大提高；MVC(Model-View-Controller)把系统的组成分解为M（模型）、 V（视图）、C（控制器)三种部件。视图表示数据在屏幕上的显示。控制器提供处理过程控制，它在模型和视图之间起连接作用。控制器本身不输出任何信息和做任何处理，它只负责把用户的请求转成针对Model的操作，和调用相应的视图来显示Model处理后的数据。三者之间关系如下图2.1： 图2.1 MVC关系图\r同样的数据，可以有不同的显示和进行各种处理。显示仅仅是表现数据，而处理是根据用户请求改变数据的过程，不但包含业务逻辑，也要提供响应策略。响应策略由控制器负责，视图可以使用不同的控制器提供不同的响应方式，这是策略(Strategy)模式的应用。 此外，MVC还允许视图嵌套，通过使用组合(Composite)模式，一致地处理组合视图和普通视图。 用多个视图表现一个模型，在视图不变的情况下改变响应策略，允许视图嵌套，这是MVC的三个主要特性。在内部结构上，MVC的主要关系是由观察者模式，策略模式和组合模式给出的。由观察者模式确定的模型视图关系是其中最为重要的。 MVC 模式有许多变体。前述结构中，由模型通知视图刷新，称为主动MVC；如果由控制器更新模型以后通知视图，称为被动MVC结构。在许多应用中，没有明显的控制器角色，也没有视图嵌套。可见根据实际需要，构成MVC的三个模式上都可能出现变化。Web浏览器就是被动MVC结构的一个实例。 \" 浏览器是一个交互程序，从概念上讲，它是由一组客户、一组解释器与一个管理它们的控制器所组成。控制器形成了浏览器的中心部件，它解释鼠标点击与键盘输入，并且调用其他组件来执行用户指定的操作。例如，当用户键入一个URL或者点击一个超文本引用时，控制器调用一个客户从所需文档所在的远程服务器上取回该文档，并且调用解释器向用户显示该文档。每个浏览器必须包含一个HTML解释器来显示文档，其他解释器是可选的。HTML解释器的输入由符合HTML语法的文档所组成，输出由位于用户显示器上的格式版本文档所组成。解释器通过将HTML规则转换成适合用户显示硬件的命令来处理版面细节。HTML解释器一个最重要的功能是包含可选项。解释器必须存储关于显示器上位置之间关系的信息和HTML文档中被瞄定的项。当用户用鼠标选定了一个项，浏览器通过当前的光标位置和存储的位置信息来决定哪个项被用户选定。\" ","date":"2021-06-28","objectID":"/mvc-design-patterns/:1:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.为什么要在Web应用中使用MVC架构 用户界面逻辑的更改往往比业务逻辑频繁，尤其是在基于Web的应用程序中。例如，可能添加新的用户界面页，或者可能完全打乱现有的页面布局。对显示的更改，尽可能地不要影响到数据和业务逻辑。 目前大部分Web应用都是将数据代码和表示混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。MVC从根本上强制性的将它们分开。尽管构造MVC应用需要一些额外的工作，但它带来的好处是无庸质疑的。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.1 提高代码重用率 最重要的一点是多个视图能共享一个模型，无论用户想要Flash界面或是 WAP 界面；用一个模型就能处理它们。由于已经将数据和业务规则从表示层分开，所以可以最大化的重用代码。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:1","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.2 提高程序的可维护性 因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变数据层和业务规则 [3]。例如，把数据库从MySQL移植到Oracle，或者把基于RDBMS数据源改变到LDAP，只需改变模型即可。一旦正确的实现了模型，不管数据来自哪里，视图都会正确的显示它们。MVC架构的运用，使得程序的三个部件相互对立，大大提高了程序的可维护性。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:2","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.3 有利于团队开发 在开发过程中，可以更好的分工，更好的协作。有利于开发出高质量的软件。良好的项 目架构设计，将减少编码工作量 ：采用MVC结构 + 代码生成器，是大多数Web应用的理想选择。部分模型(Model)、和存储过程一般可用工具自动生成。控制(Controller)器比较稳定，一般由于架构师（也可能是有经验的人）完成；那么整个项目需要手动编写代码的地方就只有视图(View)了。在这种模式下，个人能力不在特别重要，只要懂点语法基础的人都可以编写，无论项目成员写出什么样的代码，都在项目管理者的可控范围内。即使项目中途换人，也不会有太大问题。在个人能力参差不齐的团队开发中，采用MVC开发是非常理想的。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:3","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3 MVC架构的优点及不足 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3.1 MVC的优点 MVC的优点体现在以下几个方面： （1） 有利于团队开发分工协作和质量控制，降低开发成本。 （2） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。 （3） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。 （4） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。 （5） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:1","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3.2 MVC的缺点 MVC的不足体现在以下几个方面： （1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 （2）视图对模型数据的访问效率低。视图可能需要多次调用Model才能获得足够的显示数据。 （3）完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困难。 MVC 模式可以分解为以下设计模式 在GOF书的 Introduction中，有一小节是\"Design Patterns in Smalltalk MVC\"即介绍在MVC模式里用到的设计模式。它大概向我们传达了这样的信息：合成模式+策略模式+观察者模式约等于MVC模式（当然MVC模式要多一些东西）。也就是说它在大部分情况下是下面几个模式： 1、观察者模式 类图结构在Gof里的表示如下： 2、合成模式 类图结构在Gof里的表示如下： 3、策略模式 类图结构在Gof里的表示如下： 谈 谈 MVC 架构模式中的三个角色 Model （模型端） Mod封装的是数据源和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作这些状态的方法，往往是一系列的公开方法。通过这些公开方法，便可以取得模型端的所有功能。 在这些公开方法中，有些是取值方法，让系统其他部分可以得到模型端的内部状态参数，其他的改值方法则允许外部修改模型端的内部状态。模型端还必须有方法登记视图，以便在模型端的内部状态发生变化时，可以通知视图端。我们可以自己定义一个Subject接口来提供登记和通知视图所需的接口或者继承 Java.util.Observable类，让父类完成这件事。 多个 View( 视图端 ) View封装的是对数据源Model的一种显示。一个模型可以由多个视图，并且可以在需要的时候动态地登记上所需的视图。而一个视图理论上也可以同不同的模型关联起来。 在前言里提到了，MVC模式用到了合成模式，这是因为在视图端里，视图可以嵌套，比如说在一个JFrame组件里面，可以有菜单组件，很多按钮组件等。 多个 Controller( 控制器端 ) 封装的是外界作用于模型的操作。通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法（这个方法就是前面在介绍模型的时候说的改值方法）。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model来更改其状态值。这样 Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。也在前言里提到，MVC用到了策略模式，这是因为View用一个特定的Controller的实例来实现一个特定的响应策略，更换不同的Controller，可以改变View对用户输入的响应。 MVC (Model-View-Controller) : 模型利用\"观察者\"让控制器和视图可以随最新的状态改变而更新。另一方面，视图和控制器则实现了\"策略模式\"。控制器是视图的行为; 视图内部使用\"组合模\"式来管理显示组件。 以下的MVC解释图很好的标示了这种模式： 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。 这些模式携手合作，把MVC模式的三层解耦，这样可以保持设计干净又有弹性。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:2","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["Software"],"content":"Word怎么去掉百度网盘","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/","tags":["Office","Word","Panbaidu"],"title":"Word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Software"],"content":"不知道什么时候Word里面多了一个百度网盘的图标。想去掉，网上也有方法，但是不够细致，基本都是word2010版，我这个是不断更新的最新版，自己倒腾好长时间才解决，仅供大家参考哈。 step1，鼠标选中网盘的图标，右键弹出如图所示对话框，点击自定义功能区即可。 step2，点击加载项，选中选中百度网盘word选项，点击下面的转到即可。 step3，选中可加载项的百度网盘，点击删除，再确定即可。 step4，返回Word，百度网盘的图标消失，大功告成。 祝你愉快！ ","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/:0:0","tags":["Office","Word","Panbaidu"],"title":"Word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Total"],"content":"Error inflating class com.baidu.mapapi.map.MapView关于集成百度地图时的问题","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"快乐报错 Error inflating class com.baidu.mapapi.map.MapView ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:1:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"这个也是百度地图调用过程中的步骤，亦可作为参考 集成百度地图时遇到的问题,纠缠我了半天,网上各种方法都试过了,还是一如既往.最后仔细看了一下开发文档,擦.原来这面出问题了.知道遇到问题的你肯定会很急,闲话不说下面就请看: 看好了啊,如果你的这些都配置好了,见下面这7张图里面的配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:1","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"1.你的app–libs文件夹那个BaiduLBS_Android.jar,有没有放置好 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:2","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"2.app–src–main–jinLibs文件夹有没有放置,并把里面的那几个文件夹复制进去 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:3","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"3.清单文件中百度地图的ak配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:4","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"4.Application的自定义子类有没有在清单文件节点下配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:5","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"5.在自定义的那个Application的onCreate方法中要进行百度地图的初始化 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:6","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"6.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:7","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"7.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:8","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"8.如果上面都配置好了会报那个错误 ,就看看开发文档的这一句话 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:9","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"9（我的问题）模拟器没联网（F*CK） 用虚拟机上的Chrome无法上网 解决办法见我的另一篇文章：Android studio模拟器无法联网问题解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:10","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"Android studio模拟器无法联网问题解决办法","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect-error/","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio 模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect-error/"},{"categories":["Total"],"content":"出现问题 重装系统后安装了Android studio 4.2.1，记得之前用模拟器联网的时候都是直接在模拟器内部打开网络连接就好，现在不行了，不知道之前怎么操作就能联网，反正当时一点都不纠结。 查阅了网上很多解决方法，结果都调试不通。 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect-error/:1:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio 模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect-error/"},{"categories":["Total"],"content":"解决办法 只有用一个蠢办法，虽然只管一次，模拟器或者cmd一关下次打开就必须这个操作，但是为了官方模拟器的颜值和操作速度，我忍了…. 先配置了一个环境变量，避免每次从cmd中输入指令都要 cd 进入emulator文件夹 C:\\Users\\User(注意换成自己的电脑用户名)\\AppData\\Local\\Android\\Sdk\\emulator 模拟器联网：cmd中输入如下 emulator -avd Pixel_2_API_30 -dns-server 8.8.8.8,114.114.114.114 Pixel_2_API_30 是我的使用的模拟器 备注：模拟器调试快捷 Ctrl+M ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect-error/:2:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio 模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect-error/"},{"categories":["Total"],"content":"闲聊 曾经折腾黑苹果、VM的MacOS虚拟机，MacOS虚拟机也得配置DNS不然无法联网，不懂底层机制，求大佬赐教 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect-error/:3:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio 模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect-error/"},{"categories":["Learning","note"],"content":"记录回溯算法相关的笔记","date":"2021-06-04","objectID":"/backtracking-note/","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":" 通俗的讲，回溯法约等于递归里面嵌套for循环 ","date":"2021-06-04","objectID":"/backtracking-note/:0:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法问题类型 组合类 数组子数列 切割类 回文子串 子集类 类似组合 排列类 有序的组合 棋盘类 n皇后 ","date":"2021-06-04","objectID":"/backtracking-note/:1:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"问题解决思路 将回溯问题抽象为一棵n叉树，水平方向（广度）的循环使用for循环来解决，垂直方向（深度）的循环使用递归来解决 ","date":"2021-06-04","objectID":"/backtracking-note/:2:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"伪代码 void backTracking(args){ if(termination)//终止条件 collect result;//收集结果 return result;//返回结果 } for(each item in Set){//集合元素 processing node;//处理节点 recurrence function;//递归函数 backTrack operation;//回溯操作 } return final result;//返回最终结果 ","date":"2021-06-04","objectID":"/backtracking-note/:3:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法基本步骤 递归参数返回值 确定终止条件 单层递归逻辑 ","date":"2021-06-04","objectID":"/backtracking-note/:4:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Operation"],"content":"之前编辑文件卡住，再次Vim查看文件报错","date":"2021-06-01","objectID":"/vim-again-swap-error/","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"发现问题 之前使用xshell编辑文件时xshell卡住，无奈关闭xshell标签重新来过，再次vim查看文件报错 E325: ATTENTION Found a swap file by the name \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" owned by: root dated: Tue Jun 1 09:24:28 2021 file name: /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml modified: YES user name: root host name: 111.47.28.118 process ID: 10535 (still running) While opening file \"/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" dated: Thu Apr 8 01:26:02 2021 (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \":recover\" or \"vim -r /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" to recover the changes (see \":help recovery\"). If you did this already, delete the swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" to avoid this message. Swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" already exists! [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: ","date":"2021-06-01","objectID":"/vim-again-swap-error/:1:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决思路 这是由于之前我的编辑这个文件的时候卡顿了，所以在交换区产生了文件，并没有对源文件覆盖， 我修改的东西是按照文档改的，而且并没有很多，于是就把交换区的文件删除了就拉到，要是修改了很多建议看一下对比一下两个文件的区别，在觉得删除或是剪切过来继续用都行，剪切过来记得改名字就行 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:2:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决办法 删除指令 rm /var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp 在编辑就没有报错了 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:3:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"反思 Linux文件修改机制，先再交换区创建副本，进行编辑，执行保存的化就从暂存区把文件弄过来。一旦出现了问题，改变了的文件和源文件都在便于运维人员进行容错管理文件。 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:4:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Learning","note"],"content":"记录动态规划三种题型的笔记","date":"2021-05-29","objectID":"/dynamic-program/","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":" 动态规划满足最优化原理和无后效性 ","date":"2021-05-29","objectID":"/dynamic-program/:0:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划三种题型 ","date":"2021-05-29","objectID":"/dynamic-program/:1:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"1.计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic-program/:1:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"2.求最大最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 ","date":"2021-05-29","objectID":"/dynamic-program/:1:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"3.求存在性 取石子游戏,先手是否必胜 能不能选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic-program/:1:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划四个组成部分 ","date":"2021-05-29","objectID":"/dynamic-program/:2:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"1.确定状态 状态在动态规划中的作用属于定海神针 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么 类似于解数学题中，X，Y，Z代表什么 确定状态需要两个意识: 最后一步 保证最后一个问题减小规模问题不变，且结论不矛盾 子问题：问题一样，规模变小 研究最优策略的最后一步化为子问题 ","date":"2021-05-29","objectID":"/dynamic-program/:2:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"2.转移方程 根据子问题直接得到 ","date":"2021-05-29","objectID":"/dynamic-program/:2:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"3.初始条件和边界条件 不重不漏（易说不易做 ） ","date":"2021-05-29","objectID":"/dynamic-program/:2:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"4.计算顺序 自顶向下或自底向上，整体思路的体现，即能利用之前的结果进行计算，去掉重复计算的步骤 神奇的注意点（动规五部曲） dp数组以及下标的含义？二维一维数组中的i、j是什么意思 递推公式，不言而喻 dp数组的初始化 遍历顺序（0/1背包问题为什么要先遍历背包后遍历物品，反过来是否可以；完全背包问题排列和组合for循环不同） 打印dp数组，用于debug，清晰思路 ","date":"2021-05-29","objectID":"/dynamic-program/:2:4","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划基本类型 坐标型：dp数组下标为原来坐标，代表题型UniquePath 序列型：dp数组下标为前i个，错开一个 划分型：划分数组，每组满足一定性质 区间型：用f[i][j]解决 背包型：各种背包装载问题（区间） 最长子序列型：dp数组下标为原来坐标，代表题型最长上升子序列 博弈型：计算必胜或必败 综合型：综合前面两种（如区间+博弈、动态+划分）或动态和其他算法（如动态+二分查找、动态+子母树 ） ","date":"2021-05-29","objectID":"/dynamic-program/:3:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划时间空间优化 Follow Up常考 滚动数组 降维 ","date":"2021-05-29","objectID":"/dynamic-program/:4:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划打印路径（解） ","date":"2021-05-29","objectID":"/dynamic-program/:5:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划基本题型 动归基础 斐波那契额数列 爬楼梯问题 背包问题 打家劫舍 树形dp（leetcode就三道题） 股票问题 买卖时间最大利润 子序列问题 最长子序列 最长连续递增子序列 编辑距离问题，两个字符串，最小编辑数使字符串相等。 ","date":"2021-05-29","objectID":"/dynamic-program/:6:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"拔尖类型题目，与我无关：区间dp、概率dp、 ","date":"2021-05-29","objectID":"/dynamic-program/:6:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Total"],"content":"Android Studio 使用Device File Explorer管理安卓虚拟设备的文件","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":" Android Studio 使用Device File Explorer管理安卓虚拟设备的文件 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:0:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Android Device Monitor 新版的Android Studio已经把Android Device Monitor移除菜单栏了，如果要查看虚拟设备的内部文件，需要在AndroidSDK的安装目录中，右键以管理员身份打开tools文件夹中的monitor.bat。 这样做不太方便。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:1:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Device File Explorer 有两种方式可以打开Device File Explorer 直接点击界面右下角的Device File Explorer 在菜单栏，选择 View–\u003eTool Windows–\u003eDevice File Explorer，即可打开查看虚拟设备内部文件的界面。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:2:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导出文件 在Device File Explorer中，如果想将设备中的文件导出到电脑本地。 选中文件–\u003e右键选择“Save as”（快捷键 ctrl+shift+s），弹出如下界面，选择任意文件夹保存即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:3:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导入文件 选中虚拟设备中的文件夹，右键Upload 选择想要导入的文件，点击OK，即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:4:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"其他支持 使用Device File Explorer非常方便，还支持其他新建文件、文件夹、删除等操作。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:5:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Back","note"],"content":"记录Java开发过程中的一些笔记","date":"2021-05-25","objectID":"/java-note/","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Oracle Java 下载JDK账号 目前在官网下载低于jdk1.8的Java jdk的时候需要登陆，这边分享一个账号，方便下载 账号：2696671285@qq.com 密码：Oracle123 ","date":"2021-05-25","objectID":"/java-note/:1:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java获取系统时间 import java.util.Date; import java.text.SimpleDateFormat; public class NowString { public static void main(String[] args) { SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 System.out.println(df.format(new Date()));// new Date()为获取当前系统时间 //--------------------- Date date = new Date(); Timestamp nousedate = new Timestamp(date.getTime()); } } ","date":"2021-05-25","objectID":"/java-note/:2:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"整理一 这里的一片文章，我个人认为讲解的很详细，有对 java.sql.Date的使用还有困惑的请看。 java.sql.Date 只存储日期数据不存储时间数据 // 会丢失时间数据 preparedStatement.setDate(1, new java.sql.Date(date.getTime())); //可以这样来处理 preparedStatement.setTimestamp(1, new java.sql.Timestamp(new java.util.Date().getTime())); //想要得到完整的数据，包括日期和时间，可以这样 java.util.Date d = resultSet.getTimestamp(1); //这样处理更合适一些，可以避免一些潜在Timestamp 问题 java.util.Date d = new java.util.Date(resultSet.getTimestamp(1).getTime()); 自己补的话： 往数据库存储的时候可以接收 java.util.Date类型 再用getTime()方法得到代表那个Date对象的long值，再以这个long值 构造一个Timestamp对象 存进数据库中。 从存数据库里取的时候，可以先得到Timestamp用他的getTime()方法得到long值，再以这个long值构造一个 java.util.Date对象，这样就可以对这个Date对象操作了。不如说 new SimpleTimeFormat(“yyyyy-MM-dd HH:mm:ss”).format()等等 ","date":"2021-05-25","objectID":"/java-note/:2:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"整理二 用Timestamp来记录日期时间还是很方便的，但有时候显示的时候是不需要小数位后面的毫秒的，这样就需要在转换为String时重新定义格式。 Timestamp转化为String: SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //定义格式，不显示毫秒 Timestamp now = new Timestamp(System.currentTimeMillis()); //获取系统当前时间 String str = df.format(now); String转化为Timestamp: SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = df.format(new Date()); Timestamp ts = Timestamp.valueOf(time); ","date":"2021-05-25","objectID":"/java-note/:2:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"整理三 在 ResultSet中我们经常使用的setDate或getDate的数据类型是java.sql.Date，而在平时java程序中我们一般习惯使用 java.util.Date。因此在DAO层我们经常会碰到这俩种数据类型的相互转换，经过了一个下午的折腾，鄙人对两者的转换方法做出了小小总结，希望大家不吝指教。 两者的关系 java.lang.Object | +---java.util.Date | +----java.sql.Date 从这个图中我们可以知道java.sql.Date是从java.util.Date继承过来的。 相互转换 使用getTime()函数 这两个类都提供了getTime()函数，用于返回对应的毫秒数（long类型）。利用这个函数可以实现转换： java.util.Date utilDate = new java.util.Date(sqlDate.getTime()); // sql -\u003e util java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime()); // util -\u003e sql 使用SimpleDateFormat类实现转换 SimpleDateFormat 是一个以国别敏感的方式格式化和分析数据的具体类。 它允许格式化 (date -\u003e text)、语法分析和标准化。 (text -\u003e date) SimpleDateFormat dateFormat = new SimpleDateFormate(\"yyyy-MM-dd HH:mm:ss\"); java.util.Date utilDate = dateFormat.parse(sqlDate.toString()); (date -\u003e text) SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\"); //Date指定格式：yyyy-MM-dd HH:mm:ss:SSS Date date = new Date();//创建一个date对象保存当前时间 String dateStr = simpleDateFormat.format(date);//format()方法将Date转换成指定格式的String 直接转换 由于java.sql.Date是从java.util.Date中继承过来的，所以可以直接用： utilDate = sqlDate; 另类获得日期的方法： SimpleDateFormat sy=new SimpleDateFormat(\"yyyy\"); SimpleDateFormat sm=new SimpleDateFormat(\"MM\"); SimpleDateFormat sd=new SimpleDateFormat(\"dd\"); String syear=sy.format(date); String smon=sm.format(date); String sday=sd.format(date); ps： java.util.Date类中的getYear()要加上1900才可得到实际值，getMonth()则要加上1 ","date":"2021-05-25","objectID":"/java-note/:2:3","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"java获取当前时间戳的方法 ","date":"2021-05-25","objectID":"/java-note/:3:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"获取当前时间戳 //方法 一 System.currentTimeMillis(); //方法 二 Calendar.getInstance().getTimeInMillis(); //方法 三 new Date().getTime(); ","date":"2021-05-25","objectID":"/java-note/:3:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"获取当前时间 SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 获取时间戳三种方法执行效率比较： import java.util.Calendar; import java.util.Date; public class TimeTest { private static long _TEN_THOUSAND=10000; public static void main(String[] args) { long times=1000*_TEN_THOUSAND; long t1=System.currentTimeMillis(); testSystem(times); long t2=System.currentTimeMillis(); System.out.println(t2-t1); testCalander(times); long t3=System.currentTimeMillis(); System.out.println(t3-t2); testDate(times); long t4=System.currentTimeMillis(); System.out.println(t4-t3); } public static void testSystem(long times){//use 188 for(int i=0;i\u003ctimes;i++){ long currentTime=System.currentTimeMillis(); } } public static void testCalander(long times){//use 6299 for(int i=0;i\u003ctimes;i++){ long currentTime=Calendar.getInstance().getTimeInMillis(); } } public static void testDate(long times){ for(int i=0;i\u003ctimes;i++){ long currentTime=new Date().getTime(); } } } 执行结果： 133 2372 137 Calendar.getInstance().getTimeInMillis() 这种方式速度最慢，这是因为Canlendar要处理时区问题会耗费较多的时间。 ","date":"2021-05-25","objectID":"/java-note/:3:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java中的\u003c\u003c 和 \u003e\u003e 和 \u003e\u003e\u003e 详细分析 ","date":"2021-05-25","objectID":"/java-note/:4:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"\u003c\u003c表示左移移，不分正负数，低位补0；　 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 \u003c\u003c 2 　20的二进制补码：0001 0100 　向左移动两位后：0101 0000 　结果：r = 80 负数：r = -20 \u003c\u003c 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制原码 ：1110 1011 　-20 的二进制补码 ：1110 1100 　左移两位后的补码：1011 0000 　反码：1010 1111 　原码：1101 0000 　结果：r = -80 ","date":"2021-05-25","objectID":"/java-note/:4:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"\u003e\u003e表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 \u003e\u003e 2 　20的二进制补码：0001 0100 　向右移动两位后：0000 0101 　结果：r = 5 负数：r = -20 \u003e\u003e 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制反码 ：1110 1011 　-20 的二进制补码 ：1110 1100 　右移两位后的补码：1111 1011 　反码：1111 1010 　原码：1000 0101 　结果：r = -5 ","date":"2021-05-25","objectID":"/java-note/:4:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"\u003e\u003e\u003e表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数：　r = 20 \u003e\u003e\u003e 2 　的结果与 r = 20 \u003e\u003e 2 相同； 负数：　r = -20 \u003e\u003e\u003e 2 注：以下数据类型默认为int 32位 　-20:源码：10000000 00000000 00000000 00010100 　反码：11111111 11111111 11111111 11101011 　补码：11111111 11111111 11111111 11101100 　右移：00111111 11111111 11111111 11111011 　结果：r = 1073741819 ","date":"2021-05-25","objectID":"/java-note/:4:3","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"操作系统控制台中查看Java进程 ","date":"2021-05-25","objectID":"/java-note/:5:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"一、Linux篇 方法一 ps -ef|grep java 方法二 jps -l （显示java进程的Id和软件名称） jps -lmv（显示java进程的Id和软件名称；显示启动main输入参数；虚拟机参数） ","date":"2021-05-25","objectID":"/java-note/:5:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"二、Windows篇 jps jps -l（显示java进程的Id和软件路径及名称） ","date":"2021-05-25","objectID":"/java-note/:5:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java this()与super()使用详解 这几天看到类在继承时会用到this和super，这里就做了一点总结，与各位共同交流，有错误请各位指正~ this this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种： 1.普通的直接引用 这种就不用讲了，this相当于是指向当前对象本身。 2.形参与成员名字重名，用this来区分： class Person { private int age =10; public Person(){ System.out.println(\"初始化年龄：\"+age); } public int GetAge(int age){ this.age = age; return this.age; } } public class test1 { public static void main(String[] args) { Person Harry =new Person(); System.out.println(\"Harry's age is \"+Harry.GetAge(12)); } } 运行结果： 初始化年龄：10 Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 3.引用构造函数 这个和super放在一起讲，见下面。 super super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super也有三种用法： 1.普通的直接引用 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名 class Country { String name; void value() { name =\"China\"; } } class Cityextends Country { String name; void value() { name =\"Shanghai\"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); } public static void main(String[] args) { City c=new City(); c.value(); } } 运行结果： Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 3.引用构造函数 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 class Person { public static void prt(String s) { System.out.println(s); } Person() { prt(\"父类·无参数构造方法： \"+\"A Person.\"); }//构造方法(1) Person(String name) { prt(\"父类·含一个参数的构造方法： \"+\"A person's name is \" + name); }//构造方法(2) } public class Chineseextends Person { Chinese() { super();// 调用父类构造方法（1） prt(\"子类·调用父类”无参数构造方法“： \"+\"A chinese coder.\"); } Chinese(String name) { super(name);// 调用父类具有相同形参的构造方法（2） prt(\"子类·调用父类”含一个参数的构造方法“： \"+\"his name is \" + name); } Chinese(String name,int age) { this(name);// 调用具有相同形参的构造方法（3） prt(\"子类：调用子类具有相同形参的构造方法：his age is \" + age); } public static void main(String[] args) { Chinese cn =new Chinese(); cn =new Chinese(\"codersai\"); cn =new Chinese(\"codersai\",18); } } 运行结果： 父类·无参数构造方法： A Person. 子类·调用父类”无参数构造方法“： A chinese coder. 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 BigDecimal b = new BigDecimal(9.655 ); //double f1 = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); double f1 = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(\"f1=\" + f1);//f1=9.65 BigDecimal mData = new BigDecimal(\"9.655\").setScale(2, BigDecimal.ROUND_HALF_UP); System.out.println(\"mData=\" + mData);//mData=9.66 注： 此构造方法的结果有一定的不可预知性。有人可能认为在 Java 中写入 new BigDecimal(0.1) 所创建的 BigDecimal 正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于 0.1000000000000000055511151231257827021181583404541015625。这是因为 0.1 无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入 到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 另一方面，String 构造方法是完全可预知的：写入 new BigDecimal(\"0.1\") 将创建一个 BigDecimal，它正好 等于预期的 0.1。因此，比较而言，通常建议优先使用String` 构造方法。 当 double 必须用作 BigDecimal 的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用 Double.toString(double)方法，然后使用 BigDecimal(String) 构造方法，将 double 转换为 String。要获取该结果，请使用 static valueOf(double) 方法。 ","date":"2021-05-25","objectID":"/java-note/:6:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java中native关键字的详解 这几天看java的源代码时多次见到方法前有个native关键字，而且凡是有这个关键字修饰的方法都没有方法体，只是一个方法的声明。很是疑惑，于是上网查了一下，现总结如下。 ","date":"2021-05-25","objectID":"/java-note/:7:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"NO.1 ​ native用在类的method前面，表示这个method不是用java实现的。 ","date":"2021-05-25","objectID":"/java-note/:7:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"*NO.*2 java语言是运行在虚拟机上的， java又是不允许直接访问硬件的，（也就是java安全性的体现） 而java想要做一些例如绘图、画线之类的要去操作硬件的事情的话， 必然要用到底层一些的调用。 这就引出了native的关键字！ native是一个用来修饰方法的关键字！ 用它修饰的方法，在虚拟机里都有一个与这个java方法同名的函数， 去做java想要做的事情！ 也就是说： 调用到native修饰的方法， 其实就是调用虚拟机里的一个同名方法去做要做的事！ 这也就是为什么native方法都没有方法体的原因！ 例如Graphics类里有一个drawRect的方法。 它的定义就是： public native void drawRect(int x, int y, int width, int height); 调用到它的时候，就是告诉虚拟机， 我要画一个根据x,y,width,height这些参数定义的矩形！ 而实际起到作用去画这个矩形的， 是虚拟机里的一个名为XXXX_XXXX_drawRect的C函数 XXX使这个函数的打包路径，和import中的XXX.XXX差不多！ 简单说： 其实java根本什么也没做， 做的只是一些面向对象的定义（但这些定义也够复杂） 而“干实事”的都一些虚拟机里的那些用C写成的函数！ ","date":"2021-05-25","objectID":"/java-note/:7:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"NO.3 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。 ","date":"2021-05-25","objectID":"/java-note/:7:3","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"NO.4 native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。 ","date":"2021-05-25","objectID":"/java-note/:7:4","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"NO.5 java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了 ","date":"2021-05-25","objectID":"/java-note/:7:5","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"try…catch(多个异常) 多个异常采取同样的解决措施 ","date":"2021-05-25","objectID":"/java-note/:8:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"示例 class Demo { /** * @param args */ public static void main(String[] args) { try { int a = 1 / 0;// 除以0 } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) { // 多个异常见用 | 隔开 // 多个异常必须是平级关系 System.out.println(\"发生了ArithmeticException 或者 ArrayIndexOutOfBoundsException 异常\"); } try { int[] a = {1, 2}; System.out.println(a[3]); // 越界 } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) { // 出现多个异常,采取同样的处理措施 // 多个异常见用 | 隔开 // 多个异常必须是平级关系 System.out.println(\"发生了ArithmeticException 或者 ArrayIndexOutOfBoundsException 异常\"); } } } ","date":"2021-05-25","objectID":"/java-note/:8:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"result 发生了ArithmeticException 或者 ArrayIndexOutOfBoundsException 异常 发生了ArithmeticException 或者 ArrayIndexOutOfBoundsException 异常 ","date":"2021-05-25","objectID":"/java-note/:8:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"java-jar 带环境变量(参数)启动 ","date":"2021-05-25","objectID":"/java-note/:9:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"需求 java工程我们可以编译成jar也可以翻译成war，一般地，war包我会丢到tomcat容器里，启动tomcat来访问服务，端口、SSL证书、日志等等，都托给tomcat。 如果打的是jar包，我通常会用nohup启动，比如生产环境的一些db、redis、第三方secret等不会配置到项目里，今天要记录的便是用nohup java -jar 启动jar包时如何加载环境变量配置的问题。 java语言开发的jar包启动时可以按照如下方式加启动参数。 方式一：-DpropName=propValue 这种方式应该很快都能找到 -DpropName=propValue 比如： java -jar -DdatabaseUrl=\"mysql://localhost:3306/pdb?user=root\u0026password=root\" -Dapp.key=\"123\" -Dapp.secret=\"xxx\" demo.jar 多个参数也可以。 方式二：参数直接跟在命令后面，多个参数之间用空格隔开 java -jar demo.jar JOURNAL_TREENODE_DATA-20190404174502.txt processType=1 这种方式参数就是jar包里主启动类中main方法的args参数，按顺序来 方式三：使用springboot的方式，–propName=propValue方式 java -jar demo.jar --spring.profiles.active=dev --server.port=8181 注意： 运行jar包时指定端口：java -jar xxx.jar –server.port=8088 若命令行传入的server.port没有作用，服务仍然使用8081端口启动，原因是spring-cloud-config会覆盖命令行传入的参数，这是有意为之， 办法是在web-prod.yml中做点小改动，让“配置”变得“可配置”：加一对花括符 server.port={port:8081} ","date":"2021-05-25","objectID":"/java-note/:9:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"用clojure开发的jar里有惊喜 在clojure上面的配置就变得诡异了，猜猜下面的配置能不能生效呢？ java -jar -Ddatabase-url=\"mysql://localhost:3306/pdb?user=root\u0026password=root\" -Dapp.key=\"123\" -Dapp.secret=\"xxx\" demo.jar 如果你用cider-conect通过nrepl的端口连接上你的服务，你会发现，这个配置导致database-url的值确实已经改了，但是后面两个没有。 究其原因，我们java从classpath里获取参数使用的是properties形式的，也就是json的格式。这不难理解，spring有它的办法，clojure当然也有自己的方式。 \"app\": { \"key\": \"123\", \"secret\":\"xxx\" } 虽然json和我们的edn里map是很像的，但是毕竟是不同，于是要分析下现在的edn里的配置信息他是怎么读取的呢？ 代码里的env 在config这个namespace里找到了env (defstate env :start (load-config :merge [(args) (source/from-system-props) (source/from-env)])) cprop加载配置 cprop.source这个文件就是用来加载edn文件的 (defn-env-\u003epath[k](k-\u003epathk\"_\"#\"__\"))(defnread-system-env([](read-system-env{}))([opts](-\u003e\u003e(System/getenv)(map(fn [[kv]][(env-\u003epathk)(str-\u003evaluevopts)]))(into{})))) 从获取的过程看，应该是会把_做为单元节点断开，因此需要改成这样 java -jar -Ddatabase-url=\"mysql://localhost:3306/pdb?user=root\u0026password=root\" -Dapp_key=\"123\" -Dapp_secret=\"xxx\" demo.jar 对应到edn里应该是 {:app {:key \"123\" :secret \"xxx\"}} 如果仔细看看cprop这个库就不难理解了。 cprop加载配置文件的顺序是 : By default cprop will merge all configurations it can find in the following order: classpath resource config file on a file system (pointed by a conf system property or by (load-config :file )) custom configurations, maps from various sources, etc. System properties ENV variables 对于ENV的加载也有明确说明 ENV variables lack structure. The only way to mimic the structure is via use of an underscore character. The _ is converted to - by cprop, so instead, to identify nesting, two underscores can be used. 了解更多详情，请阅读cprop介绍 ","date":"2021-05-25","objectID":"/java-note/:9:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java -Djava.ext.dirs启动的坑 ","date":"2021-05-25","objectID":"/java-note/:10:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"java以jar包形式启动启动 ","date":"2021-05-25","objectID":"/java-note/:11:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"-Djava.ext.dirs=lib的作用 以bat形式启动项目，linux环境需要改变语法 java -Djava.ext.dirs=d:\\libs -classpath classes com.xxxclass 或者 设置环境变量 set lib = d:\\libs java -Djava.ext.dirs=%lib% -classpath classes com.xxxclass java命令引入jar时可以-cp参数，但-cp只能指定一个固定jar包，不能用通配符(多个jar时要一个个写,不能*.jar)，通常情况jar都在同一目录，且多于1个。可以使用-Djava.ext.dirs。 ","date":"2021-05-25","objectID":"/java-note/:11:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"下面来说说-Djava.ext.dirs的坑 -Djava.ext.dirs是通过设置系统属性的方式也加载jar包的，这个级别就有点高，和-classpath的区别在于-Djava.ext.dirs会覆盖Java本身的ext设置，java.ext.dirs指定的目录由ExtClassLoader加载器加载，如果您的程序没有指定该系统属性（-Djava.ext.dirs=d:\\libs）那么该加载器默认加载$JAVA_HOME/lib/ext目录下的所有jar文件。但如果你手动指定系统属性且忘了把$JAVA_HOME/lib/ext路径给加上，那么ExtClassLoader不会去加载$JAVA_HOME/lib/ext下面的jar文件，这意味着你将失去一些功能，例如java自带的加解密算法实现。 具体说是jre的ext目录：C:\\Program Files\\Java\\jdk1.8.0_45。一般情况下普通程序运行并无差异，因为可以看到ext目录下也就几个jar，但是如果使用java.security相关类时，也就是使用加密解决相关的算法，就会发现-Djava.ext.dirs会导致library找不到相关类而报错。如报错： NoSuchAlgorithmException: Cannot find any provider supporting RSA 这个错误当然也有可能是security\\java.security文件中配置错误引起 。 当然也有解决方法： 1、将ext下相关jar包复制到新的ext director。 2、在-D.java.ext.dirs中配置多个目录。可以使用冒号分隔（windows下使用分号）。 比如：-Djava.ext.dirs=-Djava.ext.dirs=“libs;%JAVA_HOME%\\jre\\lib\\ext”。 ","date":"2021-05-25","objectID":"/java-note/:11:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java8函数作为参数 创建Function有多种方式 public class FunctionParams { public static void main(String[] args) { Function\u003cString,String\u003e f01=(password)-\u003e Base64.getEncoder().encodeToString(password.getBytes()); // 输出加密后的字符串 System.out.println(f01.apply(\"123456\")); //-------------------------------------------------------- System.out.println(addApi(1,FunctionParams::add1)); System.out.println(addApi(1,FunctionParams::add2)); } private static String add1(int n) { return String.valueOf(n + 1); } private static String add2(int n) { return String.valueOf(n + 2); } public static String addApi(int n, Function\u003cInteger, String\u003e add) { return add.apply(n); } } ","date":"2021-05-25","objectID":"/java-note/:12:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"@FunctionalInterface的使用 ","date":"2021-05-25","objectID":"/java-note/:13:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"一.使用规则 1.必须注解在接口上 2.被注解的接口有且只有一个抽象方法 3.被注解的接口可以有默认方法/静态方法，或者重写Object的方法 ","date":"2021-05-25","objectID":"/java-note/:13:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"二.使用方法 除了可以和普通接口一样写Impl之外，还可通过Lambda表达式进行构造，而不用写Impl class。 输出结果： ","date":"2021-05-25","objectID":"/java-note/:13:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"三.使用场景 用于某一特定的场景，但是有不同的处理逻辑的时候，比如导入数据，导入是共性，但是处理逻辑都不同。然鹅感觉用处不是很大。 ","date":"2021-05-25","objectID":"/java-note/:13:3","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java中反斜杠转义问题 ","date":"2021-05-25","objectID":"/java-note/:14:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"1.符串中反斜杠 反斜杠（\\）在JAVA中有特别的意义；它和紧跟着它的那个字符构成转义字符，如\"\\n\"（表示换行）\" \\’ “（表示字符[ ’ ]）等，所以在字符串中要表示反斜杠 \\ 要用” \\ “来表示。例如这样定义一个字符串String s = “name\\sex\"是错误的，要这样定义String s = “name\\sex” 如下定义一个非法的字符串，会报错 String regx = \"women\\halou\"; System.out.print(regx); 输出： Error:(17, 30) java: 非法转义符 如下定义一个正确的字符串 String regx = \"women\\\\halou\"; System.out.print(regx); 输出： women\\halou Process finished with exit code 0 ","date":"2021-05-25","objectID":"/java-note/:14:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"2. 正则表达式中反斜杠 在正则表达式中的“\\”和后面紧跟着的那个字符构成一个转义字符，代表着特殊的意义；所以如果你要在正则表达式中表示一个反斜杠\\，应当写成“\\\\”。 下面匹配A\\ String regx = \"\\u0041\\\\\\\\\"; Pattern p = Pattern.compile(regx); Matcher m = p.matcher(\"A\\\\\\\\b\"); while(m.find()){ System.out.println(m.group()); } 输出： D:\\ProgramFiles\\eclipse\\eclipse\\JDK\\bin\\java.exe... A\\ Process finished with exit code 0 下面匹配电话号码 String regx = \"\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\"; Pattern p = Pattern.compile(regx); Matcher m = p.matcher(\"小明的电话号码为：0563-4667722，小方的电话为：0555-7777777\"); while(m.find()){ System.out.println(m.group()); } 输出： 0563-4667722 0555-7777777 Process finished with exit code 0 ","date":"2021-05-25","objectID":"/java-note/:14:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"时间格式统一 ","date":"2021-05-25","objectID":"/java-note/:15:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"需求 最近接了一个需求，解析别人从Kafka获取的信息，其中的时间格式乱七八糟，无论怎么改后台都各种报错 他的格式中部分格式使用T作为日期和时间的分隔符，有的用空格；日期部分有的用斜杠作为分隔符，有的用横杠作为分隔符，这其实两句replace就解决了，最致命的是，他的日期时间一位数，没有补0，比如2021年1月1日1点1分1秒为2021-1-1T1:1:1，这就会导致格式化日期信息报错。于是乎，就有了下面的解决办法。 ","date":"2021-05-25","objectID":"/java-note/:15:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"知识介绍 我使用的是org.apache.commons.lang3的StringUtils 方法如下： public static String leftPadTime(Integer time){ return StringUtils.leftPad(String.valueOf(time), 2, \"0\"); } 左侧填充： leftPad() StringUtils.leftPad(String str,int size); StringUtils.leftPad(String str,int size,String padStr); 右侧填充： rightPad() StringUtils.rightPad(String str,int size); StringUtils.rightPad(String str,int size,String padStr); 中间填充： center() StringUtils.center(String str, int size); StringUtils.center(String str, int size, String padString); 例： StringUtils.center(\"abcdef\", 20)； 返回结果(左右各7个空格):abcdef StringUtils.center(\"abcdef\", 20,\"*_\"); 返回结果：*_*_*_abcdef*_*_*_*_ StringUtils.leftPad(\"abc\", 10, \"*\"); 返回结果：*******abc ","date":"2021-05-25","objectID":"/java-note/:15:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"我的工具类 /** * 给带T的日期补0，如2021-1-2T1:1:2-\u003e2021-01-02T01:01:02 * @param timeS * @return */ public static String dataStrAdd0(String timeS){ StringBuffer res = new StringBuffer(); String[] ts = timeS.split(\"T\"); //日期 List\u003cString\u003e data = Arrays.asList(ts[0].split(\"-\")); //时间 List\u003cString\u003e time = Arrays.asList(ts[1].split(\":\")); data.forEach(t-\u003e{ res.append(StringUtils.leftPad(t,2,\"0\")); res.append(\"-\"); }); res.deleteCharAt(res.length()-1); res.append(\"T\"); time.forEach(t-\u003e{ res.append(StringUtils.leftPad(t,2,\"0\")); res.append(\":\"); }); res.deleteCharAt(res.length()-1); return res.toString(); } ","date":"2021-05-25","objectID":"/java-note/:15:3","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Windows 10 配置Java 环境变量 ","date":"2021-05-25","objectID":"/java-note/:16:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"下载 JDK 下载地址 点击下载按钮： 开始安装JDK： 可以设置为你想安装的路径。 ","date":"2021-05-25","objectID":"/java-note/:16:1","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"环境变量配置 1. 打开 环境变量窗口 右键 This PC(此电脑) -\u003e Properties（属性） -\u003e Advanced system settings（高级系统设置） -\u003e Environment Variables（环境变量）… 2. 新建JAVA_HOME 变量 点击 New（新建）… 按钮 输入: 变量名：JAVA_HOME 变量值：电脑上JDK安装的绝对路径 输入完毕后点击 OK。 JDK 路径下必须能够看到如下的文件。 3. 新建/修改 CLASSPATH 变量 如果存在 CLASSPATH 变量，选中点击 Edit(编辑)。 如果没有，点击 New（新建）… 新建。 输入/在已有的变量值后面添加： 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 点击 OK 保存。 4. 修改Path 变量 由于 win10 的不同，当选中 Path 变量的时候，系统会很方便的把所有不同路径都分开了，不会像 win7 或者 win8 那样连在一起。 新建两条路径： %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 4. 检查 打开 cmd，输入 java，出现一连串的指令提示，说明配置成功了: ","date":"2021-05-25","objectID":"/java-note/:16:2","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Scanner扫描器的 next* 方法行为 有的时候会发现 Scanner 的 next* 方法有 “bug”：还没等用户输入，系统就给了一个空白字符的默认值。 next* 指的是 next()、nextInt()、nextDouble() 这些。 public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入1：\"); String next = input.next(); System.out.println(\"next()：\" + next); System.out.print(\"输入2：\"); String nextLine = input.nextLine(); System.out.println(\"nextLine()：\" + nextLine); input.close(); } 例如上面的代码，会发现 nextLine 方法自动获取到了回车Enter 输入1：hello next()：hello 输入2：nextLine()： 进程已结束,退出代码0 这是因为 nextLine() 方法和其他 next* 方法获取的内容不一样。 Scanner 阻塞程序的运行，等待并把用户的输入写入缓冲区，Scanner 从缓冲区读取内容，next* 方法会以空白字符作为结束标识，截取并返回结束标识前的内容，但会把结束标识留在缓冲区中。 空白字符有：空格、tab键、回车键等 nextLine() 方法顾名思义，用来获取一行内容，理所当然以 Enter 作为结束标识。跟其他 next* 方法不一样，它会把结束标识前的内容联通结束标识一同截取，但返回的时候不带结束标识，相当于丢弃了。 上面的例子就可以理解了： 输入字符串：hello，回车后 next() 方法以回车符作为结束标识，并把回车留在了缓冲区 第二次 nextLine() 方法来获取，发现缓冲区有 next() 方法 “残留” 的回车符，获取并丢弃回车符，第二次默认就是空了 这是个不小心会容易踩坑的点。 如何解决？ 也容易。next* 方法读取后残留的空白符，它自己读取没有问题，因为空白符在开头会被忽略（所以 next* 不适合读取空字符串）；nextLine() 这个老实人就惨了，它会把空白符老老实实读给自己。但我们又可以利用它读取空白符并丢弃的特点，额外使用一个 nextLine() 方法把空白符过滤掉。 public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入1：\"); String next = input.next(); System.out.println(\"next()：\" + next); input.nextLine(); // 额外代码用来过滤Enter System.out.print(\"输入2：\"); String nextLine = input.nextLine(); System.out.println(\"nextLine()：\" + nextLine); input.close(); } 现在可以正常输入 输入1：hello next()：hello 输入2：world nextLine()：world 进程已结束,退出代码0 另外一个我个人认为容易歧义的点就是，next* 方法是获取结束标识前的内容，但并不是说结束标识后的内容就丢了。上面的例子就说明了这点，否则也不会出现第二次 “默认输入空白” 的情况。 遍历取所有值的 hasNext() 方法就更能说明问题： public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"输入：\"); String s1 = input.next(); System.out.println(s1); System.out.println(\"==================\"); while (!input.hasNext(\"#\")) { String s2 = input.next(); System.out.println(s2); } input.close(); } 输出结果： 输入：hello world good morning place holding hello ================== world good morning place holding 很明显的感觉到，第一次 next() 取走了 “hello”，后面留在缓冲区，第二次 next() 读取就不需要用户的输入，而是把剩下的内容依次读取出来。 ","date":"2021-05-25","objectID":"/java-note/:17:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"End ","date":"2021-05-25","objectID":"/java-note/:18:0","tags":["Java","SimpleDate","Date","System"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back"],"content":"解决'Exception in thread 'main' java.util.UnknownFormatConversionException: Conversion = '%''的报错并了解一定的报错机制","date":"2021-05-24","objectID":"/java-pencentage-format-error/","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"问题现象 最近在做一个java项目使用String.format进行控制台打印，结果出现如下错误： 最关键的是这个问题是偶现的，通过google定位到问题还是格式化输出过程中%之间冲突了 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:1:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人类似的问题 百度搜搜发现别人的都是因为System.out.printf引起的。 Java从1.5版本开始才具体格式化输出的功能，才有了printf这个方法，可以通过指定不同的格式来控制输出样式，其中%表示格式说明的起始符号，不可缺少。而我的问题就是因为接口响应的日志中包含了%，导致printf打印时出现异常。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:2:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人解决办法 使用 “%%” 去替换掉字符串中的 “%\",例如： String str = “hello world! % w”; System.out.printf(str.replaceAll(\"%”, “%%\")); ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人结果如下: hello world! % w ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:1","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的解决办法 同样是替换 public class PrintPencentSignalStringError { public static void main(String[] args) { NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留几位 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 // System.out.println(String.format(nf.format(0.67))); System.out.println(String.format(nf.format(0.67).replace(\"%\",\"%%\"))); String str = \"hello world! % w\"; // System.out.printf(str); System.out.printf(str.replace(\"%\",\"%%\")); } } ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:4:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人总结 只要出现了这个错误，不管Conversion = ‘任意字符’ 中是哪个值，那肯定是你使用了printf打印内容，但是其中包括了%这个关键字符，可以使用多加一个百分号来进行转义（%%）就可以正常输出了。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:5:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的想法 这两种输出格式化应该都是因为百分号的冲突问题才报的错，故附上格式化输出的对应表格，看到百分号我才恍然大悟 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:6:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"格式化输出对应表 转换符 详细说明 示例 %s 字符串类型 “喜欢请收藏” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 88 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 8.888 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） 不举例(基本用不到) %h 散列码 不举例(基本用不到) %% 百分比类型 ％(%特殊字符%%才能显示%) %n 换行符 不举例(基本用不到) %tx 日期与时间类型（x代表不同的日期与时间转换符) 不举例(基本用不到) ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:7:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Front","note"],"content":"记录JS笔记和相关示例","date":"2021-05-19","objectID":"/js-note/","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS的padStart()方法,padEnd()方法 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 'abc'.padEnd(10, '0123456789') //\"abc0123456\" 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" '123456'.padStart(10, '0') // \"0000123456\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" ","date":"2021-05-19","objectID":"/js-note/:1:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS获取当前页面源代码 document.documentElement.innerHTML 曾用于Ajax异步请求时，后台返回页面，替换当前页面html代码 Ajax的error用于成功（返回空，代码为404）；success（返回Html，代码为200）用于失败返回页面，替换代码 ","date":"2021-05-19","objectID":"/js-note/:2:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS 创建变量接收数组 //如字符串的split函数切分后每一个部分为一个数组，存储在arr中 var arr = str.split(\"\"); ","date":"2021-05-19","objectID":"/js-note/:3:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JavaScript 保留两位小数 ","date":"2021-05-19","objectID":"/js-note/:4:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"四舍五入 以下处理结果会四舍五入: var num =2.446242342; num = num.toFixed(2); // 输出结果为 2.45 ","date":"2021-05-19","objectID":"/js-note/:4:1","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"不四舍五入 以下处理结果不会四舍五入。 第一种，先把小数变整数： Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77 第二种，当作字符串，使用正则匹配： Number(15.7784514000.toString().match(/^\\d+(?:\\.\\d{0,2})?/)) // 输出结果为 15.77,不能用于整数如 10 必须写为10.0000 **注意：**如果是负数，请先转换为正数再计算，最后转回负数 ","date":"2021-05-19","objectID":"/js-note/:4:2","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"Object.assign详解 ","date":"2021-05-19","objectID":"/js-note/:5:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"一、Object.assign是什么？ 首先了解下Object.assign()是什么。我们先看看ES6官方文档是怎么介绍的？ Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 简单来说，就是Object.assign()是对象的静态方法，可以用来复制对象的可枚举属性到目标对象，利用这个特性可以实现对象属性的合并。 ","date":"2021-05-19","objectID":"/js-note/:5:1","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"二、用法 Object.assign(target, ...sources) 参数：target—\u003e目标对象 source—\u003e源对象 返回值：target，即目标对象 ","date":"2021-05-19","objectID":"/js-note/:5:2","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"三、使用示例 1、目标对象和源对象无重名属性 var target={name:'guxin',age:18}; var source={state:'single'} var result=Object.assign(target,source); console.log(target,target==result); 结果如图： 我们可以看到source上的state属性合并到了target对象上。如果只是想将两个或多个对象的属性合并到一起，不改变原有对象的属性，可以用一个空的对象作为target对象。像下面这样： var result=Object.assign({},target,source); 2、目标对象和源对象有重名属性 上面的示例目标对象和源对象是没有重名属性的，那么如果他们有重名属性又会怎样呢？是后面的属性覆盖前面的还是前面的属性覆盖后面的呢？我们接下来看下一个例子： var target={name:'guxin',age:18} var source={state:'signle',age:22} var result=Object.assign(target,source) console.log(target) 我们来看下运行结果： 可以看到如果有同名属性的话，后面的属性值会覆盖前面的属性值。 3、有多个源对象 前面的示例都是只有一个源对象，那么如果有多个源对象情况会不会不同呢？我们继续看下面的例子： var target={name:'guxin',age:18} var source1={state:'signle',age:22} var source2={mood:'happy',age:25} var result=Object.assign(target,source1,source2) console.log(target) 我们来看下运行结果： 可以看到有多个源对象情况也是和一个源对象一样的。没有同名的属性会直接复制到目标对象上，同名的属性后面的属性值会覆盖前面的同名属性值。 ","date":"2021-05-19","objectID":"/js-note/:5:3","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"四、注意事项 1、Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象，继承属性和不可枚举属性是不能拷贝的。 2、针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。 3、目标对象自身也会改变 4、异常会打断后续拷贝任务 ","date":"2021-05-19","objectID":"/js-note/:5:4","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"五、兼容性 目前IE浏览器不兼容Object.assign()，如果需要兼容IE的话最好不要直接使用这个方法。 ","date":"2021-05-19","objectID":"/js-note/:5:5","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"六、与$.extend()的比较 我们通过一个简单的示例来比较两者有什么不同， var target={name:'guxin',age:18} var source1={state:'signle',age:22} var source2={mood:'happy',age:25} var result=Object.assign(target,source1,source2) console.log(target,'assign') var targetObj={name:'guxin',age:18} var sourceObj1={state:'signle',age:22} var sourceObj2={mood:'happy',age:25} var result=$.extend(targetObj,sourceObj1,sourceObj2) console.log(targetObj,'extend') 最终运行结果如下： 可以看到两者得到的结果是一样的。所以，我认为这两个方法，除了兼容性应该是一样的。 以上内容纯属个人理解，如有小伙伴发现错误之处欢迎指正！ ","date":"2021-05-19","objectID":"/js-note/:5:6","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Learning","note\""],"content":"介绍常用的查找表法","date":"2021-05-18","objectID":"/find-table/","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","note\""],"content":"在遍历的同时，记录一些信息，以省去一层循环，这是“以空间换时间”的想法 需要记录已经遍历过的数值和它所对应的下标，可以借助查找表实现 查找表有两个常用的实现: 哈希表 平衡二叉搜索树 ","date":"2021-05-18","objectID":"/find-table/:0:0","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","Note"],"content":"HashMap初始化时为什么建议使用HashMap(int initialCapacity)指定集合大小","date":"2021-05-17","objectID":"/hashmap-initialcapacity/","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"介绍 首先设置一个合理的初始化容量可以提高HashMap的性能 在当我们对HashMap初始化没设置初始化容量时，系统会默认创建一个容量为16的大小的集合。若我们的所需的集合很小则会造成内存浪费，而当HashMap的容量值超过了临界值（threshold)时HashMap将会重新扩容的下一个2的指数幂（16-\u003e32）。HashMap扩容将会重新创建hash表降低性能。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:1:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"方法 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"官方 如果不超过12个键值对，可以不设置 如果超出，按initialCapacity = (需要存储的元素个数 / 负载因子) + 1公式计算后设置 官方的建议是initailCapacity设置成2的n次幂 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:1","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"其他 如何设置一个合理的初始化容量 当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。当HashMap的容量值超过了临界值（threshold)时就会扩容，threshold = HashMap的容量值0.75，比如初始化容量为8的HashMap当大小达到80.75=6时将会扩容到16。当我们设置HashMap的初始化容量是遵循expectedSize /0.75+1，比如expectedSize是6时 6/0.75+1=9，此时jdk处理后会被设置成16，大大降低了HashMap被扩容的几率。 当我们通过HashMap(int initialCapacity)设置初始容量的时候，HashMap并不一定会直接采用我们传入的数值，而是经过计算，得到一个新值，目的是提高hash的效率。(1-\u003e2、3-\u003e4、7-\u003e8、9-\u003e16) HashMap会选择大于初始化值的第一个2的幂作为容量。不然会限制了散列的范围。 HashMap 之所以速度快，因为它使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:2","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"集合介绍 List Set Map 都是接口 List Set继承Collection(Collections是工具类) List子类(有序，可重复)—ArrayList、Vector、LinkedList ArrayList、Vector 底层是数组（查找快，增删慢） 前者线程不安全，后者线程安全 Linkedlist 底层是链表查找慢，增删快 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:3:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"Set（无序，唯一）—HashSet TreeSet LinkedHashSet HashSet 底层是哈希表（hashcode equals） LinkedHashSet 底层是链表和哈希表–插入有序唯一，链表保证有序、哈希表保证唯一 TreeSet 底层结构是红黑树–唯一有序，自然排序、比较器排序 Map HashMap ThreeMap HashTable HashMap HashTable 无序 前者非线程安全，效率高，允许有null（kv），后者线程安全，效率低，不允许null值。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:4:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"TreeMap 有序 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序 \u003c部分整理别人知识点\u003e ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:5:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","note\""],"content":"（详细介绍）什么叫做哈希冲突？什么是负载因子？如何解决哈希冲突？？？","date":"2021-05-16","objectID":"/hash-table/","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"概念： 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为$ O(N) $，平衡树中为树的高度，即$ O(log_2 N) $，搜索的效率取决于搜索过程中元素的比较次数。 理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。 当向该结构中： ","date":"2021-05-16","objectID":"/hash-table/:1:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放 ","date":"2021-05-16","objectID":"/hash-table/:1:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(HashTable)(或者称散列表) 例如：数据集合{1，7，6，4，5，9}； 哈希函数设置为：$ hash(key) = key % capacity$; capacity为存储元素底层空间总的大小。 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快 问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？ ","date":"2021-05-16","objectID":"/hash-table/:1:2","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-概念： 对于两个数据元素的关键字$ k_i $和$ k_j (i != j) $，有$ k_i != k_j $，但有：$ Hash(k_i) == Hash(k_j) $，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。 ","date":"2021-05-16","objectID":"/hash-table/:2:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免： 首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。 两种方式解决冲突 链表式解决（Separate Chaining) 每个数据单元存储数据和next指针，形成链表 开放地址(Open Addressiting) 不用next指针，把其他下标的位置都对外开放。 开放地址的方法: a.线性探测法 冲突后搜索次数线性循环向后放置 b.平方探测(二次方探测) 冲突后根据搜索次数的平方循环向后放置 c.双哈希 ","date":"2021-05-16","objectID":"/hash-table/:3:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-哈希函数设计： 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则： 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间 哈希函数计算出来的地址能均匀分布在整个空间中 哈希函数应该比较简单 常见哈希函数： 1.直接定制法–(常用) 取关键字的某个线性函数为散列地址：$ Hash（Key）= A*Key + B $ 优点：简单、均匀 缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况 2.除留余数法–(常用) 设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：$ Hash(key) = key% p(p\u003c=m)$ ,将关键码转换成哈希地址 还有很多例作为了解：平方取中法，折叠法，随机数法，数学分析法（可以自己查找资料） 注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突 ","date":"2021-05-16","objectID":"/hash-table/:4:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-负载因子调节（重点） 已知哈希表中已有的关键字个数是不可变的，那我们能调整的就只有哈希表中的数组的大小。 ","date":"2021-05-16","objectID":"/hash-table/:5:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决 解决哈希冲突两种常见的方法是：闭散列和开散列 ","date":"2021-05-16","objectID":"/hash-table/:6:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-闭散列： 闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？ 线性探测 比如上面的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，下标为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 插入 通过哈希函数获取待插入元素在哈希表中的位置 如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到 下一个空位置，插入新元素 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他 元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此线性探测采用标 记的伪删除法来删除一个元素。 二次探测： 线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为：$ H_i = (H_0+i^2)% m $，或者： $ H_i = (H_0-i^2)% m $ 其中：i = 1,2,3…， $ H_0 $是通过散列函数Hash(x)对元素的关键码 key进行计算得到的位置，m是表的大小。 对于2.1中如果要插入44，产生冲突，使用解决后的情况为： 研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。 因此：比散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。 ","date":"2021-05-16","objectID":"/hash-table/:6:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-开散列/哈希桶（重点） 开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。 从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。 开散列，可以认为是把一个在大集合中的搜索问题转化为在小集合中做搜索了。 冲突严重时的解决办法： 刚才我们提到了，哈希桶其实可以看作将大集合的搜索问题转化为小集合的搜索问题了，那如果冲突严重，就意味着小集合的搜索性能其实也时不佳的，这个时候我们就可以将这个所谓的小集合搜索问题继续进行转化，例如： 每个桶的背后是另一个哈希表 每个桶的背后是一棵搜索树 ","date":"2021-05-16","objectID":"/hash-table/:7:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"哈希表满了 当哈希表的存储量超过百分之七十（负载因子，默认为0.75），会执行rehashing，即再次哈希，找一个大于原来二倍以上的质数重新进行计算以扩充hash表的容量 代码实现： // key-value 模型 public class HashBucket { private static class Node { private int key; private int value; Node next; public Node(int key, int value) { this.key = key; this.value = value; } } private Node[] array; private int size; // 当前的数据个数 private static final double LOAD_FACTOR = 0.75; public int put(int key, int value) { int index = key % array.length; // 在链表中查找 key 所在的结点 // 如果找到了，更新 // 所有结点都不是 key，插入一个新的结点 for (Node cur = array[index]; cur != null; cur = cur.next) { if (key == cur.key) { int oldValue = cur.value; cur.value = value; return oldValue; } } Node node = new Node(key, value); node.next = array[index]; array[index] = node; size++; if (loadFactor() \u003e= LOAD_FACTOR) { resize(); } return -1; } private void resize() { Node[] newArray = new Node[array.length * 2]; for (int i = 0; i \u003c array.length; i++) { Node next; for (Node cur = array[i]; cur != null; cur = next) { next = cur.next; int index = cur.key % newArray.length; cur.next = newArray[index]; newArray[index] = cur; } } array = newArray; } private double loadFactor() { return size * 1.0 / array.length; } public HashBucket() { array = new Node[8]; size = 0; } public int get(int key) { int index = key % array.length; Node head = array[index]; for (Node cur = head; cur != null; cur = cur.next) { if (key == cur.key) { return cur.value; } } return -1; } } ","date":"2021-05-16","objectID":"/hash-table/:8:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Front"],"content":"解决Uni-App开发组件时控制台报错Error in Created hook: 'TypeError's： Cannot read property 'num' of 'undefined' 的问题","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"Uni-App编写组件的时候，生命周期函数时遇到了使用箭头函数拿不到this的Vue对象的情况 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:0:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"代码 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:1:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"报错 浏览器控制台报下面的错误 created() { } created: () =\u003e { } ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:2:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"原因 箭头函数和普通函数是有区别的，，因为箭头凶数并没有this , this会作为变量一直向上级词法作用域查找，直至找到为止，经常导致Uncaught TypeError: Cannot read property of undefined 或Uncaught TypeError : this.myMethod is not a function之类的错误。 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:3:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"解决 用普通函数替换箭头函数就行了 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:4:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front","note"],"content":"记录使用Vue开发Uni-App小程序的笔记","date":"2021-05-14","objectID":"/vue-uni-app-note/","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"text text组件相当于html的span行布局组件 selectable属性为是否开启可被选中，当前最新版本uni-app的text的selectable属性在小程序端不能使用，暂时测试H5端正常使用 decode属性为开启是否可以解码，当前最新版本uni-app的decode属性现在无论设置为true或false都可以解码（如\u0026amp-\u003e\u0026） ","date":"2021-05-14","objectID":"/vue-uni-app-note/:1:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"view view组件相当于html的div盒子（层、垂直）布局组件，独占一行 hover-start-time、hover-stay-time现在支持字符串的数字，原来需要在属性名前加上冒号:，如:hover-start-time ","date":"2021-05-14","objectID":"/vue-uni-app-note/:2:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"Button 按钮组件，type选择为primary样式后，在H5显示蓝色，在小程序显示绿色 \u003cbutton type=\"primary\"\u003e蓝绿色按钮组件\u003c/button\u003e v-for 需要添加:key作为唯一值否则警告 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:3:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"生命周期 onError只有H5平台支持的生命周期函数，小程序端无效 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:4:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"文件上传 uni.chooseImage在H5端设置count:参数以后是限制不住多的图片上传的，但是在小程序端多的图片不会被上传 previewImage的loop:属性（查看的图片可以循环）在小程序端和H5端不起作用 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:5:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["SoftwareDesign"],"content":"ShellScript（.sh）脚本语法知识，学习编写脚本时的笔记","date":"2021-05-13","objectID":"/powerdesigner-error/","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["SoftwareDesign"],"content":"使用聚合时生成代码以后，需要修改两个role名字为不同，否则a聚合与b时会报a角色名称不唯一 ","date":"2021-05-13","objectID":"/powerdesigner-error/:0:0","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["documentation"],"content":"Hugo生成页面后，本地调试没问题，推到远程发现动画、目录没有生成","date":"2021-05-12","objectID":"/sri-hashes-error/","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"问题来源 Hugo生成页面后，本地调试没问题，推到远程发现首页和文章页面的动画，文章页面的目录没有生成 查看HTML对比并未发现不同怀疑JS 打开控制台，报这个错 Failed to find a valid digest in the 'integrity' attribute for resource 'https://kkkpjskey.github.io/js/theme.min.319518a29ce7d84523d8dfb36ac617794d807f22da6b3a2e11ba33cd8ecfcfc02cf5aabf2034912959a143bdba7573bd.js' with computed SHA-256 integrity 'nvT75FkXevX06WR8vlhFFP02xzhq9qFxLQOuS0LkWyQ='. The resource has been blocked. 查资料发现是SRI不一致的问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:1:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"寻找问题 怀疑Hugo计算SRI的Hashes问题 查看其他CSS等文件，Hashes值是对的，故怀疑主题问题 这是切换主题导致的问题，故还原主题测试发现没问题，怀疑Js文件前后不一致 寻找之前版本的这个js文件，对比，明面上并无差别（Sublime插件对比） 怀疑底层问题，经验所得查看占有的空间大小，差两个字符 不死心于是，使用Winhex肉眼对比，发现了这个 查ASCII表 多了归位键 ","date":"2021-05-12","objectID":"/sri-hashes-error/:2:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"解决 发现有差别就可以用原来的js替换了，问题解决 ","date":"2021-05-12","objectID":"/sri-hashes-error/:3:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"结论 这个字符会影响SRI的计算，本地生成页面时。有这个字符，远程提交时没这个了，前后Hashes值不一样导致了报错，可能是原主题问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:4:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"后续 突发奇想尝试下载ZIP包，结果人家的没问题，SSH下载凭空多了两字符，这就让人顶不住了！！可能是git传输的问题！！ ","date":"2021-05-12","objectID":"/sri-hashes-error/:5:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["Front","note"],"content":"使用SRI保护你的网站免受第三方CDN恶意攻击，记录SRI相关笔记","date":"2021-05-12","objectID":"/sri-note/","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"出于速度和降低服务器负载考虑，有时候我们会选择使用 CDN 加载第三方静态资源。对于一些热门的第三方库，在用户打开你的网页之前就很有可能在浏览别的网站时被浏览器缓存下来，这样就可以极大的提升网页加载速度。 然而使用 CDN 也提高了网站的安全风险：第三方静态资源放在第三方服务器上，CDN 的拥有者有没有可能偷偷的篡改这些文件，加入恶意代码呢？或者 CDN 服务器遭受了黑客攻击，整个文件被替换掉。虽然可能性不高，但不是零。JavaScript 对于当前浏览器页面有完全控制权，他们不仅仅能获取到页面上的任何内容，还能抓取用户输入的一些诸如密码之类的机密信息，还能获取到保存到 Cookie 中的登录票据等等内容，这就是所谓的 XSS 攻击。 我们需要一种机制确保从 CDN 下载的文件未被恶意篡改。某些下载网站就提供下载文件的 MD5 或 SHA1 码用于检查所下载文件的完整性，网页中有没有类似的机制呢？ ","date":"2021-05-12","objectID":"/sri-note/:0:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"What（什么是 SRI） Subresource Integrity (SRI) is a security feature that enables browsers to verify that files they fetch (for example, from a CDN) are delivered without unexpected manipulation. 在 和 link 标签中通过 integrity 属性，浏览器核实所获取的 js 文件（或 css 文件）确实是如 integrity 值规定的，然后再加载 js 文件（或应用css 文件）。 例子 如下是个 script 标签 \u003cscript src=\"https://example.com/example-framework.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"\u003e \u003c/script\u003e 注意 integrity=“sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC”，integrity 的值以 sha384- 开头，表示算法为 sha384, dash (-) 之后跟随的是 base64-encoded hash。 当前所允许的 hash 算法有 sha256, sha384, and sha512 ","date":"2021-05-12","objectID":"/sri-note/:1:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"生成 SRI Hashes值 命令行有两种方法。 ","date":"2021-05-12","objectID":"/sri-note/:2:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法一 cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A ","date":"2021-05-12","objectID":"/sri-note/:2:1","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法二 shasum -b -a 384 FILENAME.js | xxd -r -p | base64 注意，这里 shah 算法是 sha384，如果生成其他的 hash 值，是否也像这样，只需稍作修改即可（可能吧，但是未验证）。 ","date":"2021-05-12","objectID":"/sri-note/:2:2","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法三 $ echo -n \"alert('Hello, world.');\" | openssl dgst -sha384 -binary | openssl base64 -A 使用了 OpenSSL 这个 *nix 中通常都包含的工具计算哈希值。其中 alert('Hello, world.'); 是文件内容，你也可以用 cat Filename.js 直接读取某个文件。 输出 H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO，在此基础上添加前缀 sha384- 就可以了。 还有在线工具 https://srihash.org/ 可以生成不同格式的工具 https://www.xftsoft.com/tool/integrity ","date":"2021-05-12","objectID":"/sri-note/:2:3","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"浏览器如何处理 SRI (Subresource Integrity) 当浏览器遇到一个带有 integrity 的 \u003cscript\u003e 或 \u003cstyle\u003e 标签，在执行其中的 JS 脚本或应用其中的 CSS 样式之前，浏览器会首先计算所下载文件的内容的哈希值是否与 integrity 属性给定的值相同。 如果计算结果与给定值不匹配，浏览器会拒绝执行脚本内容，并报出一个网络错误，类似如下结果： When a browser encounters a \u003cscript\u003e or \u003clink\u003e element with an integrity attribute, before executing the script or before applying any stylesheet specified by the \u003clink\u003e element, the browser must first compare the script or stylesheet to the expected hash given in the integrity value. If the script or stylesheet doesn’t match its associated integrity value, then the browser must refuse to execute the script or apply the stylesheet, and must instead return a network error indicating that fetching of that script or stylesheet failed. Failed to find a valid digest in the ‘integrity’ attribute for resource ‘https://cdnjs.cloudflare.com/ajax/libs/normalize/6.0.0/normalize.min.css' with computed SHA-256 integrity ‘VbcxqgMGQYm3q8qZMd63uETHXXZkqs7ME1bEvAY1xK8=’. The resource has been blocked. 参考 Subresource Integrity https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity ","date":"2021-05-12","objectID":"/sri-note/:3:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"使用 SRI 只需给 script 或 style 标签添加 integrity 属性即可。例如： JavaScript \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e CSS \u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css\" integrity=\"sha384-7tIwW4quYS2+TZCwuAPnUY+dRqg28ylzlIoVXAwpfiTs+CMKsAOSsWYQ96c/ZnV+\" crossorigin=\"anonymous\"\u003e integrity 属性值以 shaXXX- 开头，表示后面的哈希值使用的哈希算法，目前只允许 sha256、sha384 或 sha512 这三种哈希算法，以 sha384 比较多见。后面跟对应的哈希值即可。 值得注意的是，因为启用 SRI 需要获取所下载文件的内容进行计算，所以需要 CDN 服务器启用跨域资源访问（CORS）支持，即返回 Access-Control-Allow-Origin: * 头。客户端需要使用跨域的形式加载指定文件，即添加 crossorigin=\"anonymous\" 属性。就我所知，目前国内相对常用的免费 CDN bootcdn 已经支持 CORS，百度静态 CDN 还不支持。 ","date":"2021-05-12","objectID":"/sri-note/:4:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"CSP 与 SRI 你可以使用 内容安全政策 （CSP）强制要求当前页面所有脚本加载标签启用 SRI。例如 Content-Security-Policy: require-sri-for script; 强制要求所有 script 标签启用 SRI，浏览器会拒绝加载未启用 SRI 的 script 标签。 对应的还有 CSS 版本： Content-Security-Policy: require-sri-for style; 你也可以同时启用两者。 ","date":"2021-05-12","objectID":"/sri-note/:5:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"错误恢复 使用 CDN 时别忘了当尝试从 CDN 加载文件失败后加载本地版本： \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript\u003eif (!window.jQuery) document.write('\u003cscript src=\"/jquery-3.2.1.min.js\"\u003e\u003c\\/script\u003e')\u003c/s ","date":"2021-05-12","objectID":"/sri-note/:6:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Total","note"],"content":"基于广播和服务功能的音乐播放器","date":"2021-05-11","objectID":"/android-music-box/","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1、应用知识点 ","date":"2021-05-11","objectID":"/android-music-box/:1:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.1、Android 广播接收器(Broadcast Receivers) 广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。例如，应用程序可以初始化广播来让其他的应用程序知道一些数据已经被下载到设备，并可以为他们所用。这样广播接收器可以定义适当的动作来拦截这些通信。 有以下两个重要的步骤来使系统的广播意图配合广播接收器工作。 创建广播接收器 注册广播接收器 还有一个附加的步骤，要实现自定义的意图，你必须创建并广播这些意图。 ","date":"2021-05-11","objectID":"/android-music-box/:1:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.2、服务（Service） 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。服务基本上包含两种状态 状态 描述 Started Android的应用程序组件，如活动，通过startService()启动了服务，则服务是Started状态。一旦启动，服务可以在后台无限期运行，即使启动它的组件已经被销毁。 Bound 当Android的应用程序组件通过bindService()绑定了服务，则服务是Bound状态。Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。 ","date":"2021-05-11","objectID":"/android-music-box/:1:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、原型图 老师要求的原型图仅包括四个按钮和两个文本。 四个按钮分别为上一曲、播放暂停、停止、下一曲；两个文本为曲名和歌手。 我在老师要求的基础上，结合上次实验RecyclerView进行更新，目的如图所示，实现一个类似常规音乐播放器的界面。 左侧包括歌曲的图片，上方时每首歌的列表。 ","date":"2021-05-11","objectID":"/android-music-box/:2:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、需求 编写音乐盒代码，参考群文件-源码-Musicbox，掌握源码后在其基础上添加音乐播放的 上一首 和 下一首 控制，也可以增加更多的功能。 ","date":"2021-05-11","objectID":"/android-music-box/:3:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"3、思路 在真正的代码撰写中，广播就是内嵌于activity和service的。在界面中绘制四个按钮、一个图片和两个文本，填入数据。监听不同按钮点击事件，绑定对应的广播函数或服务。 ","date":"2021-05-11","objectID":"/android-music-box/:4:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-05-11","objectID":"/android-music-box/:5:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.1、fragment_mes.xml（在原基础上添加即可） \u003candroidx.constraintlayout.widget.ConstraintLayout android:id=\"@+id/constraintLayout_mes_mp\" android:layout_width=\"match_parent\" android:layout_height=\"70dp\" android:layout_gravity=\"bottom\" android:background=\"#99BB86FC\" android:orientation=\"horizontal\"\u003e \u003cImageButton android:id=\"@+id/iB_ablum\" android:layout_width=\"70dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/flower1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.0\" /\u003e \u003cTextView android:id=\"@+id/tV_musicName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"15dp\" android:text=\"Inside the Lines\" android:textColor=\"#FFFFFFFF\" android:textSize=\"16sp\" android:textStyle=\"bold\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.333\" /\u003e \u003cTextView android:id=\"@+id/tV_singerName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"5dp\" android:text=\"Mike Perry\" android:textColor=\"#DDFFFFFF\" android:textSize=\"14sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toBottomOf=\"@+id/tV_musicName\" /\u003e \u003cImageButton android:id=\"@+id/iB_lastPiece\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_left_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_playPause\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_playPause\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_drop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_stop\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_stop\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"#00BB86FC\" android:src=\"@drawable/stop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"@+id/iB_lastPiece\" app:layout_constraintEnd_toStartOf=\"@+id/iB_nextPlay\" app:layout_constraintTop_toTopOf=\"@+id/iB_lastPiece\" /\u003e \u003cImageButton android:id=\"@+id/iB_nextPlay\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-05-11","objectID":"/android-music-box/:5:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.2、MesFragment.java（仅展示在原来recyclerView之后的内容） public class MesFragment extends Fragment implements View.OnClickListener { // 获取界面中显示歌曲标题、作者文本框 TextView title, author; // 播放/暂停、停止按钮、上一曲按钮，下一曲按钮 ImageButton play, stop, next, last; ActivityReceiver activityReceiver; public static final String CTL_ACTION = \"org.xr.action.CTL_ACTION\"; public static final String UPDATE_ACTION = \"org.xr.action.UPDATE_ACTION\"; // 定义音乐的播放状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; String[] titleStrs = new String[]{\"Inside the Lines\", \"Landslide\", \"Life\", \"Symphony\", \"The Spectre\"}; String[] authorStrs = new String[]{\"Mike Perry\", \"Headhunterz\", \"Tobu\", \"Clean Bandit\", \"Alan Walker\"}; // 获取程序界面界面中的两个按钮 play = (ImageButton) view.findViewById(R.id.iB_playPause); stop = (ImageButton) view.findViewById(R.id.iB_stop); title = (TextView) view.findViewById(R.id.tV_musicName); author = (TextView) view.findViewById(R.id.tV_singerName); //获取上一首、下一首按钮 last = (ImageButton) view.findViewById(R.id.iB_lastPiece); next = (ImageButton) view.findViewById(R.id.iB_nextPlay); // 为两个按钮的单击事件添加监听器 play.setOnClickListener(this); stop.setOnClickListener(this); //为上一首、下一首按钮添加监听器 last.setOnClickListener(this); next.setOnClickListener(this); activityReceiver = new ActivityReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); // 指定BroadcastReceiver监听的Action filter.addAction(UPDATE_ACTION); // 注册BroadcastReceiver getActivity().registerReceiver(activityReceiver, filter); Intent intent = new Intent(getActivity(), MusicService.class); // 启动后台Service getActivity().startService(intent); return view; } // 自定义的BroadcastReceiver，负责监听从Service传回来的广播 public class ActivityReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 获取Intent中的update消息，update代表播放状态 int update = intent.getIntExtra(\"update\", -1); // 获取Intent中的current消息，current代表当前正在播放的歌曲 int current = intent.getIntExtra(\"current\", -1); if (current \u003e= 0) { title.setText(titleStrs[current]); author.setText(authorStrs[current]); } switch (update) { case 0x11: play.setImageResource(R.drawable.arrow_right_drop_circle_outline); status = 0x11; break; //控制系统进入播放状态 case 0x12: // 播放状态下设置使用暂停图标 play.setImageResource(R.drawable.pause_circle_outline); // 设置当前状态 status = 0x12; break; // 控制系统进入暂停状态 case 0x13: // 暂停状态下设置使用播放图标 play.setImageResource(R.drawable.arrow_right_drop_circle_outline); // 设置当前状态 status = 0x13; break; } } } @Override public void onClick(View source) { // 创建Intent Intent intent = new Intent(\"org.xr.action.CTL_ACTION\"); switch (source.getId()) { // 按下播放/暂停按钮 case R.id.iB_playPause: intent.putExtra(\"control\", 1); break; // // 按下停止按钮 case R.id.iB_stop: intent.putExtra(\"control\", 2); break; // 按下上一曲按钮 case R.id.iB_lastPiece: intent.putExtra(\"control\", 3); break; // 按下下一曲按钮 case R.id.iB_nextPlay: intent.putExtra(\"control\", 4); break; } // 发送广播，将被Service组件中的BroadcastReceiver接收到 getActivity().sendBroadcast(intent); } } ","date":"2021-05-11","objectID":"/android-music-box/:5:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.3、MusicService.java（播放音乐服务） public class MusicService extends Service { MyReceiver serviceReceiver; AssetManager am; String[] musics = new String[]{\"insidethelines.mp3\", \"landslide.mp3\", \"life.mp3\", \"symphony.mp3\", \"thespectre.mp3\"}; // String[] musics = new String[] {\"liangliang.mp3\", \"wuhangya.mp3\",\"three.mp3\" ,\"four.mp3\",\"fif.mp3\"}; MediaPlayer mPlayer; // 当前的状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; // 记录当前正在播放的音乐 int current = 0; @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); am = getAssets(); // 创建BroadcastReceiver serviceReceiver = new MyReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); filter.addAction(MesFragment.CTL_ACTION); registerReceiver(serviceReceiver, filter); // 创建MediaPlayer mPlayer = new MediaPlayer(); // 为MediaPlayer播放完成事件绑定监听器 mPlayer.setOnCompletionListener(new OnCompletionListener() // ① { @Override public void onCompletion(MediaPlayer mp) { current++; if (current \u003e= 5) { current = 0; } //发送广播通知Activity更改文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); // 准备并播放音乐 prepareAndPlay(musics[current]); } }); } public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(final Context context, Intent intent) { int control = intent.getIntExtra(\"control\", -1); switch (control) { // 播放或暂停 case 1: // 原来处于没有播放状态 if (status == 0x11) { // 准备并播放音乐 prepareAndPlay(musics[current]); status = 0x12; } // 原来处于播放状态 else if (status == 0x12) { // 暂停 mPlayer.pause(); // 改变为暂停状态 status = 0x13; } // 原来处于暂停状态 else if (status == 0x13) { // 播放 mPlayer.start(); // 改变状态 status = 0x12; } break; // 停止声音 case 2: // 如果原来正在播放或暂停 if (status == 0x12 || status == 0x13) { // 停止播放 current++; mPlayer.stop(); status = 0x11; } case 3: current--; if (current \u003c 0) { current = 4; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; case 4: current++; if (current \u003e 4) { current = 0; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; } // 广播通知Activity更改图标、文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"update\", status); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); } } private void prepareAndPlay(String music) { try { // 打开指定音乐文件 AssetFileDescriptor afd = am.openFd(music); mPlayer.reset(); // 使用MediaPlayer加载指定的声音文件。 mPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()); // 准备声音 mPlayer.prepare(); // 播放 mPlayer.start(); } catch (IOException e) { e.printStackTrace(); } } } ","date":"2021-05-11","objectID":"/android-music-box/:5:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-05-11","objectID":"/android-music-box/:6:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.1、初始状态，暂停未进行播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.2、点击播放按钮，按钮变为等待暂停状态，音乐播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.3、点击上一曲按钮，保存当前状态（播放或暂停）切换到上一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.4、点击下一曲按钮，保存当前状态（播放或暂停）切换到下一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:4","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.5、点击暂停则停止播放，点击继续则从刚才的位置继续播放，点击停止按钮停止播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:5","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"6、结语 本次实验感想颇多，在不同的学习渠道，加上百度搜索，请教同学最终仅仅完成了一个初步的成果。后续需要改进和维护的东西还有很多很多。音乐的图标需要更换，切换歌曲应该随之切换图片，recyclerView的数据并没有与歌曲一同绑定。本人水平一般，能力有限，精力也有限，随着时间的推移慢慢完善吧。 ","date":"2021-05-11","objectID":"/android-music-box/:7:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"7、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design 注： 源码中为了实现某些功能，减少大面积重命名文件的情况，信息和朋友页面进行对调（id），朋友改为音乐（title和icon），请读者注意！ 在下次实验完成前，master分支和本次实验分支（Music_Box）会有一样的本次实验代码，下次实验完成后会新创建分支，保存新实验的代码啊，更新master分支代码 ","date":"2021-05-11","objectID":"/android-music-box/:8:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["SoftwareDesign","note"],"content":"详细介绍Mybatis中用到的设计模式","date":"2021-05-09","objectID":"/mybatis-designmode/","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["SoftwareDesign","note"],"content":" Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果； 组合模式，例如SqlNode和各个子类ChooseSqlNode等； 模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler； 适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现； 装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现； 迭代器模式，例如迭代器模式PropertyTokenizer； ","date":"2021-05-09","objectID":"/mybatis-designmode/:0:0","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["Total","note"],"content":"记录Android开发笔记","date":"2021-05-01","objectID":"/android-note/","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android5.0常用颜色属性说明 在使用Eclipse的时代，我们很少去在style文件给整个应用或者Activity去设定颜色，那是因为即使设置也不会提升用户的视觉效果。但是材料设计号称让没有设计功底的人也能做出漂亮的App，那我们今天就来看看在Androi5.0中常用的颜色属性。 我们可以先定义一个style，然后在这个style中设定每一个Activity或者整个App的颜色，最后在清单文件中来给某个Activity设置主题即可。代码如下： \u003cstyle name=\"AppTheme.NoActionBar\"\u003e \u003c!--状态栏颜色--\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003c!--控制各个控件被选中时的颜色--\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c!--页面背景色--\u003e \u003citem name=\"android:windowBackground\"\u003e@color/windowBackg\u003c/item\u003e \u003c!--底部导航栏颜色--\u003e \u003citem name=\"android:navigationBarColor\"\u003e@color/navigationColor\u003c/item\u003e \u003c!--Appbar背景色--\u003e \u003citem name=\"android:colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003c!--ToolBar上的Title颜色--\u003e \u003citem name=\"android:textColorPrimary\"\u003e@color/textColorPrimary\u003c/item\u003e \u003c!--各个控制控件的默认颜色--\u003e \u003citem name=\"android:colorControlNormal\"\u003e@color/colorControlNormal\u003c/ item\u003e \u003c/style\u003e 最后再来一张图详细说明每个item设定的到底是哪里的颜色： ","date":"2021-05-01","objectID":"/android-note/:1:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"ConstraintLayout基本使用之toLeftOf 、toTopOf、toRightOf、toBottomOf 关于ConstraintLayout的博客、文章想必大家已经见过很多了，都是很全面的，今天这篇博客主要将ConstraintLayout的 layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintTop_toTopOf ... 以上到底怎么理解呢？下面我将通过图片+文字来解释。 现在假设屏幕中间有个长宽为100dp的红色正方形，屏幕左上方有个宽高为50dp的黑色正方形，如下: 接下来我们一个一个试试这些参数吧! 1、layout_constraintLeft_toLeftOf(可以看出黑色正方形左边和红色正方形左边对齐) 2、layout_constraintLeft_toRightOf(黑色正方形的左边和红色正方形的右边对齐) 3、layout_constraintRight_toLeftOf(黑右对齐红左) 4、layout_constraintRight_toRightOf(黑右对齐红右) 剩余四个: layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf 也是同理。 让我们看一下这个参数的统一命名:layout_constraintA_toBOf， 也即代表当前布局的A方向，对齐目标布局的B方向 ","date":"2021-05-01","objectID":"/android-note/:2:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 沉浸式标题栏设置，顶部view到状态栏 Android 沉浸式标题栏设置，顶部view到状态栏 布局xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroid.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:id=\"@+id/tv_top_bg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:maxHeight=\"140dp\" android:background=\"@drawable/case_resource_transport_top_bg\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e ... \u003c/android.support.constraint.ConstraintLayout\u003e activity AndroidManifest设置 \u003cactivity android:name=\"....xxActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/AppTheme.imgFullScreen\" android:windowSoftInputMode=\"adjustPan\"/\u003e stayles.xml 添加style \u003cstyle name=\"AppTheme.imgFullScreen\"\u003e \u003citem name=\"android:windowTranslucentStatus\"\u003efalse\u003c/item\u003e \u003citem name=\"android:windowTranslucentNavigation\"\u003efalse\u003c/item\u003e \u003citem name=\"android:statusBarColor\"\u003e@android:color/transparent\u003c/item\u003e \u003c/style\u003e xxActivity添加 val decorView = window.decorView val option = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE) decorView.systemUiVisibility = option window.statusBarColor = Color.TRANSPARENT 效果： ","date":"2021-05-01","objectID":"/android-note/:3:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android去除顶部默认的标题栏 当我们在Android Studio中创建一个新的Android项目时，会发现顶部有一个标题栏。我们有的时候并不需要这个标题栏，因此我们就需要把它去掉。 在Android Studio中展开Project模块，会看到里面是一个由文件和文件夹构成的树形图。打开里面的app-\u003emanifests-\u003eAndroidManifest.xml文件，然后找到application标签的android:theme属性，把它的值改为\"@style/Theme.AppCompat.NoActionBar\"，这样就可以解决问题了。 ","date":"2021-05-01","objectID":"/android-note/:4:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android注册服务 broadcastReceiver使用时需要在AndroidManifest.xml注册格式为 package=\"com\"\u003e \u003cactivity android:name=\".MainActivity\"\u003e …… \u003c/activity\u003e \u003cservice android:name=\".XXX\" /\u003e 此处.目录取决于上面package导入的目录 ","date":"2021-05-01","objectID":"/android-note/:5:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android TextView 文字居中 有2种方法可以设置TextView文字居中： 一：在xml文件设置：android:gravity=“center” 二：在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER); ","date":"2021-05-01","objectID":"/android-note/:6:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android给View设置上下左右边框 需求 设置view上下右有边框(左边不要边框)，右上角右下角需要设置为圆角（左边不需要） 实现 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003c!-- This is the main color --\u003e \u003citem\u003e \u003cshape\u003e \u003c!-- 边框颜色 --\u003e \u003csolid android:color=\"@color/flash_text_normal\"/\u003e \u003c/shape\u003e \u003c/item\u003e \u003c!-- 给View的上 下 右设置8dp的边框 --\u003e \u003c!-- http://blog.csdn.net/lowprofile_coding/article/details/47848245--\u003e \u003citem android:top=\"1dip\" android:bottom=\"1dip\" android:right=\"1dip\" \u003e \u003cshape\u003e \u003c!-- View填充颜色 --\u003e \u003csolid android:color=\"@color/public_round_yellow\" /\u003e \u003ccorners android:topRightRadius=\"@dimen/x10\" android:bottomRightRadius=\"@dimen/x10\" /\u003e \u003c/shape\u003e \u003c/item\u003e \u003c/layer-list\u003e ","date":"2021-05-01","objectID":"/android-note/:7:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android 为TextView添加边框 今天需要在TextView上面添加一个边框，但是TextView本身不支持边框，所以只能采用其他方式，在网上查询了一下，主要有三种方式可以实现1.带有边框的透明图片2.使用xml的shape设置3继承TextView覆写onDraw方法。 ","date":"2021-05-01","objectID":"/android-note/:8:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法一 带有透明图片的背景图，这个没有什么好将的，自己制作一个就行 ，然后设置background就可以了 ","date":"2021-05-01","objectID":"/android-note/:8:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法二 通过shape来设置背景图片 首先一个textview_border.xml文件放在drawable文件夹里面 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" \u003e \u003csolid android:color=\"#ffffff\" /\u003e \u003cstroke android:width=\"1dip\" android:color=\"#4fa5d5\"/\u003e \u003c/shape\u003e 为要添加边框的TextView添加一个background android:background=\"@drawable/textview_border\" 效果图片如下: ","date":"2021-05-01","objectID":"/android-note/:8:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法三 编写一个继承TextView类的自定义组件，并在onDraw事件方法中画边框。 package com.example.test; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Canvas; import android.graphics.Paint; import android.util.AttributeSet; import android.widget.TextView; @SuppressLint(\"DrawAllocation\") public class BorderTextView extends TextView{ public BorderTextView(Context context) { super(context); } public BorderTextView(Context context, AttributeSet attrs) { super(context, attrs); } private int sroke_width = 1; @Override protected void onDraw(Canvas canvas) { Paint paint = new Paint(); // 将边框设为黑色 paint.setColor(android.graphics.Color.BLACK); // 画TextView的4个边 canvas.drawLine(0, 0, this.getWidth() - sroke_width, 0, paint); canvas.drawLine(0, 0, 0, this.getHeight() - sroke_width, paint); canvas.drawLine(this.getWidth() - sroke_width, 0, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); canvas.drawLine(0, this.getHeight() - sroke_width, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); super.onDraw(canvas); } } 效果图如下: 使用的Xml布局内容如下: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cRelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" \u003e \u003cTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:background=\"@drawable/textview_border\" android:text=\"方法二\" android:textColor=\"#FF000000\" android:id=\"@+id/test\" android:gravity=\"center\" android:layout_alignParentTop=\"true\" android:layout_marginTop=\"20dp\" android:layout_centerHorizontal=\"true\"/\u003e \u003ccom.example.test.BorderTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:text=\"方法三\" android:id=\"@+id/test3\" android:gravity=\"center\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_centerHorizontal=\"true\"\u003e \u003c/com.example.test.BorderTextView\u003e \u003c/RelativeLayout\u003e ","date":"2021-05-01","objectID":"/android-note/:8:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"全局变量 切换Fragment时有些值需要保存，故需要一个全局变量进行保存 ​ 项目开发的过程中，可能会大量的使用全局变量，在android开发中，大多数人更偏向于使用application来保存全局变量。那么我们就先来了解下在android中，application究竟是什么？有什么作用？ 　Application类是用来维护应用程序全局状态。我们可以提供自己的实现，并在AndroidManifest.xml文件的标签中指出它的名字，这将导致在创建应用程序时去实例化我们自己的Application类。Android系统会为每个程序运行时创建一个Application类的对象且仅创建一个，所以Application可以说是单例模式的一个类。且Application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局唯一的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以，通过Application来进行一些数据传递、数据共享、数据缓存等操作。 　首先创建继承自Application的MusicPlayerStatus类，定义变量update、current,并创建get和set方法。 import android.app.Application; public class MusicPlayerStatus extends Application { private int update=-1; private int current=-1; public int getUpdate() { return update; } public void setUpdate(int update) { this.update = update; } public int getCurrent() { return current; } public void setCurrent(int current) { this.current = current; } } 下面就是如何使用我们创建的全局变量了，在MainActivity中，首先要获得MusicPlayerStatus的对象，因为MusicPlayerStatus继承自Application，所以使用getApplication()方法即可，然后可以调用MusicPlayerStatus的get或set方法进行访问全局变量。 public MusicPlayerStatus musicPlayerStatus=new MusicPlayerStatus(); int update = musicPlayerStatus.getUpdate(); int current = musicPlayerStatus.getCurrent(); musicPlayerStatus.setUpdate(update); musicPlayerStatus.setCurrent(current); 注意，在使用MusicPlayerStatus之前需要修改AndroidManifest.xml文件的中的android:name = “.MusicPlayerStatus”，这样就不会访问系统提供的application，而访问我们自己创建的。 ","date":"2021-05-01","objectID":"/android-note/:9:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 使控件各占屏幕的一半 在xml中将两个要占屏幕一半的控件都加上android:layout_weight=“1”； 注意：weight只能用在LinearLayout布局中。 在LinearLayout布局中weight数值越大显示的优先权就越低。 ","date":"2021-05-01","objectID":"/android-note/:10:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Fragment生命周期 相互切换时调用的方法 ","date":"2021-05-01","objectID":"/android-note/:11:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"一、前言： Fragment生命周期图如下： ","date":"2021-05-01","objectID":"/android-note/:11:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"二、Fragment 1 切换到 Fragment 2时生命周期变化 1. 通过 add hide show 方式来切换 Fragment Fragment1 的生命周期变化为：onCreate（）、onCreateView、onStart（）、onResume（） 回调 onHiddenChanged（） 方法 Fragment2 的生命周期变化为： onCreate（）、onCreateView、onStart（）、onResume（） Fragment 2 再次返回到 Fragment 1：不走任何生命周期方法但是回调 onHiddenChanged（）方法 总结：当以这种方式进行 Fragment 1 与 Fragment 2 的切换时，Fragment 隐藏的时候并不走 onDestroyView，所有的显示也不会走 onCreateView 方法，所有的 view 都会保存在内存。 2. 使用 replace 的方法进行切换时 载入Fragment 1时： Fragment 1的生命周期：onCreate（）、onCreateView（）、onStart（）、onResume（） 切换到Fragment2时： Fragment 1的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 2的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） Fragment 2切换回Fragment 1时： Fragment2的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 1的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） 总结：通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期。 3. 使用 ViewPager 进行切换时 当使用 ViewPager 与 Fragment 进行切换时，Fragment 会进行预加载操作 所有的 Fragment 都会提前初始—\u003e预加载； 初始化时 Fragment 们的生命周期： Fragment 1 的生命周期：onCreate（）、onCreateView（） Fragment 2 的生命周期：onCreate（）、 onCreateView（） Fragment 1 切换到 Fragment 2 的生命周期： Fragment 1 ：不走任何生命周期； Fragment 2 ：走 setUserVisVleHint（）方法 切回去也是一样的 注意： setUserVisVleHint（）方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法。 /** *第一个 Fragment 需要处理 setUserVisVleHint（）方法，设置为 setUserVisibleHint(true); *否则会产空指针异常，因为 setUserVisVleHint（）方法的优先级高于 onCreate（）方法。 * * @param savedInstanceState */ @Override public void onActivityCreated(Bundle savedInstanceState) { setUserVisibleHint(true); super.onActivityCreated(savedInstanceState); } /* 主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题。 setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。 此时要对是否调用了onCreateView（）方法进行标记判断。 */ ","date":"2021-05-01","objectID":"/android-note/:11:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"三、其它切换 1. Activity 切换到 Fragment 的生命周期变化 Fragment 的生命周期变化为：onStart（）、onResume（） 2. 从 Fragment 1 进行锁屏操作 Fragment 的生命周期方法：onPause（）、onSaveInstanceState（）、onStop（）。 3. 从解锁 到 Fragment 1 的生命周期 onStart（）、 onResume（） ","date":"2021-05-01","objectID":"/android-note/:11:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"简单实现ImageView宽度填满屏幕，高度自适应的两种方式 两种方式 ","date":"2021-05-01","objectID":"/android-note/:12:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"1.重写View的onMeasure方法 核心代码 protectedvoidonMeasure(intwidthMeasureSpec,intheightMeasureSpec){ Drawable d = getDrawable(); if(d!=null){ // ceil not round - avoid thin vertical gaps along the left/right edgesintwidth = MeasureSpec.getSize(widthMeasureSpec); //高度根据使得图片的宽度充满屏幕计算而得 intheight = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth()); setMeasuredDimension(width, height); }else{ super.onMeasure(widthMeasureSpec, heightMeasureSpec); } } ","date":"2021-05-01","objectID":"/android-note/:12:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"2.设置ImageView的属性： //宽度填满屏幕 android:layout_width=”match_parent” android:scaleType=”fitXY” android:layout_height=”wrap_content” //保持比例，一定要设置 android:adjustViewBounds=”true” ","date":"2021-05-01","objectID":"/android-note/:12:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android使用Bundle+Message+Hundle进行线程间通信 ","date":"2021-05-01","objectID":"/android-note/:13:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是java自带数据对象（常规八种数据结构） 接收线程 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : String str1 = msg.getData().getString(\"text1\");//接受msg传递过来的参数 String str2 = msg.getData().getString(\"text2\");//接受msg传递过来的参数 initFinishMainActivity(str1, str2); break; default : break; } } }; 发送线程 Message msg = new Message(); msg.what = MainActivity.CANSHU; Bundle bundle = new Bundle(); bundle.putString(\"text1\",\"大明的消息传递参数的例子！\"); //往Bundle中存放数据 bundle.putString(\"text2\",\"Time：2011-09-05\"); //往Bundle中put数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是自定义对象时 自定义类 首先需要自定对象实现Serializable可序列化的接口，如下 public class Persion implements Serializable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 接收线程 getString等改为 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : Persion persion=(Persion)(msg.getData().getSerializable(\"persion\")); //接受msg传递过来的参数 initFinishMainActivity(persion); break; default: break; } } }; 发送线程 putString等改为putSerializable Message msg = new Message(); msg.what = MainActivity.CANSHU; Persion persion=new Persion(); String Name=\"zhangsan\"; persion.setName(Name); Bundle bundle = new Bundle(); bundle.putSerializable(\"persion\",persion); //往Bundle中存放数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android历史版本平台、SDK、版本名称对照（争取持续更新） 平台版本 SDK版本 版本名称 12.0 31 Android 12（Snow Cone）（刨冰） 11.0 30 Red Velvet Cake（Quince Tart）(Android R)（11）（红丝绒蛋糕） 10.0 29 (Android Q)（10） 9.0 28 Pie (Android P)（派/馅饼） 8.1 27 Oreo(Android O)（奥利奥） 8.0 26 [Oreo(Android O)（奥利奥） 7.1 25 Nougat(Android N)（牛轧糖） 7.0 24 Nougat(Android N)（牛轧糖） 6.0 23 Marshmallow(Android M)（棉花糖） 5.1 22 Lollipop(Android L)（棒棒糖） 5.0 21 Lollipop(Android L)（棒棒糖） 4.4W 20 KITKAT Wear（奇巧巧克力） 4.4 19 [KITKAT（奇巧巧克力） 4.3 18 JELLY_BEAN_MR2（软心豆粒糖/果冻豆） 4.2 / 4.2.2 17 JELLY_BEAN_MR1（软心豆粒糖） 4.1 / 4.1.1 16 JELLY_BEAN（软心豆粒糖） 4.0.3 / 4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰淇淋三明治） 4.0 / 4.01 / 4.02 14 ICE_CREAM_SANDWICH（冰淇淋三明治） 3.2 13 HONEYCOMB_MR2（蜂巢） 3.1.X 12 HONEYCOMB_MR1（蜂巢） 3.0.X 11 HONEYCOMB（蜂巢） 2.3.3 / 2.3.4 10 GINGERBREAD_MR1（姜饼） 2.3 9 GINGERBREAD（姜饼） 2.2 / 2.2.1 8 Froyo（冻酸奶） 2.1 7 Eclair_MR2（闪电泡芙） 2.0.1 6 Eclair_MR1（闪电泡芙） 2.0 5 Eclair（闪电泡芙） 1.6 4 Donut（甜甜圈） 1.5 3 Cupcake（纸杯蛋糕） 1.1 2 Petit Four 1.0 1 Astro / Bender(1.0有两版) ","date":"2021-05-01","objectID":"/android-note/:14:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android资源管理器注意事项 /data/user/0是/data/data目录的软连接或者是快捷方式 ","date":"2021-05-01","objectID":"/android-note/:15:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"ImageView / ImageButton 图片太大或者太小 第一步:指定layout_width与layout_height 在xml文件中设置的ImageButton的宽和高为： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cImageButton android:layout_width=\"100dp\" android:layout_height=\"100dp\"/\u003e 第二步:设置属性android:scaleType ImageView的属性android:scaleType，即 ImageView.setScaleType(ImageView.ScaleType)。android:scaleType是控制图片如何 resized/moved来匹对ImageView的size。ImageView.ScaleType / android:scaleType值的意义区别： ImageButton属性 ImageButton解释 CENTER /center 按图片的原来size居中显示，当图片长/宽超过View的长/宽，则截取图片的居中部分显示 CENTER_CROP / centerCrop 按比例扩大图片的size居中显示，使得图片长 (宽)等于或大于View的长(宽) CENTER_INSIDE / centerInside 将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽 FIT_CENTER / fitCenter 把图片按比例扩大/缩小到View的宽度，居中显示 FIT_END / fitEnd 把图片按比例扩大/缩小到View的宽度，显示在View的下部分位置 FIT_START / fitStart 把图片按比例扩大/缩小到View的宽度，显示在View的上部分位置 FIT_XY / fitXY 把图片 不按比例 扩大/缩小到View的大小显示 scaleType属性 scaleType说明 CENTER /center 在视图中心显示图片，并且不缩放图片 CENTER_CROP / centerCrop 按比例缩放图片，使得图片长 (宽)的大于等于视图的相应维度 CENTER_INSIDE / centerInside 按比例缩放图片，使得图片长 (宽)的小于等于视图的相应维度 FIT_CENTER / fitCenter 按比例缩放图片到视图的最小边，居中显示 FIT_END / fitEnd 按比例缩放图片到视图的最小边，显示在视图的下部分位置 FIT_START / fitStart 把图片按比例扩大/缩小到视图的最小边，显示在视图的上部分位置 FIT_XY / fitXY 把图片不按比例缩放到视图的大小显示 MATRIX / matrix 用矩阵来绘制 ","date":"2021-05-01","objectID":"/android-note/:16:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"end ","date":"2021-05-01","objectID":"/android-note/:17:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total"],"content":"详细解释Android中drawable和drawable-v24的区别","date":"2021-04-30","objectID":"/android-diff-drawable-v24/","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"今天调试一个软件，老是找不到资源 android.content.res.Resources$NotFoundException: Resource 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 7.0的关于图片资源的改变 从Android API 24（安卓7.0）开始，自定义Drawables类可以最终在XML中使用（仅在您的包中）。 8.0的关于图片资源的改变 API 26（安卓8.0）中添加了VectorDrawable自适应图标 更多解释 ","date":"2021-04-30","objectID":"/android-diff-drawable-v24/:0:0","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"Android应用使用Kolin开发，解决Kolin：A problem occurred evaluating project ':app'.","date":"2021-04-20","objectID":"/android-kolin/","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total"],"content":"报错 Build file 'C:\\All_Code\\AS_Code\\Bottom-Navigation\\Material-BottomNavigation\\app\\build.gradle' line: 2 A problem occurred evaluating project ':app'. \u003e java.lang.ExceptionInInitializerError (no error message) 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中发现原来的Kolin插件使用了$，我并未配置Kolin环境，因此找不到 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } 访问Gradle官网仓库，我修改为最新版本 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.0-M2\" } 编译运行OK ","date":"2021-04-20","objectID":"/android-kolin/:0:0","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换","date":"2021-04-04","objectID":"/android-bottom-navigation/","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:0:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"1、原型图 顶部一个导航栏，，加号按钮的下拉菜单，下面是四个Tab页面，点击下方按钮，每个页面的上下两个导航栏之间的内容会随之发生变化，同时点击状态下的图标样式也随之变化。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:1:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"2、需求 请根据课堂展示结果设计APP门户界面，包含4个tab切换效果。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:2:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"3、思路 为了使用上课讲到的Material Design设计模式，我们分别使用了TopAppBar，一个ButtomNavigationMenu以及四个Fragment。同时采用了java语言作为点击按钮后界面内容的改变控制 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:3:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.1、创建一个Empty项目 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.2、页面-activity_main.xml-四个界面的主（公共）组件 根据官方文档，导航栏有四种模式，auto、labeled、selected、unlabeled,对应关系如下 参数 解释 auto 当有3个或更少的项目时，标签的行为为“labeled”；当有4个或更多的项目时，标签的行为为“selected”。 labeled 标签显示在所有导航项目上 selected（default） 标签显示在所选的导航项目上。（默认） unlabeled 标签未显示在任何导航项目上。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:visibility=\"visible\" tools:context=\".MainActivity\"\u003e \u003cLinearLayout android:id=\"@+id/linearLayout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintBottom_toTopOf=\"@+id/bottom_navigation_menu\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"\u003e \u003cFrameLayout android:id=\"@+id/frameLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e \u003ccom.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/bottom_navigation_menu\" style=\"@style/Widget.MaterialComponents.BottomNavigationView.Colored\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:labelVisibilityMode=\"labeled\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"1.0\" app:layout_constraintStart_toStartOf=\"parent\" app:menu=\"@menu/bottom_navigation_menu\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.3、页面-fragment_ctt.xml-联系人组件（朋友、信息、设置都差不多，不再过多展示，GitHub源码地址在本文最后） \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MesFragment\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/cttText\" /\u003e \u003c/FrameLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.4、页面-bottom_navigation_menu.xml-底部导航栏组件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"\u003e \u003citem android:id=\"@+id/page_Mes\" android:enabled=\"true\" android:icon=\"@drawable/tab_weixin_normal\" android:title=\"@string/message\" /\u003e \u003citem android:id=\"@+id/page_Fri\" android:enabled=\"true\" android:icon=\"@drawable/tab_find_frd_normal\" android:title=\"@string/friends\" /\u003e \u003citem android:id=\"@+id/page_Ctt\" android:enabled=\"true\" android:icon=\"@drawable/tab_address_normal\" android:title=\"@string/contacts\" /\u003e \u003citem android:id=\"@+id/page_Set\" android:enabled=\"true\" android:icon=\"@drawable/tab_settings_normal\" android:title=\"@string/settings\" /\u003e \u003c/menu\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.5、页面-color.xml-颜色配置文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources\u003e \u003ccolor name=\"purple_200\"\u003e#FFBB86FC\u003c/color\u003e \u003ccolor name=\"purple_500\"\u003e#FF6200EE\u003c/color\u003e \u003ccolor name=\"purple_700\"\u003e#FF3700B3\u003c/color\u003e \u003ccolor name=\"teal_200\"\u003e#FF03DAC5\u003c/color\u003e \u003ccolor name=\"teal_700\"\u003e#FF018786\u003c/color\u003e \u003ccolor name=\"black\"\u003e#FF000000\u003c/color\u003e \u003ccolor name=\"white\"\u003e#FFFFFFFF\u003c/color\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:5","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.6、页面-strings.xml-文字字符串配置文件 \u003cresources\u003e \u003c!-- app标题--\u003e \u003cstring name=\"app_name\"\u003e微信80.0\u003c/string\u003e \u003c!-- 导航栏标题--\u003e \u003cstring name=\"message\"\u003e信息\u003c/string\u003e \u003cstring name=\"friends\"\u003e朋友\u003c/string\u003e \u003cstring name=\"contacts\"\u003e联系人\u003c/string\u003e \u003cstring name=\"settings\"\u003e设置\u003c/string\u003e \u003c!-- 界面二级标题--\u003e \u003cstring name=\"mesText\"\u003e这是信息页面！\u003c/string\u003e \u003cstring name=\"friText\"\u003e这是朋友页面！\u003c/string\u003e \u003cstring name=\"cttText\"\u003e这是联系人页面！\u003c/string\u003e \u003cstring name=\"setText\"\u003e这是设置页面！\u003c/string\u003e \u003c!-- TODO: Remove or change this placeholder text --\u003e \u003cstring name=\"hello_blank_fragment\"\u003eHello blank fragment\u003c/string\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:6","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.7、页面-theme.xml-主题配置文件 \u003cresources xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"Theme.Bottom_Navigation\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\"\u003e \u003c!-- Primary brand color. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/purple_500\u003c/item\u003e \u003citem name=\"colorPrimaryVariant\"\u003e@color/purple_700\u003c/item\u003e \u003citem name=\"colorOnPrimary\"\u003e@color/white\u003c/item\u003e \u003c!-- Secondary brand color. --\u003e \u003citem name=\"colorSecondary\"\u003e@color/teal_200\u003c/item\u003e \u003citem name=\"colorSecondaryVariant\"\u003e@color/teal_700\u003c/item\u003e \u003citem name=\"colorOnSecondary\"\u003e@color/black\u003c/item\u003e \u003c!-- Status bar color. --\u003e \u003citem name=\"android:statusBarColor\" tools:targetApi=\"l\"\u003e?attr/colorPrimaryVariant\u003c/item\u003e \u003c!-- Customize your theme here. --\u003e \u003c/style\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:7","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.8后台-MainActivity.java-控制逻辑代码 package cn.edu.hubu.lhy.bottom_navigation; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentTransaction; import android.os.Bundle; import android.view.Menu; import android.view.MenuInflater; import android.view.MenuItem; import android.widget.Toast; import com.google.android.material.bottomnavigation.BottomNavigationView; public class MainActivity extends AppCompatActivity { private MesFragment mesFragment = null; private FriFragment friFragment = null; private CttFragment cttFragment = null; private SetFragment setFragment = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView bottom_navigation_menu = (BottomNavigationView) findViewById(R.id.bottom_navigation_menu); bottom_navigation_menu.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); mesFragment = new MesFragment(); changeFrameLayout(\"您好\", mesFragment); } private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.page_Mes: if (mesFragment == null) { mesFragment = new MesFragment(); } changeFrameLayout(\"信息\", mesFragment); return true; case R.id.page_Fri: if (friFragment == null) { friFragment = new FriFragment(); } changeFrameLayout(\"朋友\", friFragment); return true; case R.id.page_Ctt: if (cttFragment == null) { cttFragment = new CttFragment(); } changeFrameLayout(\"联系人\", cttFragment); return true; case R.id.page_Set: if (setFragment == null) { setFragment = new SetFragment(); } changeFrameLayout(\"设置\", setFragment); return true; } return false; } }; /** * 使用Fragment组件替换原界面上的FragLayout * * @param string 提示信息 * @param fraGment 要替换成的fragment */ private void changeFrameLayout(String string, Fragment fraGment) { //弹窗 Toast.makeText(MainActivity.this, string, Toast.LENGTH_SHORT).show(); //每一次都要重新创建事务和管理工具 FragmentManager fagmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fagmentManager.beginTransaction(); //替换操作 fragmentTransaction.replace(R.id.frameLayout, fraGment); //事务具有原子性，类似数据库，每一次操作完成需要提交操作 fragmentTransaction.commit(); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:8","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.9、后台-CttFragment.java-联系人组件代码 创建Fragment自动生成的构造方法、newInstance()、onCreate()方法啊需要禁掉不然会产生一些问题 package cn.edu.hubu.lhy.bottom_navigation; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; /** * A simple {@link Fragment} subclass. * Use the {@link FriFragment#newInstance} factory method to * create an instance of this fragment. */ public class FriFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_fri, container, false); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:9","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.1、信息页面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.2、朋友界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.3、联系人界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.4、设置界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"6、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design ","date":"2021-04-04","objectID":"/android-bottom-navigation/:6:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total"],"content":"解决Android App界面与顶部状态栏重叠遮盖问题的方法","date":"2021-03-22","objectID":"/android-topbar-cover/","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Total"],"content":"问题情况截图如下： 觉得toolbar默认高度太高，给toolbar设了一个固定值。测试时发现在4.4系统上会出现与状态栏重叠的现象。给toolbar设了个margin，但是在7.0的系统上又会出现间隙。最后发现只需要在父view里加上下面两行就解决了。 android:clipToPadding=“true” android:fitsSystemWindows=“true” 解释一下上面两个布局属性的意思： android:clipToPadding 定义布局间是否有间距 android:fitsSystemWindows=“true” 意思就是设置应用布局时是否考虑系统窗口布局；如果为true，将调整系统窗口布局以适应你自定义的布局。比如系统有状态栏，应用也有状态栏时。实际就是通过在 View 上设置和系统窗口一样高度的边框（padding）来确保你的内容不会出现到系统窗口下面。 或只 在layout的主布局中加入 android:fitsSystemWindows=“true” 如下： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\" tools:context=\".MainActivity\"\u003e \u003c!-- 布局内容...... --\u003e \u003c/LinearLayout\u003e ","date":"2021-03-22","objectID":"/android-topbar-cover/:0:0","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Software"],"content":"解决AndroidStudio开发Android-Java应用的网络问题","date":"2021-03-15","objectID":"/android-net-error/","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio 网络问题","uri":"/android-net-error/"},{"categories":["Software"],"content":"Android Studio 教你修改Maven仓库地址为国内镜像 android studio 默认国外maven 这我们更改为阿里的maven 打开build.gradle 添加或者修改 allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } }修改buildscript { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' } } 这里有阿里的仓库http://maven.aliyun.com/mvn/view`可以自行查看和替换，速度都比国外快 如图所示 ","date":"2021-03-15","objectID":"/android-net-error/:1:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio 网络问题","uri":"/android-net-error/"},{"categories":["Software"],"content":"Android Studio released aar to Jcenter, plug-in could not be found 导入项目控制台报错 Unknown host ‘raw.githubusercontent.com’. You may need to adjust the proxy settings in Gradle. 似乎raw.githubusercontent.com被dns污染了，使用站长工具ping改host做前置代理也无法访问，使用站长工具查ip改host也识别不到，甚至用了魔法，可能AS自己有网络通讯，使用代理依然无效。被迫使用下面的办法（其实可以直接删除，不影响项目运行，据说是文档文件）,该方法适用所有此域名导包问题 获取源码 有大佬上传到GitHub：installv1.gradle、bintrayv1.gradle，或者使用魔法，浏览器访问（我只使用了这一种办法成功访问了）网址获取 bintrayv1.gradle apply plugin: 'com.jfrog.bintray' version = libraryVersion if (project.hasProperty(\"android\")) { // Android libraries task sourcesJar(type: Jar) { classifier = 'sources' from android.sourceSets.main.java.srcDirs } task javadoc(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } } else { // Java libraries task sourcesJar(type: Jar, dependsOn: classes) { classifier = 'sources' from sourceSets.main.allSource } } task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir } artifacts { archives javadocJar archives sourcesJar } // Bintray Properties properties = new Properties() properties.load(project.rootProject.file('local.properties').newDataInputStream()) bintray { user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg { repo = bintrayRepo name = bintrayName desc = libraryDescription websiteUrl = siteUrl vcsUrl = gitUrl licenses = allLicenses publish = true publicDownloadNumbers = true version { desc = libraryDescription gpg { sign = true //Determines whether to GPG sign the files. The default is false passphrase = properties.getProperty(\"bintray.gpg.password\") //Optional. The passphrase for GPG signing' } } } } installv1.gradle apply plugin: 'com.github.dcendents.android-maven' group = publishedGroupId // Maven Group ID for the artifact install { repositories.mavenInstaller { // This generates POM.xml with proper parameters pom { project { packaging 'aar' groupId publishedGroupId artifactId artifact // Changed case // Add your description here name libraryName description libraryDescription url siteUrl // Set your license licenses { license { name licenseName url licenseUrl } } developers { developer { id developerId name developerName email developerEmail } } scm { connection gitUrl developerConnection gitUrl url siteUrl } } } } } 在项目中手动创建installv1.gradle、bintrayv1.gradle文件，我把他们放在项目目录下的library文件夹中，手动拷贝相关的源码 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中修改原来的引用（注释或者删除） //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle' //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle' apply from: \"../library/installv1.gradle\" apply from: \"../library/bintrayv1.gradle\" 重新build即可 ","date":"2021-03-15","objectID":"/android-net-error/:2:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio 网络问题","uri":"/android-net-error/"},{"categories":["Software"],"content":"end ","date":"2021-03-15","objectID":"/android-net-error/:3:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio 网络问题","uri":"/android-net-error/"},{"categories":["Total"],"content":"在AndroidStudio中使用Java开发Android应用-版本更替不兼容报各种错误的修正","date":"2021-03-03","objectID":"/android-incompatible-version/","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"CardView、RecyclerView在buildTools28-\u003e30用法改变 Android开发 CardView卡片视图、RecyclerView回收视图 注意开发工具从28变为30以后即src目录下的bulid.grade文件中的buildTools版本改变 android { compileSdkVersion 28 buildToolsVersion \"28.0.0\" } android { compileSdkVersion 30 buildToolsVersion \"30.0.3\" } CardView、RecyclerView都发生了使用变化 引用： app目录下的bulid.grade文件中依赖dependencies改变 只要将implementation ‘com.android.support:cardview-v7:28.0.0’换成implementation ‘androidx.cardview:cardview’就行了（recyclerview类似改变）； 原因：版本28（面向android pie及以下版本）是遗留支持库的最后一个版本，因此我们建议您在使用android q并继续前进时迁移到androidx库。IDE可以帮助您：重构\u003e迁移到AndroidX…， dependencies { implementation 'com.android.support:cardview-v7:28.0.0' implementation 'com.android.support:recyclerview-v7:28.0.0' } dependencies { implementation \"androidx.cardview:cardview:1.0.0\" implementation \"androidx.recyclerview:recyclerview:1.1.0\" // For control over item selection of both touch and mouse driven selection implementation \"androidx.recyclerview:recyclerview-selection:1.1.0\" } 依赖请看官方文档Cardview、RecyclerView XML文件 主要是CardView、RecyclerView的标题 原来CardView \u003candroid.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_marginRight=\"5dp\" android:layout_marginTop=\"5dp\" android:elevation=\"5dp\" app:cardCornerRadius=\"5dp\"\u003e \u003c/android.support.v7.widget.CardView\u003e RecyclerView \u003candroid.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/android.support.v7.widget.RecyclerView\u003e 变为CardView‘ \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003candroidx.cardview.widget.CardView android:id=\"@+id/card_view\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\"\u003e \u003cTextView android:id=\"@+id/content1\" android:text=\"内容\" android:gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/\u003e \u003c/androidx.cardview.widget.CardView\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e RecyclerView’ \u003c!-- 你的可能是这样的--\u003e \u003candroid.support.v7.widget.RecyclerView \u003c!-- 这才是对的--\u003e \u003candroidx.recyclerview.widget.RecyclerView \u003c!-- xxx--\u003e \u003c!-- xxx--\u003e .../\u003e ","date":"2021-03-03","objectID":"/android-incompatible-version/:1:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Failed to find Build Tools revision 26.0.1 Error:A problem occurred configuring project ':app'. \\\u003e Failed to find Build Tools revision 26.0.1 在build.gradle 中buildToolsVersion 如何修改。看本地安装了哪些版本的 进入文件夹Android SDK 目录下build-tools，修改为里面有的版本 ","date":"2021-03-03","objectID":"/android-incompatible-version/:2:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find method google() for arguments [] on repository container. 问题： 在react native中安装realm数据库后运行react-native run-android 时报如下错： 开发环境： react-native:^0.55.4 reaml:^2.27.0 解决方案： 1、打开项目根目录下android/gradle/wrapper/gradle-wrapper.properties 将distributionUrl=https://services.gradle.org/distributions/gradle-2.14.1-all.zip中的2.14.1改成4.1 2、打开项目根目录下的android/build.gradle 1）、在buildscript和allprojects下的repositories分别添加google() 2）、将dependencies中的classpath ‘com.android.tools.build:gradle:2.2.3’中的2.2.3【具体看自己的是多少】改成3.0.1 重新运行编译项目命令，要下载新的gradle，这个过程有点慢。至此，问题已解决！ ","date":"2021-03-03","objectID":"/android-incompatible-version/:3:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find com.android.support:appcompat-v7:25.0.0 老的Android工程导入as报错如下： 10:36 Gradle sync failed: Could not find com.android.support:appcompat-v7:25.0.0. Required by: FuNongTong:app:unspecified (18 s 207 ms) 如果是gradle4.0及以下，增加maven { url “https://maven.google.com” }，如下： buildscript { repositories { jcenter() maven { url \"https://maven.google.com\" } } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() maven { url \"https://maven.google.com\" } } } 如果是gradle4.0及以上，maven { url “https://maven.google.com” }替换为google() 如下： buildscript { repositories { jcenter() google() } } allprojects { repositories { jcenter() google() } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:4:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=M android studio升级到3.1.4之后gradle里的很多配置也相应发生了一些改变。在打包的时候我就遇到了这样的问题。 报错为：Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 截图如下： 大家可以注意看一下，AS升级到3.0以上版本后，截图上的红框处的代码都要改动，否则是无法正常打包的。那要改成什么样呢，如下图所示： 改成上图所示的样子就可以正常打包了，另外我也把代码贴出来方便大家复制。 //打包后应用名称 applicationVariants.all { variant -\u003e variant.outputs.all { output -\u003e def outputFile = output.outputFile def fileName if (outputFile != null \u0026\u0026 outputFile.name.endsWith('.apk')) { if (variant.buildType.name.equals('release')) {//如果是release包 fileName = \"anjian_release_v${defaultConfig.versionName}.apk\" } else if (variant.buildType.name.equals('debug')) {//如果是debug包 fileName = \"anjian_debug_v${defaultConfig.versionName}.apk\" } outputFileName = fileName } } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:6:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"build.grade.dependence随版本引用关键字改变 // testCompile-\u003etestImplementation // compile-\u003eimplementation // provided-\u003ecompileOnly ","date":"2021-03-03","objectID":"/android-incompatible-version/:7:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use ‘annotationProce AS从2.3.3升级到3.0后，项目没有任何改动就出现了这个错误，解决步骤如下： 一、把module/build.gradle下的apt插件应用全部注释掉 二、把dependencies下的apt全部改为annotationProcessor annotationProcessor 在as最新版本也失效，要如下操作 annotationProcessor ‘org.projectlombok:lombok:1.18.6’ 修改为 compile ‘org.projectlombok:lombok:1.18.6’ 即可 三、把project/build.gradle中的apt插件声明注释 ","date":"2021-03-03","objectID":"/android-incompatible-version/:8:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"更新Gradle项目时报错Gradle sync failed: Unsupported method: BaseConfig.getApplicationIdSuffix 查看Android Gradle 插件版本说明。 https://developer.android.google.cn/studio/releases/gradle-plugin.html#updating-plugin 修改对应的项目根目录下的build.gradle的依赖（dependencies）下的gradle的build工具版本 dependencies {classpath \"com.android.tools.build:gradle:4.1.3\"} 和项目根目录下的gradle文件夹中的wrapper文件夹中的build.gradle文件中的gradle版本 distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip 注意：第一个文件要在原来jcenter（）位置加上google（） repositories{ google() jcenter()} ","date":"2021-03-03","objectID":"/android-incompatible-version/:9:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not resolve all files for configuration ‘:app:debugRuntimeClasspath’. Could not find com.android.support:appcompat-v7:23.2.1. Searched in the following locations: repositories { google() maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'}//加上这行 //jcenter() } ","date":"2021-03-03","objectID":"/android-incompatible-version/:10:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"修改\"targetSdkVersion\"和\"compileSdkVersion\" 为30报错\"NoSuchMethodException\" error for class “android.graphics.FontFamily” ","date":"2021-03-03","objectID":"/android-incompatible-version/:11:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"报错 如题修改gradle文件中版本问题报错如下 2020-06-22 13:43:21.205 14538-14538/com.gravty.everyday W/gravty.everyda: Accessing hidden method Landroid/graphics/FontFamily;-\u003e()V (greylist-max-q, reflection, denied) 2020-06-22 13:43:21.206 14538-14538/com.gravty.everyday E/TypefaceCompatApi26Impl: Unable to collect necessary methods for class java.lang.NoSuchMethodException java.lang.NoSuchMethodException: android.graphics.FontFamily. [] at java.lang.Class.getConstructor0(Class.java:2332) at java.lang.Class.getConstructor(Class.java:1728) at androidx.core.graphics.TypefaceCompatApi26Impl.obtainFontFamilyCtor(TypefaceCompatApi26Impl.java:321) at androidx.core.graphics.TypefaceCompatApi26Impl.(TypefaceCompatApi26Impl.java:84) at androidx.core.graphics.TypefaceCompatApi28Impl.(TypefaceCompatApi28Impl.java:36) at androidx.core.graphics.TypefaceCompat.(TypefaceCompat.java:47) at androidx.core.graphics.TypefaceCompat.findFromCache(TypefaceCompat.java:76) at androidx.core.content.res.ResourcesCompat.loadFont(ResourcesCompat.java:393) at androidx.core.content.res.ResourcesCompat.loadFont(ResourcesCompat.java:361) at androidx.core.content.res.ResourcesCompat.getFont(ResourcesCompat.java:339) at androidx.appcompat.widget.TintTypedArray.getFont(TintTypedArray.java:119) at androidx.appcompat.widget.AppCompatTextHelper.updateTypefaceAndStyle(AppCompatTextHelper.java:430) at androidx.appcompat.widget.AppCompatTextHelper.loadFromAttributes(AppCompatTextHelper.java:204) at androidx.appcompat.widget.AppCompatTextView.(AppCompatTextView.java:105) at androidx.appcompat.widget.AppCompatTextView.(AppCompatTextView.java:95) at androidx.appcompat.app.AppCompatViewInflater.createTextView(AppCompatViewInflater.java:182) at androidx.appcompat.app.AppCompatViewInflater.createView(AppCompatViewInflater.java:103) at androidx.appcompat.app.AppCompatDelegateImpl.createView(AppCompatDelegateImpl.java:1407) at androidx.appcompat.app.AppCompatDelegateImpl.onCreateView(AppCompatDelegateImpl.java:1457) at android.view.LayoutInflater.tryCreateView(LayoutInflater.java:1059) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:995) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:959) at android.view.LayoutInflater.rInflate(LayoutInflater.java:1121) at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:1082) at android.view.LayoutInflater.parseInclude(LayoutInflater.java:1261) at android.view.LayoutInflater.rInflate(LayoutInflater.java:1117) at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:1082) at android.view.LayoutInflater.inflate(LayoutInflater.java:680) at android.view.LayoutInflater.inflate(LayoutInflater.java:532) at android.view.LayoutInflater.inflate(LayoutInflater.java:479) at androidx.appcompat.app.AppCompatDelegateImpl.setContentView(AppCompatDelegateImpl.java:555) at androidx.appcompat.app.AppCompatActivity.setContentView(AppCompatActivity.java:161) at com.gravty.everyday.views.activities.LoginActivity.onCreate(LoginActivity.java:53) at android.app.Activity.performCreate(Activity.java:7989) at android.app.Activity.performCreate(Activity.java:7978) ","date":"2021-03-03","objectID":"/android-incompatible-version/:11:1","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"解决办法 法1 添加一个稳定的核心库implementation 'androidx.core:core:1.3.0' (https://developer.android.com/jetpack/androidx/releases/core) 在gradle build文件中 法2 如果使用了Appcompat库可以用其中的i.e. androidx.appcompat:appcompat:1.3.1 (https://developer.android.com/jetpack/androidx/releases/appcompat#version_131_3) 法3 或者委屈求全改回原来的版本如28https://developer.android.com/topic/libraries/support-library/packages#v4 ","date":"2021-03-03","objectID":"/android-incompatible-version/:11:2","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"end ","date":"2021-03-03","objectID":"/android-incompatible-version/:12:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信实例讲解（通过获取对象，调用方法）","date":"2021-03-01","objectID":"/android-activity-fragment-connect/","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信 效果显现： 实现步骤： 1.创建MainActivity，FragmentA，FragmnetB在activity_main.xml中静态加载FragmentA，FragmnetB 2.在MainActivity中获取FragmentA对象，再用对象，调用FragmentA中的方法，实现Activity与Fragment通信之间的通信 3.在FragmentA中获取MainActivity的对象，在通过MainActivity的对象获取FragmnetB对象，最后调用FragmnetB中方法，实现Fragment之间互相通信。 代码实现： 1.创建FragmentA，FragmnetB和相应的布局，这里我就不多解释了： 1.a_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#d41313\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is a fragent\" android:gravity=\"center\"/\u003e \u003cTextView android:id=\"@+id/a_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:text=\"show text\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/a_frag_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/a_frag_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentB\"/\u003e \u003c/LinearLayout\u003e 2.FragmentA： public class FragmentA extends Fragment { private TextView showTv; private EditText toBEt; private Button toBBtn; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.a_fragment, container, false); bindID(view); return view; } private void bindID(View view) { showTv = view.findViewById(R.id.a_frag_tv); toBEt = view.findViewById(R.id.a_frag_et); toBBtn = view.findViewById(R.id.a_frag_btn); } } 3.b_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#3dd526\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"this is b fragment\" android:textColor=\"#fff\" android:background=\"#000\" android:textSize=\"25sp\"/\u003e \u003cTextView android:id=\"@+id/b_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"show text\" android:textSize=\"25sp\"/\u003e \u003c/LinearLayout\u003e 4.FragmentB： public class FragmentB extends Fragment { private TextView showTv; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.b_fragment,container,false); showTv = view.findViewById(R.id.b_frag_tv); return view; } } 2.在activity_main.xml中加载之前的两个碎片： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" tools:context=\"com.example.communicationfragment.MainActivity\"\u003e \u003cLinearLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:layout_weight=\"1\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is Activity\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/main_to_a_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/main_to_a_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentA\"/\u003e \u003c/LinearLayout\u003e \u003cFrameLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\"\u003e \u003cfragmen","date":"2021-03-01","objectID":"/android-activity-fragment-connect/:1:0","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Total","note"],"content":"Android Studio 开发Android App时需要修改项目名称和包名方法","date":"2021-02-28","objectID":"/androidstudio-rename/","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":" 平时项目开发中，有时候维护项目多，有的项目结构需要改变，这就需要我们去修改项目名称或者修改包名。下面介绍一下怎样修改项目名称和包名。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:0:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"1. 修改项目名称 1）打开项目根目录下的setting.gradle文件，修改该文件中的rootProject.name='新项目名'； 2）点击 Sync Now 重新编译项目； ★ 如果只是简单修改至此，会发现项目名称后依然备注着旧项目名，并没有彻底更换新的项目名。紧接着下面操作： 3）关闭 Android Studio； 4）修改项目所在路径的文件名为新的项目名； 5）打开AS，重新导入修改后的项目即可； ★ 如果是 AS 4.0之后 的版本，修改至此就算修改完成；如果是 AS 4.0之前 的版本，会出现一些配置文件信息还是引用原来的项目名，并没有更换为新的项目名。紧接着下面操作： 6）找到项目根目录下的xx.iml文件，右键 Refactor —— Rename 打开修改编辑框； 7）输入新的项目名，点击 Refactor 修改； 8）打开项目根目录下的xx.iml文件，修改该文件中的project.id字段：external.linked.project.id=\"新项目名\" 9）打开项目下.idea/modules.xml文件，修改该文件中的fileurl和filepath字段：\u003cmodule fileurl=\"file://$PROJECT_DIR$/新项目名.iml\" filepath=\"$PROJECT_DIR$/新项目名.iml\" /\u003e 10）点击 Rebuild Project 重构项目，即可修改完成项目名称。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:1:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"2. 修改项目包名 1）选中项目中药修改的包名； 2）更改项目结构显示方式，取消 Compact Middle Packages 选项； 3）右键要修改的包名，选择 Refactor —— Rename 打开修改编辑框； 4）点击 Rename package 修改包名； 5）输入新的包名，点击 Refactor 修改； 6）点击 Do Refactor 确定修改； 7）打开项目 app/main 目录下的AndroidManifest.xml文件，修改该文件中的package=\"新包名\"字段； 8）修改项目 app 下的 build.gradle 中的applicationId \"新包名\"字段； 9）点击 Sync Now 同步，即可修改完成项目包名。 注意： 修改完包名，项目出现错误无法运行，解决方法请移步 —— 《Android Studio修改包名导致引用R文件报错问题》 ","date":"2021-02-28","objectID":"/androidstudio-rename/:2:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total"],"content":"Android Studio 导入图片标红,记录图片文件命名规则","date":"2021-02-09","objectID":"/androidstudio-picture-error/","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":" as图片不能使用\"-\"，只能使用\"_“代替 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:0:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况一 直接修改会直接提示不能带有”-\" ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:1:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况二 在系统资源管理器中拷贝进带\"-“的文件名的图片，标红报错 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:2:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"记录findViewById返回null的常见原因和解决办法","date":"2021-02-01","objectID":"/android-findviewbyid-null/","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["Total"],"content":"1.在另一个view的元素应该用baseView.findViewById()来拿 findViewById()是要指定view的，也就是说你要找的view 必须是包含在baseView里面的布局（控件） 如果在该父控件下找不到，就会报null。 2.findViewById在setContentView(R.layout.main);之前.即在setContentView调用之前，view要从父类布局里面找，父类布局还没有加载之前找，必然会返回空。 3.写的该布局（控件） ，还没有保存，导致工具不能加载到。自然也是null； 4.工具出现异常，这就是很偶然的情况，一般clean、重启 ","date":"2021-02-01","objectID":"/android-findviewbyid-null/:0:0","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["documentation","note"],"content":"Hogo使用CodeIT主题并配置Algolia作为站内搜索","date":"2021-01-10","objectID":"/hugo-algolia/","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置，以中文配置作为示例 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"KKKPJSKEY's-Case-Archives\" appID = \"algolia.com.API Keys.Application ID\" searchKey = \"algolia.com.API Keys.Admin API Key\" ","date":"2021-01-10","objectID":"/hugo-algolia/:1:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2 Algolia 配置 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “example”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.2 我这里选择香港作为存储地区 查看自己的网速 选择网速较快的地区 点击下一步 勾选 勾选 点击创建 我就跳过新手教程了 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面（见2.1） ","date":"2021-01-10","objectID":"/hugo-algolia/:2:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.2 安装 atomic-algolia（在任意目录下） npm -g install atomic-algolia --save ","date":"2021-01-10","objectID":"/hugo-algolia/:3:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.3 创建 .env 文件存放 algolia 配置（在网站根目录下） ALGOLIA_APP_ID=\"algolia.com.API Keys.Application ID\" ALGOLIA_ADMIN_KEY=\"algolia.com.API Keys.Admin API Key\" ALGOLIA_INDEX_NAME=\"example\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-01-10","objectID":"/hugo-algolia/:3:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.4 修改网站根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-01-10","objectID":"/hugo-algolia/:3:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:5","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.脚本 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.1定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.2我的脚本 分析可知仅上传流程中需要两步顺序操作，其他调试普通指令一步基本可以解决，故略去其他脚本，仅使用生成索引并上传，将GitHub Pages上传至Github仓库两步操作脚本 update.sh #!/bin/sh # If a command fails then the deploy stops set -e update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull origin master # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push origin master fi } update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.3我的最新脚本 脚本顺序弄错，应该先生成Hugo页面，再生成algolia 索引，最后将页面推上去就行 update.sh #!/bin/sh # If a command fails then the deploy stops set -e generate_pages(){ hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m已经重新生成 hugo 页面！！！\\033[0m\\n\" } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia 索引！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push fi } generate_pages update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"5结果 仓库代码检验： algolia 的索引: ","date":"2021-01-10","objectID":"/hugo-algolia/:5:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2021-01-01","objectID":"/hugo-github/","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"近些年GoLang语言逐渐火爆起来，Golang语言所做的静态博客固然也映入眼帘。相比于动态博客，静态博客的好处不言而喻，开发难度极低，不需要后台和数据库，更不需要昂贵的服务器成本和花费运维成本去维护。应老师要求以及个人未来发展，故学习静态博客的部署(补充，最近挖矿潮，比特币价格上涨，对于我等穷人，服务器的开销还是能省一点是一点)。本文因此介绍hugo和GitHub.io的初次使用搭建个人博客 ","date":"2021-01-01","objectID":"/hugo-github/:0:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1 本地部署blog ","date":"2021-01-01","objectID":"/hugo-github/:1:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.1 快速开始 1.1.1、安装方法介绍 hugo_GitHub:https://github.com/gohugoio/hugo Official_Website:https://gohugo.io/ 不同的操作系统有着不同的安装方式，官方推荐Linux或者Mac下可以使用brew或者port 进行安装Windows推荐使用Chocolatey或者Scoop进行安装，或者使用GitHub中的源码进行安装，我选择GitHub的Relaeases包进行安装，因为它不需要其他包管理工具进行安装。其他安装方式请参阅官方安装文档 https://gohugo.io/getting-started/installing 可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或csdn相关加速服务~~，甚至孙悟空的魔法~~ git clone [ssh address][http address] #示例 git clone git@github.com:gohugoio/hugo.git #SSH #或者 git clone https://github.com/gohugoio/hugo.git #HTTP 1.1.2、我的办法 https://github.com/gohugoio/hugo/releases此链接选择最新版，选择对应系统版本下载即可（我的是windows） 下载后进行解压只有三个文件，个人将hugo.exe文件放入bin目录，将网站问建放入sites目录，其他文件放在根目录 在当前目录执行（未配置环境变量） 任意处执行（配置环境变量） cd bin hugo version 单击环境变量（1），创建HOGO_HOME（2），填写路径（3），在原来Path下（4）添加bin目录（5） 执行命令后有类似返回结果（6）说明安装hugo成功（在系统环境变量中（Windows可以在Cotana直接搜索环境变量）） ","date":"2021-01-01","objectID":"/hugo-github/:1:1","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.2 创建网站 #返回上一级目录下的网站目录 cd ../sites hugo new site [site nme] #示例 hugo new site KKKPJSKEY's-Case-Archives ","date":"2021-01-01","objectID":"/hugo-github/:1:2","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.3 选择主题 在https://themes.gohugo.io/这个网址选择你喜欢的主题 https://themes.gohugo.io/material-design/这是我的选择 点击download进入对应的GitHub页面，可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或Csdn相关加速服务~~，甚至孙悟空的魔法~~ #切换到新建的网站目录下 cd KKKPJSKEY's-Case-Archives git clone [ssh address][http address] #示例 git clone git@github.com:pdevty/material-design.git themes/material-design #SSH #或者 git clone https://github.com/pdevty/material-design.git themes/material-design #HTTP （自行下载的压缩请手动解压到theme目录） ","date":"2021-01-01","objectID":"/hugo-github/:1:3","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.4 配置主题 1.4.1、metadata 请将主题目录（1）下的默认配置文件（2）中的内容（3）与网站目录（4）下的默认配置文件（5）中的内容（6）进行整合，以网站目录下的默认配置文件为准，最终成河成（7）的样子即可 1.4.2、其他配置 将根目录（1）下的config.toml文件（2）中的内容改为自己网站的内容（3） 我个人主题配置如上图所示，其他配置请自行参照主题文档进行配置 ","date":"2021-01-01","objectID":"/hugo-github/:1:4","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.5 生成模板MarkDown（带有metadata） 注意metadata中不能使用英文的双引号,可以使用英文单引号或者中文单双引号代替 hugo new [类别]/[文件名] #示例 hugo new blog/使用hugo、GitHub.io搭建个人静态博客.md 执行以上指令即可在以下路径生成对应的文件content/类别/文件名（生成一次后也可手动在content/类别/文件名创建文件，手动拷贝对应的metadata）（这里没有切换路径，但必须在网站根目录下进行） ","date":"2021-01-01","objectID":"/hugo-github/:1:5","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.6编写MarkDown 项目中其他请参照MarkDown语法规范，其中图片需要注意：图片应放到网站根目录下的static中。我为了国立不同静态资源，创建了imags和文章名两级文件夹，图片在MarkDown中应使用，同时使用顺斜杠替换原来反斜杠， /[分类名]/[项目名]/图片名.格式 #个人分类法，非强制要求 #示例 ./1.png 同时使用顺斜杠替换原来反斜杠， ","date":"2021-01-01","objectID":"/hugo-github/:1:6","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.7 本地预览与部署 1.7.1、本地预览 hugo server [-D]（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 22 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 8 Sitemaps | 1 Cleaned | 0 Built in 52 ms Watching for changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 执行后在http://localhost:1313/可以进行访问（-D参数表示无论metadata（1.4.1）是否为true都进行发布，不加参数则只发布为false的项目，下面huge生成静态文件相同） 1.7.2、生成静态文件用于发布 使用hugo [-D]生成静态文件，-D参数在1.6.1介绍的功能相同（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 15 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 5s Sitemaps | 1 Cleaned | 0 Total in 167 ms 以上结果会在网站根目录下的public下生成静态页面 ","date":"2021-01-01","objectID":"/hugo-github/:1:7","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"2 GitHub创建仓库 来到GitHub主页https://github.com/（自行注册登录） 点击左上角新建仓库 输入自己的仓库名（1，我已经创建过不能使用相同的名字因此报错，仓库名没有格式限制，请自行发挥），设置仓库分类（2，公有是所有人能看到，私有是只有项目内成员能看到），点击创建即可（3） ","date":"2021-01-01","objectID":"/hugo-github/:2:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"3 使用Git提交生成的静态页面（1.6.2） #切换到网站名字下的public下 cd public #以下为git指令 ##git 初始化 git init ##添加当前目录下的所有文件到暂存区 git add [.][-u][-A][-all] ##提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息 git commit [-m \"{message}\"] ##从将本地的分支版本上传到远程并合并。 git push 详细Git教程、参数解释在Git笔记（填坑，挖新坑）中，请移步 ","date":"2021-01-01","objectID":"/hugo-github/:3:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"4在GitHub中进行页面展示设置 在你的仓库页面点击Settings（1），在新的页面向下滑动找到GitHub Pages下的Branch（2），选择master（3，或自己的分支），在对应的网址即可访问（4） ","date":"2021-01-01","objectID":"/hugo-github/:4:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"5 结语 至此使用hugo、Github.io搭建个人静态博客彻底完成 ","date":"2021-01-01","objectID":"/hugo-github/:5:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["Operation","note"],"content":"记录Docker常用指令的笔记","date":"2020-12-21","objectID":"/docker-command-note/","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"容器管理指令 # 进入docker容器内部 docker exec -it id /bash/bin # 退出容器 exit # 启动docker容器 sudo systemctl start docker # 设置docker容器开机启动 sudo systemctl enable docker ","date":"2020-12-21","objectID":"/docker-command-note/:1:0","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"记录CentOS7 查询的几种方式和区别解释","date":"2020-12-12","objectID":"/cnetos7-shell-search/","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"1. find 　Java代码 　find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。与查询数据库（/var/lib/locatedb）文件不同，find查找磁盘空间 　find的使用格式如下： $ find \u003c指定目录\u003e \u003c指定条件\u003e \u003c指定动作\u003e 　- \u003c指定目录\u003e: 所要搜索的目录及其所有子目录。默认为当前目录。 　- \u003c指定条件\u003e: 所要搜索的文件的特征。 　- \u003c指定动作\u003e: 对搜索结果进行特定的处理。 　如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。 　find的使用实例： $ find . -name 'my*' 　搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 $ find . -name 'my*' -ls 　搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。 $ find . -type f -mmin -10 　搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。 根据文件名查询 find -name [文件名] 根据文件夹名查询 find [文件夹名] ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:1:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"2. locate 　Java代码 　locate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 　locate命令的使用实例： $ locate /etc/sh 　搜索etc目录下所有以sh开头的文件。 $ locate ~/m 　搜索用户主目录下，所有以m开头的文件。 $ locate -i ~/m 　搜索用户主目录下，所有以m开头的文件，并且忽略大小写。 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:2:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"3. whereis 　Java代码 　whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。同locate一样，查询数据库（/var/lib/locatedb）文件 　whereis命令的使用实例： $ whereis grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:3:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"4. which 　Java代码 　which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 　which命令的使用实例： $ which grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:4:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"5. type 　Java代码 　type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 　type命令的使用实例： $ type cd 　系统会提示，cd是shell的自带命令（build-in）。 $ type grep 　系统会提示，grep是一个外部命令，并显示该命令的路径。 $ type -p grep 　加上-p参数后，就相当于which命令 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:5:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"记录Linux 文件与目录管理教程的笔记","date":"2020-11-27","objectID":"/linux-file-path-note/","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"引言 我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 在开始本教程前我们需要先知道什么是绝对路径与相对路径。 绝对路径： 路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:1:0","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"处理目录的常用命令 接下来我们就来看几个常见的处理目录的命令吧： ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:0","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"ls (列出目录) 在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 [root@www ~]# ls [--color={never,auto,always}] 目录名称 [root@www ~]# ls [--full-time] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将家目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:1","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"cd (切换目录) cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对路径或绝对路径] #使用 mkdir 命令创建 runoob 目录 [root@www ~]# mkdir runoob #使用绝对路径切换到 runoob 目录 [root@www ~]# cd /root/runoob/ #使用相对路径切换到 runoob 目录 [root@www ~]# cd ./runoob/ # 表示回到自己的家目录，亦即是 /root 这个目录 [root@www runoob]# cd ~ # 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思； [root@www ~]# cd .. 接下来大家多操作几次应该就可以很好的理解 cd 命令的。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:2","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"pwd (显示目前所在的目录) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 [root@www ~]# pwd [-P] 选项与参数： -P ：显示出确实的路径，而非使用连结 (link) 路径。 实例：单纯显示出目前的工作目录： [root@www ~]# pwd /root \u003c== 显示出目录啦～ 实例显示出实际的工作目录，而非连结档本身的目录名而已。 [root@www ~]# cd /var/mail \u003c==注意，/var/mail是一个连结档 [root@www mail]# pwd /var/mail \u003c==列出目前的工作目录 [root@www mail]# pwd -P /var/spool/mail \u003c==怎么回事？有没有加 -P 差很多～ [root@www mail]# ls -ld /var/mail lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -\u003e spool/mail # 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！ ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:3","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"mkdir (创建新目录) 如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 语法： mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 实例：请到/tmp底下尝试创建数个新目录看看： [root@www ~]# cd /tmp [root@www tmp]# mkdir test \u003c==创建一名为 test 的新目录 [root@www tmp]# mkdir test1/test2/test3/test4 mkdir: cannot create directory `test1/test2/test3/test4': No such file or directory \u003c== 没办法直接创建此目录啊！ [root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！ 实例：创建权限为 rwx–x–x 的目录。 [root@www tmp]# mkdir -m 711 test2 [root@www tmp]# ls -l drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。 如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:4","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"rmdir (删除空的目录) 语法： rmdir [-p] 目录名称 选项与参数： -p : 连同上一级『空的』目录也一起删除 删除 runoob 目录 [root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(/tmp 底下)删除掉！ [root@www tmp]# ls -l \u003c==看看有多少目录存在？ drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2 [root@www tmp]# rmdir test \u003c==可直接删除掉，没问题 [root@www tmp]# rmdir test1 \u003c==因为尚有内容，所以无法删除！ rmdir: `test1': Directory not empty [root@www tmp]# rmdir -p test1/test2/test3/test4 [root@www tmp]# ls -l \u003c==您看看，底下的输出中test与test1不见了！ drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。 不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:5","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"cp (复制文件或目录) cp 即拷贝文件和目录。 语法: [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -p : 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d : 若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f : 为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i : 若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l : 进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p : 连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r : 递归持续复制，用於目录的复制行为；(常用) -s : 复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u : 若 destination 比 source 旧才升级 destination ！ 用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc [root@www ~]# cp ~/.bashrc /tmp/bashrc [root@www ~]# cp -i ~/.bashrc /tmp/bashrc cp: overwrite `/tmp/bashrc'? n \u003c==n不覆盖，y为覆盖 ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:6","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"rm (移除文件或目录) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 将刚刚在 cp 的实例中创建的 bashrc 删除掉！ [root@www tmp]# rm -i bashrc rm: remove regular file `bashrc'? y\\; #递归删除文件夹和文件，没有报错信息 [root@www tmp] rm -rf [目录名字] 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！ ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:7","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"mv (移动文件与目录，或修改名称) 语法： [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 复制一文件，创建一目录，将文件移动到目录中 [root@www ~]# cd /tmp [root@www tmp]# cp ~/.bashrc bashrc [root@www tmp]# mkdir mvtest [root@www tmp]# mv bashrc mvtest 将某个文件移动到某个目录去，就是这样做！ 将刚刚的目录名称更名为 mvtest2 [root@www tmp]# mv mvtest mvtest2 # 移动某个目录下所有到另一个目录下 [root@www tmp]# mv /xxx/* /xxxx/ ","date":"2020-11-27","objectID":"/linux-file-path-note/:2:8","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"Linux 文件内容查看 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:0","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 检看 /etc/issue 这个文件的内容： [root@www ~]# cat /etc/issue CentOS release 6.4 (Final) Kernel \\r on an \\m ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:1","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@www ~]# tac /etc/issue Kernel \\r on an \\m CentOS release 6.4 (Final) ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:2","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 实例一：用 nl 列出 /etc/issue 的内容 [root@www ~]# nl /etc/issue 1 CentOS release 6.4 (Final) 2 Kernel \\r on an \\m ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:3","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"more 一页一页翻动 [root@www ~]# more /etc/man_db.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d ....(中间省略).... --More--(28%) \u003c== 重点在这一行喔！你的光标也会在这里等待你的命令 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:4","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"less 一页一页翻动，以下实例输出/etc/man.config文件的内容： [root@www ~]# less /etc/man.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d ....(中间省略).... : \u003c== 这里可以等待你输入命令！ less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:5","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"head 取出文件前面几行 语法： head [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 [root@www ~]# head /etc/man.config 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@www ~]# head -n 20 /etc/man.config ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:6","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"tail（从末尾查看文件） 取出文件后面几行 语法： tail [参数] [文件] # 或者 tail [-n number] 文件 选项与参数： -f 循环读取， -q 不显示处理信息 -v 显示详细的处理信息 -c\u003c数目\u003e 显示的字节数 -n\u003c行数\u003e 显示文件的尾部 n 行内容 –pid=PID 与-f合用,表示在进程ID,PID死掉之后结束 -q, –quiet, –silent 从不输出给出文件名的首部 -s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测 ​ tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。 ​ tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 [root@www ~]# tail /etc/man.config # 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样： [root@www ~]# tail -n 20 /etc/man.config 实例 要显示 notes.log 文件的最后 10 行，请输入以下命令： tail notes.log # 默认显示最后 10 行 要跟踪名为 notes.log 的文件的增长情况，请输入以下命令： tail -f notes.log 此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。 显示文件 notes.log 的内容，从第 20 行至文件末尾: tail -n +20 notes.log 显示文件 notes.log 的最后 10 个字符: tail -c 10 notes.log 其他示例 tail -n 100 /etc/cron #显示最后100行数据 tail -n -100 /etc/cron #除了前99行不显示外，显示第100行到末尾行 #--------------------------------------------------------------------- tail -n -5 /test001/text001 #与 tail -n 5 /test001/text001 #显示的结果相同，均是文件末尾最后 5 行内容。 tail -n +5 /test001/text001 #显示的内容为从第 5 行开始，直到末尾的内容。tail -n 后面的数字有效输入只有单个数字（5）或者加号连接数字（+5）两种。 ","date":"2020-11-27","objectID":"/linux-file-path-note/:3:7","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"修改文件权限和群组 sudo chmod -R 777 etc(文件名|文件夹名) # -R 要大写，代表递归作用，文件夹下所有子目录权限一致 修改组群的命令使chgrp，即change group，那么修改文件拥有者的命令自然就是chown，即change owner。chown功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数。 语法如下： chown [-R]** #**账号名称** **文件****/****目录 chown [-R]** # **账号名称**:**组群** **文件****/****目录** ","date":"2020-11-27","objectID":"/linux-file-path-note/:4:0","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"Centos7限制用户访问指定目录 创建用户及指定访问目录useradd test -d /home/test -M 设置密码passwd test 将访问目录权限全部赋予用户chown -R test /home/test 将上层目录设置为root所有chown root /home 赋予权限给上层目录chmod 771 /home ","date":"2020-11-27","objectID":"/linux-file-path-note/:5:0","tags":["Linux","File","Directory"],"title":"Linux 文件与目录管理教程","uri":"/linux-file-path-note/"},{"categories":["Operation","note"],"content":"在Linux和Windows环境中为Git配置生成公私密钥","date":"2020-11-02","objectID":"/git-ssh-key/","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"Windows 所有执行命令的地方都是在管理员模式下进行，即打开cmd，Git Bash客户端用管理员身份运行程序。 ","date":"2020-11-02","objectID":"/git-ssh-key/:1:0","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"单个 在Windows下查看**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]*下是否有“id_rsa、id_rsa.pub”*文件，如果没有需要从第一步开始手动生成,有的话直接跳到第二步。 第1步：创建SSH Key 打开Git Bash，在控制台中输入以下命令: ssh-keygen -t rsa -C \"youremail@example.com\" 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行,当然，如果不想要这些可以直接输入： ssh-keygen 我一般就是这么做的。 输入完毕后按回车，程序会要求输入一个密码，输入完密码后按回车会要求再确认一次密码，如果不想要密码可以在要求输入密码的时候按两次回车，表示密码为空，并且确认密码为空，此时**[c盘\u003e用户\u003e自己的用户名\u003e.ssh]**目录下已经生成好了。 第2步：将SSH添加到版本管理仓库 不同的版本管理代码仓库都大同小异，这里以Github举例，登录Github。打开setting-\u003eSSH keys，点击右上角 New SSH key，把**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]*目录下生成好的公钥“id_rsa.pub”*文件以文本打开复制放进 key输入框中，再为当前的key起一个title来区分每个key ","date":"2020-11-02","objectID":"/git-ssh-key/:1:1","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"多个 单个创建工程中不要直接连按回车，修改一下对应的文件名即可（可以不要密码） 然后在两个ssh之间挑选一个用的相对较少的ssh，在对应的文件夹配置当前文件夹local级别的用户名和邮箱，邮箱需要与ssh相对应 备注 Git的用户信息配置 Git的配置一共有三个级别：system(系统级)、global(用户级)和local(版本库)。system的配置整个系统只有一个，global的配置每个账户只有一个，local的配置取决于Git版本库数量，在版本库才能看到。 从Git官网的资料来看，这三个级别是逐层覆盖的。首先去查找system配置，其次查找global配置，最后查找local配置。逐层查找的过程中若查到配置值，则会覆盖上一层的配置。假如三个级别都配置了用户信息，则最后生效的配置是local(版本库)级的。 Git配置用户名邮箱的命令 system配置 git config --system user.name \"username\" git config --system user.email user@email.com global配置 git config --global user.name \"username\" git config --global user.email user@email.com local配置 git config --local user.name \"username\" git config --local user.email user@email.com ","date":"2020-11-02","objectID":"/git-ssh-key/:1:2","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"记录CentOS7 防火墙操作指令笔记","date":"2020-10-10","objectID":"/cnetos7-firewall/","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":" #防火墙端口列表 firewall-cmd --list-port #添加规则 firewall-cmd --zone=public --add-port=80/tcp --permanent #重启防火墙 systemctl restart firewalld.service #移除端口: firewall-cmd --zone=public --remove-port=80/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent #centos7启动防火墙 systemctl start firewalld.service #centos7停止防火墙/关闭防火墙 systemctl stop firewalld.service #centos7重启防火墙 systemctl restart firewalld.service #设置开机启用防火墙 systemctl enable firewalld.service #设置开机不启动防火墙 systemctl disable firewalld.service # 开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 命令含义： # --zone #作用域 # --add-port=80/tcp #添加端口，格式为：端口/通讯协议 # --permanent #永久生效，没有此参数重启后失效 # 重启防火墙 firewall-cmd --reload #常用命令介绍 firewall-cmd --state ##查看防火墙状态，是否是running firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones ##列出支持的zone firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd --add-service=ftp ##临时开放ftp服务 firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务 firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务 firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 # 更多命令，使用 firewall-cmd --help # 查看帮助文件 #\u003e\u003e\u003eCentOS 7默认使用的是firewall作为防火墙，使用iptables必须重新设置下 #直接关闭防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 # 设置 iptables service yum -y install iptables-services # 如果要修改防火墙配置，如增加防火墙端口3306 vi /etc/sysconfig/iptables # 增加规则 # -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 保存退出后 systemctl restart iptables.service #重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 # 最后重启系统使设置生效即可。 # 查询端口号80 是否开启： firewall-cmd --query-port=80/tcp ","date":"2020-10-10","objectID":"/cnetos7-firewall/:0:0","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":"记录CentOS7 端口管理指令的笔记","date":"2020-10-02","objectID":"/centos-port/","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation","note"],"content":" lsof -i tcp:80 # 查看80端口占用情况 netstat -ntlp # 列出所有端口 ","date":"2020-10-02","objectID":"/centos-port/:0:0","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation"],"content":"解决 CentOS7下 javac:未找到命令 问题 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"问题描述： 在linux下编译java程序，执行javac编译生成class文件时，在centos7终端输入如，javac hello.java 会提示未找到指令，但用java -verison测试环境变量是没问题的。 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:1:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"尝试解决： 重新再linux配置环境变量，输入 vi /etc/profile进入，添加以下代码： export JAVA_HOME=/usr/local/jdk1.8.0_144 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:2:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"再测试，最后也没有成功 后来在stackoverflow上看到了这个 84 down vote accepted You installed the Java Runtime Environment (JRE) only, which does not contain javac. For javac, you have to install the OpenJDK Development Environment. You can install java-devel or java-1.6.0-openjdk-devel, which both include javac. By the way: you can find out which package provides javac with a yum search, e.g. su -c ‘yum provides javac’ Another note: using yum and openjdk is only one possibility to install the JDK. Many people prefer Sun/Oracle’s “original” SDK. See How to install Java SDK on CentOS? and links for alternatives. 大意就是我们用yum来装原生的就行了 在终端输入 yum install java-devel 执行安装，再测试就行了 补充：Vi编辑常用快捷键 复制：ctrl+insert 粘贴：shift+insert 按Esc保存退出编译，shift+zz退出 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:3:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation","note"],"content":"记录CentOS7 管理MariaDB指令的笔记","date":"2020-09-09","objectID":"/centos7-mariadb/","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"基本管理指令 systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 ","date":"2020-09-09","objectID":"/centos7-mariadb/:1:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"连接数据库报错Too Many Connectionsbaocuo 重启数据库即可 ","date":"2020-09-09","objectID":"/centos7-mariadb/:2:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation"],"content":"修改Tomcat配置文件导致Tomcat部署Jstl项目报错","date":"2020-08-30","objectID":"/tomcat-jstl-error/","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"问题来源 原Tomcat启动有一条警告，由于看着不爽就查了办法去掉了 办法是修改Tomcat根目录下的conf文件夹下的catalina.properties文件（我这个版本的Tomcat大概在110行） apache-tomcat-9.0.41\\conf\\catalina.properties 改成如下图的样子，报错就消失了 改的时候还很年轻，并不知道自己改了什么，觉得还不错，于是天坑就挖好了 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:1:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"翻车 后面跟着老师开发jsp的时候使用了jstl，然后就死活报错 四处百度无果，向老师求助，老师怀疑是未正确导包，加上我正使用最新版idea，没有j2ee创建web项目了，只能创建普通项目，进入后在添加web模块，加深了老师怀疑导包问题。 期间曾将tld文件直接解压出来使用，被老师喊停，并劝我用maven，我于是转普通j2ee项目为Maven的Web项目，结果肯定问题没解决。 后有尝试创建普通Maven项目，再加入Web组件，依然没解决。 后由于课程时间有限，老师放弃了我。 不甘心，只能解压出tld文件直接使用，熬夜追赶任务进度 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:2:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"解决 项目部署时，同学没有服务器，委托我进行部署，巧妙的发现同学的项目在我这也有问题，将我的代码发给同学，同学可以运行。同时发现部署在服务器上没有任何问题，故深刻怀疑Tomcat的问题。 经过这个思路的稍作搜索，下载了新的tomcat，发现警告，想起了我对Tomcat配置文件下手的事情，所以恢复修改 系统顺利运行！！！问题终于解决。鬼问题纠结了我许久 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:3:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"云服务器安装软件（端口）连接失败解决办法,附各种常用默认端口","date":"2020-08-20","objectID":"/server-port-cant-connect/","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Operation"],"content":" 服务器需要进行控制面板对服务器端口进行放行如3306、8080 软件 默认、常用端口 协议 HTTP协议代理服务器 80/8080/3128/8081/9080 HTTP SOCKS代理协议服务器 1080 FTP（文件传输）协议代理服务器 21 Telnet（远程登录）协议代理服务器 23 HTTP服务器，默认的端口号（木马Executor开放此端口） 80 tcp HTTPS（securely transferring web pages）服务器 443 tcp /udp Telnet（不安全的文本传送）（木马Tiny Telnet Server所开放的端口） 23 tcp FTP（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； 21 tcp TFTP（Trivial File Transfer Protocol ） 69 udp SSH（安全登录）、SCP（文件传输）、端口重定向， 22 tcp SMTP Simple Mail Transfer Protocol (E-mail)，（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； 25 tcp POP3 Post Office Protocol (E-mail) 110 tcp WebLogic 7001 WebSphere应用程序 9080 WebSphere管理工具 9090 JBOSS 8080 TOMCAT 8080 WIN2003远程登陆 3389 Symantec AV/Filter for MSE 8081 Mysql数据库 3306 Oracle 数据库 1521 ORACLE EMCTL 1158 Oracle XDB（ XML 数据库） 8080 Oracle XDB FTP服务 2100 MS SQL SERVER数据库server 1433 tcp /udp MS SQL*SERVER数据库monitor 1434 tcp /udp QQ 1080 udp ","date":"2020-08-20","objectID":"/server-port-cant-connect/:0:0","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Software","note"],"content":"两种VSCode代码行检测插件，支持多种语言","date":"2020-07-28","objectID":"/vscode-count-line/","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"VSCode Counter 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:0","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"使用 ctrl + shift +p，输入counter，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:1","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"loc 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:0","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"使用 ctrl + shift +p，输入LineCount，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:1","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Operation","note"],"content":"记录CentOS7 查看系统软件信息的指令笔记","date":"2020-07-01","objectID":"/linux-system-info-note/","tags":["Linux","CentOS7","System"],"title":"CentOS7 查看系统软件信息","uri":"/linux-system-info-note/"},{"categories":["Operation","note"],"content":"CentOS7 查看系统版本 cat /etc/redhat-release ","date":"2020-07-01","objectID":"/linux-system-info-note/:1:0","tags":["Linux","CentOS7","System"],"title":"CentOS7 查看系统软件信息","uri":"/linux-system-info-note/"},{"categories":["Operation"],"content":"分析/bin、/usr/bin、/sbin、/usr/sbin的主要区别","date":"2020-06-15","objectID":"/linux-bin-sbin/","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":" /bin: bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。 /usr/bin:主 要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。 /sbin: 主 要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。 /usr/sbin:放置一些网路管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。 ","date":"2020-06-15","objectID":"/linux-bin-sbin/:0:0","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":"项目中途添加.gitignore不生效的办法","date":"2020-06-03","objectID":"/git-mid-gitignore/","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法一 # 清除 缓存区 git rm -r --cached . # 再执行正常的提交流程即可 # 我的 gitignore **/*.md ","date":"2020-06-03","objectID":"/git-mid-gitignore/:1:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法二 删除.git文件，重新执行 # 初始化 git init 即可 ","date":"2020-06-03","objectID":"/git-mid-gitignore/:2:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation","note"],"content":"使用管理工具宝塔面板创建部署网站","date":"2020-05-31","objectID":"/bt-site/","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"1、请自行装好宝塔面板以及Nginx、PHP（其他项目请装对应的服务器以及应用服务器） ","date":"2020-05-31","objectID":"/bt-site/:1:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"2、进入对应的宝塔面板页面点击左侧导航栏的网站（1），再点击添加站点（2）， ","date":"2020-05-31","objectID":"/bt-site/:2:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"3、一下添加对应的数据，并点击提交即可 ","date":"2020-05-31","objectID":"/bt-site/:3:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"在Linux的CentOS8上更换国内yum源","date":"2020-04-29","objectID":"/centos8-change-source/","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":" cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo_back vi CentOS-Base.repo ","date":"2020-04-29","objectID":"/centos8-change-source/:0:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # [BaseOS] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=BaseOS\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/BaseOS/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=extras\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=centosplus\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [AppStream] name=CentOS-$releasever - AppStream #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=AppStream\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/AppStream/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [PowerTools] name=CentOS-$releasever - PowerTools #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=PowerTools\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/PowerTools/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial yum clean all yum makecache ","date":"2020-04-29","objectID":"/centos8-change-source/:1:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"在Linux的Centos7系统上安装Docker","date":"2020-03-20","objectID":"/docker-centos7/","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。 社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。 ","date":"2020-03-20","objectID":"/docker-centos7/:0:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"一、安装docker 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0 $ sudo yum install \u003cFQPN\u003e # 例如：sudo yum install docker-ce-17.12.0.ce 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version ","date":"2020-03-20","objectID":"/docker-centos7/:1:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"二、问题 1、因为之前已经安装过旧版本的docker，在安装的时候报错如下： Transaction check error: file /usr/bin/docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 2、卸载旧版本的包 $ sudo yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 3、再次安装docker $ sudo yum install docker-ce ","date":"2020-03-20","objectID":"/docker-centos7/:2:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation"],"content":"解决centos安装不上apache:No match for argument: httpd","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"找到yum.conf [root@d78acc291c9e var]# find / -name yum.conf /etc/yum.conf ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:1:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"注释掉exclude那行，也可只删除httpd [main] gpgcheck=1 installonly_limit=3 clean_requirements_on_remove=True best=True #exclude=httpd nginx php mysql mairadb python-psutil python2-psutil //重新安装yum install httpd -y systemctl enable httpd systemctl start httpd systemctl status httpd 　Active: active (running) 　Status: “Started, listening on: port 80” [root@d78acc291c9e var]# httpd -v Server version: Apache/2.4.37 (centos) Server built: Dec 23 2019 20:45:34 ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:2:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Total","note"],"content":"Idea设置XML模板并创建xml文件","date":"2020-01-11","objectID":"/idea-xml/","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Total","note"],"content":"1、File—-\u003eSettings 2、Editor(3)—-\u003eFile And Code Templates(4) —\u003e中间选中Files(5) —–\u003e点击左边+号(6)，右边是建立子模版（7），添加模板 —–\u003e输入模板名字：Name:XML File.xml （8，name可以自定义） ——\u003e后缀名extension：xml （9）—\u003e在面板中间输入内容（10，内容请根据自己需求更改，或建立子模版）： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cconfig\u003e \u003cclassName\u003eclassName\u003c/className\u003e \u003c/config\u003e —–\u003e把enable live Template(激活模板)勾选上（11） ——\u003e点击Apply（12）—ok 3、选中文件夹（1）—–\u003eNew（2）——–\u003e找到XML File（3），输入名字，点击确定，就可以创建xml文件了 ","date":"2020-01-11","objectID":"/idea-xml/:0:0","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Operation"],"content":"Docker 容器常见故障排查及处理，将常见问题分类","date":"2019-12-30","objectID":"/docker-error-by-type/","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"Docker是一种相对使用较简单的容器，我们可以通过以下几种方式获取信息： 1、通过docker run执行命令，或许返回信息 2、通过docker logs 去获取日志，做有针对性的筛选 3、通过systemctl status docker查看docker服务状态 4、通过journalctl -u docker.service 查看日志 ","date":"2019-12-30","objectID":"/docker-error-by-type/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"以下是整理的docker容器类问题故障，分为9个类 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"一、启动类故障 1、docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 原因：Docker未正常启动 解决方式： systemctl start docker 2、can’t create unix socket /var/run/docker.sock: is a directory 原因：docker.sock不能创建 解决方式： rm -rf /var/run/docker.sock 然后重新启动docker 3、Job for docker.service failed. Failed to start Docker Application 原因：Selinux引起 解决方式： /etc/sysconfig/selinux , 把 selinux 值改为disabled 重启docker解决 4、docker: Error response from daemon: /var/lib/docker/overlay/XXXXXXXXXXXXXXXXXXXXXXX: no such file or directory. 原因：docker没有指定目录或文件 解决方式： systemctl stop docker rm -rf /var/lib/docker/* systemctl start docker 重启run镜像启动容器 5、docker: Error response from daemon: Conflict. The container name “XXX” is already in use by container “XXX”. You have to remove (or rename) that container to be able to reuse that name. 原因：docker name重名 解决方式： 改名容器或者删除重建容器 6、Error: Connection activation failed: No suitable device found for this connection 原因：网卡配置问题 解决方式： 重启网卡 7、系统重启后docker无法启动 报错为：docker0: iptables: No chain/target/match by that name 原因：docker服务iptables问题 解决方式： 重启docker服务system restart docker 8、Error starting daemon: error initializing graphdriver: driver not supported 使用overlay2存储驱动启动docker daemon报错 原因：daemon缺少配置 解决方式： 添加配置： /etc/docker/daemon.json {“storage-driver”: “overlay2”, “storage-opts”: [“overlay2.override_kernel_check=true”]} 9、Failed to start docker.service: Unit docker.service is masked. 未知原因：docker 被mask 解决方式： systemctl unmask docker.service systemctl unmask docker.socket systemctl start docker.service 10、Failed to start docker.service: Unit is not loaded properly: Invalid argument. 未知原因：docker服务无法正常load 解决方式： 卸载docker， 删除docker.service 重新安装docker 11、docker-compose启动容器时报错： /usr/lib/python2.7/site-packages/requests/init.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn’t match a supported version! RequestsDependencyWarning) 未知原因：pip相应组件版本不支持 解决方式： pip uninstall urllib3 pip uninstall chardet pip install requests 12、docker容器重启故障 强杀docker进程后，重启docker。docker中的容器无法启动并报错 docker restart XXXXXXX Error response from daemon: Cannot restart container XXXXXXX: container “XXXXXXXXXXXXXXXX”: already exists 原因：旧容器未安全退出 解决方式： docker-containerd-ctr –address /run/docker/containerd/docker-containerd.sock –namespace c rm \u003c容器hash_id\u003e docker start 容器 13、docker重启错误-重启命令一直卡住 systemctl restart docker 卡住 未知原因：可能是启动的容器数量过多，或者磁盘IO问题 解决方式： systemctl start docker-cleanup.service systemctl start docker ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:1","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"二、权限问题报错 14、Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock 解决方式： 查看 /var/run/docker.sock所在用户组 将用户重新加入docker组中，usermod -aG docker ${USER} 15、chown socket at step GROUP: No such process 原因：docker无法找到Group组信息，docker组有可能被误删除， 解决方式： groupadd docker 16、Post http:///var/run/docker.sock/v1.XXX /auth: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS-enabled daemon without TLS? 原因：非Root用户管理Docker时，权限不足 解决方式： groupadd docker usermod -a -G docker user 17、docker commit镜像时报错 Error processing tar file(exit status 1): unexpected EOF 原因：可能是权限问题引起 解决方式： chmod +x 加一个执行权限 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:2","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"三、镜像和仓库问题报错 18、Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io 原因：Docker仓库无法访问 解决方式： 修改Docker仓库源为国内或者自建的仓库源 修改/etc/docker/daemon.json 19、推送本地镜像报错 The push refers to a repository [XXXX] Get https://xxx/v1/_ping: http: server gave HTTP response to HTTPS client 原因：docker registry未采用https服务所致 解决方式： /etc/docker/daemon.json 文件写入： { “insecure-registries”:[\"\"] } 20、/usr/bin/docker-current: Error response from daemon: oci runtime error: container_linux.go: starting container process caused “exec: “/bin/bash”: executable file not found in $PATH”. 原因：Docker镜像自身问题或者Docker引擎版本比较低导致 解决方式： 可以升级Docker版本服务 21、构建镜像，执行chown -R非常慢 原因：Docker使用写时复制策略，所以chown命令执行时，会将上层镜像文件全部复制到当前层，然后再修改权限，再写入文件系统。 解决方式： 不应该使用chown -R 这类大批量修改文件的命令 22、docker build构建镜像的时候报错： Message from syslogd kernel:unregister_netdevice: waiting for lo to become free. Usage count = 1 原因：docker engine版本过高 解决方式： docker engine版本需要和docker内部镜像的内核版本匹配 23、docker: Error response from daemon: containerd: container did not start before the specified time-out.ERRO[0133] error getting events from daemon: context canceled 原因：修改完docker root dir，重启后，下载镜像报错 解决方式： 重启docker服务 或者重启服务器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:3","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"四、资源问题报错 25、Docker no space left on device 原因：空间不足 解决方式：清理空间,删除未被使用的容器，镜像等资源 docker system prune -a 26、/var/lib/docker/containers 占用过大 原因：日志文件占用过大 解决方式： cat /dev/null \u003e *-json.log 或者 增加dockerd启动参数，/etc/docker/daemon.json {“log-driver”:“json-file”, “log-opts”: {“max-size”:“2G”, “max-file”:“10”} 27、max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 原因：系统参数默认配置过小 解决方式： 修改/etc/sysctl.conf里面的vm.max_map_count 调大 28、Got starting container process caused “process_linux.go:301:running exec setns process for init caused “exit status 40””: unknown.from time to time 原因：可能是cache问题引起 解决方式： echo 1 \u003e /proc/sys/vm/drop_caches 29、docker本机启动多台容器导致出现后续容器启动失败 原因：查看硬盘空间是否满，如果不是硬盘空间问题引起 解决方式： vim /etc/sysctl.conf 添加参数 fs.aio-max-nr = 1048576 sysctl -p 30、Docker启动异常，状态反复restarting Docker logs 容器名，查看异常日志 查看/var/log/messages 原因：内存跑满，引起OOM 解决方式： 释放内存后，再启动容器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:4","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"五、版本不兼容报错 31、overlayfs: Can’t delete file moved from base layer to newly created dir even on ext4 原因：Centos 提供的文件系统 XFS 和 Overlay 兼容问题导致, 解决方式： 这个问题的修复在内核 4.4.6以上 32、docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused “process_linux.go:297: getting the final child’s pid from pipe caused “read init-p: connection reset by peer””: unknown. 原因：Docker版本和操作系统版本不匹配 解决方式： 重新安装和操作系统内核支持的docker 版本 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:5","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"六、网络或端口问题报错 33、WARNING: IPv4 forwarding is disabled. Networking will not work. 原因：ipv4网络无法转发 解决方式: /usr/lib/sysctl.d/00-system.conf 在最后一行添加net.ipv4.ip_forward=1 重启network服务。删除错误的容器，再次创建新容器 34、Creating network “xxxxxxx” with the default driver 原因：docker网关冲突 启动容器、docker-compose启动容器后，断网问题 解决方式： 配置 docker-compose.yml内给启动的容器配置参数network_mode: “bridge” 35、Unable to find a node that satisfies the following conditions [port xxxx] 原因：当容器使用端口映射(docker run -p xxxx:xxxx或 compose模板中的 ports)之后 系统会在宿主机上创建一个port，通过NAT来访问容器的指定port。如果宿主机上的端口被容器或者系统进程占用，就会导致端口分配失败。 解决方式： 清除占用端口的容器或者进程，或调整容器端口映射的宿主机端口避免冲突 36、Error response from daemon: service endpoint with name xxx already 原因：端口已经被占用 解决方式： 重启docker容器 37、docker: Error response from daemon: driver failed programming external connectivity on endpoint XXXXX: Bind for 0.0.0.0:80 failed: port is already allocated 原因：容器端口冲突 解决方式： 更换宿主机绑定端口 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:6","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"七、Docker安装报错 38、安装docker报Requires: container-selinux \u003e= 2.9 原因：container-selinux版本低或者是没安装的原因 解决方式： wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install epel-release yum makecache yum install container-selinux 39、安装docker-compose时报错 “ImportError: ‘module’ object has no attribute ‘check_specifier’” 原因：setuptools版本问题 解决方式： 升级setuptools到30.1.0版本以上版本 pip install –upgrade setuptools 40、安装docker-compose时报错 DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7. 原因：python2.7提示升级 解决方式： pip install -i https://pypi.douban.com/simple docker-compose ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:7","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"八、Docker删除报错 41、docker删除容器报错 Error response from daemon:Driver overlay failed to remove root filesystem xxxxx: remove/var/lib/docker/overlay2/xxxxx/merged: device or resource busy 原因：容器挂载数据卷，无法直接删除 解决方式： grep docker /proc/*/mountinfo | grep xxxxx kill进程后 再重新删除容器 42、状态dead的容器删除报错 Error response from daemon: Driver aufs failed to remove root filesystem XXXXXXXXXXXXXXXX: aufs: unmount error after retries: /var/lib/docker/aufs/mnt/xxxxxxxx: device or resource busy 原因：dead状态容器无法删除，还在占用资源 解决方式： docker rm -fv 容器id 过几分钟后会自动删除 43、docker删除镜像报错 Error response from daemon: conflict: unable to remove repository reference “XXXX” (must force) - container XXXX is using its referenced image YYYY 原因：镜像正在被某容器使用 解决方式： 需要删除相关ID容器后，才能删除镜像 44、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXXXXXXXXX (must be forced) - image is referenced in multiple repositories 原因：镜像login push 了远端其他仓库 解决方式： 如果不需要此镜像， docker rmi -f 强删 45、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXX (cannot be forced) - image has dependent child images 原因：存在依赖于父镜像的子镜像 解决方式： 强制删除镜像或者批量删除容器，再删除镜像 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:8","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"九、其他报错 46、docker: Error response from daemon: driver failed programming external connectivity on end-point XXXXXXX: (iptables failed: iptables –wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 –dport 8080 -j ACCEPT: iptables: No chain/target/match by that name. 原因：防火墙问题引起 解决方式： 关闭防火墙，重启docker 47、执行docker info出现如下警告 WARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled 原因：配置问题引起，需要启用bridge-nf-call-iptables 解决方式： vi /etc/sysctl.conf 添加以下内容 net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-arptables = 1 48、docker数据库相关报错 使用Docker创建mysql容器闪退 Database is uninitialized and password option is not specified 解决方式： docker run -d -e MYSQL_ROOT_PASSWORD=[密码] -p 3306:3306 mysql镜像 Docker使用规范建议 尽量使用最近1-2年的新的稳定的docker版本 不要去安装今年前很老的版本，大量的bug已经被新版本更新解决掉了 尽量不要去创建非常大的镜像，比如5G10G以上的 镜像要尽量轻量化，去除不必要的软件，数据等 容器内挂载宿主机配置，使用只读 容器需要-v 宿主机的配置文件，尽量使用ro只读 数据要挂载宿主机物理硬盘或存储节点上 不要直接在容器里run，避免容器宕机引起数据丢失 应用日志一定要挂到宿主机上 不要直接打印到容器内，避免只能docker logs方式查看，避免去vulume目录里查看日志 不要只使用latest标签 Tag要有个管理标准，可以根据tag查找对应版本 不要使用容器ip，配置里更不能写死（默认172.17.0.x） 容器重启后，ip很可能会变 尽量不要在单容器内跑多进程 容器不是虚拟机，尽量做到1个容器，1个进程 跨环境镜像保持一致 不论是测试，UAT，生产环境，尽量保持同一个镜像，不要变更，环境变更只需要变更环境变量参数做区分 一定监控docker容器，即使发现问题 建议使用prometheus监控容器 一定要限制docker容器的资源， 尤其是CPU、内存、硬盘空间，甚至是网络等，避免侵占宿主机的硬件资源 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:9","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"解决Git提交错误怎么办的集中办法和相关知识","date":"2019-12-05","objectID":"/git-commit-error/","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"方法: ","date":"2019-12-05","objectID":"/git-commit-error/:1:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"reset git reset --hard \u003ccommit_id\u003e git push origin HEAD --force # 或 git push origin HEAD --force 其他: #根据–soft –mixed –hard，会对working tree和index和HEAD进行重置: git reset --mixed #此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset --soft #回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard #彻底回退到某个版本，本地的源码也会变为上一个版本的内容 HEAD 最近一个提交 HEAD^ 上一次 \u003ccommit_id\u003e 每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到. reset的结果是完全回复到某次提交的状态，但是有可能再多人开发时，不能及时通知导致冲突 ","date":"2019-12-05","objectID":"/git-commit-error/:1:1","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"revert 2.使用“git revert -n 版本号”反做，并使用“git commit -m 版本名”提交： （1）反做，使用“git revert -n 版本号”命令。如下命令，我们反做版本号为8b89621的版本： git revert -n 8b89621019c9adc6fc4d242cd41daeb13aeb9861 注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。 （2）提交，使用“git commit -m 版本名”，如： git commit -m \"revert add text.txt\" 此时可以用“git log”查看本地的版本信息，可见多生成了一个新的版本，该版本反做了“add text.txt”版本，但是保留了“add text2.txt”版本： 3.使用“git push”推上远程库： git push ","date":"2019-12-05","objectID":"/git-commit-error/:1:2","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"commit合并 有时commit太多，而且可能一个commit只是提交一个小bug，那么合并commit势在必行。 有两种方法： 一是在提交最后一个修改的commit使用参数，这时之前的一个commit将会合并到这个即将提交的commit中来： git commit -a --amend -m \"my message here\"如果之前有一个提交，并且信息为: git commit -a -m \"my last commit message\" 则这个commit message将不存在。但该commit的信息已经合并到\"my message here\"中了。 第二个是，如果你提交了最后的修改，这时可用： git reset --soft HEAD^ #或HEAD^意为取消最后commit git commit --amend 这将会把最后一个commit合并到前一个提交中去，例如（由上往下读）： git add b.text git commit -a -m \"my message here\" git add a.text git commit -a -m \"my last commit message\" 那么最后存在的将是\"my last commit message\"。也可后退n个，合并到前面第n+1个commit中去： $ git reset --soft HEAD~n #后退到第n，我也不清楚具体含义。 $ git commit --amend [-m \"new message\"] 我觉得最方面的是调用reflog查看操作历史，找到具体的commit id，然后直接git reset –hard [commit_id]就回到你要的版本！ ","date":"2019-12-05","objectID":"/git-commit-error/:2:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"强制Push注意事项 本地回复后需要使用–force强制push到远程仓库 git push origin --force 会报如下错误： You are not allowed to force push code to a protected branch on this project 如果用的是gitlab版本库，这说明gitlab对仓库启用了保护，需要在仓库中设置一下： GitLab Community Edition 11.7.5 \"Settings\" -\u003e \"Repository\" -\u003e scroll down to \"Protected branches\". \"设置\" -\u003e \"仓库\" -\u003e 滑动到 \"Protected branches\". 番外：语言设置 \"User Name\" -\u003e \"Settings\" -\u003e \"Profile\" -\u003e scroll down to \"Main settings\" \"用户名\" -\u003e \"设置\" -\u003e \"用户资料\" -\u003e 滑到 \"主要设置\" GitLab Community Edition 13.7.4 \"Admin Area\" -\u003e \"Settings\" -\u003e \"Genneal\" -\u003e scroll down to \"Visibility and access controls\". \"管理中心\" -\u003e \"设置\" -\u003e \"通用\" -\u003e 滑到 \"可见性与访问控制\". 番外：语言设置 \"User Name\" -\u003e \"Settings\" -\u003e \"Preferences\" scroll down to -\u003e \"Localization\" \"用户名\" -\u003e \"设置\" -\u003e \"偏好设置\" 滑到 -\u003e \"本地化\" ","date":"2019-12-05","objectID":"/git-commit-error/:3:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"解决CentOS7运行Docker报错 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\" 问题","date":"2019-11-01","objectID":"/docker-daemon-is-running/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Operation"],"content":"执行命令：sudo dockerd –debug 注意此条指令不能Ctrl+C停止，否则还会出现一样的错误 之后重启docker：systemctl restart docker就可以了 在网上搜了半天，有的是去编辑 /etc/docker/daemon.json 文件，而有的是在 docker.service 如果在 /etc/docker/daemon.json 的解决办法：添加 insecure-registries 即可 sudo vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://zydiol88.mirror.aliyuncs.com\"], \"insecure-registries\": [\"161.17.60.38:85\"] } 如果是在 docker.service 解决办法：在 ExecStart 添加 –insecure-registry find / -name docker.service -type f /usr/lib/systemd/system/docker.service # 在 ExecStart 这行后面加上 -insecure-registry=Harbor登录地址 sudo vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --insecure-registry=161.17.60.38:85 sudo systemctl daemon-reload sudo systemctl restart docker 重启完成后重新登录即可 # 在linux总端登录Harbor： sudo docker login -u tens -p Tens123456 161.17.60.38:85 ","date":"2019-11-01","objectID":"/docker-daemon-is-running/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Back","note"],"content":"Idea在Maven中和手动导入Jar包中直接查看Jar包源码","date":"2019-10-03","objectID":"/idea-jar-src/","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"Maven 1、从maven相关仓库添加依赖到Pom文件 2、点击Idea中的Maven（1）下的依赖文件夹（2）下的你想找源码的包（3），右键单击download source（下载源码） 3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:1:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"手动导jar包 1、自行手动导jar包到项目 2、直接使用Maven分类的全局搜索即可 Maven：3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:2:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Operation","note"],"content":"GitLab（私服）修改仓库成员可见属性","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Operation","note"],"content":"在 UI 界面中，选择 Settings \u003e General。 在弹出的界面中，选择 Visibility, project features, permissions 后面的 Expand 按钮。 然后在弹出的界面中，将 Project Visibility 下面从 Private 选择为 Public。 你的项目就可以被 Public 访问到了。 最后，不要忘记将你的修改保存以便于生效。 ","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/:0:0","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Software","note"],"content":"记录常用的Vim笔记","date":"2019-08-31","objectID":"/vim-note/","tags":["Environment","Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Software","note"],"content":"指令模式下的指令 # vim高亮搜索 /名字 或 选中后 shift+3（非小键盘） # 关闭vim搜索高亮 输入:nohlsearch 或:set nohlsearch； # vim增加页码 ：set num # 或 ：set number ","date":"2019-08-31","objectID":"/vim-note/:1:0","tags":["Environment","Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Operation","note"],"content":"在Linux的CentOS7系统中使用shell指令查看Git安装的路径","date":"2019-07-01","objectID":"/centos7-git-path/","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation","note"],"content":" command -v git ","date":"2019-07-01","objectID":"/centos7-git-path/:0:0","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation"],"content":"解决CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）报错","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":" # service docker start Redirecting to /bin/systemctl start docker.service Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details. # systemctl status docker.service ● docker.service - Docker Application Container Engine Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled) Drop-In: /usr/lib/systemd/system/docker.service.d └─flannel.conf Active: failed (Result: exit-code) since Wed 2018-08-29 04:54:57 UTC; 20s ago Docs: https://docs.docker.com Process: 10689 ExecStart=/usr/bin/dockerd (code=exited, status=1/FAILURE) Main PID: 10689 (code=exited, status=1/FAILURE) ****** systemd[1]: Starting Docker Application Container Engine... ****** dockerd[10689]: can't create unix socket /var/run/docker.sock: is a directory ****** systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE ******systemd[1]: Failed to start Docker Application Container Engine. ******systemd[1]: Unit docker.service entered failed state. ******systemd[1]: docker.service failed. ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":"解决 # 删除docker.sock rm -rf /var/run/docker.sock # 重新启动即可 service docker restart ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation","note"],"content":"Git-Branch分支操作的常用指令笔记","date":"2019-05-01","objectID":"/git-branch/","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"创建分支 # 根据名称创建分支,并切换分支 git checkout -b {name} # 示例 git checkout -b zhangsan # 这条指令是 git checkout zhangsan # 和 git branch zhangsan # 两条指令的结合体 ","date":"2019-05-01","objectID":"/git-branch/:1:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"查看分支 # 查看所有分支，当前分支为绿色 git branch [-a] # -a 所有分支 # 创建分支 git branch mybranch # 切换分支 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:2:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改分支名称 # 需要将分支br_rename_old修改为br_rename_new，执行如下步骤： ## 1、切换到br_rename_old分支，如果已经在这个分支下，可以不执行此步骤 git checkout br_rename_old ## 2、将代码更新到和远程仓库一致 git pull origin br_rename_old ## 3.1、将本地仓库的br_rename_old的名称修改为br_rename_new git branch -m br_rename_old br_rename_new ## 3.2、将本地仓库的当前分支的名称修改为br_rename_new git branch -m br_rename_new ## 4、将远程分支br_rename_old删除 git push origin --delete br_rename_old ## 5、将本地分支push到远程仓库 git push --set-upstream origin br_rename_new ","date":"2019-05-01","objectID":"/git-branch/:3:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"设置默认(master)分支 ","date":"2019-05-01","objectID":"/git-branch/:4:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"master分支设置为master（默认） git branch --set-upstream-to=origin/master master ","date":"2019-05-01","objectID":"/git-branch/:4:1","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"备份分支 根据git当前提交节点创建分支button-and-input，继承之前所有提交代码 git branch button-and-input ","date":"2019-05-01","objectID":"/git-branch/:5:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法一 将本地创建的button-and-input分支提交到远程，名字为button-and-input git push origin button-and-input:button-and-input ","date":"2019-05-01","objectID":"/git-branch/:5:1","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法二 正常提交代码流程但最后一步提交到新创建的仓库或之前做过直接可以提交至新创建的远程仓库分支 git add . git commit -m \"Message\" git push origin button-and-input 二者都能达到备份代码目的 ","date":"2019-05-01","objectID":"/git-branch/:5:2","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"其他 合并分支：(merge from) $ git checkout master $ git merge mybranch (merge from mybranch) 删除本地分支： $ git branch -d mybranch 强制删除分支： $ git branch -D mybranch 列出所有分支： $ git branch ","date":"2019-05-01","objectID":"/git-branch/:6:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"非绝对必要且明白产生其他后果时才能进行的操作 # 切换分支 在没有commit时请备份代码或者commit、push后再进行提交否则，会导致当前代码全部丢失 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:7:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改","date":"2019-04-30","objectID":"/git-package-rename/","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":" “修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改 git mv -f [file] [newfile] #示例 git mv -f Github GitHub #-f=--forse,即使目标存在，也强制重命名或移动文件 ","date":"2019-04-30","objectID":"/git-package-rename/:0:0","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":"展示Git仓库交互流程方法和部分参数之间的区别","date":"2019-03-15","objectID":"/git-push-ways/","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"简单Git仓库交互 一般小项目交互 # 0.拉取代码 git clone [仓库地址] # 或 git init git remote add [仓库地址] # git remote add 只是在您的git config中创建一个条目，指定特定URL的名称。你必须有一个现有的git仓库来使用它。需要init # git clone通过复制位于您指定的URI上的现有git存储库来创建新的git存储库。不需要init ################################################################################################ # 开发 ################################################################################################ # 1.添加当前目录下的所有文件到暂存区： git add [.][-u][-A][-all] # -u 将文件的修改、文件的删除，添加到暂存区。 # . 将文件的修改，文件的新建，添加到暂存区。 # -A/-all 将文件的修改，文件的删除，文件的新建，添加到暂存区。 # 2.提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息，不添加-m参数会弹出问价，要求填写message git commit [-m \"{message}\"] # 示例 git commit -m \"这是个标签1\" # 3.从将本地的分支版本上传到远程并合并。不添加origin master会提交到默认分支，添加后可以分开分支进行开发互不干扰 git push [origin {master}] ","date":"2019-03-15","objectID":"/git-push-ways/:1:0","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"大型项目Git仓库交互 ","date":"2019-03-15","objectID":"/git-push-ways/:2:0","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"Fork原项目 一般的Git仓库自带，将其复制一份到自己的仓库，称为Remote ","date":"2019-03-15","objectID":"/git-push-ways/:2:1","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"拉取代码 拉去自己仓库的Remote代码，本地称为Local git clone [仓库地址] # 或 git init git remote add [仓库地址] ","date":"2019-03-15","objectID":"/git-push-ways/:2:2","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"开发 ","date":"2019-03-15","objectID":"/git-push-ways/:2:3","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"提交（合并） 第一种：将自己仓库中原来fork的项目删掉 (delete deletethis repository)，然后在重新到原作者仓库中(fork)一份最新代码（不推荐方式），这似乎达到了我们的最终目的，但是自己改变的代码没合并进来。 第二种：在本地建立两个库的中介，把两个远程库都clone到本地，然后拉取原项目更新到本地，合并更新，最后push到你的github就完成。（推荐方式） 第二种实现 查看关联仓库信息 git remote -v 添加原仓库关联 git remote add upstream [原仓库地址] git remote -v upstream相当于一个别名，名字随便取。 再次查看关联仓库信息 git remote -v 获取原仓库代码 这时有两个远程分支，我们继续 fetch，然后把原项目更新的内容fetch到本地 git fetch upstream 查看下分支 git branch -av 一个本地分支master，三个远程分支，画红线的就是要合并的 merge git checkout master git merge hunter/master 冲突 如果有冲突的话，需要丢掉本地分支 git reset –hard hunter/master 提交 这时你的当前本地的项目变成和原作者的主项目一样了，可以把它提交到你的GitHub库 git commit -am ‘更新到原作者的主分支’ git push origin git push -u origin master -f –强制提交 合并到原仓库 发起合并请求 以GitHub为例，先点击Pull requsets（1），再点击New pull requset（2）创建合并请求 选择本地和远程仓库（1）（2），点击Create pull requset发起合并请求，等待原仓库作者测试同意合并即可 至此项目提交圆满结束 再次接到开发任务后(第二种实现) Loop 先更新原仓库 git fetch upstream 切换自己开发分支 git checkout master 将原仓库合并到自己仓库分支 git merge upstream/master 将更新推送到自己的Remote git add [.][-u][-A][-all] git commit -m \"这是个标签1\" git push [origin {master}] 是否合并 有开发内容则发起PR，无开发内容（仅更新原作者代码）直接跳过此步骤 开发 …… End Loop 如此仅需从获取源仓库代码开始循环即可 循环 ","date":"2019-03-15","objectID":"/git-push-ways/:2:4","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"Git在本地初始化仓库流程","date":"2019-02-04","objectID":"/git-repo-init/","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":" 自行在系统环境中安装Git，这里不做介绍 #Git 本地仓库初始化，生成.git的隐藏文件 git init # 配置个人信息邮箱、姓名 --global是指全局有效，无论在哪个仓库均有效 ## 姓名 git config --global user.name \"{name}\" # 示例 git config --global user.name \"zhangsan\" ## 邮箱 git config --global user.email {email.example.com} # 示例 git config --global user.name \"{zhangsan.qq.com}\" # 查看配置信息 git config --list # 修改配置信息 # 重新添加一次即可覆盖 # 或 git config --global configName configValue # 删除 git config --global --unset configName (只针对存在唯一值的情况) ","date":"2019-02-04","objectID":"/git-repo-init/:0:0","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":"从底层解释yum makecache的作用","date":"2019-01-24","objectID":"/yum-makecache/","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Operation","note"],"content":"疑问： yum makecache 的作用到底是什么呢? 查看了很多的资料，都说是会从服务器中下载一些信息，但是我做了一个测试。 [root@localhost 7]# yum clean all [root@localhost 7]# yum install createrepo -y [root@localhost 7]# yum remove createrepo -y 断网之后 [root@localhost 7]# yum install createrepo -y #安装成功 #发现还是可以安装成功，所以可以判断这时通过缓存安装的。但是为了严谨再执行以下命令。 [root@localhost 7]# yum clean all #清理缓存再安装 [root@localhost 7]# yum install createrepo -y #安装失败 根据上述实验，我们可以判断yum 安装软件包的时候就已经把该软件包缓存起来了，而不需要执行yum makecache 进行额外的缓存。 但是很多资料中都说安装好软件之后需要执行yum makecache 这个命令进行缓存。(不知道是什么原因) 总结：yum安装的时候会将安装包进行缓存，不过最好还是再执行一下yum makecache命令。 ","date":"2019-01-24","objectID":"/yum-makecache/:0:0","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Hardware"],"content":"Win10鼠标出现延迟现象","date":"2018-12-31","objectID":"/windows-mouse-delay/","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"1、修改控制面板电源选项 控制面板下的电源选项 找到自己当前的电源计划，点击更改计划设置 点击更改高级电源设置 在Usb设置下的USB选择性暂停设置下的使用电池和接通电源均禁用（该操作可能耗电，情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:1:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"2、由于连接在扩展坞上，切换至USB无此情况，怀疑扩展坞问题，更换扩展坞情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:2:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"3、随着Win10 更新，原扩展坞和鼠标延迟现象彻底消失，最新版的Win10还是有Bug的 ","date":"2018-12-31","objectID":"/windows-mouse-delay/:3:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Operation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2018-11-11","objectID":"/shell-script-note/","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"set -e的作用 #!/bin/bash set -e ... command 1 command 2 ... exit 0 你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。 这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。 ","date":"2018-11-11","objectID":"/shell-script-note/:1:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"特殊变量（$0、$1、$2、 $?、 $# 、$@、 $*） shell编程中有一些特殊的变量可以使用。这些变量在脚本中可以作为全局变量来使用。 名称 说明 $0 脚本名称 $1-9 脚本执行时的参数1到参数9 $? 脚本的返回值 $# 脚本执行时，输入的参数的个数 $@ 输入的参数的具体内容（将输入的参数作为一个多个对象，即是所有参数的一个列表） $* 输入的参数的具体内容（将输入的参数作为一个单词） $@与$*的区别： 　$@与$*都可以使用一个变量来来表示所有的参数内容，但这两个变量之间有一些不同之处。 　$@：将输入的参数作为一个列表对象 　$*：将输入的参数作为一个单词 #源代码： echo \"脚本的名字是：\"$0 n=1 echo \"使用\\$@的参数列表为：\"$@ for temstr in \"$@\" do echo \"第$n个参数是：\" $temstr let n+=1 done n=1 echo \"使用\\$*的参数列表为：\"$* for temstr in \"$*\" do echo \"第$n个参数是：\" $temstr let n+=1 done #执行结果： $ ./test.sh 1 2 3 4 脚本的名字是：./test.sh 使用$@的参数列表为：1 2 3 4 第1个参数是： 1 第2个参数是： 2 第3个参数是： 3 第4个参数是： 4 使用$*的参数列表为：1 2 3 4 第1个参数是： 1 2 3 4 在上面的例子中，使用$@与$*是，都是用双引号引起来，但当$*不使用双引号时，结果与$@的结果相同。 　原因分析： 　当都使用双引号时，我们可以看到参数列表输出都是一样的，说明确实两个变量都可以存储所有的参数内容，也就显示出来两个变量之间的对参数处理的不同，即一个将其作为列表处理，一个讲所有参数作为一个单词处理。 　当$*不适用双引号时，执行到for语句时，会首先将$*的值（1 2 3 4 ）取出来，然后循环语句就变成了　for tem in 1 2 3 4 ，最后的输出结果也就变成了列表的循环输出。 #源码： #!/bin/bash n=1 for tem in $* do echo $n is $tem let n+=1 done 执行结果： # ./test.sh 1 2 3 4 1 is 1 2 is 2 3 is 3 4 is 4 　在这里补充一下单引号、双引号以及没有引号的区别： 单引号： 　可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看见的是什么就会输出什么。 双引号： 　把双引号内的内容输出出来；如果内容中有命令，变量等，会先把变量，命令解析出结果，然后在输出最终内容来。 　双引号内命令或变量的写法为命令或变量或$（命令或变量）。 无引号： 　把内容输出出来，可能不会讲含有空格的字符串视为一个整体输出； 　如果内容中有命令、变量等，会先把变量、命令解析结果，然后在输出最终内容来； 　如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用，不过最好用双引号替代之 ","date":"2018-11-11","objectID":"/shell-script-note/:2:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"Shell脚本IF条件判断和判断条件总结 这里有IF条件判断的语法和常用的判断条件总结,需要的朋友可以参考下 ","date":"2018-11-11","objectID":"/shell-script-note/:3:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"前言: 无论什么编程语言都离不开条件判断。SHELL也不例外。 代码如下: if list then do something here elif list then do another thing here else do something else here fi ","date":"2018-11-11","objectID":"/shell-script-note/:3:1","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"EX: 代码如下: \\#!/bin/sh SYSTEM=`uname -s` #获取操作系统类型，我本地是linux if [ $SYSTEM = \"Linux\" ] ; then #如果是linux的话打印linux字符串 echo \"Linux\" elif [ $SYSTEM = \"FreeBSD\" ] ; then echo \"FreeBSD\" elif [ $SYSTEM = \"Solaris\" ] ; then echo \"Solaris\" else echo \"What?\" fi #ifend 基本上和其他脚本语言一样。没有太大区别。不过值得注意的是。[]里面的条件判断。 ","date":"2018-11-11","objectID":"/shell-script-note/:3:2","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"1、字符串判断 条件 解释 str1 = str2 当两个串有相同内容、长度时为真 str1 != str2 当串str1和str2不等时为真 -n str1 当串的长度大于0时为真(串非空) -z str1 当串的长度为0时为真(空串) str1 当串str1为非空时为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:3","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"2、数字的判断 条件 解释 int1 -eq int2 两数相等为真 int1 -ne int2 两数不等为真 int1 -gt int2 int1大于int2为真 int1 -ge int2 int1大于等于int2为真 int1 -lt int2 int1小于int2为真 int1 -le int2 int1小于等于int2为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:4","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"3、文件的判断 参数 解释 -r file 用户可读为真 -w file 用户可写为真 -x file 用户可执行为真 -f file 文件为正规文件为真 -d file 文件为目录为真 -c file 文件为字符特殊文件为真 -b file 文件为块特殊文件为真 -s file 文件大小非0时为真 -t file 当文件描述符(默认为1)指定的设备为终端时为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:5","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"4、复杂逻辑判断 参数 解释 -a 与 -o 或 ! 非 ","date":"2018-11-11","objectID":"/shell-script-note/:3:6","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"结尾 语法虽然简单，但是在SHELL里使用的时候，他的功能变得强大了。 ================================================================== ","date":"2018-11-11","objectID":"/shell-script-note/:3:7","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"附 表 参数 解释 [ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 [ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。 [ STRING1 != STRING2 ] 如果字符串不相等则为真。 [ STRING1 \u003c STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 [ STRING1 \u003e STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 [ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. ","date":"2018-11-11","objectID":"/shell-script-note/:3:8","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"运行 在Linux系统下运行.sh文件有两种方法，比如我在root目录下有个datelog.sh文件 第一种（这种办法需要用chmod使得文件具备执行条件(x): chmod u+x datelog.sh）： 1、在任何路径下，输入该文件的绝对路径/root/datelog.sh就可执行该文件（当然要在权限允许情况下） 2、cd到datelog.sh文件的目录下，然后执行./datelog.sh 第二种（这种办法不需要文件具备可执行的权限也可运行）： 1、在该文件路径下sh加上文件名字即可，sh datelog.sh 2、在任意路径下，sh 加上文件路径及文件名称：sh /root/ datelog.sh ","date":"2018-11-11","objectID":"/shell-script-note/:4:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"脚本换行符,如何在Bash Shell中使用换行符（\\n） \\n(换行)用作基于Unix的系统的换行符。下面是在bash shell脚本中使用换行符的简单示例。 双引号中的字符串：$ echo -e “This is First Line \\nThis is Second Line” 单引号中的字符串：$ echo -e ‘This is First Line \\nThis is Second Line’ 带$前缀的字符串：$ echo $‘This is First Line \\nThis is Second Line’ 使用printf命令：$ printf “This is First Line \\nThis is Second Line” ","date":"2018-11-11","objectID":"/shell-script-note/:5:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Software","note"],"content":"记录火狐浏览器使用笔记","date":"2018-10-15","objectID":"/firefox-note/","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器使用笔记","uri":"/firefox-note/"},{"categories":["Software","note"],"content":"火狐浏览器禁用js 首先打开火狐浏览器 接着再地址栏输入about:config，点击回车键 接着看到如下画面。去掉下次任显示此警告前面的方框里的钩，再点击我 保证会小心按钮 点击后看到如下画面，在搜索地址栏中输入javascript.enabled 接着就会看到如下图，原来有很多的内容变成之后两个了。 鼠标右键第一个，弹出菜单。再点击切换 当一行的中的，值由trun变成false。时候说明已经关闭了。 如下图只要打开有javascript，页面就会无法使用了。有些页面还会提示。 ","date":"2018-10-15","objectID":"/firefox-note/:1:0","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器使用笔记","uri":"/firefox-note/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错","date":"2018-09-15","objectID":"/win10-update-80070003/","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错 关闭Windows Update服务 删除C:\\Windows\\SoftwareDistribution\\Download下的内容 启动Windows Update服务 再次更新即可 ","date":"2018-09-15","objectID":"/win10-update-80070003/:1:0","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Hardware","note"],"content":"记录键盘符号中英文对照表","date":"2018-08-20","objectID":"/keyboard-chinese-english/","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["Hardware","note"],"content":" 键 英文 中文 ~ tilde 波浪符 ` back quote 反引号 ! exclamation mark or bang 叹号 @ at 艾特 # hash or number or sharp 井号 $ dollar 美元符 % percent 百分号 ^ caret 脱字符、插入符 \u0026 and or ampersand 与和符 ***** asterisk 星号 ( ) parentheses 圆括号、小括号 [ ] brackets 方括号、中括号 { } curly brackets 花括号、大括号 - hyphen or dash or minus 连字符、减号 _ underscore 下划线 + plus 加号 = equal 等号 / slash 斜线 ** back slask 反斜线 | pipe or bar 竖线 : colon 冒号 ; semicolon 分号 ' single quote 单引号 \" “ quote 双引号 \u003c less than or angle brackets 小于 \u003e greater than or angle brackets 大于 , comma 逗号 . period or dot 句号 ? question mark 问号 ESC escape key 跳离键 Backspace backspace key 退格键 Insert insert key 插入建 Home home key 原位键 Delete delete key 删除键 End end key 结尾键 Page Up page up key 向上翻页键 Page Down page down key 向下翻页键 Enter enter key 回车键 Tab tab key 制表键 Caps Lock caps lock key 大写锁定键 ALT alternate key 可选键 CTRL control key 控制键 SHIFT shift key 上档键 Space space bar 空格键 Num num lock key 数字键盘锁定键 ","date":"2018-08-20","objectID":"/keyboard-chinese-english/:0:0","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["Back"],"content":"记录Idea各种乱码解决办法","date":"0001-01-01","objectID":"/idea-chinese-garbled-code-error/","tags":["IDE","Idea","ChineseGarbledCode","Error"],"title":"Idea各种乱码解决办法","uri":"/idea-chinese-garbled-code-error/"},{"categories":["Back"],"content":"Idea控制台乱码 全部转换为utf-8 如此设置tomcat下的conf文件夹下的logging.properties文件中 java.util.logging.ConsoleHandler.encoding = UTF-8一行不需要改变 （打开设置） 1.idea设置全部为utf-8 2.修改控制台编码为utf-8 3.1普通Java项目启动设置utf-8（打开Settings设置，同第一步） -encoding UTF-8 3.2JavaWeb项目启动设置utf-8（打开配置） -Dfile.encoding=UTF-8 ","date":"0001-01-01","objectID":"/idea-chinese-garbled-code-error/:1:0","tags":["IDE","Idea","ChineseGarbledCode","Error"],"title":"Idea各种乱码解决办法","uri":"/idea-chinese-garbled-code-error/"},{"categories":["Back"],"content":"低版本Idea文件中中文乱码 解决方法 一：修改 IDEA 开发环境的 File Encodings step1：点击菜单栏 File -\u003e 选择 Settings -\u003e 搜索 File Encodings step2：将以下的 Encoding 修改成 UTF-8 解决方法 二：修改安装文件，添加 -Dfile.encoding=UTF-8 step1：IDEA软件安装目录bin目录下，找到以下两个文件 step2：分别打开文件，在文件中添加 -Dfile.encoding=UTF-8 step3：重启IDEA ","date":"0001-01-01","objectID":"/idea-chinese-garbled-code-error/:2:0","tags":["IDE","Idea","ChineseGarbledCode","Error"],"title":"Idea各种乱码解决办法","uri":"/idea-chinese-garbled-code-error/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.78.1). 推荐使用 Hugo extended 版本\r\r由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 CodeIT 主题的仓库是: https://github.com/sunt-programator/CodeIT. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/sunt-programator/CodeIT.git themes/CodeIT 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/sunt-programator/CodeIT.git themes/CodeIT ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 CodeIT 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"CodeIT\" [params] # CodeIT 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/sunt-programator/CodeIT/issues/158) noClasses = false 注意\r\r在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意\r\r默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \"\r基本配置下的预览\r 技巧\r\r当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\r\r 注意\r\r由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender \r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧\r\r网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多…\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, CodeIT 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # CodeIT 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"CodeIT\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # (HTML format is supported) # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意\r\rHugo extended 版本对于自定义样式是必需的.\r\r 通过定义自定义 .scss 样式文件, CodeIT 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/CodeIT/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url(\"https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext\"); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n CodeIT 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \"\r语言切换\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo 如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意\r\r请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容.\r\r 技巧\r\r也可以使用 文章前置参数 来翻译网址.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/CodeIT/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, CodeIT 主题支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎?\r\r以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. \r\r 关于 algolia 的使用技巧\r\r你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json…\r\r","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\" \u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.1 instagram(旧版) instagram 的文档 instagram官方文档（Facebook） 一个 instagram 示例: {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} 呈现的输出效果如下: 这个instagram的shortcode功能依赖于 Instagram的一个API, 然而自从2020年10月24日起就被弃用了。因此，无法从此API端点获取任何图像，从而导致在使用instagram的shortcode时出错。有关更多信息，请查看GitHub问题[#7879] #7879. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.2 instagram(我搜索并根据官方文档的办法) instagram 的文档（Hugo官方未更新） instagram官方文档（Facebook） #1.在开发者官方注册 #在开发者工具中创建任务获取app-id和app-secret，填入下面的请求地址 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id={your-app-id} \u0026client_secret={your-app-secret} \u0026grant_type=client_credentials\" # 示例 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id=123\u0026client_secret={456} \u0026grant_type=client_credentials\" #获得token后填入下面的地址，即可获得返回的html代码 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url={url}\u0026access_token={access-token}\" # 示例 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url=https://www.instagram.com/p/fA9uwTtkSN/\u0026access_token=IGQVJ...\" 总结如下，新版无法进行直接内嵌完成，需要完成以下步骤（两种方式均可）参考前端大佬js获取的方式 Instagram oEmbed 嵌入 IG 貼文 Facebook：应用程式、ID、密钥、URL 4.2.1直接使用手机客户端应用打开，找到对应的文章，点击三点，再点击内嵌即可生成对应的访问地址 4.2.2使用代码方式步骤 到Facebook for Developers上建立一个应用程序，取得编号、密钥 要在Firebase 开启Facebook 登入功能，需要有一组Facebook 应用程式的ID、密钥。 本篇建立的应用程式是示范用，本篇上线时就会删除，因此应用程式编号、密钥都会不存在。 进到FACEBOOK for Developers的页面并登入FB帐号后，点击「建立应用程式」： 工作的部份选「更多选项」： 下一个是要填写应用程式的显示名称，就填一个我们看得懂在做什么的名称： 填完后按下「建立应用程式」，就会建立完成。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"应用程式编号、密钥、OAuth URL 应用程式建立完，进到应用程式，左侧选单点击「设定\u003e 基本资料」，就会看到「应用程式编号」、「应用程式密钥」，以及一些需要填写的栏位： 应用程序上新增产品：oEmbed，并把应用程序调整成「上线」 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增产品：oEmbed 应用程式建立完成后，左侧选单点击「产品」旁边的「+」： 然后找到「oEmbed」这项，点击「设定」： 会跳一个确认框，打勾后按下「确认」，左侧的产品清单就会新增oEmbed，代表新增成功。 最后顶部那条有一个显示为「调整中」的Toggle 按钮： 我们点一下按钮，并确认要切换模式，让它变成「上线」，这个应用程式就可以对外使用了： 在Google云端硬盘上新增Google Apps Script的档案，档案中写取得Access Token的代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增GAS 档案当后端，取得FB Access Token 为了要能够使用FB 的应用程式，必须要有一个Access Token 才能够被FB 放行，因为取Token 的过程会用到密钥，因此要写在后端，写在前端会被看光光。 最快写一支后端的方式就是用Google 云端硬碟里的Google Apps Script 档案，以下简称GAS。 进到Google 云端硬碟，点左上角的「新增\u003e 更多\u003e Google Apps Script」： 进到档案后，我们先改个档名进行存档，滑到左上角的档案名称上，点击一次就可以开始改档名 右侧预设会有一个myFunction，整个删掉后，贴上以下程式码，主要是来取得Access Token的： var appId = '从FB后台取得的「应用程式编号」' ; var secret = '从FB后台取得的「应用程式密钥」' ; var uri = 'https://graph.facebook.com/oauth/access_token?client_id=' + appId + '\u0026client_secret=' + secret + '\u0026grant_type=client_credentials' ; function doGet ( e ) { var response = UrlFetchApp . fetch ( uri ) ; return ContentService . createTextOutput ( response ) . setMimeType ( ContentService . MimeType . JSON ) ; } appId、secret这二个变数记得要修改。 doGet指的是当这个GAS预到GET时要执行哪些动作，function里面写的是向FB取得Access Token。 程式码贴上并更新好变数后，按下右上角的「部署\u003e 新增部署作业」： 点击「选取类型」右边的齿轮icon，选择「网页应用程式」： 接着右侧「谁可以存取」的地方改为所有人： 按下「部署」后，第一次部署会需要开存取权： 点击上图的「授予存取权」后，会出现一个警告视窗： 因为这个应用程式是我们自己写的，是可以相信的，点击上图左上角的「进阶」后，会展开一小行字： 点击上图左下角的「前往XXX（不安全）」，因为我们的应用程式没向Google 请求验证过，这边就会一直秀出不安全的字样。 点击了以后会要授予存取权： 按下「允许」，这个GAS 档就成功部署，并且会给一串网址： 这个网址很重要，就像API一样，GET这个网址，就会回传一组Access Token回来。 用JavaScript、Postman、浏览器等取Access Token，并用Access Token取得Instagram贴文的嵌入代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"取Token、取IG 贴文 在上一步的最后我们取得了部署的网址，首先我们先用GET取得Access Token回来： const getToken = '部署完取得的网址' ; fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) Console 出来的response 资料会像这样： { access_token: \"405342487221016|50nqwaePxasUkpNVyIwrJpoA2H0\", token_type: \"bearer\" } 所以我们可以知道，response.access_token就是我们要的Access Token。 接下来就是拿这个Access Token 去取得IG 的贴文内容。 首先我们要先有IG 贴文的网址，在贴文上面点右上角的点点点，在点击「复制连结」，就取到贴文的网址了： 有了贴文的网址，也有了Token，我们可以用一个GET来取得贴文的资讯： const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //要不要隐藏描述，true隐藏、false不隐藏 fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e response . access_token ) . then ( token =\u003e { fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }` ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) } ) ; 从API 的URL 上可以看到，需要的参数有：IG 贴文网址、Access Token，跟hidecaption 是否要隐藏描述。 hidecaption 没有写在新的文件里，神奇的是却有写在旧文件里，这是Augustus 看了前一篇的文章后试出来的，所以如果哪天FB 把这参数拿掉也不用意外。 另外，复制出的IG 贴文网址本身会带一个参数，像这样： https://www.instagram.com/p/CK6wSwfpuVi/?igshid=1wy9n8xgtbe89 实测后，有没有写到igshid 这个参数都没关系，都抓得到贴文资料回来。 除了上面三个参数，还有二个参数是官方文件有提供的：maxwidth、omitscript。 maxwidth 是可以指定嵌入贴文时的最大宽度。 omitscript是Boolean值，预设为false，一般来说我们在嵌入IG贴文时，IG会自动把贴文的资料载入，如果我们想要有另外执行载入贴文的需求，这边就可以写true，之后再执行：instgrm.Embeds.process()就可以把贴文载进页面中。 But！实作时，不确定是不是Augustus有写错，不论omitscript是true或false，如果没执行instgrm.Embeds.process()那贴文就会是呈现白白的样子，像这样： 而且旧的方法吐回来的html，里面会自行引用IG 的embed.js，新的看起来是跟FB 整并所以就没有了，要自行引用： \u003cscript src=\"https://www.instagram.com/embed.js\"\u003e\u003c/script\u003e console 出来的response 会长这样： 可以看到的值有： author_name html provider_name provider_url thumbnail_height thumbnail_url thumbnail_width type version width 其中html就是我们要嵌入IG贴文的程式码，整段放到我们要放的地方就行，这篇的Demo是放在\u003cdiv id=\"ig-iframe\"\u003e\u003c/div\u003e这个div中。 完整嵌入IG 贴文的程式码如下： \u003c div id =\" ig-iframe \" \u003e \u003c/ div \u003e \u003c script src =\" https://www.instagram.com/embed.js \" \u003e \u003c/ script \u003e \u003c script \u003e const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //选填，要不要隐藏描述，true隐藏、false不隐藏，预设为false const maxWidth = 400 ; //选填，贴文的最大宽度是多少 fetch ( getToken ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const token = res . access_token ; fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }\u0026maxwidth= ${ maxWidth }` ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const wrap = document . getElementById ( 'ig-iframe' ) ; wrap . insertAdjacentHTML ( 'afterbegin' , res . html ) ; instgrm . Embeds . process ( ) ; } ) . catch ( err =\u003e { throw Error ( e ) } ) } ) . catch ( err =\u003e { throw Error ( e ) } ) ; \u003c/ script \u003e 完成的IG 贴文嵌入就完成啦~ 如此两种方式并不能简洁快速的嵌入instagram，需要同一般资源一样进行嵌入，Hugo官方表示不能继续使用，且暂时并未做出修改适配，若已经适配请联系我。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} 呈现的输出效果如下: Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ## 8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用\r\r有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意\r\r不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做.\r\r 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧\r\rfeaturedImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 CodeIT 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \"\r文章摘要预览\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意\r\r请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 CodeIT 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意\r\r不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 CodeIT 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 CodeIT 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧\r\r有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单.\r\r 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int\\_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧\r\r你可以在 网站配置 中自定义公式块和行内公式的分割符.\r\r Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 CodeIT 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 CodeIT 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome CodeIT 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧\r\r这个方法可以间接解决一个还未解决的 Hugo 的 issue.\r\r 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意\r\rHugo extended 版本对于 style shortcode 是必需的.\r\r style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\"\rLighthouse (image)\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip\r\r一个 技巧 横幅\r\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 _-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --_ C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K 线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: \r如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r\r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意\r\r脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库.\r\r 一个 script 示例: {{\u003c script \u003e}} console.log('Hello CodeIT!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation","note"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 CodeIT 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003e Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. \u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e这是 \u003cb\u003eHTML\u003c/b\u003e\u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** **渲染为粗体** 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. _渲染为斜体_ _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. **_加粗和斜体_** ~~**删除线和加粗**~~ ~~_删除线和斜体_~~ ~~**_加粗, 斜体和删除线_**~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel \u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del \u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. \u003e Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e \u003e \u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor \u003e \u003e odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: - 一项内容 * 一项内容 - 一项内容 例如: - Lorem ipsum dolor sit amet - Consectetur adipiscing elit - Integer molestie lorem at massa - Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at - Faucibus porta lacus fringilla vel - Aenean sit amet erat nunc - Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003e Nulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ------------------------------------------------------------------------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003e path to data files to supply the data that will be passed into templates. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003e engine to be used for processing templates. Handlebars is the default. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | | :----: | ------------------------------------------------------------------------: | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents - [Chapter 1](#chapter-1) - [Chapter 2](#chapter-2) - [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rCodeIT 主题提供了一个包含更多功能的 图片的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"14 转义 文档中一下部分字符特别是类似于\u003cscript\u003e、\u003clink\u003e这样的标签等符号不能直接写大于小于号，需要进行转义，否则会使页面报错（前面添加 \\ 或者使用 ` 包裹(代码)或 \\ 和 ` 包裹，或者使用 Html 转义字符） 用 \\ 和 ` 包裹 \\`val\\` 需要转义的字符 显示结果 描述 实体名称 实体编号 空格     \u003c 小于号 \u003c \u003c \u003e 大于号 \u003e \u003e \u0026 与和号 \u0026 \u0026 \" 双引号 \" \" ' 单引号 '(IE不支持) ' 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:14:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"Hugo 和 CodeIT 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人与身体 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"活动 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"符号 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旗帜 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Back","note"],"content":"记录Mysql数据库相关的笔记","date":"2021-07-15","objectID":"/mysql-install-note/","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"下载 ","date":"2021-07-15","objectID":"/mysql-install-note/:1:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"最新版本 https://dev.mysql.com/downloads/mysql/ ","date":"2021-07-15","objectID":"/mysql-install-note/:1:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"历史版本 https://downloads.mysql.com/archives/community/ ","date":"2021-07-15","objectID":"/mysql-install-note/:1:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"安装 ","date":"2021-07-15","objectID":"/mysql-install-note/:2:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"Windows 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 下。 接下来我们需要配置下 MySQL 的配置文件 打开刚刚解压的文件夹 C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： [client] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=C:\\\\Program_Green\\\\Java_env\\\\mysql-5.7.33-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=C:\\\\Program_Green\\\\Java_env\\\\mysql-5.7.33-winx64\\\\data # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 配置环境变量 在系统变量处新建MYSQL_HOME项 MYSQL_HOME C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 在Path处添加%MYSQL_HOME%\\bin（或者用;（英文）分割，Append到最后） 接下来我们来启动下 MySQL 数据库： 以管理员身份打开 cmd 命令行工具，切换目录： cd C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64\\bin 初始化数据库： mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码，如： ... 2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws\u0026hjQ ... APWCY5ws\u0026hjQ 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。 输入以下安装命令： mysqld install 启动输入以下命令即可： net start mysql 注意: 在 5.7 需要初始化 data 目录： C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 mysqld --initialize-insecure 初始化后再运行 net start mysql 即可启动 mysql。 登录 MySQL 当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名: mysql -h 主机名 -u 用户名 -p 参数说明： -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可： mysql -u root -p 按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应: Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysq\u003e 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 修改初始密码 不重置初始密码什么都不能做 ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 修改密码的方法： mysql\u003e alter user root@localhost identified by 'ZfL001!'; ","date":"2021-07-15","objectID":"/mysql-install-note/:2:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"Linux Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址： MySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。 MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。 MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。 MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。 MySQL-bench - MySQL数据库服务器的基准和性能测试工具。 安装前，我们可以检测系统是否自带安装 MySQL: rpm -qa | grep mysql 如果你系统有安装，那可以选择进行卸载: rpm -e mysql　// 普通删除模式 rpm -e --nodeps mysql　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 安装 MySQL： 接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server 权限设置： chown mysql:mysql -R /var/lib/mysql 初始化 MySQL： mysqld --initialize 启动 MySQL： systemctl start mysqld 查看 MySQL 运行状态： systemctl status mysqld **注意：**如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 此外,你也可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。 yum install mariadb-server mariadb mariadb数据库的相关命令是： systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 验证 MySQL 安装 在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。 使用 mysqladmin 工具来获取服务器状态： 使用 mysqladmin 命令来检查服务器的版本, 在 linux 上该二进制文件位于 /usr/bin 目录，在 Windows 上该二进制文件位于C:\\mysql\\bin 。 [root@host]# mysqladmin --version linux上该命令将输出以下结果，该结果基于你的系统信息： mysqladmin Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386 如果以上命令执行后未输出任何信息，说明你的Mysql未安装成功。 使用 MySQL Client(Mysql客户端) 执行简单的SQL命令 你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到 MySQL 服务器上，默认情况下 MySQL 服务器的登录密码为空，所以本实例不需要输入密码。 命令如下： [root@host]# mysql 以上命令执行后会输出 mysql\u003e提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql\u003e 提示符执行SQL命令： mysql\u003e SHOW DATABASES; +----------+ | Database | +----------+ | mysql | | test | +----------+ 2 rows in set (0.13 sec) Mysql安装后需要做的 Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： [root@host]# mysqladmin -u root password \"new_password\"; 现在你可以通过以下命令来连接到Mysql服务器： [root@host]# mysql -u root -p Enter password:******* **注意：**在输入密码时，密码是不会显示了，你正确输入即可。 ","date":"2021-07-15","objectID":"/mysql-install-note/:2:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"管理 ","date":"2021-07-15","objectID":"/mysql-install-note/:3:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"Windows 在 Windows 系统下，打开命令窗口(cmd)，进入 MySQL 安装目录的 bin 目录。 启动： cd c:/mysql/bin net start mysql #管理员模式控制台 # 或 mysqld --console #(服务不启动，需要在手动去服务界面启动或执行上面一条指令) 关闭： cd c:/mysql/bin net stop mysql #管理员模式控制台 # 或 mysqladmin -u root shutdown #无密码 mysqladmin -u root -p shutdown # 要输入密码 在安装mysql时系统会添加服务，可以通过管理工具里面的 \u003c服务\u003e 一项来停止和启动mysql。这样修改的my.ini就会生效了。 ","date":"2021-07-15","objectID":"/mysql-install-note/:3:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":["Back","note"],"content":"Linux 首先，我们需要通过以下命令来检查MySQL服务器是否启动： ps -ef | grep mysqld 如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器: root@host# cd /usr/bin ./mysqld_safe \u0026 如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令: root@host# cd /usr/bin ./mysqladmin -u root -p shutdown Enter password: ****** ","date":"2021-07-15","objectID":"/mysql-install-note/:3:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-install-note/"},{"categories":null,"content":" 警告\r\rSorry, this article has not been completely translated into French. Welcome to take the time to propose a translation by  making a PR to the theme!\r\r  CodeIT is a clean, elegant but advanced blog theme for Hugo. It is based on the original LoveIt Theme, LeaveIt Theme, and KeepIt Theme. Hugo Theme CodeITHugo Theme CodeIT \"\rHugo Theme CodeIT\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"许可协议 CodeIT 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 CodeIT 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 CodeIT","uri":"/about/"}]