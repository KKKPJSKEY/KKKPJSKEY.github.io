[{"categories":["Total","note"],"content":"基于广播和服务功能的音乐播放器","date":"2021-05-11","objectID":"/android-music-box/","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1、应用知识点 ","date":"2021-05-11","objectID":"/android-music-box/:1:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.1、Android 广播接收器(Broadcast Receivers) 广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。例如，应用程序可以初始化广播来让其他的应用程序知道一些数据已经被下载到设备，并可以为他们所用。这样广播接收器可以定义适当的动作来拦截这些通信。 有以下两个重要的步骤来使系统的广播意图配合广播接收器工作。 创建广播接收器 注册广播接收器 还有一个附加的步骤，要实现自定义的意图，你必须创建并广播这些意图。 ","date":"2021-05-11","objectID":"/android-music-box/:1:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.2、服务（Service） 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。服务基本上包含两种状态 状态 描述 Started Android的应用程序组件，如活动，通过startService()启动了服务，则服务是Started状态。一旦启动，服务可以在后台无限期运行，即使启动它的组件已经被销毁。 Bound 当Android的应用程序组件通过bindService()绑定了服务，则服务是Bound状态。Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。 ","date":"2021-05-11","objectID":"/android-music-box/:1:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、原型图 老师要求的原型图仅包括四个按钮和两个文本。 四个按钮分别为上一曲、播放暂停、停止、下一曲；两个文本为曲名和歌手。 我在老师要求的基础上，结合上次实验RecyclerView进行更新，目的如图所示，实现一个类似常规音乐播放器的界面。 左侧包括歌曲的图片，上方时每首歌的列表。 ","date":"2021-05-11","objectID":"/android-music-box/:2:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、需求 编写音乐盒代码，参考群文件-源码-Musicbox，掌握源码后在其基础上添加音乐播放的 上一首 和 下一首 控制，也可以增加更多的功能。 ","date":"2021-05-11","objectID":"/android-music-box/:3:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"3、思路 在真正的代码撰写中，广播就是内嵌于activity和service的。在界面中绘制四个按钮、一个图片和两个文本，填入数据。监听不同按钮点击事件，绑定对应的广播函数或服务。 ","date":"2021-05-11","objectID":"/android-music-box/:4:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-05-11","objectID":"/android-music-box/:5:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.1、fragment_mes.xml（在原基础上添加即可） \u003candroidx.constraintlayout.widget.ConstraintLayout android:id=\"@+id/constraintLayout_mes_mp\" android:layout_width=\"match_parent\" android:layout_height=\"70dp\" android:layout_gravity=\"bottom\" android:background=\"#99BB86FC\" android:orientation=\"horizontal\"\u003e \u003cImageButton android:id=\"@+id/iB_ablum\" android:layout_width=\"70dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/flower1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.0\" /\u003e \u003cTextView android:id=\"@+id/tV_musicName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"15dp\" android:text=\"Inside the Lines\" android:textColor=\"#FFFFFFFF\" android:textSize=\"16sp\" android:textStyle=\"bold\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.333\" /\u003e \u003cTextView android:id=\"@+id/tV_singerName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"5dp\" android:text=\"Mike Perry\" android:textColor=\"#DDFFFFFF\" android:textSize=\"14sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toBottomOf=\"@+id/tV_musicName\" /\u003e \u003cImageButton android:id=\"@+id/iB_lastPiece\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_left_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_playPause\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_playPause\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_drop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_stop\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_stop\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"#00BB86FC\" android:src=\"@drawable/stop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"@+id/iB_lastPiece\" app:layout_constraintEnd_toStartOf=\"@+id/iB_nextPlay\" app:layout_constraintTop_toTopOf=\"@+id/iB_lastPiece\" /\u003e \u003cImageButton android:id=\"@+id/iB_nextPlay\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-05-11","objectID":"/android-music-box/:5:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.2、MesFragment.java（仅展示在原来recyclerView之后的内容） public class MesFragment extends Fragment implements View.OnClickListener { // 获取界面中显示歌曲标题、作者文本框 TextView title, author; // 播放/暂停、停止按钮、上一曲按钮，下一曲按钮 ImageButton play, stop, next, last; ActivityReceiver activityReceiver; public static final String CTL_ACTION = \"org.xr.action.CTL_ACTION\"; public static final String UPDATE_ACTION = \"org.xr.action.UPDATE_ACTION\"; // 定义音乐的播放状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; String[] titleStrs = new String[]{\"Inside the Lines\", \"Landslide\", \"Life\", \"Symphony\", \"The Spectre\"}; String[] authorStrs = new String[]{\"Mike Perry\", \"Headhunterz\", \"Tobu\", \"Clean Bandit\", \"Alan Walker\"}; // 获取程序界面界面中的两个按钮 play = (ImageButton) view.findViewById(R.id.iB_playPause); stop = (ImageButton) view.findViewById(R.id.iB_stop); title = (TextView) view.findViewById(R.id.tV_musicName); author = (TextView) view.findViewById(R.id.tV_singerName); //获取上一首、下一首按钮 last = (ImageButton) view.findViewById(R.id.iB_lastPiece); next = (ImageButton) view.findViewById(R.id.iB_nextPlay); // 为两个按钮的单击事件添加监听器 play.setOnClickListener(this); stop.setOnClickListener(this); //为上一首、下一首按钮添加监听器 last.setOnClickListener(this); next.setOnClickListener(this); activityReceiver = new ActivityReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); // 指定BroadcastReceiver监听的Action filter.addAction(UPDATE_ACTION); // 注册BroadcastReceiver getActivity().registerReceiver(activityReceiver, filter); Intent intent = new Intent(getActivity(), MusicService.class); // 启动后台Service getActivity().startService(intent); return view; } // 自定义的BroadcastReceiver，负责监听从Service传回来的广播 public class ActivityReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 获取Intent中的update消息，update代表播放状态 int update = intent.getIntExtra(\"update\", -1); // 获取Intent中的current消息，current代表当前正在播放的歌曲 int current = intent.getIntExtra(\"current\", -1); if (current \u003e= 0) { title.setText(titleStrs[current]); author.setText(authorStrs[current]); } switch (update) { case 0x11: play.setImageResource(R.drawable.arrow_right_drop_circle_outline); status = 0x11; break; //控制系统进入播放状态 case 0x12: // 播放状态下设置使用暂停图标 play.setImageResource(R.drawable.pause_circle_outline); // 设置当前状态 status = 0x12; break; // 控制系统进入暂停状态 case 0x13: // 暂停状态下设置使用播放图标 play.setImageResource(R.drawable.arrow_right_drop_circle_outline); // 设置当前状态 status = 0x13; break; } } } @Override public void onClick(View source) { // 创建Intent Intent intent = new Intent(\"org.xr.action.CTL_ACTION\"); switch (source.getId()) { // 按下播放/暂停按钮 case R.id.iB_playPause: intent.putExtra(\"control\", 1); break; // // 按下停止按钮 case R.id.iB_stop: intent.putExtra(\"control\", 2); break; // 按下上一曲按钮 case R.id.iB_lastPiece: intent.putExtra(\"control\", 3); break; // 按下下一曲按钮 case R.id.iB_nextPlay: intent.putExtra(\"control\", 4); break; } // 发送广播，将被Service组件中的BroadcastReceiver接收到 getActivity().sendBroadcast(intent); } } ","date":"2021-05-11","objectID":"/android-music-box/:5:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.3、MusicService.java（播放音乐服务） public class MusicService extends Service { MyReceiver serviceReceiver; AssetManager am; String[] musics = new String[]{\"insidethelines.mp3\", \"landslide.mp3\", \"life.mp3\", \"symphony.mp3\", \"thespectre.mp3\"}; // String[] musics = new String[] {\"liangliang.mp3\", \"wuhangya.mp3\",\"three.mp3\" ,\"four.mp3\",\"fif.mp3\"}; MediaPlayer mPlayer; // 当前的状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; // 记录当前正在播放的音乐 int current = 0; @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); am = getAssets(); // 创建BroadcastReceiver serviceReceiver = new MyReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); filter.addAction(MesFragment.CTL_ACTION); registerReceiver(serviceReceiver, filter); // 创建MediaPlayer mPlayer = new MediaPlayer(); // 为MediaPlayer播放完成事件绑定监听器 mPlayer.setOnCompletionListener(new OnCompletionListener() // ① { @Override public void onCompletion(MediaPlayer mp) { current++; if (current \u003e= 5) { current = 0; } //发送广播通知Activity更改文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); // 准备并播放音乐 prepareAndPlay(musics[current]); } }); } public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(final Context context, Intent intent) { int control = intent.getIntExtra(\"control\", -1); switch (control) { // 播放或暂停 case 1: // 原来处于没有播放状态 if (status == 0x11) { // 准备并播放音乐 prepareAndPlay(musics[current]); status = 0x12; } // 原来处于播放状态 else if (status == 0x12) { // 暂停 mPlayer.pause(); // 改变为暂停状态 status = 0x13; } // 原来处于暂停状态 else if (status == 0x13) { // 播放 mPlayer.start(); // 改变状态 status = 0x12; } break; // 停止声音 case 2: // 如果原来正在播放或暂停 if (status == 0x12 || status == 0x13) { // 停止播放 current++; mPlayer.stop(); status = 0x11; } case 3: current--; if (current \u003c 0) { current = 4; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; case 4: current++; if (current \u003e 4) { current = 0; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; } // 广播通知Activity更改图标、文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"update\", status); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); } } private void prepareAndPlay(String music) { try { // 打开指定音乐文件 AssetFileDescriptor afd = am.openFd(music); mPlayer.reset(); // 使用MediaPlayer加载指定的声音文件。 mPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()); // 准备声音 mPlayer.prepare(); // 播放 mPlayer.start(); } catch (IOException e) { e.printStackTrace(); } } } ","date":"2021-05-11","objectID":"/android-music-box/:5:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-05-11","objectID":"/android-music-box/:6:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.1、初始状态，暂停未进行播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.2、点击播放按钮，按钮变为等待暂停状态，音乐播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.3、点击上一曲按钮，保存当前状态（播放或暂停）切换到上一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.4、点击下一曲按钮，保存当前状态（播放或暂停）切换到下一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:4","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.5、点击暂停则停止播放，点击继续则从刚才的位置继续播放，点击停止按钮停止播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:5","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"6、结语 本次实验感想颇多，在不同的学习渠道，加上百度搜索，请教同学最终仅仅完成了一个初步的成果。后续需要改进和维护的东西还有很多很多。音乐的图标需要更换，切换歌曲应该随之切换图片，recyclerView的数据并没有与歌曲一同绑定。本人水平一般，能力有限，精力也有限，随着时间的推移慢慢完善吧。 ","date":"2021-05-11","objectID":"/android-music-box/:7:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"7、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design 注： 源码中为了实现某些功能，减少大面积重命名文件的情况，信息和朋友页面进行对调（id），朋友改为音乐（title和icon），请读者注意！ 在下次实验完成前，master分支和本次实验分支（Music_Box）会有一样的本次实验代码，下次实验完成后会新创建分支，保存新实验的代码啊，更新master分支代码 ","date":"2021-05-11","objectID":"/android-music-box/:8:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换","date":"2021-04-04","objectID":"/android-bottom-navigation/","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:0:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"1、原型图 顶部一个导航栏，，加号按钮的下拉菜单，下面是四个Tab页面，点击下方按钮，每个页面的上下两个导航栏之间的内容会随之发生变化，同时点击状态下的图标样式也随之变化。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:1:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"2、需求 请根据课堂展示结果设计APP门户界面，包含4个tab切换效果。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:2:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"3、思路 为了使用上课讲到的Material Design设计模式，我们分别使用了TopAppBar，一个ButtomNavigationMenu以及四个Fragment。同时采用了java语言作为点击按钮后界面内容的改变控制 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:3:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.1、创建一个Empty项目 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.2、页面-activity_main.xml-四个界面的主（公共）组件 根据官方文档，导航栏有四种模式，auto、labeled、selected、unlabeled,对应关系如下 参数 解释 auto 当有3个或更少的项目时，标签的行为为“labeled”；当有4个或更多的项目时，标签的行为为“selected”。 labeled 标签显示在所有导航项目上 selected（default） 标签显示在所选的导航项目上。（默认） unlabeled 标签未显示在任何导航项目上。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:visibility=\"visible\" tools:context=\".MainActivity\"\u003e \u003cLinearLayout android:id=\"@+id/linearLayout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintBottom_toTopOf=\"@+id/bottom_navigation_menu\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"\u003e \u003cFrameLayout android:id=\"@+id/frameLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e \u003ccom.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/bottom_navigation_menu\" style=\"@style/Widget.MaterialComponents.BottomNavigationView.Colored\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:labelVisibilityMode=\"labeled\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"1.0\" app:layout_constraintStart_toStartOf=\"parent\" app:menu=\"@menu/bottom_navigation_menu\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.3、页面-fragment_ctt.xml-联系人组件（朋友、信息、设置都差不多，不再过多展示，GitHub源码地址在本文最后） \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MesFragment\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/cttText\" /\u003e \u003c/FrameLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.4、页面-bottom_navigation_menu.xml-底部导航栏组件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"\u003e \u003citem android:id=\"@+id/page_Mes\" android:enabled=\"true\" android:icon=\"@drawable/tab_weixin_normal\" android:title=\"@string/message\" /\u003e \u003citem android:id=\"@+id/page_Fri\" android:enabled=\"true\" android:icon=\"@drawable/tab_find_frd_normal\" android:title=\"@string/friends\" /\u003e \u003citem android:id=\"@+id/page_Ctt\" android:enabled=\"true\" android:icon=\"@drawable/tab_address_normal\" android:title=\"@string/contacts\" /\u003e \u003citem android:id=\"@+id/page_Set\" android:enabled=\"true\" android:icon=\"@drawable/tab_settings_normal\" android:title=\"@string/settings\" /\u003e \u003c/menu\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.5、页面-color.xml-颜色配置文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources\u003e \u003ccolor name=\"purple_200\"\u003e#FFBB86FC\u003c/color\u003e \u003ccolor name=\"purple_500\"\u003e#FF6200EE\u003c/color\u003e \u003ccolor name=\"purple_700\"\u003e#FF3700B3\u003c/color\u003e \u003ccolor name=\"teal_200\"\u003e#FF03DAC5\u003c/color\u003e \u003ccolor name=\"teal_700\"\u003e#FF018786\u003c/color\u003e \u003ccolor name=\"black\"\u003e#FF000000\u003c/color\u003e \u003ccolor name=\"white\"\u003e#FFFFFFFF\u003c/color\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:5","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.6、页面-strings.xml-文字字符串配置文件 \u003cresources\u003e \u003c!-- app标题--\u003e \u003cstring name=\"app_name\"\u003e微信80.0\u003c/string\u003e \u003c!-- 导航栏标题--\u003e \u003cstring name=\"message\"\u003e信息\u003c/string\u003e \u003cstring name=\"friends\"\u003e朋友\u003c/string\u003e \u003cstring name=\"contacts\"\u003e联系人\u003c/string\u003e \u003cstring name=\"settings\"\u003e设置\u003c/string\u003e \u003c!-- 界面二级标题--\u003e \u003cstring name=\"mesText\"\u003e这是信息页面！\u003c/string\u003e \u003cstring name=\"friText\"\u003e这是朋友页面！\u003c/string\u003e \u003cstring name=\"cttText\"\u003e这是联系人页面！\u003c/string\u003e \u003cstring name=\"setText\"\u003e这是设置页面！\u003c/string\u003e \u003c!-- TODO: Remove or change this placeholder text --\u003e \u003cstring name=\"hello_blank_fragment\"\u003eHello blank fragment\u003c/string\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:6","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.7、页面-theme.xml-主题配置文件 \u003cresources xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"Theme.Bottom_Navigation\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\"\u003e \u003c!-- Primary brand color. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/purple_500\u003c/item\u003e \u003citem name=\"colorPrimaryVariant\"\u003e@color/purple_700\u003c/item\u003e \u003citem name=\"colorOnPrimary\"\u003e@color/white\u003c/item\u003e \u003c!-- Secondary brand color. --\u003e \u003citem name=\"colorSecondary\"\u003e@color/teal_200\u003c/item\u003e \u003citem name=\"colorSecondaryVariant\"\u003e@color/teal_700\u003c/item\u003e \u003citem name=\"colorOnSecondary\"\u003e@color/black\u003c/item\u003e \u003c!-- Status bar color. --\u003e \u003citem name=\"android:statusBarColor\" tools:targetApi=\"l\"\u003e?attr/colorPrimaryVariant\u003c/item\u003e \u003c!-- Customize your theme here. --\u003e \u003c/style\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:7","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.8后台-MainActivity.java-控制逻辑代码 package cn.edu.hubu.lhy.bottom_navigation; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentTransaction; import android.os.Bundle; import android.view.Menu; import android.view.MenuInflater; import android.view.MenuItem; import android.widget.Toast; import com.google.android.material.bottomnavigation.BottomNavigationView; public class MainActivity extends AppCompatActivity { private MesFragment mesFragment = null; private FriFragment friFragment = null; private CttFragment cttFragment = null; private SetFragment setFragment = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView bottom_navigation_menu = (BottomNavigationView) findViewById(R.id.bottom_navigation_menu); bottom_navigation_menu.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); mesFragment = new MesFragment(); changeFrameLayout(\"您好\", mesFragment); } private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.page_Mes: if (mesFragment == null) { mesFragment = new MesFragment(); } changeFrameLayout(\"信息\", mesFragment); return true; case R.id.page_Fri: if (friFragment == null) { friFragment = new FriFragment(); } changeFrameLayout(\"朋友\", friFragment); return true; case R.id.page_Ctt: if (cttFragment == null) { cttFragment = new CttFragment(); } changeFrameLayout(\"联系人\", cttFragment); return true; case R.id.page_Set: if (setFragment == null) { setFragment = new SetFragment(); } changeFrameLayout(\"设置\", setFragment); return true; } return false; } }; /** * 使用Fragment组件替换原界面上的FragLayout * * @param string 提示信息 * @param fraGment 要替换成的fragment */ private void changeFrameLayout(String string, Fragment fraGment) { //弹窗 Toast.makeText(MainActivity.this, string, Toast.LENGTH_SHORT).show(); //每一次都要重新创建事务和管理工具 FragmentManager fagmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fagmentManager.beginTransaction(); //替换操作 fragmentTransaction.replace(R.id.frameLayout, fraGment); //事务具有原子性，类似数据库，每一次操作完成需要提交操作 fragmentTransaction.commit(); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:8","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.9、后台-CttFragment.java-联系人组件代码 创建Fragment自动生成的构造方法、newInstance()、onCreate()方法啊需要禁掉不然会产生一些问题 package cn.edu.hubu.lhy.bottom_navigation; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; /** * A simple {@link Fragment} subclass. * Use the {@link FriFragment#newInstance} factory method to * create an instance of this fragment. */ public class FriFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_fri, container, false); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:9","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.1、信息页面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.2、朋友界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.3、联系人界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.4、设置界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"6、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design ","date":"2021-04-04","objectID":"/android-bottom-navigation/:6:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Back"],"content":"记录Spring的笔记","date":"2021-08-25","objectID":"/spring-note/","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"BeanUtils工具类中的copyProperties方法使用 1、两个包下的BeanUtils.copyProperties对比 BeanUtils是开发中常用到的工具类，而获取这一工具类主要是通过导入org.springframework.beans.BeanUtils或者org.apache.commons.beanutils.BeanUtils包来获取，但是不同的包中BeanUtils的方法使用是不一样的，接下来就对这两个包中的copyProperties方法进行对比。 先来看一下这两个包中的copyProperties方法的定义： //org.springframework.beans.BeanUtils public static void copyProperties(Object source, Object target){....} //org.apache.commons.beanutils.BeanUtils public static void copyProperties(Object dest,Object orig){....} 由定义可知，在org.springframework.beans.BeanUtils包下的copyProperties第一个参数是被copy的对象，而org.apache.commons.beanutils.BeanUtils中是第二个参数，所以使用时不要弄混。 1）接下来定义两个实体类Student和Teacher，用来模拟目标对象（target/dest）中包含被copy的对象（source/orig）的所有字段时 @Data public class Student { private String id; private String name; private String age; public Student(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } } @Data public class Teacher { private String id; private String name; private String age; private String sex; public Teacher() {} public Teacher(String id, String name, String age, String sex) { this.id = id; this.name = name; this.age = age; this.sex = sex; } } 先使用org.springframework.beans.BeanUtils下的copyProperties来进行测试，执行代码如下： import org.springframework.beans.BeanUtils; public static void main(String[] args) throws Exception { Student student = new Student(UUID.randomUUID().toString(), \"zhangsan\", \"19\"); Teacher teacher = new Teacher(); System.out.println(student.toString()); BeanUtils.copyProperties(student,teacher); System.out.println(teacher.toString()); } 执行结果如下： Student(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19) Teacher(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19, sex=null) 当将引入的包改为org.apache.commons.beanutils.BeanUtils时，将上述中的执行代码进行如下修改： BeanUtils.copyProperties(teacher,student); //因为apache包下被copy的参数在第二个位置 执行结果如下： Student(id=900d0b93-1913-4022-b86b-127682cd9f5c, name=zhangsan, age=19) Teacher(id=00c47e77-785d-4939-89db-e757979050ec, name=zhangsan, age=19, sex=null) 小结：当目标对象（target/dest）中包含被copy的对象（source/orig）的所有字段时，两种包下的copyProperties方法均可以执行成功。 2）对上述中说到的实体类进行修改，即目标对象（target/dest）中不包含被copy的对象（source/orig）的所有字段时，修改后的内容如下： @Data public class Student { private String id; private String name; private String age; public Student(String id, String name, String age) { this.id = id; this.name = name; this.age = age; } } @Data public class Teacher { private String id; private String name; public Teacher() {} public Teacher(String id, String name) { this.id = id; this.name = name; } } 执行代码与1）中的一样这里就不写了，先使用org.apache.commons.beanutils.BeanUtils中的copyProperties方法，执行结果如下： Student(id=6f6711ef-fa2f-420d-b0b3-b76998356533, name=zhangsan, age=19) Exception in thread \"main\" java.lang.NoClassDefFoundError: org/apache/commons/collections/FastHashMap at org.apache.commons.beanutils.PropertyUtilsBean.getPropertyDescriptor(PropertyUtilsBean.java:964) at org.apache.commons.beanutils.PropertyUtilsBean.isWriteable(PropertyUtilsBean.java:1479) at org.apache.commons.beanutils.BeanUtilsBean.copyProperties(BeanUtilsBean.java:280) at org.apache.commons.beanutils.BeanUtils.copyProperties(BeanUtils.java:135) at com.learn.controller.BeanController.main(BeanController.java:39) Caused by: java.lang.ClassNotFoundException: org.apache.commons.collections.FastHashMap at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 5 more 接下来使用org.springframework.beans.BeanUtils下的copyProperties方法，执行结果如下： Student(id=87665c46-9a6f-4936-9c9d-1513e29f2bca, name=zhangsan, age=19) Teacher(id=87665c46-9a6f-4936-9c9d-1513e29f2bca, name=zhangsan) 小结：目标对象（target/dest）中不包含被copy的对象（source/orig）的所有字段时，应选用org.springframework.beans.BeanUtils下的copyProperties方法 3）基于2）中的实体类来看下另外一种情况，修改下执行代码，实体类不变： public static void main(String[] args) throws Exception { Student student = new Student(U","date":"2021-08-25","objectID":"/spring-note/:1:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"Spring integration学习总结 Spring integration是一个企业应用集成系统。主要通过消息、通道、消息端点等概念完成不同系统之间的集成。 ","date":"2021-08-25","objectID":"/spring-note/:2:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.1 消息（Message） 消息包括header（头）和payload（负载） message的header一般是id，时间戳或者目的地址什么的，比如如果你发的消息是个文件，那么header应该存放文件的名称，消息头可以根据需要修改。Payload就是负载，也就睡消息的主要内容，主要通过这个进行通信。 ","date":"2021-08-25","objectID":"/spring-note/:2:1","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.2 消息通道（Message channel） 消息传输的通道。分两种，一种是point-to-point点对点的，一种是publish-subscribe发布订阅形式的。如果是点对点的channel，至少会有一个消费者consumer能收到发送的message，另一种订阅发布的channel，spring integration试图去用广播的形式发布message给那些订阅者subscriber。 主要实现如下： PublishSubscribeChannel：将消息广播给所有的订阅者。 QueueChannel：可以缓存消息，在缓存消息没有达到上限时，消息发送者将消息发送到该通道后立即返回。如果缓存消息数量达到设定的容量，则消息发送者发送消息后会被阻塞，直到消息队列中有空间为止或者超时。对于消息接收者正好相反，尝试获取消息时，如果队列中有消息会立即返回，如果队列中没有消息则会一直阻塞直到超时（需要设定超时时间，不设定的话一直阻塞）。 PriorityChannel：一个排序队列。默认是根据消息头中的\"priority\"属性值进行排序，也可以通过实现Comparator\u003cMessage\u003c?\u003e\u003e接口的逻辑来进行排序。 RendezvousChannel：类似于QueueChannel，只是容量为0。也就是发送者发送消息时，接受者必须将其接收才会返回，否则一直被阻塞。接受者也是一样。 DirectChannel：用于点对点场景，但实现的是PublishSubscribeChannel接口，因此该通道会将消息直接分发给接收者，和PublishSubscribeChannel的区别就是，接收者只有一个。除此之外，DirectChannel还有一个最重要的特点就是发送和接收双方处于一个线程当中，如下：发送者发送消息-\u003e接收者接收消息并触发处理操作-\u003e返回。Spring Integration中的缺省的通道就是DirectChannel。例如\u003cint:channel id=\"xxxx\"/\u003e。 ExecutorChannel：用于点对点场景，和DirectChannel的配置相同，但主要的区别是ExecutorChannel将消息分发的操作委派给一个TaskExecutor的实例来进行，因此发送消息时不会进行阻塞。 Scoped Channel：暂不理解。 ","date":"2021-08-25","objectID":"/spring-note/:2:2","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3 消息端点（Message Endpoint） 可以对消息进行处理的地方。包括如下的主要构件： ","date":"2021-08-25","objectID":"/spring-note/:2:3","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.1 Transformer 可以对消息的内容或者结构进行修改，最常见的是修改消息内容的格式，或者对消息头的内容进行添加、修改和删除。用法如下： \u003cint:transformer id=\"testTransformer\" ref=\"testTransformerBean\" input-channel=\"inChannel\" method=\"transform\" output-channel=\"outChannel\"/\u003e \u003cbeans:bean id=\"testTransformerBean\" class=\"org.foo.TestTransformer\" /\u003e 决定一个消息是否被过滤掉，只有没有被过滤掉的消息才发送到输出通道上。filter多用于publish subscribe模式中，很多consumer消费者可以收到相同的message并且可以用filter来接收指定类型的消息并将其加工处理。 \u003cint:filter input-channel=\"input\" output-channel=\"output\" ref=\"exampleObject\" method=\"someBooleanReturningMethod\"/\u003e \u003cbean id=\"exampleObject\" class=\"example.SomeObject\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:4","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.3 Router 路由器，通常是一个输入通道，多个输出通道。根据消息头或者消息体的内容，决定将消息转发到哪个输出通道上。 \u003cint:router input-channel=\"drinks\" ref=\"drinkRouter\" method=\"route\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:5","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.4 Splitter 对应一个输入通道，多个输出通道。Splitter把消息从输入通道上分割发送到它的输出通道上。比如用于把一个复合型的payload负载分割成很多子负载payloads，发送到多个输出通道上。 \u003cint:splitter input-channel=\"orders\" ref=\"orderSplitter\" method=\"split\" output-channel=\"drinksTransform\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:6","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.5 Aggregator 集合器，和splitter对应。用于把多种message组合成一个单一的message。事实上aggregator比splitter要复杂一些，因为它需要维持message的状态，决定什么时候提供组合,什么时候超时timeout，甚至可以将一个局部的结果放弃，并发送到一个隔离的channel里。Spring integration提供了一个CompletionStrategy来配置timeout超时，是否在超时的时候发送一个结果并且废弃这个channel（这里应该是说消息废弃这个channel）。Aggregator在聚合时，会将消息头中消息ID相同的消息进行聚合。 \u003cint:aggregator input-channel=\"preparedDrinks\" method=\"prepareDelivery\" output-channel=\"deliveries\"\u003e \u003cbeans:bean class=\"com.abc.springintegration.cafe.xml.Waiter\"/\u003e \u003c/int:aggregator\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:7","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.6 Service Activator 用来连接应用的接口和message framework消息框架的组件，一个输入的频道input message channel必须被设定，一个service activator的方法被执行并且返回了一个值，那么可以提供一个输出频道output message channel（如果消息提供自己的返回地址，那么这是可选的）。这个规则适用于所有的consumer endpoints。输入从input channel到service activator再到message handler，然后返回output message到service activator到output message channel。归根结底：被继承组件的主要对外接口。 \u003cint:service-activator input-channel=\"coldDrinks\" ref=\"barista\" method=\"prepareColdDrink\" output-channel=\"preparedDrinks\"/\u003e ","date":"2021-08-25","objectID":"/spring-note/:2:8","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"2.3.7 Channel Adapter 连接一个消息通道和其他实体之间的对象。channel adapter也分inbound内绑定和outbound外绑定。 Inbound通道适配：通常的作用是将一个外部系统的资源进行转换，通过消息通道输送到系统中，用于进行后续的处理。 Outbound通道适配：将系统中的资源通过消息通道发送给Outbound通道适配，然后该“Outbound通道适配”将其转换为外部的资源。 举例：\u003cfile:inbound-channel-adapter\u003e的作用，将文件系统中的文件进行读取，将文件对象或者文件内容发送到消息通道中。 \u003cfile:outbound-channel-adapter\u003e的作用，将处理好的文件资源输出到文件系统中。 Spring Integration目前支持的常用channel-adapter如下： File FTP/FTPS HTTP JDBC SFTP Mail XML 等等 ","date":"2021-08-25","objectID":"/spring-note/:2:9","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3 使用经验 ","date":"2021-08-25","objectID":"/spring-note/:3:0","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.1 重复下载远程服务器上的文件 Spring Integration下载远程服务器可以使用其工作原理是监控远程服务器上的文件，一旦有新的文件就会首先下载到本地，然后将文件对象装载到channel中。在测试的过程中发现，这两步是各自独立进行的，也就是说，下载部分只下载远程服务器上存在但本地目录不存在的文件，将文件对象装载到channel的操作是监控本地目录中的文件，如果没有装载过就进行处理。有时候远程服务器上的相同文件名的文件是定期更新的，需要客户端定期下载，这种情况下的默认处理就有问题了： 1） 下载一次后，如果本地文件已经存在，就不会重复下载。 2） 即使将本地文件进行删除，此时虽然会下载，但下载到本地后不会将文件对象装载到channel中进行后续的处理。 Spring社区中也没有好的处理办法，这种情况下，可以使用下载到本地后对文件进行改名的方法进行规避，使用方法如下，见红色部分： \u003cint-sftp:inbound-channel-adapter id=\"sftpInboundAdapter\" session-factory=\"sftpSessionFactory\" remote-directory=\"/srv/data/stc/crm/\" local-directory=\"file:///srv/data/stc/crm/upload\" local-filename-generator-expression=\"substring(0,lastIndexOf('.')) + '_' + T(java.lang.System).currentTimeMillis() + substring(lastIndexOf('.'))\" channel=\"downloadFileChannel\" delete-remote-files=\"true\" auto-startup=\"true\" filter=\"entryListFilter\"\u003e \u003cint:poller max-messages-per-poll=\"1\" cron=\"0/1 * * * * * \" /\u003e \u003c/int-sftp:inbound-channel-adapter\u003e 进行了上面的配置后，下载下来的文件名会变成原来的文件名中加上了时间戳，这样就规避了上述的问题，如果也许需要还原原来的文件名，可以在进入channel后的后续的处理中再进行处理。 ","date":"2021-08-25","objectID":"/spring-note/:3:1","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.2 如何控制inbound-channel-adapter类的对象是否工作 context = new FileSystemXmlApplicationContext(\"/conf/stc-job.xml\"); SourcePollingChannelAdapter adapter = context.getBean(\"sftpInboundAdapter\", SourcePollingChannelAdapter.class); adapter.stop(); //停止工作 adapter.start(); //开始工作 ","date":"2021-08-25","objectID":"/spring-note/:3:2","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.3 Spring Integration 触发 Spring batch 的 job Spring Integration的配置如下： \u003cfile:inbound-channel-adapter directory=\"file:///srv/data/stc/crm\" channel=\"inputFileChannel\" filename-pattern=\"*.csv\"\u003e \u003cint:poller max-messages-per-poll=\"1\" cron=\"0/1 * * * * * \" /\u003e \u003c/file:inbound-channel-adapter\u003e \u003cint:service-activator input-channel=\"inputFileChannel\" output-channel=\"jobLaunchRequestChannel\" ref=\"fileToJobLaunchRequestAdapter\" method=\"adapt\"/\u003e \u003cint:service-activator input-channel=\"jobLaunchRequestChannel\" output-channel=\"jobExecutionChannel\"\u003e \u003cbeans:bean class=\"org.springframework.batch.integration.launch.JobLaunchingMessageHandler\"\u003e \u003cbeans:constructor-arg ref=\"jobLauncher\" /\u003e \u003c/beans:bean\u003e \u003c/int:service-activator\u003e \u003cbeans:bean id=\"fileToJobLaunchRequestAdapter\" class=\"com.abc.job.FileToJobLaunchRequestAdapter\"\u003e \u003cbeans:property name=\"job\" ref=\"stcJob\"/\u003e \u003c/beans:bean\u003e \u003c!--其中，红色stcJob为Spring batch的job名称，需要做如下的配置：--\u003e \u003cjob id=\"stcJob\"\u003e …… \u003c/job\u003e 对于Spring Job的触发类FileToJobLaunchRequestAdapter，代码如下： public class FileToJobLaunchRequestAdapter implements InitializingBean{ private Job job; public void setJob(Job job){ this.job = job; } public void afterPropertiesSet() throws Exception{ Assert.notNull(job, \"A Job must be provided\"); } @ServiceActivator public JobLaunchRequest adapt(File file) throws NoSuchJobException{ String fileName = file.getAbsolutePath(); if (!fileName.startsWith(\"/\")){ fileName = \"/\" + fileName; } fileName = \"file://\" + fileName; String outPutPath = \"file:///srv/smartcare/export/\"; String outPutFilePath = outPutPath + file.getName(); String outPutTmpFilePath = outPutFilePath; JobParameters jobParameters = new JobParametersBuilder().addString(\"input.file.path\", fileName) .addString(\"output.file.path\", outPutTmpFilePath) .addString(\"file.src\", outPutTmpFilePath) .addString(\"file.original.name\", file.getName()) .addString(\"file.dst\", outPutFilePath) .addLong(\"time.stamp\", System.currentTimeMillis()) .toJobParameters(); //确保job多次执行时，通过让jobParameters发生变化，从而区分job if (job.getJobParametersIncrementer() != null){ jobParameters = job.getJobParametersIncrementer() .getNext(jobParameters); } return new JobLaunchRequest(job, jobParameters); } public void output(File file){ System.out.println(\"receive file = \" + file.getName() + \", path = \" + file.getPath()); return; } } ","date":"2021-08-25","objectID":"/spring-note/:3:3","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back"],"content":"3.4 JAVA 代码中发消息给 Spring Integration 的 channel Java代码： Message\u003cFile\u003e message = MessageBuilder.withPayload(file).build(); sftpChannel.send(message); **sftpChannel**为Spring integration的channel名称。 在Spring Integration的配置文件中，做如下的配置： \u003cint-sftp:outbound-channel-adapter id=\"sftpOutboundAdapter\" session-factory=\"sftpSessionFactory\" channel=\"outFileChannel\" charset=\"UTF-8\" temporary-file-suffix=\".uploading\" remote-directory=\"/srv\"/\u003e 其中，**sftpChannel的名称等于outFileChannel**就可以了。 ","date":"2021-08-25","objectID":"/spring-note/:3:4","tags":["Java","Spring"],"title":"Spring笔记","uri":"/spring-note/"},{"categories":["Back","note"],"content":"记录Mysql事务的笔记","date":"2021-08-25","objectID":"/mysql-transact/","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"脏读、不可重复读、幻读 ","date":"2021-08-25","objectID":"/mysql-transact/:1:0","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"一、分析 1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 例如： 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。 与此同时， 事务B正在读取张三的工资，读取到张三的工资为8000。 随后， 事务A发生异常，而回滚了事务。张三的工资又回滚为5000。 最后， 事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。 2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 例如： 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。 与此同时， 事务B把张三的工资改为8000，并提交了事务。 随后， 在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 例如： 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。 此时， 事务B插入一条工资也为5000的记录。 这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 4、提醒 不可重复读的重点是修改： 同样的条件，你读取过的数据，再次读取出来发现值不一样了 幻读的重点在于新增或者删除： 同样的条件，第 1 次和第 2 次读出来的记录数不一样 5、第一类丢失更新 A事务撤销时，把已经提交的B事务的更新数据覆盖了。例如： 这时候取款事务A撤销事务，余额恢复为1000，这就丢失了更新。 6、第二类丢失更新 A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失 ","date":"2021-08-25","objectID":"/mysql-transact/:1:1","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"二、如何解决 为了解决上述问题，数据库通过 锁机制解决并发访问的问题。根据锁定对象不同：分为行级锁和表级锁；根据并发事务锁定的关系上看：分为共享锁定和独占锁定，共享锁定会防止独占锁定但允许其他的共享锁定。而独占锁定既防止共享锁定也防止其他独占锁定。为了更改数据，数据库必须在进行更改的行上施加行独占锁定，insert、update、delete和selsct for update语句都会隐式采用必要的行锁定。 但是直接使用锁机制管理是很复杂的，基于锁机制，数据库给用户提供了不同的 事务隔离级别，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的锁。 不同的隔离级别对并发问题的解决情况如图： 注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低。 ","date":"2021-08-25","objectID":"/mysql-transact/:1:2","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"什么是数据库ACID? 事务在当今的企业系统无处不在，即使在高并发环境下也可以提供数据的完整性。一个事务是一个只包含所有读/写操作成功的集合。如下图： 一个事务本质上有四个特点ACID： Atomicity原子性 Consistency一致性 Isolation隔离性 Durability耐久性 ","date":"2021-08-25","objectID":"/mysql-transact/:2:0","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"原子性 原子性任务是一个独立的操作单元，是一种要么全部是，要么全部不是的原子单位性的操作。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:1","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"一致性 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。 一致性有下面特点： 如果一个操作触发辅助操作（级联，触发器），这些也必须成功，否则交易失败。 如果系统是由多个节点组成，一致性规定所有的变化必须传播到所有节点（多主复制）。如果从站节点是异步更新，那么我们打破一致性规则，系统成为\"最终一致性\"。 一个事务是数据状态的切换，因此，如果事务是并发多个，系统也必须如同串行事务一样操作。 在现实中，事务系统遭遇并发请求时，这种串行化是有成本的， Amdahl法则描述如下：它是描述序列串行执行和并发之间的关系。 “一个程序在并行计算情况下使用多个处理器所能提升的速度是由这个程序中串行执行部分的时间决定的。” 大多数数据库管理系统选择（默认情况下）是放宽一致性，以达到更好的并发性。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:2","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"隔离性 事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:3","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"耐久性 一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。 尽管一些数据库系统提供多版本并发控制 MVCC, 他们的并发控制都是通过锁完成，因此，锁会增加执行的串行性，影响并发性。 SQL标准规定了四个隔离水平： READ_UNCOMMITTED READ_COMMITTED REPETABLE_READ SERIALIZABLE 隔离级别 脏读 非重复读 Phantom read READ_UNCOMMITTED allowed allowed allowed READ_COMMITTED prevented allowed allowed REPETABLE_READ prevented prevented allowed SERIALIZABLE prevented prevented prevented ","date":"2021-08-25","objectID":"/mysql-transact/:2:4","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"脏读 脏读发生在：当一个事务允许读取一个被其他事务改变但是未提交的状态时，这是因为并没有锁阻止读取，如上图，你看到第二个事务读取了一个并不一致的值，不一致的意思是，这个值是无效的，因为修改这个值的第一个事务已经回滚，也就是说，第一个事务修改了这个值，但是未提交确认，却被第二个事务读取，第一个事务又放弃修改，悔棋了，而第二个事务就得到一个脏数据。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:5","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"非重复读 反复读同一个数据却得到不同的结果，这是因为在反复几次读取的过程中，数据被修改了，这就导致我们使用了stale数据，这可以通过一个共享读锁来避免。这是隔离级别READ_COMMITTED会导致可重复读的原因。设置共享读锁也就是隔离级别提高到REPETABLE_READ。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:6","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Back","note"],"content":"Phantom 读 当第二个事务插入一行记录，而正好之前第一个事务查询了应该包含这个新纪录的数据，那么这个查询事务的结果里肯定没有包含这个刚刚新插入的数据，这时幻影读发生了，通过变化锁和predicate locking避免。 下图是主流数据库的默认隔离级别： Database Default isolation Level Oracle READ_COMMITTED MySQL REPETABLE_READ Microsoft SQL Server READ_COMMITTED PostgreSQL READ_COMMITTED DB2 CURSOR STABILITY (a.k.a READ_COMMITTED) READ_COMMITED 是正确的选择，因为SERIALIZABLE虽然能在不同事务发生时避免stale数据，也就是避免上述丢失刚刚修改的数据，但是性能是最低的，因为是一种最大化的串行。 ","date":"2021-08-25","objectID":"/mysql-transact/:2:7","tags":["DataBase","Mysql","Transaction"],"title":"Mysql事务笔记","uri":"/mysql-transact/"},{"categories":["Net","note"],"content":"记录HTTP教程的笔记","date":"2021-08-25","objectID":"/http/","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net","note"],"content":"HTTP状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 ","date":"2021-08-25","objectID":"/http/:1:0","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net","note"],"content":"HTTP状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1 信息，服务器收到请求，需要请求者继续执行操作 2 成功，操作被成功接收并处理 3 重定向，需要进一步的操作以完成请求 4 客户端错误，请求包含语法错误或无法完成请求 5 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 笑谈 程序员最想看到的：200-OK。 程序员不想看到的：500-Internal-Server-Error。 用户不想看到的：401-Unauthorized、403-Forbidden、408-Request-Time-out。 ","date":"2021-08-25","objectID":"/http/:2:0","tags":["HTTP"],"title":"HTTP教程","uri":"/http/"},{"categories":["Net"],"content":"记录GET和POST两种基本请求方法的区别","date":"2021-08-25","objectID":"/http-get-post-diff/","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"引言 GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:1:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"w3schools\"标准答案\" GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:2:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"对比 GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 解释w3schools答案 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 参数大小限制 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案\"里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:3:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Net"],"content":"其他讨论 GET和POST还有一个重大区别 简单的说 GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼\"嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 ","date":"2021-08-25","objectID":"/http-get-post-diff/:4:0","tags":["Http","Difference"],"title":"GET和POST两种基本请求方法的区别","uri":"/http-get-post-diff/"},{"categories":["Software","note"],"content":"记录解决chrome浏览器图标缓存问题的笔记","date":"2021-08-25","objectID":"/chrome-favicon/","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Software","note"],"content":"一、先解决图标缓存问题 尝试解决 清空浏览器缓存，无效 直接访问图片地址，无效 删除本地favicon缓存文件，有效 C:\\Users\\xxxxxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default 其中xxxxxx为用户名 **删除Favicons文件** 你可以将Favicons文件移到其他位置，如果直接删除Favicons文件，会出现以前添加的书签都没有图标，除此之外没有其他影响，当你重新访问网站图标会重新加载出来缓存进Favicons文件，如图，建议先将Favicons移动其他位置 ","date":"2021-08-25","objectID":"/chrome-favicon/:1:0","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Software","note"],"content":"二、修改网站图标 vue项目修改网站图标，方法①是html通用的，有如下两种方法 我的图标位置 ①、vue项目直接修改全局 index.html 文件，其他项目可以根据你的页面布局添加，通过 link 标签引入图标 \u003clink rel=\"shortcut icon\" href=\"/static/favicon.ico\"\u003e \u003clink rel=\"shortcut icon\" type=\"image/x-icon\" href=\"/static/ico1.jpg\"\u003e ②、仅支持vue项目，针对开发环境，发布环境类似，修改 webpack.dev.conf.js 文件，找到 new HtmlWebpackPlugin 添加 favicon: ‘./static/favicon.ico’，你的图标路径，注意有个点 打开网站可以看到图标 方法① 方法② 注意： 发现一个问题，方法②比方法①优先级高 方法①②都设置，以先加载的那个为准，方法②先加载 推荐一个好用的网站 我的网站图标就是用工具生成的 ","date":"2021-08-25","objectID":"/chrome-favicon/:2:0","tags":["Chrome","Favicons"],"title":"解决Chrome浏览器图标缓存问题","uri":"/chrome-favicon/"},{"categories":["Operation","note"],"content":"记录Git仓库之间交互指令教程的笔记","date":"2021-08-25","objectID":"/git-mutual-note/","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Push ","date":"2021-08-25","objectID":"/git-mutual-note/:1:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"目标 当远程仓库仅有一个且本地和远程都只有一个分支时可以省略主机名、本地分支名、远程分支名 git push 当远程仓库仅有一个且本地分支和远程分支同名时，将本地[branch]分支推送至origin主机的对应分支 git push origin [branch] 将本地mybranch1与origin主机的对应分支建立管道，以后允许使用git push省略提交。 两条指令小小的区别为-u在origin主机没有对应分支时会创建分支完成提交，但是时下面那条指令是不能完成提交的，仅仅在远程存在对应分支的情况下允许提交。 git push -u origin mybranch1 git branch --set-upstream-to=origin/mybranch1 mybranch1 ","date":"2021-08-25","objectID":"/git-mutual-note/:1:1","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"范围 提交所有本地分支到远程对应分支 git push --all ","date":"2021-08-25","objectID":"/git-mutual-note/:1:2","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"条件 强制推送，不考虑版本迭代，特别是允许旧版本覆盖新版本从而导致之前提交内容丢失。官方文档仅建议我们最多强制推送一个分支 git push [-f | --force] git push origin [branch] [-f | --force] # 官方建议 删除所有提交，等于在当前分支前加: git push [-d | --delete | :[branch]] ","date":"2021-08-25","objectID":"/git-mutual-note/:1:3","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Remote 显示所有的远程仓库 git remote -v 显示某个远程仓库信息 git remote show [remote] 添加远程版本库，shortname类似Id git remote add [shortname] [url] 删除 git remote rm name # 删除远程仓库 修改 git remote rename old_name new_name # 修改仓库名 ","date":"2021-08-25","objectID":"/git-mutual-note/:2:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Fork 一般在别人仓库页面如Gitee/Github/Gitlab复制一份代码到自己的仓库页面 ","date":"2021-08-25","objectID":"/git-mutual-note/:3:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Fetch 从远程仓库获取代码 git fetch [shortname] ","date":"2021-08-25","objectID":"/git-mutual-note/:4:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Merge 将shortname主机的branch分支代码合并到当前本地开发分支 git merge [shortname]/[branch] ","date":"2021-08-25","objectID":"/git-mutual-note/:5:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Operation","note"],"content":"Git Pull 等价于Fetch+Merge，但是不推荐使用，不能清晰查看分支间变更。 git pull origin [branch] ","date":"2021-08-25","objectID":"/git-mutual-note/:6:0","tags":["Git","Mutual"],"title":"Git仓库之间交互指令教程","uri":"/git-mutual-note/"},{"categories":["Software","note"],"content":"记录Intellij IDEA教程的笔记","date":"2021-08-25","objectID":"/idea-note/","tags":["Ide","Idea","Java"],"title":"Intellij IDEA教程","uri":"/idea-note/"},{"categories":["Software","note"],"content":"使用Intellij IDEA的Bookmarks 今天用idea的时候，无意按了什么，发现了了一个小功能，叫做BookMark 然后去查阅了一下文档，主要功能也就是可以清晰的看到自己标的书签附近的代码，比如我们在第11行 按一下F11插入一个书签，就会有一个小钩子。 我们可以按 Shift+F11就可以直接看到11行附近的代码 如果有多个书签，在打开这个书签管理的时候，可以完全使用键盘进行控制：按上下键进行选择,Enter键跳转到所选的书签那，Esc关闭窗口，Alt+上/下可以在这个列表将某个书签以Y轴移动。 我们还可以使用以（ 助记符）数字作为书签，在所在行按快捷键 Ctrl+Shift+任意数字，就可以插入一个标签了，要将光标跳转到某个书签，只需要 Ctrl+对应的标签数字。实在是很方便。 ","date":"2021-08-25","objectID":"/idea-note/:1:0","tags":["Ide","Idea","Java"],"title":"Intellij IDEA教程","uri":"/idea-note/"},{"categories":["Software","note"],"content":"记录IntelliJ IDEA统计代码行数插件教程的笔记","date":"2021-08-25","objectID":"/idea-count-lines-note/","tags":["Idea","Plugin"],"title":"IntelliJ IDEA统计代码行数插件教程","uri":"/idea-count-lines-note/"},{"categories":["Software","note"],"content":"步骤 第一步首先需要知道idea统计项目代码行数，主要是使用Statistic插件来统计，点击File-\u003eSettings，如下图所示： 第二步进去Settings界面之后，点击Plugins，然后点击下方正中间的Browse repositories，如下图所示： 第三步进去插件应用之后，搜索Statistic，选中之后，点击右侧的Install进行安装插件，如下图所示： 第四步等待几秒钟，插件就安装成功了，点击close，如下图所示： 第五步返回上一界面，可以看到Statistic插件，点击OK之后，会要求重启idea，如下图所示： 第六步重启idea之后，在左下方可以看到Statistic，点击，可以看到项目代码的行数，如下图所示： ","date":"2021-08-25","objectID":"/idea-count-lines-note/:1:0","tags":["Idea","Plugin"],"title":"IntelliJ IDEA统计代码行数插件教程","uri":"/idea-count-lines-note/"},{"categories":["Software"],"content":"记录Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包的解决办法","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Software"],"content":"报错 如图 Cannot resolve xxx package ","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/:1:0","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Software"],"content":"解决 请教同事后要求切换Idea自带的Maven，自己安装的Maven不行 ","date":"2021-08-25","objectID":"/idea-selfmaven-nexus-init-error/:2:0","tags":["Idea","Maven","Nexus","Error"],"title":"Idea使用Maven连接Nexus打开别人代码时报错Cannot resolve包","uri":"/idea-selfmaven-nexus-init-error/"},{"categories":["Back"],"content":"记录new与newInstance()的区别","date":"2021-08-25","objectID":"/mysql-index-note/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/mysql-index-note/"},{"categories":["Back"],"content":"1 ","date":"2021-08-25","objectID":"/mysql-index-note/:0:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/mysql-index-note/"},{"categories":["Back"],"content":"B+ 树的优缺点 ","date":"2021-08-25","objectID":"/mysql-index-note/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/mysql-index-note/"},{"categories":["Back"],"content":"优点 单次请求涉及的磁盘IO次数少（出度d大，且非叶子节点不包含表数据，树的高度小）； 查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）； 遍历效率高（从符合条件的某个叶子节点开始遍历即可）； 在B+树中， 由于底层的各个叶子节点都通过指针组织成一个双向链表， 结构如下图所示。 因此，只需要从跟节点到叶子节点定位到第一个满足条件的Key, 然后不断在叶子节点迭代next指针即可实现遍历，此时相当于顺序IO。相反，如果通过每次从根节点查找进行遍历，相当于进行随机IO，效率低下，如下图所示： ","date":"2021-08-25","objectID":"/mysql-index-note/:1:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/mysql-index-note/"},{"categories":["Back"],"content":"缺点 B+树最大的性能问题在于会产生大量的随机IO，主要存在以下两种情况： 主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片； 即使主键是有序递增的，大量写请求的分布仍是随机的； ","date":"2021-08-25","objectID":"/mysql-index-note/:1:2","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/mysql-index-note/"},{"categories":["Back"],"content":"记录Idea格式化Xml后替换换行符接口提交报错的解决办法","date":"2021-08-24","objectID":"/xml-idea-format-error/","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"现象 使用Swagger或者Postman访问均报错500 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:1:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"分析 流程是在Idea中将Xml写好，使用Idea带正则的替换，将\\n替换为空，改变为一行，再放到Swagger中进行执行。 由于程序是部署的怀疑参数问题，换了几种xml，发现部分会报错，认为是xml问题，检查后发现端倪 如图二者多了一个换行，遥想学习汇编时老师所讲的回车和换行是两回事。于是拿出根本方法Winhex二进制对比。发现二进制下确实多了0A，但是\\n只替换了换行，回车还在，才造成了后台500的问题 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:2:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Back"],"content":"解决 格式化代码后再换成一行再替换就好了，\\s慎用，应为Xml头信息属性间还是有空格的，所以还是换成一行替换\\n比较好 ","date":"2021-08-24","objectID":"/xml-idea-format-error/:3:0","tags":["Java","SpringCloud","SpringBoot","Xml","Idea","Error"],"title":"Idea格式化Xml后替换换行符接口提交报错","uri":"/xml-idea-format-error/"},{"categories":["Software"],"content":"记录win10报错“无法编辑写该值的新内容时出错”的解决办法","date":"2021-08-24","objectID":"/reg-auth-error/","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Software"],"content":"问题 注册表无法修改删除，提示：无法编辑写该值的新内容时出错的提示 ","date":"2021-08-24","objectID":"/reg-auth-error/:1:0","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Software"],"content":"步骤 1、在无法编辑的注册表键值上右键，菜单中选择\"权限\"； 2、点击\"高级\"按钮； 3、点击所有者后面的\"更改\"按钮； 4、在选择用户或组窗口，点击\"高级\"-“立即查找”； 5、在搜索结果中点击选中搜索结果中的当前用户名（一个头的头像就是），然后点击\"确定\"-“确定”； 6、点击勾选\"Administrator的权限\"项目下面\"完全控制\"后面\"允许\"，然后点击底部\"确定\"即可。 ","date":"2021-08-24","objectID":"/reg-auth-error/:2:0","tags":["System","Regedit","Error"],"title":"win10报错“无法编辑写该值的新内容时出错”","uri":"/reg-auth-error/"},{"categories":["Hardware","note"],"content":"记录Dell新版BIOS教程的笔记","date":"2021-08-24","objectID":"/dell-bios-note/","tags":["BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Hardware","note"],"content":"Dell进入BIOS 开机按F2，和联想的一致，且F12都是进入启动项修改界面 ","date":"2021-08-24","objectID":"/dell-bios-note/:1:0","tags":["BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Hardware","note"],"content":"BIOS永久修改启动项 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:0","tags":["BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Hardware","note"],"content":"Legacey DELL bios操作一次 点击security, PPT security关闭ptt，把ptt on 勾去掉，点击apply （必须点） secure boot 右边打钩. advanced boot option 先选择右侧的第一个勾，点击apply 之后 第二个灰色的那个勾才可以变成可打勾的 ，然后打勾之后在点击apply 建议用–AMpe工具箱_Win10PE//WIN7PE 工具箱V4.0//WePE_32_V2.0 其中BIOS设置中，有两种让他启动进入系统的方法，分别是为UEFI和Legacey 两种模式分别对应的硬盘分区格式： 在Legacy启动模式中，硬盘分区格式应该为MBR格式； 在UEFI启动模式中，硬盘分区格式应该为GUID（GPT）格式。 开机未进入系统是DEL/F2，进入BIOS 在 BIOS 的Boot菜单下，将Secure Boot 改为 Disabled 将Boot List Option 改为 Legacy (BIOS切换到Legacy时：就是USB装系统时使用， BIOS切换到UEFI时：选择“开启(Enable)”;正常win10。) 保存后，重新开机敲击F12，即可看到开机启动选项了。 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:1","tags":["BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Hardware","note"],"content":"UEFI 1、首先笔记本开机，按F2进入BIOS界面。按照图示点开Secure Boot，选中Secure Boot Enable，在右侧取消勾选Secure Boot Enable。 2、在右下角点击Apply保存，重启电脑，再次按F2进入BIOS。按照图示选中Advanced Boot Options，右侧勾选Enable Legacy Option ROMs。 3、再选择图示1处：Boot Sequence，右侧选择Legacy，在图示3处出现U盘选项，将U盘选项上移到第一选项。 4、U盘设置为第一选项后，再次选择UEFI模式，此时，图示3处显示UEFI模式U盘启动，点击Apply保存，插入U盘启动盘，重启电脑即可。 ","date":"2021-08-24","objectID":"/dell-bios-note/:2:2","tags":["BIOS","Dell"],"title":"Dell新版BIOS教程","uri":"/dell-bios-note/"},{"categories":["Software","note"],"content":"记录浏览器首页被恶意劫持的解决办法","date":"2021-08-24","objectID":"/browser-hijacked/","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Software","note"],"content":"方法/步骤 当我们打开浏览器时就跳转到下图页面。但实际这并不是出发跳转的页面。 我们打开浏览器选项查看是否被修改。此处没有被恶意修改,那么问题就可能出在注册表中。 按win键-运行-输入\"regedit。exe\" 运行注册表编辑器 “编辑\"菜单—“查找”,输入跳转页面网址,搜索。 下图是搜索到的结果,我们找到罪魁祸首了。 右键–修改—输入你要替换该网址例如:about:blank 当然你也可以直接删除该键值 下图是处理完毕后再次打开浏览器。就可以看到自己要的页面了 ","date":"2021-08-24","objectID":"/browser-hijacked/:1:0","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Software","note"],"content":"其他办法 可以通过360安全卫士或腾讯安全卫士锁定IE首页 浏览网页时注意安全使用 ","date":"2021-08-24","objectID":"/browser-hijacked/:2:0","tags":["Browser","Hack"],"title":"浏览器首页被恶意劫持","uri":"/browser-hijacked/"},{"categories":["Back","note"],"content":"记录SpringCloud使用spring-test进行单元测试教程的笔记","date":"2021-08-23","objectID":"/springcloud-unittset/","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"步骤 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:0","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"1、 新建项目sc-test，对应的pom.xml文件如下 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemalocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelversion\u003e4.0.0\u003c/modelversion\u003e \u003cgroupid\u003espring-cloud\u003c/groupid\u003e \u003cartifactid\u003esc-test\u003c/artifactid\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003cname\u003esc-test\u003c/name\u003e \u003curl\u003ehttp://maven.apache.org\u003c/url\u003e \u003cparent\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-parent\u003c/artifactid\u003e \u003cversion\u003e2.0.4.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003cdependencymanagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.cloud\u003c/groupid\u003e \u003cartifactid\u003espring-cloud-dependencies\u003c/artifactid\u003e \u003cversion\u003eFinchley.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencymanagement\u003e \u003cproperties\u003e \u003cproject.build.sourceencoding\u003eUTF-8\u003c/project.build.sourceencoding\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-data-redis\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.apache.commons\u003c/groupid\u003e \u003cartifactid\u003ecommons-pool2\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-web\u003c/artifactid\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupid\u003eorg.springframework.boot\u003c/groupid\u003e \u003cartifactid\u003espring-boot-starter-test\u003c/artifactid\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e --\u003e \u003c/dependencies\u003e \u003c/project\u003e 说明：只要使用spring-boot-starter-test即可，该jar已经包含spring-boot-test ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:1","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"2、 新建spring boot启动类 package sc.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } } 备注：如果没有该类，spring-test启动将报错，见下图 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:2","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"3、 新建操作redis的配置类 package sc.test.config; import java.io.Serializable; import org.springframework.boot.autoconfigure.AutoConfigureAfter; import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration @AutoConfigureAfter(RedisAutoConfiguration.class) public class RedisCacheAutoConfiguration { @Bean public RedisTemplate\u003cString, Serializable\u003e redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) { RedisTemplate\u003cString, Serializable\u003e template = new RedisTemplate\u003c\u003e(); //键的序列化方式 template.setKeySerializer(new StringRedisSerializer()); //值的序列化方式 template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; } } ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:3","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"4、 新建配置文件application.yml server:port:9005spring:application:name:sc-redisredis:host:127.0.0.1password:port:6379timeout:10000# 连接超时时间（毫秒）database:0# Redis默认情况下有16个分片，这里配置具体使用的分片，默认是0lettuce:pool:max-active:8# 连接池最大连接数（使用负值表示没有限制） 默认 8max-wait:-1# 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1max-idle:8# 连接池中的最大空闲连接 默认 8min-idle:0# 连接池中的最小空闲连接 默认 0 ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:4","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"5、 新建测试类TestRedis.java package sc.test.unit; import java.io.Serializable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.stream.IntStream; import org.junit.Test; import org.junit.runner.RunWith; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.test.context.junit4.SpringRunner; import sc.test.model.User; @RunWith(SpringRunner.class) @SpringBootTest public class TestRedis { private static final Logger log = LoggerFactory.getLogger(TestRedis.class); @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate\u003cString, Serializable\u003e redisCacheTemplate; @Test public void get() { // 测试线程安全 // ExecutorService executorService = Executors.newFixedThreadPool(1000); // IntStream.range(0, 1000).forEach(i -\u003e // executorService.execute(() -\u003e stringRedisTemplate.opsForValue().increment(\"kk\", 1)) // ); stringRedisTemplate.opsForValue().set(\"key\", \"{'name':'huangjinjin', 'age':30}\"); final String value = stringRedisTemplate.opsForValue().get(\"key\"); log.info(\"[字符缓存结果] - [{}]\", value); String key = \"manage:user:1\"; User u = new User(); u.setId(1L); u.setAge(30); u.setPosition(\"cto\"); u.setUserName(\"good boy\"); redisCacheTemplate.opsForValue().set(key, u); //从缓存获取User对象 final User user = (User) redisCacheTemplate.opsForValue().get(key); log.info(\"[对象缓存结果] - userName={}, age={}, position={}\", // user.getUserName(), user.getAge(), user.getPosition()); } } ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:5","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["Back","note"],"content":"6、 进行测试 （1） reids server没有启动时，运行TestRedis.java（右键选择Junit Test） 接不上Reids server异常 （2） reids server启动后时，运行TestRedis.java，出现绿条说明执行代码成功 日志中打印相关数据，说明数据也存贮到redis server中 7、 使用redis-cli验证数据是否正在存档redis server中 有了spring-boot-starter-test，就可以不使用restful接口对spring boot写的接口进行单元测试了。不但可以测试redis，也可以测试数据库的增删查改。可以使用spring中的各种注解，注入对象。 源码：https://gitee.com/hjj520/spring-cloud-2.x ","date":"2021-08-23","objectID":"/springcloud-unittset/:1:6","tags":["Java","SpringCloud","UnitTest"],"title":"SpringCloud使用spring-test进行单元测试教程","uri":"/springcloud-unittset/"},{"categories":["documentation","note"],"content":"记录Office使用教程的笔记","date":"2021-08-23","objectID":"/office-note/","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"新版本Office（2016或更新）制作渐变色艺术字效果 ","date":"2021-08-23","objectID":"/office-note/:1:0","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"引言 我们在需要艺术字的时候，一般都会想到使用PS来制作，如果电脑上没有安装PS，或是只是做几个简单点的艺术字的话，那就直接使用word2016吧，word2016也可以制作出漂亮的艺术字哦，下面我们就一起来看一下如何使用word2016制作艺术字吧。 ","date":"2021-08-23","objectID":"/office-note/:1:1","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"步骤 1、首先在word2016中输入要制作的艺术字，本文就以\" 百度经验\"为例来进行说明吧，输入后选中刚刚输入的字，然后在弹出的菜单中把字体设置为\" 黑体\"，字号设置的大一点，如72 2、接下来点击开始菜单工具栏上的\" 字体颜色“下拉按钮，在弹出菜单中选择” 渐变“菜单项 3、这时会弹出渐变菜单，在弹出的菜单中选择” 其它渐变“菜单项 4、在右侧弹出的” 设置文本效果格式“菜单中，选择” 渐变填充“一项 5、接下来在” 预设渐变“右侧的下拉菜单中选择一个渐变样式 6、接着在类型与方向的下拉菜单中分别设置好，这个过程中可以看一下输入的文本，会随着设置的变化而自动变化，直到我们满意为止 7、接下来就是要设置” **渐变光圈\"**了，渐变光圈的作用就是设置渐变的颜色与渐变的位置，选中第一个渐变光圈，然后在下面的\" 颜色“下拉菜单中设置好颜色 8、这时就可以看到原来输入的文本已变化了，变成了我们设置的第一个渐变光圈的颜色 9、接下来我们设置剩余的渐变光圈颜色、位置、透明度与亮度等等，如果感觉渐变光圈不够用的话，可以手工添加渐变光圈的个数 10、设置好后，我们可以看一下新生产的渐变字，是不是已经有点PS差不多的效果了啊 11、另外我们也可以点击下面的” 文本边框“一项，设置渐变色的边框，可以根据我们的需要通过下面的各项进行设置就可以了，同时可以随时查看左侧渐变字的效果，随意调整。 12、最后我们看一下生成的渐变艺术字吧，是不是很漂亮啊，几乎与PS的效果是一样的哦。 ","date":"2021-08-23","objectID":"/office-note/:1:2","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"Word标题中的文字底色图案如何去掉 ","date":"2021-08-23","objectID":"/office-note/:2:0","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"对于标题 选中后右键修改样式去图案 ","date":"2021-08-23","objectID":"/office-note/:2:1","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"对于全局 选中后页面布局-\u003e边框 页面底纹 ","date":"2021-08-23","objectID":"/office-note/:2:2","tags":["Office"],"title":"Office使用教程","uri":"/office-note/"},{"categories":["documentation","note"],"content":"记录Markdown让文字居中和带颜色的笔记","date":"2021-08-23","objectID":"/md-font-center-size/","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"1.说明 本文主要叙述如何写出更加优美的markdown文档。在我们观看文档的过程中，良好的格式将会带来很大的收益。对于不同颜色的字体也并不会显得花里胡哨，只会让我们表达的内容更加的清晰。下面来具体的看一下操作的流程。 ","date":"2021-08-23","objectID":"/md-font-center-size/:1:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"2. 文字的居中 对于标准的markdown文本，是不支持居中对齐的。还好markdown支持html语言，所以我们采用html语法格式即可。 \u003ccenter\u003e这一行需要居中\u003c/center\u003e 下面就是排版后的结果 这一行需要居中\r","date":"2021-08-23","objectID":"/md-font-center-size/:2:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.文字的字体及颜色 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.1 字体更换 同样我们也需要遵照其标准的语法格式 \u003cfont face=\"黑体\"\u003e我是黑体字\u003c/font\u003e 下面是测试结果 我是黑体字 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:1","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.2 大小更换 大小为size \u003cfont face=\"黑体\" size=10\u003e我是黑体字\u003c/font\u003e 我是黑体字 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:2","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"3.3 颜色替换 对于html语音中，颜色是用color来表示，所以可以表示如下 \u003cfont color=red size=72\u003e颜色\u003c/font\u003e 效果如下 颜色 ","date":"2021-08-23","objectID":"/md-font-center-size/:3:3","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["documentation","note"],"content":"4 总结 善用markdown语法，记住markdown语法是兼容html预言的，这很重要。 ","date":"2021-08-23","objectID":"/md-font-center-size/:4:0","tags":["Markdown","Html","Css"],"title":"Markdown让文字居中和带颜色","uri":"/md-font-center-size/"},{"categories":["Back","note"],"content":"记录Java中的包装类(Wrapper Class in Java )的笔记","date":"2021-08-23","objectID":"/java-auto-pkg-note/","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"包装类型的继承结构图 包装类型的继承结构图\r","date":"2021-08-23","objectID":"/java-auto-pkg-note/:1:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是包装类型，包装类型的作用是什么？ Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。 我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:2:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"包装类的应用场景 1、集合类泛型只能是包装类； // 编译报错 List\u003cint\u003e list1 = new ArrayList\u003c\u003e(); // 正常 List\u003cInteger\u003e list2 = new ArrayList\u003c\u003e(); 2、成员变量不能有默认值； private int status; 基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。 3、方法参数允许定义空值； private static void test1(int status){ System.out.println(status); } 看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:3:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"自动装箱、拆箱机制 在Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:4:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是自动装箱？ 自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。 Integer i1 = new Integer(8); Integer i2 = Integer.valueOf(8); // 自动装箱 Integer i3 = 8; 以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。 其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:5:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Back","note"],"content":"什么是自动拆箱？ 自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。 // 自动拆箱 int i4 = i3; int i5 = i3.intValue(); 继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。 自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。 需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。 参考链接：深入浅出 Java 中的包装类 ","date":"2021-08-23","objectID":"/java-auto-pkg-note/:6:0","tags":["Java","Wrapper"],"title":"Java中的包装类(Wrapper Class in Java )","uri":"/java-auto-pkg-note/"},{"categories":["Net","note"],"content":"记录URL汉字编码问题（及乱码解决）的笔记","date":"2021-08-23","objectID":"/url-code-note/","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"一、问题的由来 URL就是网址，只要上网，就一定会用到。 一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。比如，世界上有英文字母的网址 “http://www.abc.com”，但是没有希腊字母的网址\"http://www.aβγ.com\"（读作阿尔法-贝塔-伽玛.com）。这是因为网络标准RFC 1738 ;做了硬性规定： “…Only alphanumerics [0-9a-zA-Z], the special characters “$-.+!*'(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.” “只有字母和数字[0-9a-zA-Z]、一些特殊符号”$-.+!*'(),\"[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。\" 这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致\"URL编码\"成为了一个混乱的领域。 下面就让我们看看，“URL编码\"到底有多混乱。我会依次分析四种不同的情况，在每一种情况中，浏览器的URL编码方法都不一样。把它们的差异解释清楚之后，我再说如何用Javascript找到一个统一的编码方法。 ","date":"2021-08-23","objectID":"/url-code-note/:1:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"二、情况1：网址路径中包含汉字 打开IE（我用的是8.0版），输入网址” http://zh.wikipedia.org/wiki/春节 “。注意，“春节\"这两个字此时是网址路径的一部分。 查看HTTP请求的头信息，会发现IE实际查询的网址是” http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82 “。也就是说，IE自动将\"春节\"编码成了”%E6%98%A5%E8%8A%82”。 我们知道，“春\"和\"节\"的utf-8编码分别是\"E6 98 A5\"和\"E8 8A 82”，因此，\"%E6%98%A5%E8%8A%82\"就是按照顺序，在每个字节前加上%而得到的。（具体的转码方法，请参考我写的《字符编码笔记》。） 在Firefox中测试，也得到了同样的结果。所以， 结论1就是，网址路径的编码，用的是utf-8编码。 ","date":"2021-08-23","objectID":"/url-code-note/:2:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"三、情况2：查询字符串包含汉字 在IE中输入网址\" http://www.baidu.com/s?wd=春节 “。注意，“春节\"这两个字此时属于查询字符串，不属于网址路径，不要与情况1混淆。 查看HTTP请求的头信息，会发现IE将\"春节\"转化成了一个乱码。 切换到十六进制方式，才能清楚地看到，“春节\"被转成了\"B4 BA BD DA”。 我们知道，“春\"和\"节\"的GB2312编码（我的操作系统\"Windows XP\"中文版的默认编码）分别是\"B4 BA\"和\"BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。 Firefox的处理方法，略有不同。它发送的HTTP Head是\"wd=%B4%BA%BD%DA”。也就是说，同样采用GB2312编码，但是在每个字节前加上了%。 所以， 结论2就是，查询字符串的编码，用的是操作系统的默认编码。 ","date":"2021-08-23","objectID":"/url-code-note/:3:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"四、情况3：Get方法生成的URL包含汉字 前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。 如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。 举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词\"春节”，生成的查询字符串是不一样的。 百度生成的是%B4%BA%BD%DA，这是GB2312编码。 Google生成的是%E6%98%A5%E8%8A%82，这是UTF-8编码。 所以， 结论3就是，GET和POST方法的编码，用的是网页的编码。 ","date":"2021-08-23","objectID":"/url-code-note/:4:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"五、情况4：Ajax调用的URL包含汉字 前面三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用。还是根据吕瑞麟老师的文章，在这种情况下，IE和Firefox的处理方式完全不一样。 举例来说，有这样两行代码： url = url + “?q=” +document.myform.elements[0].value; // 假定用户在表单中提交的值是\"春节\"这两个字 http_request.open(‘GET’, url, true); 那么，无论网页使用什么字符集，IE传送给服务器的总是\"q=%B4%BA%BD%DA\"，而Firefox传送给服务器的总是\"q=%E6%98 %A5%E8%8A%82\"。也就是说， 在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。这就是我们的结论4。 ","date":"2021-08-23","objectID":"/url-code-note/:5:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"六、Javascript函数：escape() 好了，到此为止，四种情况都说完了。 假定前面你都看懂了，那么此时你应该会感到很头痛。因为，实在太混乱了。不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果。如果程序员要把每一种结果都考虑进去，是不是太恐怖了？有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？ 回答是有的，就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。 Javascript语言用于编码的函数，一共有三个，最古老的一个就是escape()。虽然这个函数现在已经不提倡使用了，但是由于历史原因，很多地方还在使用它，所以有必要先从它讲起。 实际上，escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如\"春节\"的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春\"是第6625个（十六进制）字符，“节\"是第8282个（十六进制）字符。 它的具体规则是，除了ASCII字母、数字、标点符号”@ * _ + - . /“以外，对其他所有字符进行编码。在\\u0000到\\u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是 unescape()。 所以，“Hello World\"的escape()编码就是\"Hello%20World”。因为空格的Unicode值是20（十六进制）。 还有两个地方需要注意。 首先，无论网页的原始编码是什么，一旦被Javascript编码，就都变为unicode字符。也就是说，Javascipt函数的输入和输出，默认都是Unicode字符。这一点对下面两个函数也适用。 其次，escape()不对”+“编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 ","date":"2021-08-23","objectID":"/url-code-note/:6:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"七、Javascript函数：encodeURI() encodeURI()是Javascript中真正用来对URL编码的函数。 它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号”; / ? : @ \u0026 = + $ , #\"，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。 它对应的解码函数是decodeURI()。 需要注意的是，它不对单引号’编码。 ","date":"2021-08-23","objectID":"/url-code-note/:7:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"八、Javascript函数：encodeURIComponent() 最后一个Javascript编码函数是encodeURIComponent()。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。 因此，\"; / ? : @ \u0026 = + $ , #\"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。 它对应的解码函数是decodeURIComponent()。 ","date":"2021-08-23","objectID":"/url-code-note/:8:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"PS1 网页里的form编码其实不完全取决于网页编码，form标记中有一个accept-charset属性，在非ie浏览器种，如果将其赋值(比如 accept-charset=“UTF-8”)，则表单会按照这个值表示的编码方式进行提交。 在ie下，我的兼容解决办法是： form1.onsubmit=function(){ document.charset=this.getAttribute(‘accept-charset’); } ","date":"2021-08-23","objectID":"/url-code-note/:9:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Net","note"],"content":"PS2 字符编码笔记：ASCII，Unicode和 UTF-8 1. ASCII码 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从 0000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。 ASCII码一共规定了128个字符的编码，比如空格\"SPACE\"是32（二进制00100000），大写的字母A是65（二进制 01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 2、非ASCII编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和 UTF-8是毫无关系的。 3.Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain，U+0041表示英语的大写字母A，U+4E25表示汉字\"严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 4. Unicode的问题 需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字\"严\"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode 在很长一段时间内无法推广，直到互联网的出现。 5.UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF- 16和UTF-32，不过在互联网上基本不用。 重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 2）对于n字节的符号（n\u003e1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ——————–+——————————————— 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 下面，还是以汉字\"严\"为例，演示如何实现UTF-8编码。 已知\"严\"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此\"严\"的UTF-8编码需要三个字节，即格式是\"1110xxxx 10xxxxxx 10xxxxxx\"。然后，从\"严\"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严\"的UTF-8编码是 “11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 6. Unicode与UTF-8之间的转换 通过上一节的例子，可以看到\"严\"的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击\"文件\"菜单中的\"另存为\"命令，会跳出一个对话框，在最底部有一个\"编码\"的下拉条。 里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。 1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。 2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。 3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。 4）UTF-8编码，也就是上一节谈到的编码方法。 选择完\"编码方式\"后，点击\"保存\"按钮，文件的编码方式就立刻转换好了。 7. Little endian和Big endian 上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字\"严\"为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big- Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 因此，第一个字节在前，就是\"大头方式”（Big endian），第二个字节在前就是\"小头方式\"（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 8. 实例 下面，举一个实例。 打开\"记事本\"程序Notepad.exe，新建一个文本文件，内容就是一个\"严\"字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。 1）ANSI：文件的编码就是两个字节\"D1 CF\"，这正是\"严\"的GB2312编码，这也暗示GB2312是采用大头方式存储的。 2）Unicode：编码是四个字节\"FF FE 25 4E\"，其中\"FF FE\"表明是小头方式存储，","date":"2021-08-23","objectID":"/url-code-note/:10:0","tags":["Url","Chinese"],"title":"URL汉字编码问题（及乱码解决）","uri":"/url-code-note/"},{"categories":["Back"],"content":"记录URL含中文时后代码重定向时中文接收不到的解决办法","date":"2021-08-23","objectID":"/url-zh-cn-code-error/","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"问题 Url的中文接收不到 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:1:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"分析 Url中不能直接存在中文，需要进行编码，使用源码。程序中使用的是编码的中文 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:2:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["Back"],"content":"解决 重定向前将中文使用utf-8进行编码 tableName = URLEncoder.encode(tableName,\"utf-8\");//首先通过utf-8进行编码 在被重定向的接口使用utf-8解码 tableName = URLDecoder.decode(tableName,\"utf-8\");//再用utf-8解码，我的页面使用的utf-8编码 问题完美解决 ","date":"2021-08-23","objectID":"/url-zh-cn-code-error/:3:0","tags":["Java","Web","Url","Error"],"title":"Url含中文时后代码重定向时中文接收不到","uri":"/url-zh-cn-code-error/"},{"categories":["documentation","note"],"content":"记录Csdn转换为Markdown工具使用教程的笔记","date":"2021-08-23","objectID":"/csdn-download-markdown-note/","tags":["Csdn","Markdown"],"title":"Csdn转换为Markdown工具使用教程","uri":"/csdn-download-markdown-note/"},{"categories":["documentation","note"],"content":"推荐 ➹ Clean-mark, 这是一个很棒的工具，针对你的需求；它可以将博客文章转换为干净的Markdown文本文件。 安装： npm install clean-mark --global 使用: clean-mark \"http://some-website.com/fancy-article\" 示例： clean-mark \"https://jeffjade.com/2017/12/31/136-talk-about-nicelinks-site/\" 更多特质可参见：https://github.com/croqaz/clean-mark#why- 。 ","date":"2021-08-23","objectID":"/csdn-download-markdown-note/:0:0","tags":["Csdn","Markdown"],"title":"Csdn转换为Markdown工具使用教程","uri":"/csdn-download-markdown-note/"},{"categories":["Front"],"content":"记录nfound 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details的区别错误的办法","date":"2021-08-23","objectID":"/vue-install-error/","tags":["JavaScript","Js","Error"],"title":"found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details","uri":"/vue-install-error/"},{"categories":["Front"],"content":"报错 npm 安装包之后，如果出现类似下面的信息 found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details 如果 npm audit fix，之后还是有问题，可能是不能自动 fix，尽量不要 --force 强制 fix。 可以先 npm update，然后 npm audit 查看详情，再手动安装相关库。 ","date":"2021-08-23","objectID":"/vue-install-error/:1:0","tags":["JavaScript","Js","Error"],"title":"found 12 vulnerabilities (7 moderate, 5 high) run `npm audit fix` to fix them, or `npm audit` for details","uri":"/vue-install-error/"},{"categories":["Back","note"],"content":"记录Spring Boot Actuator的笔记","date":"2021-08-23","objectID":"/spring-boot-actuator-note/","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"简介 Spring Boot Actuator可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。 Actuator同时还可以与外部应用监控系统整合，比如 Prometheus, Graphite, DataDog, Influx, Wavefront, New Relic等。这些系统提供了非常好的仪表盘、图标、分析和告警等功能，使得你可以通过统一的接口轻松的监控和管理你的应用。 Actuator使用Micrometer来整合上面提到的外部应用监控系统。这使得只要通过非常小的配置就可以集成任何应用监控系统。 我将把Spring Boot Actuator教程分为两部分： 第一部分(本文)教你如何配置Actuator和通过Http endpoints来进入这些特征。 第二部分教你如何整合Actuator和外部应用监控系统。 ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:1:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"创建一个有Actuator的Spring Boot工程 首先让我们建一个依赖acutator的简单应用。 你可以使用Spring Boot CLI创建应用： spring init -d=web,actuator -n=actuator actuator 或者，你可以使用Spring Initializr网站来创建应用： Spring initialzr.png\r","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:2:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"增加Spring Boot Actuator到一个存在的应用 你可以增加spring-boot-actuator模块到一个已经存在的应用，通过使用下面的依赖。 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 对于Gradle，依赖如下： dependencies { compile(\"org.springframework.boot:spring-boot-starter-actuator\") } ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:3:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"使用Actuator Endpoints来监控应用 Actuator创建了所谓的endpoint来暴露HTTP或者JMX来监控和管理应用。 举个例子，有一个叫/health的endpoint，提供了关于应用健康的基础信息。/metricsendpoints展示了几个有用的度量信息，比如JVM内存使用情况、系统CPU使用情况、打开的文件等等。/loggersendpoint展示了应用的日志和可以让你在运行时改变日志等级。 值得注意的是，每一给actuator endpoint可以被显式的打开和关闭。此外，这些endpoints也需要通过HTTP或者JMX暴露出来，使得它们能被远程进入。 让我们运行应用并且尝试进入默认通过HTTP暴露的打开状态的actuator endpoints。之后，我们将学习如何打开更多的endpoints并且通过HTTP暴露它们。 在应用的根目录下打开命令行工具运行以下命令： mvn spring-boot:run 应用默认使用8080端口运行。一旦这个应用启动了，你可以通过http://localhost:8080/actuator来展示所有通过HTTP暴露的endpoints。 {\"_links\":{\"self\":{\"href\":\"http://localhost:8080/actuator\",\"templated\":false},\"health\":{\"href\":\"http://localhost:8080/actuator/health\",\"templated\":false},\"info\":{\"href\":\"http://localhost:8080/actuator/info\",\"templated\":false}}} 打开http://localhost:8080/actuator/health，则会显示如下内容: {\"status\":\"UP\"} 状态将是UP只要应用是健康的。如果应用不健康将会显示DOWN,比如与仪表盘的连接异常或者缺水磁盘空间等。下一节我们将学习spring boot如何决定应用的健康和如何修复这些健康问题。 infoendpoint(http://localhost:8080/actuator/info)展示了关于应用的一般信息，这些信息从编译文件比如META-INF/build-info.properties或者Git文件比如git.properties或者任何环境的property中获取。你将在下一节中学习如何改变这个endpoint的输出。 默认，只有health和info通过HTTP暴露了出来。这也是为什么/actuator页面只展示了health和infoendpoints。我们将学习如何暴露其他的endpoint。首先，让我们看看其他的endpoints是什么。 以下是一些非常有用的actuator endpoints列表。你可以在official documentation上面看到完整的列表。 Endpoint ID Description auditevents 显示应用暴露的审计事件 (比如认证进入、订单失败) info 显示应用的基本信息 health 显示应用的健康状态 metrics 显示应用多样的度量信息 loggers 显示和修改配置的loggers logfile 返回log file中的内容(如果logging.file或者logging.path被设置) httptrace 显示HTTP足迹，最近100个HTTP request/repsponse env 显示当前的环境特性 flyway 显示数据库迁移路径的详细信息 liquidbase 显示Liquibase 数据库迁移的纤细信息 shutdown 让你逐步关闭应用 mappings 显示所有的@RequestMapping路径 scheduledtasks 显示应用中的调度任务 threaddump 执行一个线程dump heapdump 返回一个GZip压缩的JVM堆dump ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:4:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"打开和关闭Actuator Endpoints 默认，上述所有的endpints都是打开的，除了shutdown endpoint。 你可以通过设置management.endpoint.\u003cid\u003e.enabled to true or false(id是endpoint的id)来决定打开还是关闭一个actuator endpoint。 举个例子，要想打开shutdown endpoint，增加以下内容在你的application.properties文件中： management.endpoint.shutdown.enabled=true ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:5:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"暴露Actuator Endpoints 默认，素偶偶的actuator endpoint通过JMX被暴露，而通过HTTP暴露的只有health和info。 以下是你可以通过应用的properties可以通过HTTP和JMX暴露的actuator endpoint。 通过HTTP暴露Actuator endpoints。 # Use \"*\" to expose all endpoints, or a comma-separated list to expose selected ones management.endpoints.web.exposure.include=health,info management.endpoints.web.exposure.exclude= 通过JMX暴露Actuator endpoints。 # Use \"*\" to expose all endpoints, or a comma-separated list to expose selected ones management.endpoints.jmx.exposure.include=* management.endpoints.jmx.exposure.exclude= 通过设置management.endpoints.web.exposure.include为*，我们可以在http://localhost:8080/actuator页面看到如下内容。 {\"_links\":{\"self\":{\"href\":\"http://localhost:8080/actuator\",\"templated\":false},\"auditevents\":{\"href\":\"http://localhost:8080/actuator/auditevents\",\"templated\":false},\"beans\":{\"href\":\"http://localhost:8080/actuator/beans\",\"templated\":false},\"health\":{\"href\":\"http://localhost:8080/actuator/health\",\"templated\":false},\"conditions\":{\"href\":\"http://localhost:8080/actuator/conditions\",\"templated\":false},\"configprops\":{\"href\":\"http://localhost:8080/actuator/configprops\",\"templated\":false},\"env\":{\"href\":\"http://localhost:8080/actuator/env\",\"templated\":false},\"env-toMatch\":{\"href\":\"http://localhost:8080/actuator/env/{toMatch}\",\"templated\":true},\"info\":{\"href\":\"http://localhost:8080/actuator/info\",\"templated\":false},\"loggers\":{\"href\":\"http://localhost:8080/actuator/loggers\",\"templated\":false},\"loggers-name\":{\"href\":\"http://localhost:8080/actuator/loggers/{name}\",\"templated\":true},\"heapdump\":{\"href\":\"http://localhost:8080/actuator/heapdump\",\"templated\":false},\"threaddump\":{\"href\":\"http://localhost:8080/actuator/threaddump\",\"templated\":false},\"prometheus\":{\"href\":\"http://localhost:8080/actuator/prometheus\",\"templated\":false},\"metrics-requiredMetricName\":{\"href\":\"http://localhost:8080/actuator/metrics/{requiredMetricName}\",\"templated\":true},\"metrics\":{\"href\":\"http://localhost:8080/actuator/metrics\",\"templated\":false},\"scheduledtasks\":{\"href\":\"http://localhost:8080/actuator/scheduledtasks\",\"templated\":false},\"httptrace\":{\"href\":\"http://localhost:8080/actuator/httptrace\",\"templated\":false},\"mappings\":{\"href\":\"http://localhost:8080/actuator/mappings\",\"templated\":false}}} ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:6:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"解析常用的actuator endpoint ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:7:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"/health endpoint health endpoint通过合并几个健康指数检查应用的健康情况。 Spring Boot Actuator有几个预定义的健康指标比如DataSourceHealthIndicator, DiskSpaceHealthIndicator, MongoHealthIndicator, RedisHealthIndicator, CassandraHealthIndicator等。它使用这些健康指标作为健康检查的一部分。 举个例子，如果你的应用使用Redis，RedisHealthindicator将被当作检查的一部分。如果使用MongoDB，那么MongoHealthIndicator将被当作检查的一部分。 你也可以关闭特定的健康检查指标，比如在prpperties中使用如下命令： management.health.mongo.enabled=false 默认，所有的这些健康指标被当作健康检查的一部分。 显示详细的健康信息 health endpoint只展示了简单的UP和DOWN状态。为了获得健康检查中所有指标的详细信息，你可以通过在application.yaml中增加如下内容： management: endpoint: health: show-details: always 一旦你打开上述开关，你在/health中可以看到如下详细内容： {\"status\":\"UP\",\"details\":{\"diskSpace\":{\"status\":\"UP\",\"details\":{\"total\":250790436864,\"free\":27172782080,\"threshold\":10485760}}}} health endpoint现在包含了DiskSpaceHealthIndicator。 如果你的应用包含database(比如MySQL)，health endpoint将显示如下内容： { \"status\":\"UP\", \"details\":{ \"db\":{ \"status\":\"UP\", \"details\":{ \"database\":\"MySQL\", \"hello\":1 } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":100330897408, \"threshold\":10485760 } } } } 如果你的MySQL server没有启起来，状态将会变成DOWN： { \"status\":\"DOWN\", \"details\":{ \"db\":{ \"status\":\"DOWN\", \"details\":{ \"error\":\"org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30006ms.\" } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":100324585472, \"threshold\":10485760 } } } } 创建一个自定义的健康指标 你可以通过实现HealthIndicator接口来自定义一个健康指标，或者继承AbstractHealthIndicator类。 package com.example.actuator.health; import org.springframework.boot.actuate.health.AbstractHealthIndicator; import org.springframework.boot.actuate.health.Health; import org.springframework.stereotype.Component; @Component public class CustomHealthIndicator extends AbstractHealthIndicator { @Override protected void doHealthCheck(Health.Builder builder) throws Exception { // Use the builder to build the health status details that should be reported. // If you throw an exception, the status will be DOWN with the exception message. builder.up() .withDetail(\"app\", \"Alive and Kicking\") .withDetail(\"error\", \"Nothing! I'm good.\"); } } 一旦你增加上面的健康指标到你的应用中去后，health endpoint将展示如下细节: { \"status\":\"UP\", \"details\":{ \"custom\":{ \"status\":\"UP\", \"details\":{ \"app\":\"Alive and Kicking\", \"error\":\"Nothing! I'm good.\" } }, \"diskSpace\":{ \"status\":\"UP\", \"details\":{ \"total\":250790436864, \"free\":97949245440, \"threshold\":10485760 } } } } ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:7:1","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"/metrics endpoint metrics endpoint展示了你可以追踪的所有的度量。 { \"names\": [ \"jvm.memory.max\", \"http.server.requests\", \"process.files.max\", ... \"tomcat.threads.busy\", \"process.start.time\", \"tomcat.servlet.error\" ] } 想要获得每个度量的详细信息，你需要传递度量的名称到URL中，像 http://localhost:8080/actuator/metrics/{MetricName} 举个例子，获得systems.cpu.usage的详细信息，使用以下URLhttp://localhost:8080/actuator/metrics/system.cpu.usage。它将显示如下内容: { \"name\": \"system.cpu.usage\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 0 } ], \"availableTags\": [] } ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:7:2","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"/loggers endpoint loggers endpoint，可以通过访问http://localhost:8080/actuator/loggers来进入。它展示了应用中可配置的loggers的列表和相关的日志等级。 你同样能够使用http://localhost:8080/actuator/loggers/{name}来展示特定logger的细节。 举个例子，为了获得root logger的细节，你可以使用http://localhost:8080/actuator/loggers/root： { \"configuredLevel\":\"INFO\", \"effectiveLevel\":\"INFO\" } 在运行时改变日志等级 loggers endpoint也允许你在运行时改变应用的日志等级。 举个例子，为了改变root logger的等级为DEBUG ，发送一个POST请求到http://localhost:8080/actuator/loggers/root，加入如下参数 { \"configuredLevel\": \"DEBUG\" } 这个功能对于线上问题的排查非常有用。 同时，你可以通过传递null值给configuredLevel来重置日志等级。 ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:7:3","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"/info endpoint info endpoint展示了应用的基本信息。它通过META-INF/build-info.properties来获得编译信息，通过git.properties来获得Git信息。它同时可以展示任何其他信息，只要这个环境property中含有infokey。 你可以增加properties到application.yaml中，比如： # INFO ENDPOINT CONFIGURATION info: app: name: @project.name@ description: @project.description@ version: @project.version@ encoding: @project.build.sourceEncoding@ java: version: @java.version@ 注意，我使用了Spring Boot的Automatic property expansion 特征来扩展来自maven工程的properties。 一旦你增加上面的properties，info endpoint将展示如下信息： { \"app\": { \"name\": \"actuator\", \"description\": \"Demo project for Spring Boot\", \"version\": \"0.0.1-SNAPSHOT\", \"encoding\": \"UTF-8\", \"java\": { \"version\": \"1.8.0_161\" } } } ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:7:4","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"使用Spring Security来保证Actuator Endpoints安全 Actuator endpoints是敏感的，必须保障进入是被授权的。如果Spring Security是包含在你的应用中，那么endpoint是通过HTTP认证被保护起来的。 如果没有， 你可以增加以下以来到你的应用中去： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e 接下去让我们看一下如何覆写spring security配置，并且定义你自己的进入规则。 下面的例子展示了一个简单的spring securiy配置。它使用叫做EndPointRequest 的ReqeustMatcher工厂模式来配置Actuator endpoints进入规则。 package com.example.actuator.config; import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest; import org.springframework.boot.actuate.context.ShutdownEndpoint; import org.springframework.boot.autoconfigure.security.servlet.PathRequest; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; @Configuration public class ActuatorSecurityConfig extends WebSecurityConfigurerAdapter { /* This spring security configuration does the following 1. Restrict access to the Shutdown endpoint to the ACTUATOR_ADMIN role. 2. Allow access to all other actuator endpoints. 3. Allow access to static resources. 4. Allow access to the home page (/). 5. All other requests need to be authenticated. 5. Enable http basic authentication to make the configuration complete. You are free to use any other form of authentication. */ @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .requestMatchers(EndpointRequest.to(ShutdownEndpoint.class)) .hasRole(\"ACTUATOR_ADMIN\") .requestMatchers(EndpointRequest.toAnyEndpoint()) .permitAll() .requestMatchers(PathRequest.toStaticResources().atCommonLocations()) .permitAll() .antMatchers(\"/\") .permitAll() .antMatchers(\"/**\") .authenticated() .and() .httpBasic(); } } 为了能够测试以上的配置，你可以在application.yaml中增加spring security用户。 # Spring Security Default user name and password spring: security: user: name: actuator password: actuator roles: ACTUATOR_ADMIN 你可以在Github上看到完整的代码。 ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:8:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"更多学习资源 Spring Boot Actuator: Production-ready features Micrometer: Spring Boot 2’s new application metrics collector ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:9:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back","note"],"content":"翻译源 Spring Boot Actuator: Health check, Auditing, Metrics gathering and Monitoring ","date":"2021-08-23","objectID":"/spring-boot-actuator-note/:10:0","tags":["Java","SpringBoot","Actuator"],"title":"Spring Boot Actuator笔记","uri":"/spring-boot-actuator-note/"},{"categories":["Back"],"content":"记录数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function的解决办法","date":"2021-08-23","objectID":"/sql-group-by-error/","tags":["Java","Database","Error"],"title":"数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function","uri":"/sql-group-by-error/"},{"categories":["Back"],"content":"分析 用了聚集函数 前面要select的列必须出现在聚集函数或者groupby里，不然它不知道怎么分配 查询大于平均WEIGHT的零件，列出他们的供应商代码（SNO），零件代码（PNO），工程代码（JNO），供应数量（QTY） insert into P(Pno,Pname,color,weight) values ('P1','螺母','红',12), ('P2','螺栓','绿',17), ('P3','螺丝刀','蓝',14), ('P4','螺丝刀','红',14), ('P5','凸轮','蓝',40), ('P6','齿轮','红',30); insert into SPJ(Sno,Pno,Jno,QTY) values ('S1','P1','J1',200), ('S1','P1','J3',100), ('S1','P1','J4',700), ('S1','P2','J2',100), ('S2','P3','J1',400), ('S2','P3','J2',200), ('S2','P3','J4',500), ('S2','P3','J5',400), ('S2','P5','J1',400), ('S2','P5','J2',100), ('S3','P1','J1',200), ('S3','P3','J1',200), ('S4','P5','J1',100), ('S4','P6','J3',300), ('S4','P6','J4',200), ('S5','P2','J4',100), ('S5','P3','J1',200), ('S5','P6','J2',200), ('S5','P6','J4',500); 1）查询大于平均WEIGHT的零件，列出他们的供应商代码（SNO），零件代码（PNO），工程代码（JNO），供应数量（QTY） select sno,spj.pno,jno,qty from spj,p where spj.pno=p.pno and weight\u003e(select avg(weight) from p) select sno,pno,jno,qty from spj where pno in(select pno from p where weight\u003e(select avg(weight) from p)) 错误 select sno,spj.pno,jno,qty from spj,p where spj.pno=p.pno having weight\u003e(select avg(weight) from p) 错 having要和group by 一起用 ","date":"2021-08-23","objectID":"/sql-group-by-error/:1:0","tags":["Java","Database","Error"],"title":"数据库报错：column 'x' must appear in the GROUP BY clause or be used in an aggregate function","uri":"/sql-group-by-error/"},{"categories":["Back"],"content":"记录new与newInstance()的区别","date":"2021-08-23","objectID":"/repository-dao-diff/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"分开解释 Repository：对象仓库。用于对象全部管理，贯穿整个对象的声明周期。 DAO（Data Access Object) ：数据访问对象是一个面向对象的数据库接口，负责对数据库的CRUD。 ","date":"2021-08-23","objectID":"/repository-dao-diff/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"基本关系 Repository通过DAO进行数据库的对象的管理 ","date":"2021-08-23","objectID":"/repository-dao-diff/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"高阶讨论 使用了持久化框架如Hibernate、Mybatis（Plus）等，无需区分Repository与DAO Repository是对象的仓库，也就是保存对象的地方，这个仓库就是我们普通意义的仓库，一个真正OO系统，业务层是围绕活动的对象进行，活动的对象是从仓库中获取的，也是通过交给仓库进行对象长久保管，也就是持久化意思，说白了，就是保存到数据库。 而DAO则没有如此OO概念，DAO是Data access Object，DAO中有数据概念，还是没有摆脱数据库的影子。 所以，Repository替代DAO，是OO深入的趋势，但是在具体处理中，由于性能或设计不够周到或者一些事情把握不定，DAO还会继续存在一段时间，属于过渡式消失。 Repository和DAO两个概念比较中发现，Repository是相对对象而言，而DAO是相对数据库而言，只要我们还是使用关系数据库保存对象，也可能这两者都同时存在，因为侧重点不一样，但是可以肯定的是，业务层应该直接和Repository打交道，而不是DAO. Repository=对象管理（对象工厂+对象缓存+…）+DAO，JiveJdon3中将缓存放在DAO中现在觉得不恰当 Repository的对象可以对外进行解释，如专业人员认为的订单，商品等， DAO更偏于开发人员为了实现开发目的而产生的对象，如外键关系、包含关系等。 DAO是对象访问接口类 接口类=方法的管理类 就是操作数据库的具体方法的类 User UserDAOImpl 就是管理怎么把User对象存进取出数据库的具体方法的类 repository是对象仓库类 仓库类=对象的管理类 User UserRepository 就是管理怎么样才能有效的访问User类的类 UserRepository在必要的时候才调用UserDAOImpl去操作数据库 你也可以吧UserRepository理解为UserCache,当然Repository不仅仅是cache的功能 简单的例子就是如果你有一个Model Object包含着一些Value Object，那么每个Object都回有相应的一个DAO，因为DAO都已经告诉你叫作Data access object，所以，每一个object都需要一个dao来做数据库等地层数据处理。 Reposirtory是对每一个Model Object来说的，一个Reposirtory基本上对应一个Model Object. 比如Person 包含一些Value Object比如address, work 等等，那么 Person就有一个Reposirtory，它里面有相关的方法比如，只是单纯的取出一个Person，然后Load相关的address和work在需要的时候，因为，有时候你不需要一次把所有的Value Object在一个Model Object提取的时候都一次性提出来，那样子叶增加系统负担也会造成资源浪费。 说白了就是Model Object有Reposirtory而Value Object没有，Value Object的基本操作可以用Dao而DDD有明确说明一般所有的对象操作都要面向的是Model Object。 Reposirtory提供对象管理， 管理对象可以通过DAO写入数据库或读取数据库组装对象，或者放入缓存等，这些业务层都不需要知道，业务层只对Reposirtory要求对象管理。 DAO就是数据库访问层，提供数据库CRUD操作。被包含在Reposirtory之内。 如果业务层直接调用DAO层，那么系统设计应该趋向数据库设计。 Repository 是放在BLL的，作为BL访问存取的地方。 而DAO可看成DAL提供BLL的接口，是放在DAL的 至于DAO是不是取消，就看DAL的设计了 业务是只管从仓库（Repository）中取出他所需要的对象，而不关心是从哪里存取，这些是Repository 的事情，Repository 可能通过DAO将数据完成持久化 repository是domain概念，dao是program概念。主要是看问题的角度和层次不同。 ","date":"2021-08-23","objectID":"/repository-dao-diff/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"DAO和Repository的区别","uri":"/repository-dao-diff/"},{"categories":["Back"],"content":"记录Swagger发请求报错Cannot deserialize value of type java.util.Date的解决办法","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"报错内容 Swagger前台报400 Java后台报错如上图 ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:1:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"分析 时间格式化问题，后台限制了json的格式 格式化实体类日期字段 public class DateT { @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\") Date date; } ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:2:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Back"],"content":"解决 按照图片更改即可 ","date":"2021-08-23","objectID":"/cannot-deserialize-value-type/:3:0","tags":["Java","Swagger","Json","Error"],"title":"Swagger发请求报错Cannot deserialize value of type java.util.Date","uri":"/cannot-deserialize-value-type/"},{"categories":["Software"],"content":"记录Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]的解决办法","date":"2021-08-23","objectID":"/maven-dump-file-error/","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"原因 使用maven进行打包 install package时报错 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:1:0","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:0","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决一：临时手动操作 ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:1","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software"],"content":"解决二：pom.xml配置 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e\u003c!--编译跳过测试文件检查的生命周期--\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cskip\u003etrue\u003c/skip\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003cresources\u003e \u003c!--如果pro和xml文件放在源码java包下，也需要编译--\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e ","date":"2021-08-23","objectID":"/maven-dump-file-error/:2:2","tags":["Maven"],"title":"Maven 编译报错：Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date]","uri":"/maven-dump-file-error/"},{"categories":["Software","note"],"content":"记录IDEA如何离线使用maven仓库？的笔记","date":"2021-08-23","objectID":"/idea-maven-offline-note/","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Software","note"],"content":"步骤 第一步，将相关的maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压： 第二步，将maven的配置文件settings.xml拷贝一份出来，在localRepository中配置本地仓库的地址。例如我刚才拷贝出来的仓库放在D:/repository下，然后配置下本地的镜像，本地仓库的地址一定要配置正确。 D:/repository下，然后配置下本地的镜像，本地仓库的地址一定要配置正确。 不需要配置localRepository标签，配置一个本地mirror即可 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csettings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"\u003e \u003c!-- \u003clocalRepository\u003eD:/repository\u003c/localRepository\u003e --\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003ecentral\u003c/id\u003e \u003cname\u003ecentral\u003c/name\u003e \u003c!-- 将镜像地址设置为本地maven地址 --\u003e \u003curl\u003efile://D:/repository\u003c/url\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e 第三步，打开IDEA的maven设置：file-\u003esettings搜索maven。注意要将maven设置为Work offline（离线模式），然后将User settings file配置成上一步拷贝的settings.xml的地址，点击OK。 这个时候就已经完成maven的离线配置了。如果还不行可以刷新一下maven的依赖，点击reimport，然后依赖就可以导入进来了。如果还是红色的线，可以尝试点击启动项目，看是不是报错，有的时候可能是没有及时刷新导致的。 ","date":"2021-08-23","objectID":"/idea-maven-offline-note/:1:0","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Software","note"],"content":"番外 另外分享一个maven离线打包的命令:mvn -o，此命令是在maven打包的时候不去下载仓库的依赖，非常有用。 mvn clean package -o -DskipTest // 或者使用这种方式跳过测试 mvn clean package -o -Dmaven.test.skip=true ","date":"2021-08-23","objectID":"/idea-maven-offline-note/:2:0","tags":["Maven","Idea"],"title":"IDEA如何离线使用maven仓库？","uri":"/idea-maven-offline-note/"},{"categories":["Back"],"content":"记录flyway中sql脚本修改导致的错误的解决方法","date":"2021-08-23","objectID":"/flyway-script-change-error/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"简介 flyway是一个简单开源数据库版本控制器（约定大于配置），主要提供migrate、clean、info、validate、baseline、repair等命令（Flyway java基本知识：https://blog.csdn.net/tanghin/article/details/51264795）。 使用该工具，配置好数据库脚本，在项目运行的时候即可将数据库脚本执行到数据库中，同时会在数据库表schema_version中增加相应的记录（若第一次执行，则会创建该表）。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"报错1 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"分析1 那么这段话表示什么意思呢？ 看这句话： Caused by:ori.flywaydb.core.api.FlywayException:Validate failed:migration checksum mismatch for migration 1.15.0 -\u003eApplied to database: 37561532 -\u003eResolved locally : -351684334 Flyway中的checksum值应当是-351684334，但是实际上运行的值是37561532，而且这个错误是在运行SQL Script 1.15.0出现的！ 那么出现这个问题的原因是什么呢？ 这里涉及到flyway的一些基本常识，flyway 官方文档 常识1）：项目每次执行，都会调用数据库，会先运行SQL Script 要使用到Flyway，但是flyway查询数据时，会判断数据库的数据结构或者数据什么的是否改变，判断标准就是checksum。 如图所示：在1.15被执行之前，执行的版本是1.14，也是初始化，但是在项目中的SQLScript更新到1.15版本后，项目开始运行的话，会先执行1.15，如果1.15没有执行即第二行没有增加的话，那么，会执行1.15版本，然后会有个checksum，如果检测到有1.15版本的话，那么将会检测自己的checksum后数据库里面的checksum是否相等，如果相等，那么就不会报错，但是，如果不相等的话，就会报出上面的异常；如果没有1.15版本的话，就会成功进行数据操作，最后生成1.15的记录。 常识2）Github管理项目，由于项目开发不是一个人，运行项目的版本可能不相同，但是数据库只有一个，每个项目运行都会用到flyway，进行数据操作。 总结：Github下，运行的版本不一样，有的使用的Sql Script 版本是1.14，但是有的是1.15，如果版本不进行及时更新的话，就会出现错误。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"解决1 如何解决这个问题： 将上面数据表格中的对应的数据元删掉，然后运行最新的版本。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"报错2 今天重新导入了项目，在运行项目的时候报错： org.springframework.beans.factory.BeanCreationException: Errorcreating bean with name 'flyway' defined in URL[file:/E:/gerp/war/target/gerp/WEB-INF/classes/spring/spring-jdbc.xml]:Invocation of init method failed; nested exception isorg.flywaydb.core.api.FlywayException: Validate failed: Detected appliedmigration not resolved locally: 18.616 之类的。 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:5:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"解决2 通过查找资料发现，Flyway执行脚本的时候会检查脚本是否有改动，并对其进行校验。若改动，则会校验错误，报错。 后尝试把数据库表中的schema_version删除，但虽然能够执行脚本，但若存在一些不能重复操作的sql（如：建表语句），依然会报错。 最终需要把schema_version与其相对应才能正常使用 ","date":"2021-08-23","objectID":"/flyway-script-change-error/:6:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"flyway中sql脚本修改导致的错误","uri":"/flyway-script-change-error/"},{"categories":["Back"],"content":"记录SpringBoot报错This primary key of 'id' is primitive !不建议如此请使用包装类 in Class解决办法","date":"2021-08-23","objectID":"/wrapper-class-not-recommended-error/","tags":["Java","SpringBoot","Error"],"title":"SpringBoot报错：不建议如此请使用包装类","uri":"/wrapper-class-not-recommended-error/"},{"categories":["Back"],"content":"原因及解决 报错原因：用idea自动导入实体类的时候 ，默认为long 实际应为Long，再次启动 不出现警告。 @Data public class ProgressVo { private long id; private String employeeNo; private String name; private String progress; private String created; private long pid; } ","date":"2021-08-23","objectID":"/wrapper-class-not-recommended-error/:1:0","tags":["Java","SpringBoot","Error"],"title":"SpringBoot报错：不建议如此请使用包装类","uri":"/wrapper-class-not-recommended-error/"},{"categories":["Back","note"],"content":"记录RESTful风格接口使用Json传递数据教程的笔记","date":"2021-08-23","objectID":"/restful-json-note/","tags":["RESTful","Json"],"title":"RESTful风格接口使用Json传递数据教程","uri":"/restful-json-note/"},{"categories":["Back","note"],"content":"JsonIgnore JSONField(serialize = false) JsonIgnore 相对 ObjectMapper objectMapper = new ObjectMapper(); String ttt2 =objectMapper.writeValueAsString(user); ObjectMapper对有注解jsonIgnore的不会返回，其它全部返回 JSONField(serialize = false) String ttt = JSONObject.toJSONString(user); JSONObject对有JSONField(serialize = false)的不会返回，null的也不返回 ","date":"2021-08-23","objectID":"/restful-json-note/:1:0","tags":["RESTful","Json"],"title":"RESTful风格接口使用Json传递数据教程","uri":"/restful-json-note/"},{"categories":["Back","note"],"content":"记录MybatisPlus访问PostgreSql教程的笔记","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"自定义TypeHnadler的使用 自定义的TypeHandler主要是转换Jsonb和array等类型 ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"如果是使用mybatisplus的内置方法,则需要在实体字段加上@TableField注解,并且需要在类名上启动@TableName(autoResultMap = true) // autoResultMap = true 必须写,否则无法识别 @TableName(autoResultMap = true) public class BlogUser implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String name; @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private LocalDateTime createTime; private Integer version; // 使用类型转换,否则无法增删改查 @TableField(typeHandler= JsonTypeHandler.class) private Map\u003cString,Object\u003e relation; } ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:1","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"如果是写在xml里面,则必须在对应字段注明转换器class: \u003cinsert id=\"addxml\" parameterType=\"com.hou.postgresql.blog.entity.po.BlogUser\"\u003e INSERT INTO blog_user (name, relation, fans, birthday, points, login_time, write_interval, numbers, adult, address, weight) VALUES (#{name}, /*必须显式的指明转换器,否则编译过程就会报错,主要是List,map这种数组,jsonb对应的实体类型*/ #{relation,typeHandler=com.hou.postgresql.handler.JsonTypeHandler}, #{fans,typeHandler=com.hou.postgresql.handler.ArrayTypeHandler}, #{birthday}, #{points}, #{loginTime}, #{writeInterval}::interval, #{numbers,typeHandler=com.hou.postgresql.handler.ArrayTypeHandler}, #{adult}, #{address}, #{weight}) \u003c/insert\u003e ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:1:2","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"column is of type jsonb but expression is of type character varying问题 即使写了转换器,查询的时候没问题,但是插入的时候依然会报这个错,这时需要在连接的url后面加上参数stringtype=unspecified就可以正常添加了 url: jdbc:postgresql://192.168.1.11:5432/postgres?currentSchema=sys\u0026stringtype=unspecified ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:2:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back","note"],"content":"所有数据类型参数格式 url后面加上stringtype=unspecified就可以使用任意格式插入了,除了json和array之外,其他的特殊类型,比如地址,间隔,时间等都可以使用string 参数如下: { \"address\": \"192.168.1.70\", // inet \"adult\": false, // boolean \"birthday\": \"1994-12-16\", // date \"fans\": [\"zhangpeng\",\"zhouhang\",\"pengle\"], \"loginTime\": \"09:12\", // time \"name\": \"侯征\", \"numbers\": [12,56,42], // array \"points\": 10.522, // numeric \"relation\": { // jsonb \"key\": \"value\" }, \"weight\": \"[45,50]\", // 区间 \"writeInterval\": \"800\" // 时间间隔,单位秒 } ","date":"2021-08-23","objectID":"/mybatis-postgresql-jsonb-note/:3:0","tags":["Java","MybatisPlus","Database","Sql","PostgreSql"],"title":"MybatisPlus访问PostgreSql教程","uri":"/mybatis-postgresql-jsonb-note/"},{"categories":["Back"],"content":"记录详细使用说明的笔记","date":"2021-08-22","objectID":"/springfox-swagger-note/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"1.spring-boot依赖 \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.9.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-08-22","objectID":"/springfox-swagger-note/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"2.swagger 配置 swagger文档默认访问地址：/swagger-ui.html swagger文档默认访问地址：/swagger-ui.html @Configuration @EnableSwagger2 //开启swagger，自动生成文档 public class SwaggerConfig { //一个Docket是一个组，组的划分可以通过paths()或apis()来实现，组名称可以作为api搜索条件。组包含多个tags，tag可以包含多个api； @Bean public Docket api() { //apiInfo():配置文档描述 //apis():api过滤规则，可以自定义为那些接口生成文档 //useDefaultResponseMessages():是否使用默认的响应信息 //paths()::可以根据请求路径过滤api //globalResponseMessage():：所有接口统一定义响应信息 //produces(): 为所有接口设置响应类型 //consumes():(): 为所有接口设置请求类型 //protocols(): 为所有接口设置支持的协议 //groupName（）：组名称 //tags：设置标签 Tag tag = new Tag(\"订单导出api\", \"订单相关导出api描述\"); ResponseMessage error = new ResponseMessageBuilder().code(500).message(\"系统异常\").build(); return new Docket(DocumentationType.SWAGGER_2) .useDefaultResponseMessages(false) .globalResponseMessage(RequestMethod.GET, Lists.newArrayList(error)) .apiInfo(apiInfo()) .groupName(\"订单导出api\") .protocols(Sets.newHashSet(\"http\", \"https\")) .consumes(Sets.newHashSet(MediaType.APPLICATION_JSON_VALUE)) .produces(Sets.newHashSet(MediaType.APPLICATION_JSON_VALUE)) .tags(tag) .select() .apis((RequestHandlerSelectors.basePackage(\"com.zhen.export\")) .paths(PathSelectors.any()).build(); } private ApiInfo apiInfo() { //title:文档标题 //description：文档的描述 //termsOfServiceUrl:文档的服务条款说明网址 //version:版本号 //contact：文档的联系人信息 //license:文档版权信息 //licenseUrl:版权信息超链接 return new ApiInfoBuilder() .title(\"珍品导出系统API文档\") .description(\"珍品导出系统API文档\") .contact(new Contact(\"moon\", \"www.baidu.com\", \"moon@zhen.com\")) .license(\"license-moon\"). .licenseUrl: 版权信息超链接(\"license-moon-url\") .termsOfServiceUrl(\"http://www.zhen.com\").version(\"2.0\").build(); } ","date":"2021-08-22","objectID":"/springfox-swagger-note/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"3.相关注解使用和说明 3.相关注解使用和说明 @RestController @RequestMapping(\"/orders\") @Api(tags = \"订单导出api\") public class OrderExportController { @ApiOperation(value = \" 订单导出任务-对象请求\", notes = \"订单导出任务详细描述\", httpMethod = \"GET\", produces = MediaType.APPLICATION_JSON_VALUE) @ApiImplicitParams({ @ApiImplicitParam(paramType = \"query\", name = \"test\", value = \"测试字段\", required = true, dataType = \"String\") }) @ApiResponses({ @ApiResponse(code = 500, message = \"系统异常\") }) @RequestMapping(value = \"/doExportTaskToOperationOnObject.json\", method = RequestMethod.GET) public EgResponse doExportTaskToOperationOnObject(OrderDetailRequest req, @ApiIgnore String test, HttpServletRequest request) throws Exception { return EgResponse.success(new OrderInfo()); } OrderDetailRequest：接口的请求对象，不需要格外注解，可以自动识别展示在文档中，可以用ApiModelProperty注解定义对象字段在文档中的展示 @ApiIgnore：可以用在controller类，方法参数上，使其不展示在文档中 @api：为功能模块添加说明信息，不是必须的，所有匹配的controller都会自动生成文档 属性名 说明 tags 接口的标签名，可用于分组，不能设置tag的描述，只能在swagger配置时设置组描述。每个controller都会生成默认的标签 produces 支持的响应类型，mime类型，多个值逗号分隔 consumes 入参类型值，mime类型，多个值逗号分隔 authorizations 获取此操作的授权列表 protocols 支持的传输协议，如http。多个协议逗号分隔 hidden 是否隐藏该模块 @ApiImplicitParams：描述方法参数的集合包含多个ApiImplicitParam注解 @ApiImplicitParam：描述方法参数信息 属性名 说明 value 参数描述 name 参数名称 defaultValue 参数默认值 allowableValues 参数允许的取值集合 required 是否必填 allowMultiple 是否可以传多个 dataType 参数值的类型 dataTypeClass 参数值得java类型 paramType 参数的类型，可选值path, query, body, header,form example 参数值例子，paramType!=body时有效 examples paramType=body时有效 allowEmptyValue 是否可以传递空值 @ApiOperation：模块中每个接口定义，不是必须的，spring会自动扫描所有的接口。 属性名 说明 value 接口名称 httpMethod 接口使用http方法，可选值 “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS”,“PATCH”。如果未指定则使用除\"PATH\"之外的其它所有 produces 支持的响应类型，mime类型，多个值逗号分隔 consumes 入参类型值，mime类型，多个值逗号分隔 notes 接口的详细描述 response 接口的响应类型。文档的响应信息结构可以根据方法的返回值自动处理。 protocols 支持的传输协议，如http。多个协议逗号分隔 hidden 是否在文档中展示改接口 responseHeaders http响应头信息描述 authorizations 获取此操作的授权列表 code HTTP返回状态码 nickname 第三方工具使用operationId来唯一表示此操作 tags 接口所属标签，默认为controller标签 extensions 扩展属性描述 @ApiResponses：响应信息集合，包含多个ApiResponse注解 @ApiResponse：定义不同http响应码的相关相关响应信息 属性名 说明 code http响应码 message 响应码描述 response 响应实体类 examples 响应例子 examples 响应例子 public class OrderDetailRequest { @ApiModelProperty(value = \"平台编码\", required = true, example = \"70\") private String platformCode; @ApiModelProperty(value = \"平台订单号\", required = true, example = \"sn20201029\") private String platformOrderSn; @ApiModelProperty(value = \"订单状态\", example = \"0\", allowableValues = \"0,1,2,3,4\") private Integer status; @ApiModelProperty(value = \"特殊字段\", example = \"0\", hidden = true) private BigDecimal special; @ApiModelProperty(value = \"开始时间 格式：yyyy-MM-dd HH:mm:ss\") private String startTime; } @ApiModel(value = \"response\", description = \"用于通用响应\") public class EgResponse { @ApiModelProperty(value = \"响应码\", example = \"200\") private String code; @ApiModelProperty(value = \"响应码描述\", example = \"成功\") private String message; @ApiModelProperty(\"响应数据\") private T data; } @ApiModel：实体的描述，主要用于响应实体，不是必须的 属性名 说明 value 实体名称 description 实体说明 parent 设置父类型 subTypes 设置子类型 @ApiModelProperty：实体中字段的描述 属性名 说明 value 字段描述 name 字段名称，会覆盖默认名称 allowableValues 允许的取值范围，主要用于请求实体中 description 实体说明 example 字段样例值。对于请求实体，该值在测试时自动填充入请求参数中；对于响应实体，则会展示在响应例子中 dataType 字段类型 required 是否必填 position 字段的顺序 hidden 是否在文档中隐藏该字段 allowEmptyValue 是否允许传递空置 ","date":"2021-08-22","objectID":"/springfox-swagger-note/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back"],"content":"4.对应关系 ","date":"2021-08-22","objectID":"/springfox-swagger-note/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"springfox-swagger笔记","uri":"/springfox-swagger-note/"},{"categories":["Back","note"],"content":"记录PageHelper笔记和示例","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"PageHelper是什么东西？ PageHelper是一个Mybatis的分页插件，其原理利用Mybatis提供的Interceptor接口创建了其实现类PageInterceptor类来实现分页功能。使用起来很方便，只需要简单的引入包，并且附加一行代码就可以实现在使用Mybatis时自动分页查询 ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:1:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"如何使用PageHelper? 导入依赖的包，我这里使用的是spring boot starter的包, maven代码: \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.2.13\u003c/version\u003e \u003c/dependency\u003e 在代码中需要分页时，直接在mapper方法调用前，插入一行PageHelper类的分页method即可 PageHelper.startPage(taskPageVo.getPageNum(), taskPageVo.getPageSize()); //多种分页方法，具体查看PageHelper类 List\u003cSaTask\u003e saTasks = saTaskMapper.findTasks(userIds, taskPageVo.getStatus(), null, null); ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:2:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"使用PageHelper处理多个不同类型数据库数据源 上面的方法在单个数据源中或多个相同类型的数据库数据源中使用没有任何问题，但是在多个数据源中使用就会有问题。原因是不同的数据库分页的sql语句不一样，譬如mysql使用limit，sqlserver使用top，oracle使用rownum等等。而PageHelper为我们提供了方便，只要配置属性autoRuntimeDialect为true就可以完全支持不同类型数据库数据源分页了 针对上面的问题该如何解决，网上搜索了一下，大概有三种方式 方式一，在定义sessionFactory的时候，不同的数据源使用不同的PageInterceptor过滤 //mysql @Bean(name = \"masterSqlSessionFactory\") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier(\"masterDataSource\") DataSource masterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(masterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MysqlDataSourceConfig.MAPPER_LOCATION)); sessionFactory.getObject().getConfiguration().setMapUnderscoreToCamelCase(true);//配置驼峰映射 sessionFactory.getObject().getConfiguration().setLogImpl(StdOutImpl.class); //分页插件 Interceptor interceptor = new PageInterceptor(); Properties properties = new Properties(); //分页数据库方言为mysql properties.setProperty(\"helperDialect\", \"mysql\"); //是否为分页数据库多个数据配置 properties.setProperty(\"autoRuntimeDialect\", \"true\"); //是否分页合理化 properties.setProperty(\"reasonable\", \"false\"); interceptor.setProperties(properties); sessionFactory.setPlugins(new Interceptor[] {interceptor}); return sessionFactory.getObject(); } //sqlserver @Bean(name = \"clusterSqlSessionFactory\") public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(\"clusterDataSource\") DataSource clusterDataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(clusterDataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(SqlserverDataSourceConfig.MAPPER_LOCATION)); // sessionFactory.getObject().getConfiguration().setMapUnderscoreToCamelCase(true);//配置驼峰映射 sessionFactory.getObject().getConfiguration().setLogImpl(StdOutImpl.class); //分页插件 Interceptor interceptor = new PageInterceptor(); Properties properties = new Properties(); //分页数据库方言为sqlserver properties.setProperty(\"helperDialect\", \"sqlserver\"); //是否为分页数据库多个数据配置 properties.setProperty(\"autoRuntimeDialect\", \"true\"); //是否分页合理化 properties.setProperty(\"reasonable\", \"false\"); interceptor.setProperties(properties); sessionFactory.setPlugins(new Interceptor[] {interceptor}); return sessionFactory.getObject(); } 方式二：统一配置PageHelper Config类，实际上也就是统一配置PageInterceptor @Configuration public class PageHelperConfig { @Bean PageInterceptor pageInterceptor() { PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.setProperty(\"offsetAsPageNum\", \"false\"); properties.setProperty(\"rowBoundsWithCount\", \"false\"); properties.setProperty(\"pageSizeZero\", \"true\"); properties.setProperty(\"reasonable\", \"false\"); properties.setProperty(\"supportMethodsArguments\", \"false\"); properties.setProperty(\"returnPageInfo\", \"none\"); properties.setProperty(\"autoRuntimeDialect\", \"true\"); //处理多数据源数据库 pageInterceptor.setProperties(properties); return pageInterceptor; } } 方式三：在application.yml文件中配置PageHelper的属性支持多数据源 pagehelper:autoRuntimeDialect:true ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:3:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back","note"],"content":"在不同类型数据库的数据源情况下，正确的在spring boot 中使用PageHelper 使用方式一，看网络上的朋友，需要根据对应的sessionFactory创建SqlSessionTemplate，并且在Mapper上加分页参数，我没有测试过，但是感觉麻烦。 使用方式二，则可能简单方便点。但是方式一和方式二都有共同的问题，就是除非直接导入的依赖包是非spring boot starter包，而是直接导入pagehelper包，如： \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003c/dependency\u003e 否则都会出现一个问题，第一次使用某个类型的数据库分页查询正确，后面使用的其他类型数据库分页 查询都会失败。 使用方式三可以完全的使用PageHelper解决不同类型数据库数据源的分页问题。 方式一和方式二出现问题的根本原因是autoRuntimeDialect属性没有被设置上导致的。因为使用spring boot starter包时，每次服务器启动的时候spring容器都会去实例化PageHelperAutoConfiguration类，在这个类里会去读取yml文件中配置pagehelper属性，如果没有在yml中配置pagehelper.autoRuntimeDialect=true，那么它的值就为null，到时候PageHelper类就自动认为不是多数据源。HelperDialect 方言永远是第一次查询时的方言。 源码分析（由于篇幅有限，简单的截图说明） ","date":"2021-08-22","objectID":"/mybatis-pagehelper-note/:4:0","tags":["Orm","Mybatis","Plugin"],"title":"PageHelper笔记","uri":"/mybatis-pagehelper-note/"},{"categories":["Back"],"content":"记录动态语言和静态语言的本质区别的区别","date":"2021-08-22","objectID":"/static-dynamic-diff/","tags":["Language","Difference"],"title":"动态语言和静态语言的本质区别是什么？","uri":"/static-dynamic-diff/"},{"categories":["Back"],"content":"静态语言 静态类型语言 如果在编译时知道变量的类型，则该语言是静态类型的。我们经常说道的Java、C、C++在写代码的时候必须指定每个变量的类型。 优点就是编译器可以执行各种检查，也就是程序还没跑起来就能找到一些小错误，也就是是在compile-time检查出错误的。 ","date":"2021-08-22","objectID":"/static-dynamic-diff/:1:0","tags":["Language","Difference"],"title":"动态语言和静态语言的本质区别是什么？","uri":"/static-dynamic-diff/"},{"categories":["Back"],"content":"动态语言 动态类型语言 一般是脚本语言，比如说Perl、Ruby、Python、PHP、JavaScript，可以更快地编写代码，不必每次都指定类型，做type checking是在run-time的时候去做的。优点是可能代码开发快，但是维护难（但是脚本语言平常写的代码量应该不太多，还比较好debug和修改） ","date":"2021-08-22","objectID":"/static-dynamic-diff/:2:0","tags":["Language","Difference"],"title":"动态语言和静态语言的本质区别是什么？","uri":"/static-dynamic-diff/"},{"categories":["Front"],"content":"记录JS error : split is not a function报错的解决办法","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"JS报错 如图 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:1:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"问题所在 split 只能是字符串才能执行，其他类型参数需要转换类型，否则报错 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:2:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Front"],"content":"解决 转换为str类型 var a = 123 (a+\"\").split(\"\") 解决了 ","date":"2021-08-22","objectID":"/js-split-is-not-a-function-error/:3:0","tags":["JavaScript","Error"],"title":"JS error : split is not a function","uri":"/js-split-is-not-a-function-error/"},{"categories":["Net","note"],"content":"记录Gmail的Host解决方案","date":"2021-08-22","objectID":"/gmail-host-note/","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"原因 Gmail 在国内可用google.cn的 Host来改进连接速度，避免被GFW干扰，经测试联通 网络打开Gmail速度飞快，特共享之！ 由于公布的Host地址很快会被GFW强奸，所以google.cn服务器的IP地址会经常变化， 那么只要我们能找到变化的IP地址，经常更新host文件便可以解决这个问题。 ","date":"2021-08-22","objectID":"/gmail-host-note/:1:0","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"办法 ","date":"2021-08-22","objectID":"/gmail-host-note/:2:0","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"1 在运行里敲击cmd，然后敲击如下代码： nslookup www.google.cn 8.8.8.8 ","date":"2021-08-22","objectID":"/gmail-host-note/:2:1","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Net","note"],"content":"2 （补充：如果不行，可将命令中的“www.google.cn\" 换成”www.google.com.hk\"或者“www.google.com\" 试下） 返回得到的IP地址取任意一个来替换203.208.46.X，然后保存host文件即可。 203.208.46.X maps.google.com 203.208.46.X mail.google.com 203.208.46.X maps-api-ssl.google.com 203.208.46.X images1-focus-opensocial.googleusercontent.com 203.208.46.X images2-focus-opensocial.googleusercontent.com 203.208.46.X www.google.com 203.208.46.X encrypted.google.com 203.208.46.X chrome.google.com 203.208.46.X clients1.google.com 203.208.46.X clients2.google.com 203.208.46.X clients3.google.com 203.208.46.X clients4.google.com 203.208.46.X clients5.google.com 203.208.46.X clients6.google.com 203.208.46.X clients7.google.com 203.208.46.X clients1.googleusercontent.com 203.208.46.X clients2.googleusercontent.com 203.208.46.X clients3.googleusercontent.com 203.208.46.X clients4.googleusercontent.com 203.208.46.X clients5.googleusercontent.com 203.208.46.X clients6.googleusercontent.com 203.208.46.X clients7.googleusercontent.com 203.208.46.X profiles.google.com 203.208.46.X plus.google.com 203.208.46.X talkgadget.google.com 203.208.46.X picasaweb.google.com 203.208.46.X lh1.ggpht.com 203.208.46.X lh2.ggpht.com 203.208.46.X lh3.ggpht.com 203.208.46.X lh4.ggpht.com 203.208.46.X lh5.ggpht.com 203.208.46.X lh6.ggpht.com 203.208.46.X lh6.googleusercontent.com 203.208.46.X lh5.googleusercontent.com 203.208.46.X lh4.googleusercontent.com 203.208.46.X lh3.googleusercontent.com 203.208.46.X lh2.googleusercontent.com 203.208.46.X lh1.googleusercontent.com 203.208.46.X spreadsheets.google.com 203.208.46.X docs.google.com 203.208.46.X pop.gmail.com 203.208.46.X scholar.l.google.com 203.208.46.X news.google.com 203.208.46.X video.google.com 203.208.46.X translate.google.com ","date":"2021-08-22","objectID":"/gmail-host-note/:2:2","tags":["Hosts","Google"],"title":"Gmail 的Host解决方案","uri":"/gmail-host-note/"},{"categories":["Front","note"],"content":"记录Html笔记和相关示例","date":"2021-08-16","objectID":"/html-note/","tags":["Html"],"title":"Html笔记","uri":"/html-note/"},{"categories":["Front","note"],"content":"如何让button变成\u003ca href='链接'\u003e\u003c/a\u003e效果 其实就是一行代码，不过网上老有人拿错误代码来误导，不知道是不是以前的语法有不一样，下面放正确方法 在原窗口跳转到新网址 \u003cbutton onclick=\"window.location.href='http://www.baidu.com'\"\u003e链接\u003c/button\u003e 打开新窗口跳转到新网址 \u003cbutton onclick=\"window.open('http://www.baidu.com')\"\u003e链接\u003c/button\u003e 这两个方法不一样，看清楚，切记切记。 ","date":"2021-08-16","objectID":"/html-note/:1:0","tags":["Html"],"title":"Html笔记","uri":"/html-note/"},{"categories":["Total","note"],"content":"记录Jsp相关笔记合示例","date":"2021-08-16","objectID":"/jsp-note/","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"jsp fmt标签详解 JSTL标签提供了对国际化（I18N）的支持，它可以根据发出请求的客户端地域的不同来显示不同的语言。同时还提供了格式化数据和日期的方法。实现这些功能需要I18N格式标签库（I18N-capable formation tags liberary）。引入该标签库的方法为： \u003c%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %\u003e I18N格式标签库提供了11个标签，这些 标签从功能上可以划分为3类如下： （1）数字日期格式化。formatNumber标签、formatData标签、parseNumber标签、parseDate标签、timeZone标签、setTimeZone标签。 （2）读取消息资源。bundle标签、message标签、setBundle标签。 （3）国际化。setlocale标签、requestEncoding标签。 接下将详细介绍这些标签的功能和使用方式。 ","date":"2021-08-16","objectID":"/jsp-note/:1:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.1 数字日期格式化 数字日期格式化标签共有6个，用来将数字或日期转换成设定的格式。 1．\u003cfrm:formatNumber/\u003e标签 该标签依据特定的区域将数字改变为不同的格式来显示。 【语法1】： \u003cfrm:formatNumber value=”被格式化的数据”[type=”number|currency|percent”][pattern=”pattern”] [currencyCode=”code”][currencySymbol=”symbol”][groupingUsed=”true|false”] [maxIntergerDigits=”maxDigits”][minIntergerDigits=”minDigits”][maxFractionDigits=”maxDigits”] [minFractionDigits=”minDigits”][var=”name”][scope=page|request|session|application]/\u003e 【语法2】： \u003cfrm:formatNumber [type=”number|currency|percent”][pattern=”pattern”][currencyCode=”code”] [currencySymbol=”symbol”][groupingUsed=”true|false”][maxIntergerDigits=”maxDigits”] [minIntergerDigits=”minDigits”][maxFractionDigits=”maxDigits”][minFractionDigits=”minDigits”] [var=”name”][scope=page|request|session|application]\\\u003e \u003cfmt:formatNumber\u003e标签参数说明: 名称 说明 EL 类型 必须 默认值 value 要格式化的数据 是 String 是 无 type 指定类型（单位、货币、百分比等）见表 是 String 否 number pattern 格式化的数据样式 是 String 否 无 currencyCode 货币单位代码 是 String 否 无 cuttencySymbol 货币符号（$、￥） 是 String 否 无 groupingUsed 是否对整数部分进行分组如（9，999） 是 boolean 是 true maxIntergerDigits 整数部分最对显示多少位数 是 int 否 无 minIntergerDigits 整数部分最少显示多少位 是 int 否 无 maxFractionDigits 小数部分最多显示多少位 是 int 否 无 minFractionDigits 小数部分最少显示多少位 是 int 否 无 var 存储格式化后的数据 否 String 否 无 scope var的JSP范围 否 String 否 page Type属性的类型应用:. 类型 说明 示例 number 数字格式 0.8 currency 当地货币 ￥0.80 percent 百分比格式 80% 【示例代码】：实现了对数字的格式化、货币的格式、货币的格式化。使用\u003cfrm:formatNumber\u003e的各种属性的设定。 \u003ctable border=1 cellpadding=\"0\" cellspacing=\"0\" align=\"center\"\u003e \u003ctr align=\"center\"\u003e \u003ctd width=\"100\"\u003e类型 \u003c/td\u003e \u003ctd width=\"100\"\u003e使用数据\u003c/td\u003e \u003ctd width=\"100\"\u003e结果\u003c/td\u003e \u003ctd width=\"300\"\u003e说明\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e108.75\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" pattern=\"###.#\"\u003e108.75\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用pattern可以定义显示的样式。本例设定为###.#小数部分将使用四舍五入法。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" pattern=\"#.####E0\"\u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用科学计数法。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" \u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003c/td\u003e \u003ctd\u003e使用默认分组。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" groupingUsed=\"false\" \u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e不使用分组。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e数字格式化\u003c/td\u003e\u003ctd\u003e9557\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"number\" maxIntegerDigits=\"3\"\u003e9557\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e使用位数限定，根据指定的位数显示，其他数字忽略。例如：9不被显示。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e百分比格式化\u003c/td\u003e\u003ctd\u003e0.98\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"percent\"\u003e0.98\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e用百分比形式显示一个数据。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e货币格式化\u003c/td\u003e\u003ctd\u003e188.88\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"currency\" \u003e188.8\u003c/fmt:formatNumber\u003e\u003c/td\u003e \u003ctd\u003e将一个数据转化为货币形式输出。\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e存储数据\u003c/td\u003e\u003ctd\u003e188.88\u003c/td\u003e \u003ctd\u003e\u003cfmt:formatNumber type=\"currency\" var=\"money\"\u003e188.8\u003c/fmt:formatNumber\u003e \u003cc:out value=\"${money}\"\u003e\u003c/c:out\u003e \u003c/td\u003e \u003ctd\u003e存储的money的值为${money} \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 【代码说明】： （1）从应用角度可以把属性分为三类：数字格式化、货币格式化、百分比格式化。使用type指定类型。 （2）应用于数字格式化的属性有：partten属性、maxIntegerDigits属性、minIntegerDigits属性、maxFractionDigits属性和minFactionDigits属性。其中partten属性在设定格式化样式时会比较准确如：四舍五入、科学计数法的使用。而使用maIntegerDirgits等属性时，只把设定位数以外的数字舍去。 （3）货币格式化可以使用数字格式化的所有属性。如果有必要建议使用partten属性。currencyCode属性和currencySymbol只用于货币格式化。 （4）百分比格式化使用到的属性为type属性、partten属性，设定type属性的类型为percent即可。 （5）使用var属性时，会将格式化后的值存在JSP的某个范围内（一个String类型的字符串包括符号等）。\u003cfrm:forNumber\u003e将不再输出格式化后的值可以使用EL表达式输出。 （6）通用属性：type属性、partten属性、var属性和scope属性。 2．\u003cfrm:parseNumber\u003e标签 将格式化后的数字、货币、百分比都转化为数字类型。 【语法1】： \u003cfmt:parseNumber value=\"number\" [type=”number|currency|percent”][pattern=”pattern”] [parseLocale=”locale”][intergerOnly=”true|false”][scope=”page|request|session|application”]/\u003e 【语法2】： \u003cfmt:parseNumber [type=”number|currency|percent”][pattern=”pattern”] [parseLocale=”locale”] [intergerOnly=”true|false”][scope=”page|request|session|application”]\\\u003e Number \u003c/fmt:parseNumber \u003cfmt:parseNumber\u003e标签参数说明: 名称 说明 EL 类型 是否必须 默认值 value 被解析的字符串 是 String 是 无 type 指定单位（数字、货币、百分比） 是 String 是 number pattern 格式样式 是 String 否 无 parseLocale 用来替代默认区域的设定 是 String，Java.util.Locale 是 默认本地样式 var 存储已经格式化的数据 否 String 否 无 scope var变量的作用域 否 String 是 page \u003cfmt:pars","date":"2021-08-16","objectID":"/jsp-note/:1:1","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.2 读取消息资源 读取消息资源用到的标签主要有4个：\u003cfmt:message\u003e标签、\u003cfmt:param\u003e标签、\u003cfmt:bundle\u003e标签和\u003cfmt:setBundle\u003e标签。主要用于从资源文件中读取信息。 1．\u003cfmt:bundle\u003e标签 该标签主要用于将资源文件绑定于它的标签体中的显示。 【语法】： \u003cfmt:bundle basename=”name”[prefix=”prefix”]\u003e ….标签主题 \u003c/fmt:bundle\u003e \u003cfmt:bundle\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 basename 指定使用的资源文件的名称 是 String 是 无 prefix 前置关键字 是 String 否 无 2．\u003cfmt:setBundle\u003e标签 该标签主要用于绑定资源文件或者把资源文件保存在指定的JSP范围内。 【语法】： \u003cfmt:setBundle basename=”name” [var=”name”][scope=”page|request|session|application”]\\\u003e \u003cfmt:setBundle\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 basename 指定使用的资源文件的名称 是 String 是 无 var 指定将资源文件保存的名称 否 String 否 无 scope 设定将资源文件保存的JSP范围 否 String 否 page 3．\u003cfmt:message\u003e标签 该标签主要负责读取本地资源文件，从指定的消息文本资源文件中读取键值，并且可以将键值保存在指定的JSP范围内。 【语法1】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]/\u003e 【语法2】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]\\\u003e \u003cfmt:param/\u003e \u003c/fmt:message 【语法3】： \u003cfmt:message key=”keyName”[bundle=”bundle”][scope=”page|request|session|application”]\\\u003e key \u003cfmt:param/\u003e … \u003c/fmt:message\u003e \u003cfmt:message\u003e标签属性说明： 参数名 说明 EL 类型 必须 默认值 key 指定键值的名称（索引） 是 String 是 无 bundle 指定消息文本的来源 是 LocalizationContext 否 无 var 指定存储键值的变量名 否 String 否 无 scope 指定var的作用域 否 String 否 page 提示：建议此处的bundle使用EL表达式，因为属性bundle的类型为LocalizationContext，而不是一个String类型的URL。 【示例代码】：实现从指定的资源文件中读取对应key的值。 首先编写一个资源文件内容下 name=olive password=01234 使用标签从资源文件中读取相应的值。 \u003cfmt:bundle basename=\"message\"\u003e \u003cc:out value=\"从message资源文件中得到的key为name的值为：\"\u003e\u003c/c:out\u003e \u003cfmt:message key=\"name\" \u003e\u003c/fmt:message\u003e \u003c/fmt:bundle\u003e \u003chr\u003e \u003cfmt:setBundle basename=\"message\" var=\"m\"/\u003e \u003cfmt:message key=\"password\" bundle=\"${m}\"\u003e\u003c/fmt:message ${m} 【代码解析】： （1）使用\u003cfmt:bundle\u003e标签指定从message.properties文件中读取值。 （2）使用\u003cfmt:message\u003e标签读取资源文件中key为name的值。\u003cfmt:message\u003e标签放在\u003cfmt:bundle\u003e标签体内使用。 （3）使用\u003cfmt:setBundle\u003e标签在page范围绑定一个配置文件，以m为参数名存储。 （4）使用\u003cfmt:message\u003e标签得到key为password的值，此处指定资源文件的方式为使用\u003cfmt:message\u003e标签的bundle属性来设定。 （5）输出参数m的值，加深对bundle的理解。 \u003cfmt:bundle\u003e标签中有一个prefix属性，该标签用来指明前缀。例如配置文件内容如下： org.person.name=olive org.personpassword=01234 如果不使用prefix标签，在取值是要指明前缀。例如： \u003cfmt:bundle basename=”message”\u003e \u003cfmt:message key=”org.person.name”\u003e\u003c/fmt:message\u003e \u003cfmt:message key=”org.person.password”\u003e\u003c/fmt:message\u003e \u003c/fmt:bundle 使用prefix属性可以简化取值时的代码。 \u003cfmt:bundle basename=”message” prefix=”org.person”\u003e \u003cfmt:message key=”name”\u003e\u003c/fmt:message\u003e \u003cfmt:message key=”password”\u003e\u003c/fmt:message\u003e \u003c/fmt:bundle\u003e 4．\u003cfmt:param\u003e标签 该标签主要用于当\u003cfmt:message\u003e中资源文件中获得键值时，动态的为资源文件中的变量赋值。 【语法1】： \u003cfmt:param value=”value”/\u003e 【语法2】： \u003cfmt:param \u003e …标签主体 \u003c/fmt:param\u003e 【示例代码】： （1）创建资源文件。在message.properties文件中增加一个key和value。 news={0} welcome to out website! \u003cbr\u003etoday is :{1,date} 表达的含义是键news对应的是一个字符串，字符串中还有动态变量{0}表示第一个动态变量，{1,date}表示第二个动态变量并且该变量是一个日期类型的对象。 （2）通过标签从资源文件中取出键值，并给动态变量赋值显示在页面。 \u003cfmt:bundle basename=\"message\"\u003e \u003cfmt:message key=\"news\"\u003e \u003cfmt:param value=\"olive\" /\u003e \u003cfmt:param value=\"${date}\"/\u003e \u003c/fmt:message\u003e \u003c/fmt:bundle\u003e 【代码解析】： （1）使用\u003cfmt:bundle\u003e标签把资源文件绑定在标签体内。 （2）在\u003cfmt:bundle\u003e标签体内使用\u003cfmt:message\u003e得到键值。 （3）使用\u003cfmt:param\u003e为资源文件中的动态变量赋值。 ","date":"2021-08-16","objectID":"/jsp-note/:1:2","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"9.3.3 国际化 国际化这个分类中共包含两个标签：用于设定语言地区\u003cfmt:setLocale/\u003e和用于设定请求的字符编码的\u003cfmt:requestEncoding\u003e标签。 1．\u003cfmt:setLocale/\u003e标签 \u003cfmt:setLocale\u003e标签用来设定用户语言区域。 【语法】： \u003cfmt:setLocale value=”locale”[variant=”variant”][scope=”page|request|session|application”]\u003e fmt:setLocale标签属性说明： 参数名 说明 EL 类型 必须 默认值 value 指定区域代码 是 Stringjava.util.Locale 是 无 variant 操作系统的类型 是 String 是 无 scope 设定时区的作用范围 否 String 是 page value属性用来指定使用的语言代码，可以从浏览器的【工具】—【Internet选项】—【语言】—【添加】中查看浏览器支持的语言种类及语言代码。例如：中文（zh_cn）、台湾（zh_tw）、香港（zh_mo）等。 【示例代码】：实现了设定不同的区域代码，根据不同的区域代码浏览将显示不同格式的日期。 \u003cfmt:setLocale value=\"en_us\" /\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e \u003chr\u003e \u003cfmt:setLocale value=\"zh_cn\" /\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e \u003chr\u003e \u003cfmt:setLocale value=\"zh_TW\"/\u003e \u003cfmt:formatDate value=\"${date}\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/\u003e 【代码解析】： （1）浏览器默认跟您使用的操作系统的语言相同，因此默认值zh_cn。使用fmt:setLocale/标签设置使用的语言为en_us（英语）。使用fmt:formateDate格式化输出的时间字符串，该标签会根据不同的语言输出不同的日期格式。 （2）使用的语言修改为zh_cn，再次用格式化输出。 （3）使用语言修改为zh_TW，输出格式化后的时间。 2．\u003cfmt:requestEncoding\u003e标签 该标签用于设定请求的编码格式。功能同servletRequest.setCharacterEncoding()方法相同。 【语法】： \u003cfmt:requestEncoding [value=”charEncoding”]/\u003e 【参数说明】： value属性用来指定使用的编码集例如：gbk、gb2312等。当没有给出value的值时将会自动搜索取寻找合适的编码方式，因此能够很好的解决中文乱码问题。 ","date":"2021-08-16","objectID":"/jsp-note/:1:3","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSP 标准标签库（JSTL） JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 根据JSTL标签所提供的功能，可以将其分为5个类别。 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 ","date":"2021-08-16","objectID":"/jsp-note/:2:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL 库安装 Apache Tomcat安装JSTL 库步骤如下： 从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 本站下载地址：jakarta-taglibs-standard-1.1.2.zip 下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。 接下来我们在 web.xml 文件中添加以下配置： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003cjsp-config\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/fmt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/fmt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/fmt-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/fmt-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/core\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/c.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/core-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/c-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/sql\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/sql.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/sql-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/sql-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/x\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/x.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003ctaglib\u003e \u003ctaglib-uri\u003ehttp://java.sun.com/jsp/jstl/x-rt\u003c/taglib-uri\u003e \u003ctaglib-location\u003e/WEB-INF/x-rt.tld\u003c/taglib-location\u003e \u003c/taglib\u003e \u003c/jsp-config\u003e \u003c/web-app\u003e 使用任何库，你必须在每个 JSP 文件中的头部包含 标签。 ","date":"2021-08-16","objectID":"/jsp-note/:2:1","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"核心标签 核心标签是最常用的 JSTL标签。引用核心标签库的语法如下： \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e 标签 描述 用于在JSP中显示数据，就像\u003c%= … \u003e 用于保存数据 用于删除数据 用来处理产生错误的异常状况，并且将错误信息储存起来 与我们在一般程序中用的if一样 本身只当做\u003cc:when\u003e和\u003cc:otherwise\u003e的父标签 \u003cc:choose\u003e的子标签，用来判断条件是否成立 \u003cc:choose\u003e的子标签，接在\u003cc:when\u003e标签后，当\u003cc:when\u003e标签判断为false时被执行 检索一个绝对或相对 URL，然后将其内容暴露给页面 基础迭代标签，接受多种集合类型 根据指定的分隔符来分隔内容并迭代输出 用来给包含或重定向的页面传递参数 重定向至一个新的URL. 使用可选的查询参数来创造一个URL ","date":"2021-08-16","objectID":"/jsp-note/:2:2","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"格式化标签 JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下： \u003c%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %\u003e 标签 描述 使用指定的格式或精度格式化数字 解析一个代表着数字，货币或百分比的字符串 使用指定的风格或模式格式化日期和时间 解析一个代表着日期或时间的字符串 绑定资源 指定地区 绑定资源 指定时区 指定时区 显示资源配置文件信息 设置request的字符编码 ","date":"2021-08-16","objectID":"/jsp-note/:2:3","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"SQL标签 JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： \u003c%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %\u003e 标签 描述 指定数据源 运行SQL查询语句 运行SQL更新语句 将SQL语句中的参数设为指定值 将SQL语句中的日期参数设为指定的java.util.Date 对象值 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 ","date":"2021-08-16","objectID":"/jsp-note/:2:4","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"XML 标签 JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下： \u003c%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %\u003e 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的\u003cTomcat 安装目录\u003e\\lib下: XercesImpl.jar 下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar 下载地址： http://xml.apache.org/xalan-j/index.html 标签 描述 与\u003c%= … \u003e,类似，不过只用于XPath表达式 解析 XML 数据 设置XPath表达式 判断XPath表达式，若为真，则执行本体中的内容，否则跳过本体 迭代XML文档中的节点 \u003cx:when\u003e和\u003cx:otherwise\u003e的父标签 \u003cx:choose\u003e的子标签，用来进行条件判断 \u003cx:choose\u003e的子标签，当\u003cx:when\u003e判断为false时被执行 将XSL转换应用在XML文档中 与\u003cx:transform\u003e共同使用，用于设置XSL样式表 ","date":"2021-08-16","objectID":"/jsp-note/:2:5","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL函数 JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下： \u003c%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %\u003e 函数 描述 fn:contains() 测试输入的字符串是否包含指定的子串 fn:containsIgnoreCase() 测试输入的字符串是否包含指定的子串，大小写不敏感 fn:endsWith() 测试输入的字符串是否以指定的后缀结尾 fn:escapeXml() 跳过可以作为XML标记的字符 fn:indexOf() 返回指定字符串在输入字符串中出现的位置 fn:join() 将数组中的元素合成一个字符串然后输出 fn:length() 返回字符串长度 fn:replace() 将输入字符串中指定的位置替换为指定的字符串然后返回 fn:split() 将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回 fn:startsWith() 测试输入字符串是否以指定的前缀开始 fn:substring() 返回字符串的子集 fn:substringAfter() 返回字符串在指定子串之后的子集 fn:substringBefore() 返回字符串在指定子串之前的子集 fn:toLowerCase() 将字符串中的字符转为小写 fn:toUpperCase() 将字符串中的字符转为大写 fn:trim() 移除首尾的空白符 ","date":"2021-08-16","objectID":"/jsp-note/:2:6","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Total","note"],"content":"JSTL 1.1 与 JSTL 1.2 之间的区别？如何下载 JSTL 1.2? JSTL 1.2 中不要求 standard.jar 包。 您可以在 Maven 中央仓库中找到它们。 http://repo2.maven.org/maven2/javax/servlet/jstl/ http://repo2.maven.org/maven2/taglibs/standard/ 由于JSTL 1.1已经过时，Apache已将其置于存档中。选择jakarta-taglibs-standard-current.zip文件。但是，如果您正在运行Servlet 2.5兼容容器并且web.xml声明为至少Servlet 2.5，那么您应该能够使用新的JSTL 1.2。需要注意的是JSTL 1.2并没有要求standard.jar。 ","date":"2021-08-16","objectID":"/jsp-note/:3:0","tags":["Jsp","Java"],"title":"Jsp笔记","uri":"/jsp-note/"},{"categories":["Operation","note"],"content":"记录Linux进程管理的笔记和相关示例","date":"2021-08-16","objectID":"/linux-proc-mange-note/","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"查看Linux端口占用，并kill掉相关进程 话不多说，本文介绍Linux常规操作：查看端口占用进程，根据PID kill掉相关进程。另外补充：根据程序名查看进程PID。 首先，两条命令，lsof命令和netstat命令。 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:0","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"方式一：lsof命令 1、查看占用端口进程的PID： lsof -i:{端口号} 2、根据PID kill掉相关进程： kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:1","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"方式二：netstat命令 1、查看占用端口进程的PID： netstat -tunlp|grep {port} 2、kill方法如上。 kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:2","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"补充1：根据程序名查看对应的PID 1、用ps命令（zb专用）： ps -ef | grep {programName} kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 查看详细内存占用 ps aux -u root | grep {programName} 2、用pgrep命令： pgrep命令的p表明了这个命令是专门用于进程查询的grep。 pgrep {programName} kill -9 {PID} #直接杀掉 #或 kill -15 {PID} #接收完发送端的数据再杀掉，类似TCP/IP的关闭 ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:3","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Operation","note"],"content":"补充2：根据PID查看对应的进程 ps -aux |grep -v grep|grep {$PID} ","date":"2021-08-16","objectID":"/linux-proc-mange-note/:1:4","tags":["Linux","Progress"],"title":"Linux进程管理笔记","uri":"/linux-proc-mange-note/"},{"categories":["Back"],"content":"记录学习Spring-Integration笔记","date":"2021-07-28","objectID":"/spring-integration/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"一、what ​ 首先，什么是spring-integration？研究之初，对这根管道有些迷惑，这是队列？这个activeMQ有啥区别？待研究了一段时间之后，才发现，spring-integration越来越像曾经做过的esb组件。那么spring-integration到底是什么呢？ ​ 官网给出的解释是，spring-integration是一个功能强大的EIP(Enterprise Integration Patterns)，即企业集成模式。对，spring-integration是一个集大成者。就我自己的理解，集成了众多功能的它，是一种便捷的事件驱动消息框架用来在系统之间做消息传递的。 ","date":"2021-07-28","objectID":"/spring-integration/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"二、why ​ 那么，我们为什么用它呢？spring-integration的官网上，给出了以下说法 ​ spring-integration的目标 提供一个简单的模型来实现复杂的企业集成解决方案 为基于spring的应用添加异步的、消息驱动的行为 让更多的Spring用户来使用他 看这种解释，我的直观感觉是：啥玩意？不懂啊！接着看到spring-integration的原则 组件之间应该是松散的，模块性的易测的 应用框架应该强迫分离业务逻辑和集成逻辑 扩展节点应该有更好的抽象和可以再使用的能力 感觉，这个应该说的是解耦吧。另外看了下其他人的理解，如果你的系统处在各个系统的中间，需要JMS交互，又需要Database/Redis/MongoDB，还需要监听Tcp/UDP等，还有固定的文件转移，分析。还面对着时不时的更改需求的风险。那么，它再适合不过了。 ","date":"2021-07-28","objectID":"/spring-integration/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"三、how ​ 那么，重点来了，如何使用呢？在介绍之前，先简单的介绍几个名词。 ","date":"2021-07-28","objectID":"/spring-integration/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"1.Message ​ Message是它的基础构件和核心，所有的流程都围绕着Message运转，如图所示 Message，就是所说的消息体，用来承载传输的信息用的。Message分为两部分，header和payload。header是头部信息，用来存储传输的一些特性属性参数。payload是用来装载数据的，他可以携带的任何Object对象，放什么都行，随你 。 ","date":"2021-07-28","objectID":"/spring-integration/:3:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"2.MessageChannel ​ 消息管道，生产者生产一个消息到channel，消费者从channel消费一个消息，所以channel可以对消息组件解耦，并且提供一个方便的拦截功能和监控功能。 ​ 对于MessageChannel，有以下几种 （1）.PublishSubscribeChannel ​ 发布订阅式通道形式，多用于消息广播形式，发送给所有已经订阅了的用户。在3.x版本之前，订阅者如果是0，启动会报错或者发送的时候报错。在4.x版本后，订阅者是0，则仍然会返回true。当然，可以配置最小订阅者数量（min-subscribers） （2）.QueueChannel ​ 队列模式通道，最常用的形式。与发布订阅通道不同，此通道实现点对点式的传输方式，管道内部是队列方式，可以设置管道的容量，如果内部的消息已经达到了最大容量，则会阻塞住，直到队列有时间，或者发送的消息被超时处理。 （3）.PriorityChannel ​ 优先级队列通道，我的理解为QueueChannel的升级版，可以无视排队，根据设置的优先级直接插队。（壕无人性） （4）.RendezvousChannel ​ 前方施工，禁止通行！这个是一个强行阻塞的通道，当消息进入通道后，通道禁止通行，直到消息在对方通道receive()后，才能继续使用。 （5）.DirectChannel ​ 最简单的点对点通道方式，一个简单的单线程通道。是spring-integration的默认通道类型 （6）.ExecutorChannel ​ 多线程通道模式，开启多线程执行点对点通道形式。这个通道博主还未研究，不敢多说…….. ","date":"2021-07-28","objectID":"/spring-integration/:3:2","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"3.Message Endpoint ​ 消息的终点，或者我称他为消息节点，在channel你不能操作消息，只能在endpoint操作。对于常用的消息节点，有以下几种 （1）.Transformer ​ 解释者，转换者，翻译者，怎么理解都可以。作用是可以将消息转为你想要的类型。可以将xml形式转换成string类型。 \u003c!-- Filter过滤器 --\u003e \u003cint:channel id=\"filterAChannel\"/\u003e \u003cint:filter input-channel=\"filterAChannel\" output-channel=\"filterBChannel\" expression=\"payload.name.equals('haha')\"/\u003e \u003cint:channel id=\"filterBChannel\"/\u003e \u003cint:service-activator input-channel=\"filterBChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"/\u003e （2）.Filter ​ 过滤器，顾名思义，过滤用的，用来判断一个消息是否应该被传输。用我的理解看，他就是spring-integration里面的if语句。 \u003c!-- transformer转换器 --\u003e \u003cint:channel id=\"transformerInChannel\"/\u003e \u003cint:transformer input-channel=\"transformerInChannel\" output-channel=\"transformerOutChannel\" expression=\"payload.name.toUpperCase() + '- [' + T(java.lang.System).currentTimeMillis() + ']'\"/\u003e \u003cint:channel id=\"transformerOutChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"transformerOutChannel\" ref=\"receiveServiceImpl\" method=\"helloTransformer\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e （3）.Router ​ 路由器，用来管理一个消息应该被发送到哪个channel中。相当于JAVA里面的switch case语句吧。判断条件很多，可是使用header里面的参数具体值（比如header里面有个定义为testRouter的参数，数值为A，那么消息经过路由会发送到判断为A的通道内，后面使用中再详细讲解） （4）.Service Activator ​ 我称他为服务激活器，是一个连接服务实例到消息系统的通用端点。对于服务激活器，可能是因为我理解的不够全面，我总是将他和通道适配器搞混，因为我自己测试发现，激活器和适配器都可以作为一个消息出通道的节点。 （5）.Channel Adapter ​ 通道适配器是将消息通道连接到某个其他系统或传输的端点。通道适配器可以是入站或出站。通常情况下，通道适配器将在消息与从其他系统（文件，HTTP请求，JMS消息等）接收或发送的任何对象或资源之间进行映射。 （6）.Channel Bridge ​ 通道桥梁，用来作为管道之间进行通信使用的，常用情景为：在一个输入管道，将管道的内容发送到另外N个管道输出，配置方式如下 \u003c!-- bridge --\u003e \u003cint:channel id=\"bridgeSendChannel\"/\u003e \u003cint:bridge input-channel=\"bridgeSendChannel\" output-channel=\"bridgeReceiveAChannel\"/\u003e \u003cint:channel id=\"bridgeReceiveAChannel\"/\u003e \u003cint:bridge input-channel=\"bridgeReceiveAChannel\" output-channel=\"bridgeReceiveBChannel\"/\u003e \u003cint:channel id=\"bridgeReceiveBChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"bridgeReceiveBChannel\" expression=\"@receiveServiceImpl.helloBridge(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e ​ 另外还有Splitter（分解器），Aggregator（聚合器）等。对于其他的消息节点，博主还没有做过多研究，就不再次误人子弟了。后续会将未研究到的一一补上。 ","date":"2021-07-28","objectID":"/spring-integration/:3:3","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"4.Channel Interceptor ​ 管道拦截器，能够以非常优雅，非常温柔的方式捕获管道传递之间的节点。对于拦截器，spring-integration给了我们六种节点 ​ 分别是发送前，邮寄后，发送成功后，接收前，接收后，接受成功后。可以分别在不同的节点进行操作。 ","date":"2021-07-28","objectID":"/spring-integration/:3:4","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"四、use（demo地址在本文最后） 下面使用到的Test类为 import lombok.Data; /** * 普通测试dto * @author lin */ @Data public class Test { private String name; private String age; } ","date":"2021-07-28","objectID":"/spring-integration/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（1）普通方式 ​ xml配置，这里配置了一个通道helloWorldChannel，配置了个接收激活点，即接收方的地址为helloServiceImpl里面的hello方法。（其中ref指对应接收的类名，method指类里面接收的方法） \u003c!-- 测试dto模式传输 --\u003e \u003cint:channel id=\"testChannel\"/\u003e \u003cint:service-activator input-channel=\"testChannel\" ref=\"receiveServiceImpl\" method=\"hello\"/\u003e ​ 发送方Service里面 /** * 测试传输dto */ @Override public void testDto() { System.out.println(\"testDto方法\"); Test test = new Test(); test.setName(\"testDto\"); test.setAge(\"18\"); testChannel.send(MessageBuilder.withPayload(test).build()); } ​ 接收方Service里面 @Override public void hello(Test test) { System.out.println(test.getName() + \" \" + test.getAge()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:1","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（2）普通多参数方式 ​ xml配置，这里通过获取payload里面的具体参数来传参的形式 \u003c!-- 测试多参数传递 --\u003e \u003cint:channel id=\"moreParamChannel\"/\u003e \u003cint:service-activator input-channel=\"moreParamChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"/\u003e ​ 发送方Service里面，将所有的参数通过Map形式装载到payload里面 /** * 测试多参数传输 */ @Override public void moreParamm() { System.out.println(\"greetMoreParam方法\"); HashMap\u003cString, String\u003e map = new HashMap(); map.put(\"name\", \"moreParam\"); map.put(\"age\", \"18\"); helloWorldMoreParamChannel.send(MessageBuilder.withPayload(map).build()); } ​ 接收方Service里面 @Override public void helloMoreParam(String name, String age) { System.out.println(name + \" \" + age); } ","date":"2021-07-28","objectID":"/spring-integration/:4:2","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（3）JMS方式 ​ xml配置，这里配置了个MQ，将消息放入mq中进行传递 \u003c!-- 测试Mq配置--\u003e \u003cint:channel id=\"topicChannel\"/\u003e \u003cbean id=\"jmsConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"\u003e \u003cproperty name=\"brokerURL\"\u003e \u003cvalue\u003etcp://127.0.0.1:61616?trace=true\u0026keepAlive=true\u003c/value\u003e \u003c/property\u003e \u003cproperty name=\"useAsyncSend\" value=\"true\"/\u003e \u003c/bean\u003e \u003cint-jms:outbound-channel-adapter channel=\"topicChannel\" destination-name=\"topic.myTopic\" pub-sub-domain=\"true\"/\u003e \u003cint:channel id=\"listenerChannel\"/\u003e \u003cint-jms:message-driven-channel-adapter id=\"messageDrivenAdapter\" channel=\"listenerChannel\"destination-name=\"topic.myTopic\" pub-sub-domain=\"true\"/\u003e \u003cint:service-activator input-channel=\"listenerChannel\" ref=\"messageListenerImpl\" method=\"processMessage\"/\u003e ​ 发送方Service里面 /** * 使用mq进行传输发送方法 */ @Override public void send() { HashMap\u003cString,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"name\",\"MqService\"); map.put(\"age\",\"18\"); topicChannel.send(MessageBuilder.withPayload(map).build()); } ​ 接收方Service里面 public void processMessage(HashMap\u003cString,Object\u003e map) { System.out.println(\"MessageListener::::::Received message: \" + map.toString()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:3","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（4）订阅方式 ​ xml配置，这里配置了两个订阅者，订阅者分别是两个方法 \u003c!-- 测试订阅发布 --\u003e \u003c!--min-subscribers=\"\"参数为预期最小订阅者，如果必须有订阅者，则这里填写最少数；默认值为0--\u003e \u003cint:publish-subscribe-channel id=\"pubsubChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"pubsubChannel\" ref=\"receiveServiceImpl\" method=\"helloReceiveOne\"\u003e \u003c/int:outbound-channel-adapter\u003e \u003cint:outbound-channel-adapter channel=\"pubsubChannel\" ref=\"receiveServiceImpl\" method=\"helloReceiveTwo\"\u003e \u003c/int:outbound-channel-adapter\u003e ​ 发送方Service里面 @Override public void pubsubSend() { Test test = new Test(); test.setName(\"pubsubSend\"); test.setAge(\"18\"); publishSubscribeChannel.send(MessageBuilder.withPayload(test).build()); } ​ 接收方Service里面 @Override public void helloReceiveOne(Test test){ System.out.println(\"One:\"+test.getName()+\" \"+test.getAge()); } @Override public void helloReceiveTwo(Test test){ System.out.println(\"Two:\"+test.getName()+\" \"+test.getAge()); } ","date":"2021-07-28","objectID":"/spring-integration/:4:4","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（5）router方式 ​ xml配置，这里配置了一个入口通道，当消息进入入口后，通过判断header里面的’tsetHeader’参数的值，如果值为A，则进入routerAChannel通道，如果为B则进入routerBChannel通道。进入通道后分别进入两者的接收方法中。其中两种方法用了传递类，和多参数传递的形式。 \u003c!-- 测试路由 --\u003e \u003c!-- 路由入口 --\u003e \u003cint:channel id=\"routingChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003c!-- 路由器 --\u003e \u003cint:header-value-router input-channel=\"routingChannel\" header-name=\"testHeader\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003cint:mapping value=\"A\" channel=\"routerAChannel\"/\u003e \u003cint:mapping value=\"B\" channel=\"routerBChannel\"/\u003e \u003c/int:header-value-router\u003e \u003c!-- 路由出口 --\u003e \u003cint:channel id=\"routerAChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"routerAChannel\" ref=\"receiveServiceImpl\" method=\"helloRouterTest\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e \u003cint:channel id=\"routerBChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:outbound-channel-adapter channel=\"routerBChannel\" expression=\"@receiveServiceImpl.helloRouterMap(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"/\u003e \u003c/int:outbound-channel-adapter\u003e ​ 发送方Service里面 @Override public void routerA(String name, String age) { Test test = new Test(); test.setAge(age); test.setName(name); routingChannel.send(MessageBuilder.withPayload(test).setHeader(\"testHeader\", \"A\").build()); } @Override public void routerB(String name, String age) { HashMap\u003cString,String\u003e map = new HashMap\u003c\u003e(); map.put(\"name\", name); map.put(\"age\", age); routingChannel.send(MessageBuilder.withPayload(map).setHeader(\"testHeader\", \"B\").build()); } ​ 接收方Service里面 @Override public void helloRouterTest(Test test){ System.out.println(\"routerA方法\"); System.out.println(\"helloRouterTest:\"+test.getName()+\" \"+test.getAge()); } @Override public void helloRouterMap(String name,String age){ System.out.println(\"routerB方法\"); System.out.println(\"helloRouterMap:\"+name+\" \"+age); } ","date":"2021-07-28","objectID":"/spring-integration/:4:5","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（6）网关方式 ​ xml配置，在这里面配置了一个接口类，当调用这个接口的方法时，就会进入网关配置的通道 \u003c!-- 网关通道口模式，dto --\u003e \u003cint:channel id=\"getWayChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:gateway service-interface=\"com.lin.integration.service.interfaces.UseGetWaySender\" id=\"helloGetWaySender\" default-request-channel=\"getWayChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"getWayChannel\" ref=\"receiveServiceImpl\" method=\"hello\"\u003e \u003cint:poller fixed-delay=\"0\"\u003e\u003c/int:poller\u003e \u003c/int:outbound-channel-adapter\u003e \u003c!-- 网关通道口模式，多参数传递 --\u003e \u003cint:channel id=\"getWayMoreParamChannel\"\u003e \u003cint:queue/\u003e \u003c/int:channel\u003e \u003cint:gateway service-interface=\"com.lin.integration.service.interfaces.MoreParamSender\" id=\"getWayMoreParamSender\" default-request-channel=\"getWayMoreParamChannel\"/\u003e \u003cint:outbound-channel-adapter channel=\"getWayMoreParamChannel\" expression=\"@receiveServiceImpl.helloMoreParam(payload.name,payload.age)\"\u003e \u003cint:poller fixed-delay=\"0\"\u003e\u003c/int:poller\u003e \u003c/int:outbound-channel-adapter\u003e ​ 网关interface里面 public interface UseGetWaySender { void sendMessage(Test test); } public interface MoreParamSender { void sendMessage(Map map); } ​ 发送方Service里面 /** * 测试网关dto */ @Override public void getWay() { Test test = new Test(); test.setAge(\"18\"); test.setName(\"getWay\"); useGetWaySender.sendMessage(test); } /** * 测试网关多参数 */ @Override public void getWayMoreParam() { HashMap\u003cString, String\u003e map = new HashMap(); map.put(\"name\", \"getWayMoreParam\"); map.put(\"age\", \"18\"); moreParamSender.sendMessage(map); } ","date":"2021-07-28","objectID":"/spring-integration/:4:6","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Back"],"content":"（7）全局拦截器 ​ 拦截器中，将需要拦截的管道进行拦截，拦截之后就会对这个管道的发送端，接收端进行拦截，拦截的接口在上文已经提到过，拦截的配置如下 \u003c!-- 全局拦截器 --\u003e \u003cint:channel-interceptor pattern=\"testInterceptorChannel\" order=\"3\" ref=\"countingChannelInterceptor\"\u003e \u003c/int:channel-interceptor\u003e \u003cint:channel id=\"testInterceptorChannel\"/\u003e \u003cint:service-activator input-channel=\"testInterceptorChannel\" ref=\"receiveServiceImpl\" method=\"hello\"/\u003e ​ 对于近期的spring-integration研究，这些只是“初探”，如此好的一个框架模式，我也将在今后进行深入研究，会将文章进行补充，希望各位对于我文章里面的不足与错误的地方进行批评指出，从而能互相交流研究，多谢。 参考文献： https://docs.spring.io/spring-integration/docs/5.0.4.RELEASE/reference/html/ https://www.aliyun.com/jiaocheng/301276.html https://blog.csdn.net/xiayutai1/article/details/53302652?locationNum=4\u0026fps=1 http://www.iteye.com/topic/744524 https://blog.csdn.net/slivefox/article/details/3740541 https://my.oschina.net/zhzhenqin/blog/86586 http://www.importnew.com/16538.html demo码云地址（10.21更新，增加了java dsl）： https://gitee.com/doubletreelin/spring-integration-mydemo.git ","date":"2021-07-28","objectID":"/spring-integration/:4:7","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"Spring-Integration笔记","uri":"/spring-integration/"},{"categories":["Learning","note"],"content":"转载别人翻译大佬文章，请不要在“微服务”的狂热中迷失自我！","date":"2021-07-28","objectID":"/intellect-in-microservices/","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"引言 2017年是“微服务”疯狂的一年，如同股灾前的狂欢，各种不同行业的技术团队都在宣讲着自己微服务实践的道路。然而大家是否有反思过自己真的在玩“微服务”吗？您真的在“微服务”中受益了吗？还是为了凑这波的热点，而被折腾的疲惫不堪？ 下面的内容是《The Death of Microservice Madness in 2018》一文的翻译，本文很好地阐述了“微服务”在带来诸多优势的同时也对技术团队增加的复杂度所带来的挑战。各个技术团队Leader们，是时候好好思考一下，在这一波的疯狂中，您的团队是否都做到位了？还是又充当了一回“时髦架构师”？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:1:0","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"正文 原文：The Death of Microservice Madness in 2018 链接 微服务在过去几年一直是一个非常热门的话题（附录1）。何为“微服务的疯狂”，举个例子： 众所周知，Netflix在DevOps上的表现非常棒。Netfix可以做微服务。因此：如果我做微服务，我也将非常擅长DevOps。 很多情况下，我们盲目的投入巨大的努力来接入微服务模式，然而往往却很少去考虑接入的成本和收益能否有效的帮我们解决当前我们正面临的痛点。 下面，我将详细描述微服务是什么，以及为什么这种模式这么吸引人，最后再聊一聊一些微服务正面临的一些关键挑战。 如果你正在考虑微服务是否适合你，是否能帮你解决当前面临的问题？那继续往下看，我会用一系列简单的问题来帮你走出你的困惑。这一系列“问题”在文章的最后。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:0","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"什么是微服务，为什么微服务如此受欢迎？ 来来来，老司机带你从基础走一波。一个例子：下面这张图是一个假想的视频共享平台的实现方式，左侧是用一个“整体服务”来实现，右侧是多个微服务的形式来实现： [Monolith与微服务视频共享平台的比较\r两种系统设计的区别在于左侧是一个整体的大而全的服务。右侧是一组小而多，但每个都是一个具体的服务，每个服务都有特定的角色。 当从系统细节层面来绘制图表时，很容易看出微服务的很多潜在的好处，简单从几个方面来说一下： 独立开发：小型独立组件可由小型独立团队构建。一个小组可以改变“Upload”服务，而不会干扰“Transcode”服务，甚至都不需要知道这个服务。了解组件的时间大大减少，开发新功能也更容易。 独立部署：每个单独的组件都可以独立部署。这样可以以更快的速度和更少的风险发布新功能。比如：“Streaming”组件的修复或功能可以部署，而不需要部署其他组件。 独立的可伸缩性：每个组件可以彼此独立地进行缩放。在需求多并发同时需要发布新的版本时，可以放大“Download”组件，以处理增加的负载，而不必扩大每个组件，这使得弹性缩放更加可行并降低了成本。 可重用性：组件实现一个小的，特定的功能。这意味着它们可以更容易地适用于其他系统、服务或产品。“Transcode”组件可以被其他业务部门使用，甚至可以变成一个新的业务，或者为其他组提供Transcode服务。 从细节层面上来看，微服务模型较之于整体模型的好处显而易见。但是问题来了，如果真的是这样的话 - 为什么微服务模式最近几年才流行？我一生都快走完了（尴尬，貌似暴露年龄了），它才出现？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:1","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"如果这微服务这么好，为什么之前大家没有这样做呢？ 这个问题有两种答案。其一是，它强依赖我们最好的技术能力，另一个是最近的技术进步，促使我们能够把它带到一个新的高度。 当我开始写软文来回答这个问题的时候，发现这将会是一个很长的描述，所以从实际的角度出发，我将把它拆成两篇文章，稍后再发表2。第1篇文章，我将跳过一些内容，比如：从单个程序到多个程序的过程，忽略ESB和面向服务的体系结构，组件设计和有限的上下文等等。 感兴趣的朋友可以稍后阅读更多关于journey的信息。尽管，在很多方面我们已经这样做了一段时间，但是随着最近容器技术（特别是Docker）和编排技术（如Kubernetes、Mesos、Consul等等）的普及，从技术的角度来看，微服务模式变得更加可行。 因此，如果我们想要实施微服务的话，我们最好仔细慎重考虑是否真的需要。我们已经看到了高大上的“理论效益”，但值得一提的是，未知的挑战又是什么？ ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:2","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"微服务有什么问题呢？ 微服务如此强大、完美，哪里还会有什么挑战？这是目前我见过的最大的问题。 开发的复杂性增加 对于开发者来说事情会变得更加困难。在开发人员想要在远程工作的情况下，或者可能跨越许多服务的功能的情况下，开发人员必须在他们的机器上运行它们，或者连接到它们。这通常比简单地运行单个程序更复杂。 这个挑战可以通过工具（附录3）得到部分缓解，但随着构成系统的服务数量的增加，开发人员在整个系统运行时面临的挑战也会越来越多。 运维的复杂性增加 对于不开发服务但维护服务的团队来说，潜在的复杂性是一个巨大的挑战。他们不是管理几个正在运行的服务，而是管理数十，数百或数千个正在运行的服务。服务越多，沟通越多，潜在的失败风险就越多。 DevOps的复杂性增加 阅读以上两点，可能会发现运维和开发是分开处理的，尤其是考虑到DevOps作为一种实践的普及（我是DevOps的真爱粉）。DevOps难道不能缓解这一痛点？ 目前面临的挑战是，许多组织仍然依靠独立的开发和运营团队来运行 - 而一些组织则更倾向于采用微服务。 对于已经采用了DevOps的组织来说，这仍然很难。既是开发者又是运维者，已经非常艰难（但是要建立好的软件却很关键），但是也必须了解容器编排系统的细微差别，特别是快速发展的系统是非常困难的。这使我想到了下一点。 没专业知识？别玩微服务 当很多事情都由专家完成时，最终的结果也将是极好的。但想象一下，一个机构或组织使用单一的整体系统并不总是可以很顺利的运行。那做些什么能够来改善并让这些事情变得更好呢？通过增加系统服务的数量？但同时也会增加运行的复杂性。 不可否认，通过有效的自动化、监控和编排等，这一切都可以改善。但挑战很少是技术本身——真正的挑战其实是找到能够有效使用技术的人。恰恰目前这些技能需求非常高，可能很难找到符合你需求的人。 现实世界的系统往往界限不清 在我们用来描述微服务的好处的所有例子中，我们都谈到了独立的组件。但是在很多情况下，组件并不是完全独立的。正所谓“纸上得来终觉浅，绝知此事要躬行”，某些领域可能看起来有限，但是当你陷入冗繁的细节时，你会发现他们比你预期的更具挑战性。 这是事情变得非常复杂的地方。事实上，如果你的边界没有明确定义，那么会发生什么情况呢？即使理论上的服务可以单独部署，你会发现，由于服务之间的相互依赖关系，你必须部署一系列微服务作为一个组服务。 这意味着你需要管理协同工作的版本，这些版本的服务在联调时会经过验证和测试，你实际上没有可独立部署的系统，因为要部署新功能，你需要仔细编排许多服务的同时去部署。 状态的复杂性往往被忽略 在前面的例子中，我提到一个功能部署可能需要同时部署多个版本的许多服务。假设合理的部署技术将缓解这种情况，例如蓝/绿部署（大多数服务编排平台很少原生支持这种功能），或者并行运行多个版本的服务，以及决定使用哪个版本的消费通道。 如果服务是无状态的，这些技术可以缓解大量的挑战。但是无国界的服务非常坦率，容易处理。事实上，如果你有无状态的服务，那么我会倾向于考虑跳过微服务，并考虑使用无服务器模型。 实际上，许多服务需要管理。我们的视频共享平台的一个例子可能是订阅服务。订阅服务的新版本可以以不同形状将数据存储在订阅数据库中。如果你同时运行这两个服务，则一次运行两个模式的系统。如果您进行了蓝／绿部署，而其他服务依赖于新形状中的数据，则必须同时更新这些数据，并且如果订阅服务部署失败并回滚，则可能还需要使用级联回滚。 同样，可能你会说，在NoSQL数据库中，这些架构问题会消失，但事实并非如此。不强制执行模式的数据库无法连接无模式系统——这意味着模式往往是在应用程序级而不是数据库级进行管理的。理解数据结构以及如何流转的根本性问题并不能被消除。 沟通的复杂性往往被忽略 当你建立一个相互依赖的大型服务网络时，可能会有很多的服务间通信。这导致了一些挑战。首先，有很多事情可能会失败。我们必须假设网络call可能会失败，这意味着当一个服务call另一个服务时，它应该至少需要重试几次。现在当一个服务可能调用很多服务时，我们最终会遇到一个更加复杂的情况。 用户上传视频共享服务中的视频。我们可能需要运行upload服务，将数据传递到transcode服务，更新订阅，更新建议等等。所有这些调用都需要一定程度的协调，如果过程中任何部分失败，我们都需要重试。 这个重试逻辑可能难以管理。试图同步做事往往会导致站不住脚，失败点太多。在这种情况下，更可靠的解决方案是使用异步模式来处理通信。这里面临的挑战是异步模式本身往往会使系统具有状态性。如前所述，分布式状态系统和有状态系统很难处理。 当一个微服务系统使用消息队列进行服务内通信时，你基本上需要有一个大的数据库（消息队列或代理）将这些服务组合在一起。同样，虽然起初看起来似乎不是一个挑战，但你懂的——出来混迟早都是要还的。X版本的服务可能会写入某种格式的消息，当发送服务更改发送的消息的详细信息时，依赖于该消息的服务也将需要更新。 当然，可以有许多不同格式的消息处理服务，但这很难管理。现在，在部署新版本的服务时，你可能会有两个不同版本的服务尝试处理来自同一队列的消息，甚至可能是由不同版本的发送服务发送的消息。这可能会导致复杂的边缘情况。为了避免这些边缘情况，仅允许特定版本的消息存在可能更容易，这意味着你需要将一组服务的版本作为一个整体来部署，以确保先前版本的消息被正确地屏蔽。 这再次突出表明，独立部署的想法可能不会像预期的那样顺利。 版本控制可能很难 为了缓解前面提到的挑战，版本控制需要非常谨慎的管理。再说一下，看起来貌似有一种趋势——假设遵循像Semver[4]这样的标准或许将可以解决这个问题。然而事实并非完全如此。虽然Semver是一个合理的使用惯例，但是你仍然需要持续的跟踪那些可以一起工作的服务和API的版本。 这可能会使事情变得非常具有挑战性，并且很多时候可能会让你感到困惑——哪些版本的服务可以一起正常工作。 在软件系统中管理依赖关系是非常困难的，无论是节点模块，Java模块，C库还是其他。当一个实体消费独立组件之间的冲突的挑战是很难处理的。 当依赖关系是静态的时候，这些挑战是很难处理的。虽然可以进行修补、更新、编辑等，但是如果依赖关系本身是实时服务，那么你可能根本无法更新它们——你可能需要运行许多版本（上面已经描述过这些挑战），或者直到整个系统得到修复。 分布式事务 在需要跨操作交易完整性的情况下，微服务可能会非常痛苦。分布式状态很难处理，很多小的单位可能会很难进行编排交易。 试图通过使操作幂等性，提供重试机制等来避免这个问题可能听起来很诱人，而且在很多情况下确实可能起作用。但可能有一些场景，你只需要一个事务失败或成功，而不想它处于中间状态。解决这个问题或者在微服务模型中实现它的代价可能是非常高的。 微服务可能是变相的庞然大物 显然，单独的服务和组件可能是孤立部署的，但是在大多数情况下，你将不得不运行某种编排平台，比如Kubernetes。如果你使用的是托管服务，例如Google的GKE 5或Amazon的EKS 6，则会为你处理管理群集的大量复杂性。 但是，如果你要自己管理集群，那么你正在管理一个庞大而复杂的关键任务系统。尽管单个服务可能具有前面所述的所有优点，但你需要非常小心地管理群集。这个系统的部署可能很难，更新可能很难，故障转移可能也很困难等等。 在许多情况下，总体收益仍然存在，但重要的是不要轻视或低估管理另一个庞大而复杂系统的额外复杂性。托管服务可能会有所帮助，但在很多情况下，这些服务都是新兴的不稳定的（例如，Amazon EKS直到在2017年底才宣布）——谁用谁知道。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:3","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"微服务疯狂之死！ 只有通过仔细考虑才能避免为微服务而微服务的疯狂。为了帮助解决这个问题，我想了一些你可能想问自己的问题，以及可能的答案： 在考虑微服务时问自己的问题 你可以在这里下载PDF副本：microservice-questions.pdf ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:4","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"最后的想法：不要混淆微服务和架构 我故意避免这篇文章中的“a”字。但是，我的朋友Zoltan在校对这篇文章的时候提到了一个很好的观点。 没有微服务体系结构。微服务只是组件的另一种模式或实现，无他。无论是否存在于系统中，都不意味着系统的体系结构得到了解决。 微服务在许多方面与打包和运维的技术过程有关，而不是系统的固有设计。组件的适当边界仍然是工程系统中最重要的挑战之一。 无论你的服务是否在Docker容器中，你总是需要仔细考虑如何将系统放在一起。没有唯一的答案，只有更多的选择。 我希望你看完这篇文章觉得有趣！一如既往，如果你有任何疑问或想法，请在下面评论即可。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:5","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"附录：进一步阅读 以下链接可能有用： Martin Fowler - Bounded Context - 马丁的文章是很棒的，我极力推荐这一篇。 Martin Fowler - 微服务 - 这篇着重介绍微服务的模式。 微服务 - 好还是坏？ - 阅读这篇文章，你将了解BjörnFrantzén对微服务的看法。 什么时候不要做微服务 - 来自于Christian Posta的话题中的优秀帖子 Dave Kerr -微服务整体架构 - 微服务世界中CI / CD和DevOps的实用技巧 - 最近一次关于微服务的devops会议演示。 ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:6","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning","note"],"content":"参考 [https://trends.google.com/trends/explore?date=today 5-y\u0026q=microservice](https://trends.google.com/trends/explore?date=today 5-y\u0026q=microservice) 如果你不想错过这篇文章，你可以订阅RSS源，或者在LinkedIn或Twitter上关注我。 Docker Compose是一个很好的解决方案，Fuge非常聪明，在MiniKube这种情况下，也可以选择在本地运行编排。 https://semver.org/ 谷歌Kubernetes引擎，一个从谷歌云平台诞生Kubernetes托管服务：https://cloud.google.com/kubernetes-engine/ 亚马逊弹性容器服务（已支持Kubernetes），一个从亚马逊Web服务诞生的Kubernetes托管服务：https://aws.amazon.com/eks/ 原文链接：The Death of Microservice Madness in 2018（翻译：王杰） ","date":"2021-07-28","objectID":"/intellect-in-microservices/:2:7","tags":["Microservices"],"title":"请不要在“微服务”的狂热中迷失自我！","uri":"/intellect-in-microservices/"},{"categories":["Learning"],"content":"银行跑批业务的初步理解（批量批量.....流水账）","date":"2021-07-28","objectID":"/run-batch/","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"一、初步理解 白天的柜台交易, 实时的 对帐户进行操作。 晚上 批量 , 比如 一些报表的生成 , 定期储蓄到期的自动转存 , 行内行外业务清分清算 ， 有时还可能赶上利息计算……. 当然 不是所有的数据都是实时操作 , 因此跑批就是为此诞生。 ","date":"2021-07-28","objectID":"/run-batch/:1:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"二、逐渐深入 批量是相对来说，并不一定是在晚上，白天也有批量，主要是完成业务处理的。 批量的核心功能是进行 核算，如总分核对、试算平衡 等，这样保证全行的帐务没有偏差。 一般，为提高交易的 反应时间，一些 对帐清算 等不需要实时入账的功能 也由批量完成；同时，还有一些为了减少柜员工作量和减少高峰时期资源争夺的交易，如待收代付等，也归入批量完成的功能。一些特殊业务，如记息记提等。还有一块批量就是为了统计和管理的需要而出的一些报表。 ","date":"2021-07-28","objectID":"/run-batch/:2:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"三、跑批… 跑批 最主要就是产生总帐, 进行总分核对。或者 是进行大批量交易，如:结息,计提,代收付等(这一步可以在各分布平台做)。或者 是生成报表,导出流水数据等。简单来讲就是每天结算几次，一般是在10点到12点左右。 ","date":"2021-07-28","objectID":"/run-batch/:3:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Learning"],"content":"四、更深入的理解 每天系统需要跑批一次，将所有分行还有办事处的信息录入到总的计算机内，进行分析、运算。然后将第二天需要的事情发布出去（比如卡函的打印，账单的答应） ","date":"2021-07-28","objectID":"/run-batch/:4:0","tags":["Development","Markdown","GitHub","CodeIt","Blog"],"title":"通过银行业务理解 跑批","uri":"/run-batch/"},{"categories":["Back","note"],"content":"记录MyBatis-Plus使用的笔记","date":"2021-07-28","objectID":"/mybatisplus-note/","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 通用BaseMapper使用介绍 详细见快速开始 拥有 Java 开发环境以及相应 IDE 熟悉 Spring Boot 熟悉 Maven 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 其对应的数据库 Schema 脚本如下： DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); 其对应的数据库 Data 脚本如下： DELETE FROM user; INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); ::: danger Question 如果从零开始用 MyBatis-Plus 来实现该表的增删改查我们需要做什么呢？ ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"初始化工程 创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示） ::: tip 可以使用 Spring Initializer 快速初始化一个 Spring Boot 工程 ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"添加依赖 引入 Spring Boot Starter 父工程： \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003espring-latest-version\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e 引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、h2 依赖： Latest Version: \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003eLatest Version\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"配置 在 application.yml 配置文件中添加 H2 数据库的相关配置： # DataSource Configspring:datasource:driver-class-name:org.h2.Driverschema:classpath:db/schema-h2.sqldata:classpath:db/data-h2.sqlurl:jdbc:h2:mem:testusername:rootpassword:test 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： @SpringBootApplication @MapperScan(\"com.baomidou.mybatisplus.samples.quickstart.mapper\") public class Application { public static void main(String[] args) { SpringApplication.run(QuickStartApplication.class, args); } } ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:3","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"编码 编写实体类 User.java（此处使用了 Lombok 简化代码） @Data public class User { private Long id; private String name; private Integer age; private String email; } 编写Mapper类 UserMapper.java public interface UserMapper extends BaseMapper\u003cUser\u003e { } ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:4","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"开始使用 添加测试类，进行功能测试： @SpringBootTest public class SampleTest { @Autowired private UserMapper userMapper; @Test public void testSelect() { System.out.println((\"----- selectAll method test ------\")); List\u003cUser\u003e userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); } } ::: tip UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件 ::: 控制台输出： User(id=1, name=Jone, age=18, email=test1@baomidou.com) User(id=2, name=Jack, age=20, email=test2@baomidou.com) User(id=3, name=Tom, age=28, email=test3@baomidou.com) User(id=4, name=Sandy, age=21, email=test4@baomidou.com) User(id=5, name=Billie, age=24, email=test5@baomidou.com) ::: tip 完整的代码示例请移步：Spring Boot 快速启动示例 | Spring MVC 快速启动示例 ::: ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:5","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 但 MyBatis-Plus 的强大远不止这些功能，想要详细了解 MyBatis-Plus 的强大功能，请继续学习 ","date":"2021-07-28","objectID":"/mybatisplus-note/:1:6","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 通用IService使用介绍 ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"一、引言 MP除了通用的Mapper还有通用的Servcie层，这也减少了相对应的代码工作量，把通用的接口提取到公共。其实按照MP的这种思想，可以自己也实现一些通用的Controller。 由于官网文档没有IService的使用教程，快速开始仅仅有Mapper的教程，故写了本文 ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"二、IService使用 Service Service层需要继承IService，当然实现层也要继承对应的实现类。 /** * \u003cp\u003e * 用户 服务类 * \u003c/p\u003e * * @author IT贱男 * @since 2019-06-14 */ public interface UserService extends IService\u003cUser\u003e { } /** * \u003cp\u003e * 用户 服务实现类 * \u003c/p\u003e * * @author IT贱男 * @since 2019-06-14 */ @Service public class UserServiceImpl extends ServiceImpl\u003cUserMapper, User\u003e implements UserService { } 这里基本的增删改查就不一一演示了，演示几个特殊一点的方法。 getOne()，这个是方法返回结果不止一条则会抛出异常，如果想默认取第一条结果，可以给这方法传第二个参数为false。 @Test public void getOne() { User one = userService.getOne(Wrappers.\u003cUser\u003elambdaQuery().eq(User::getAge, 31),false); System.out.println(one); } saveOrUpdateBatch()，批量新增或者修改方法,判断ID是否存在，如果ID不存在执行新增，如果ID存在先执行查询语句，查询结果为空新增，否则修改。 @Test public void saveOrUpdateBatch() { User user1 = new User(); user1.setName(\"兔子\"); user1.setAge(18); User user2 = new User(); user2.setId(1088250446457389060L); user2.setName(\"乌龟\"); user2.setAge(18); List\u003cUser\u003e users = Arrays.asList(user1, user2); boolean b = userService.saveOrUpdateBatch(users); System.out.println(b); } 接下来说一下基于lambda的相关操作 /** * lombda查询 */ @Test public void lambdaQuery(){ List\u003cUser\u003e list = userService.lambdaQuery().eq(User::getAge, 18).list(); list.forEach(System.out::println); } /** * lombda修改 */ @Test public void lambdaUpdate(){ boolean update = userService.lambdaUpdate().eq(User::getAge, 18).set(User::getAge, 31).update(); System.out.println(update); } /** * lombda删除 */ @Test public void lambdaRemoce(){ boolean remove = userService.lambdaUpdate().eq(User::getAge, 18).remove(); System.out.println(remove); } ","date":"2021-07-28","objectID":"/mybatisplus-note/:2:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"Maybatis-Plus lambdaQuery和mapper中EQ、NE、GT、LT、GE、LE的对时间的用法及详解 ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"1.等于当前时间 taskFlowService.lambdaQuery().eq(TaskFlow::getCreateTime,DateUtil.now()) ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:1","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"2.不等于当前时间 taskFlowService.lambdaQuery().ne(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:2","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"3.大于当前时间 taskFlowService.lambdaQuery().gt(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:3","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"4.小于当前时间 taskFlowService.lambdaQuery().lt(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:4","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"5.大于等于当前时间 taskFlowService.lambdaQuery().ge(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:5","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"6.小于等于当前时间 taskFlowService.lambdaQuery().le(TaskFlow::getCreateTime,DateUtil.now()); ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:6","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"7.2个时间段是否相交 if((!start1.after(end2))\u0026\u0026(!end1.before(start2))){ System.out.println(\"时间重叠\"); } ","date":"2021-07-28","objectID":"/mybatisplus-note/:3:7","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 更新操作示例 @Component public class UserMapperUpdateTest extends MybatisPlusSamplesChapter1ApplicationTests { @Resource private UserMapper userMapper; @Test public void updateById() { User user = new User(); user.setId(1087982257332887553L); user.setEmail(\"gblfy@163.com\"); user.setAge(22); int rows = userMapper.updateById(user); System.out.println(\"影响记录数:\" + rows); } //UPDATE user SET age=?, email=? WHERE id=? /** * 根据 whereEntity 条件，更新记录 * * @param entity 实体对象 (set 条件值,可以为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） */ @Test public void updateByWrapper() { UpdateWrapper\u003cUser\u003e updateWrapper = new UpdateWrapper\u003c\u003e(); updateWrapper.eq(\"name\", \"李艺伟\") .eq(\"age\", 28); User user = new User(); user.setEmail(\"gblfy2@sino.com\"); user.setAge(22); int rows = userMapper.update(user, updateWrapper); System.out.println(\"影响记录数:\" + rows); } //UPDATE user SET age=?, email=? WHERE name = ? AND age = ? /** * 当表中字段很多,只更新少量字段的值（建议使用） */ @Test public void updateByWrapper2() { UpdateWrapper\u003cUser\u003e updateWrapper = new UpdateWrapper\u003c\u003e(); updateWrapper.eq(\"name\", \"李艺伟\") .eq(\"age\", 28) .set(\"age\", 30); int rows = userMapper.update(null, updateWrapper); System.out.println(\"影响记录数:\" + rows); //UPDATE user SET age=?, email=? WHERE name = ? AND age = ? } @Test public void updateByWrapperLambda() { LambdaUpdateWrapper\u003cUser\u003e lambdaUpdateWrapper = Wrappers.\u003cUser\u003elambdaUpdate(); lambdaUpdateWrapper.eq(User::getName, \"李艺伟\") .eq(User::getAge, 28) .set(User::getAge, 30); int rows = userMapper.update(null, lambdaUpdateWrapper); System.out.println(\"影响记录数:\" + rows); } @Test public void updateByWrapperLambdaChain() { boolean sign = new LambdaUpdateChainWrapper\u003cUser\u003e(userMapper) .eq(User::getName, \"李艺伟\") .eq(User::getAge, 22) .set(User::getAge, 30).update(); System.out.println(sign); } //UPDATE user SET age=? WHERE name = ? AND age = ? ","date":"2021-07-28","objectID":"/mybatisplus-note/:4:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 分页查询示例 IPage封装了各种分页的信息，包括不限于总页数，当前页数，总个数，是否有上一页或下一页等 @GetMapping(\"/user/allpage\") public IPage\u003cPrimaryUser\u003e getAllIP() { IPage\u003cPrimaryUser\u003e primaryUserPage = primaryUserMapper.selectPage(new Page\u003c\u003e(1,2),null); return primaryUserPage; } ","date":"2021-07-28","objectID":"/mybatisplus-note/:5:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"MyBatis-Plus 模糊查询及QueryWrapper\u003c\u003e常用条件方法介绍 【通用条件：】 【比较大小： ( =, \u003c\u003e, \u003e, \u003e=, \u003c, \u003c= )】 eq(R column, Object val); // 等价于 =，例: eq(\"name\", \"老王\") ---\u003e name = '老王' ne(R column, Object val); // 等价于 \u003c\u003e，例: ne(\"name\", \"老王\") ---\u003e name \u003c\u003e '老王' gt(R column, Object val); // 等价于 \u003e，例: gt(\"name\", \"老王\") ---\u003e name \u003e '老王' ge(R column, Object val); // 等价于 \u003e=，例: ge(\"name\", \"老王\") ---\u003e name \u003e= '老王' lt(R column, Object val); // 等价于 \u003c，例: lt(\"name\", \"老王\") ---\u003e name \u003c '老王' le(R column, Object val); // 等价于 \u003c=，例: le(\"name\", \"老王\") ---\u003e name \u003c= '老王' 【范围：（between、not between、in、not in）】 between(R column, Object val1, Object val2); // 等价于 between a and b, 例： between(\"age\", 18, 30) ---\u003e age between 18 and 30 notBetween(R column, Object val1, Object val2); // 等价于 not between a and b, 例： notBetween(\"age\", 18, 30) ---\u003e age not between 18 and 30 in(R column, Object... values); // 等价于 字段 IN (v0, v1, ...),例: in(\"age\",{1,2,3}) ---\u003e age in (1,2,3) notIn(R column, Object... values); // 等价于 字段 NOT IN (v0, v1, ...), 例: notIn(\"age\",{1,2,3}) ---\u003e age not in (1,2,3) inSql(R column, Object... values); // 等价于 字段 IN (sql 语句), 例: inSql(\"id\", \"select id from table where id \u003c 3\") ---\u003e id in (select id from table where id \u003c 3) notInSql(R column, Object... values); // 等价于 字段 NOT IN (sql 语句) 【模糊匹配：（like）】 like(R column, Object val); // 等价于 LIKE '%值%'，例: like(\"name\", \"王\") ---\u003e name like '%王%' notLike(R column, Object val); // 等价于 NOT LIKE '%值%'，例: notLike(\"name\", \"王\") ---\u003e name not like '%王%' likeLeft(R column, Object val); // 等价于 LIKE '%值'，例: likeLeft(\"name\", \"王\") ---\u003e name like '%王' likeRight(R column, Object val); // 等价于 LIKE '值%'，例: likeRight(\"name\", \"王\") ---\u003e name like '王%' 【空值比较：（isNull、isNotNull）】 isNull(R column); // 等价于 IS NULL，例: isNull(\"name\") ---\u003e name is null isNotNull(R column); // 等价于 IS NOT NULL，例: isNotNull(\"name\") ---\u003e name is not null 【分组、排序：（group、having、order）】 groupBy(R... columns); // 等价于 GROUP BY 字段, ...， 例: groupBy(\"id\", \"name\") ---\u003e group by id,name orderByAsc(R... columns); // 等价于 ORDER BY 字段, ... ASC， 例: orderByAsc(\"id\", \"name\") ---\u003e order by id ASC,name ASC orderByDesc(R... columns); // 等价于 ORDER BY 字段, ... DESC， 例: orderByDesc(\"id\", \"name\") ---\u003e order by id DESC,name DESC having(String sqlHaving, Object... params); // 等价于 HAVING ( sql语句 )， 例: having(\"sum(age) \u003e {0}\", 11) ---\u003e having sum(age) \u003e 11 【拼接、嵌套 sql：（or、and、nested、apply）】 or(); // 等价于 a or b， 例：eq(\"id\",1).or().eq(\"name\",\"老王\") ---\u003e id = 1 or name = '老王' or(Consumer\u003cParam\u003e consumer); // 等价于 or(a or/and b)，or 嵌套。例: or(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e or (name = '李白' and status \u003c\u003e '活着') and(Consumer\u003cParam\u003e consumer); // 等价于 and(a or/and b)，and 嵌套。例: and(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e and (name = '李白' and status \u003c\u003e '活着') nested(Consumer\u003cParam\u003e consumer); // 等价于 (a or/and b)，普通嵌套。例: nested(i -\u003e i.eq(\"name\", \"李白\").ne(\"status\", \"活着\")) ---\u003e (name = '李白' and status \u003c\u003e '活着') apply(String applySql, Object... params); // 拼接sql（若不使用 params 参数，可能存在 sql 注入），例: apply(\"date_format(dateColumn,'%Y-%m-%d') = {0}\", \"2008-08-08\") ---\u003e date_format(dateColumn,'%Y-%m-%d') = '2008-08-08'\") last(String lastSql); // 无视优化规则直接拼接到 sql 的最后，可能存若在 sql 注入。 exists(String existsSql); // 拼接 exists 语句。例: exists(\"select id from table where age = 1\") ---\u003e exists (select id from table where age = 1) 【QueryWrapper 条件：】 select(String... sqlSelect); // 用于定义需要返回的字段。例： select(\"id\", \"name\", \"age\") ---\u003e select id, name, age select(Predicate\u003cTableFieldInfo\u003e predicate); // Lambda 表达式，过滤需要的字段。 lambda(); // 返回一个 LambdaQueryWrapper 【UpdateWrapper 条件：】 set(String column, Object val); // 用于设置 set 字段值。例: set(\"name\", null) ---\u003e set name = null etSql(String sql); // 用于设置 set 字段值。例: setSql(\"name = '老李头'\") ---\u003e set name = '老李头' lambda(); // 返回一个 LambdaUpdateWrapper 我们直接创建测试类进行展示 QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); 在QueryWrapper\u003c\u003e中，有很多已经编译好的方法，我们可以直接进行调用， @Test void test4(){ QueryWrapper\u003cUser\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.likeRight(\"name\",\"K\"); // .likeRight(\"email\",4); 右查询 左%e%右 List\u003cMap\u003cString,Object\u003e\u003em","date":"2021-07-28","objectID":"/mybatisplus-note/:6:0","tags":["Java","ORM","MyBatisPlus"],"title":"MyBatis-Plus笔记","uri":"/mybatisplus-note/"},{"categories":["Back","note"],"content":"SpringBoot连接使用PostgreSQL数据库","date":"2021-07-28","objectID":"/postgresql-note/","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"一、介绍 此次更新时间：2020-10-28，现在是上班时间，偷更一下。其实使用IDEA的话无需配置Maven什么的，如果你们公司不是强制要求使用Eclipse的话，只需要有个JDK的环境即可，IDEA自带了一个版本的Maven，还是挺新的，目前IDEA最新版2.2.3的版本。我们也不用按照下面这个步骤去下载Spring Initializr，我们在IDEA中新建项目选择到Maven就行了，干净简洁。 目前在Resources目录下的application大多数是使用yml语法了。现在已经太长时间没有接触过 postgresql了，长期使用MySQL，只要数据量在几百万，加加索引，优化SQL工作量还是不大，而且外面的公司还是比较愿意使用MySQL的，我面试别人的时候，也不会问什么乱七八糟的数据库，考虑到公司的业务和生成报表相关，对于SQL优化非常重视，所以数据库只问MySQL。 这篇文章是初次接触 PostgreSQL 时所写，从MyBatis 1.3.2 的版本大家也能看的出来，本来写了个简单的CRUD的DEMO，结果时间太久找不到了。 ","date":"2021-07-28","objectID":"/postgresql-note/:1:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"1、情况说明 在这里我使用SpringBoot配置JPA连接到PostgreSql数据库的。源码也会提供给大家（此文末尾），效果如下 数据库： 运行效果： ","date":"2021-07-28","objectID":"/postgresql-note/:1:1","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"2、安装软件及依赖包 完整搭建SpringBoot及依赖包：https://blog.csdn.net/qq_41647999/article/details/83214100 需要的SpringBoot代码从Spring官网下载：https://start.spring.io/ Mybaits官网：http://www.mybatis.org/mybatis-3/ 最关键的地方是在依赖包那里，需要引用Mybaits和PostgreSql的包。 什么是JPA 和 Mybaits? 两者都是基于JDBC做了连接持久化的两个开源框架，jdbc不陌生吧，每次连接都要创建实例，执行完sql之后还要关闭连接实例，做了持久化之后，就会大大降低IO的开销。JPA不用自己写SQL，mybatis按理来说是需要自己写SQL的（使用通用Mapper或者Mybatis plus 也能不写SQL），各有各的好处。 将下载的项目解压出来。 ","date":"2021-07-28","objectID":"/postgresql-note/:1:2","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"二、配置 如果您的环境配置和我搭建SpringBoot的博文一样的话，用eclipse打开项目。 连接数据库 resources //数据库的地址以及端口号 spring.datasource.url=jdbc:postgresql://localhost:5432/postgres //账号（默认为postgres） spring.datasource.username=postgres //密码 spring.datasource.password=123456ok spring.datasource.driverClassName=org.postgresql.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect spring.jpa.properties.hibernate.hbm2ddl.auto=update yml spring:datasource:# primary:url:jdbc:postgresql://localhost:5432/postgres# url: jdbc:mysql://localhost:3306/springboot?useSSL=false# jdbc-url: jdbc:mysql://localhost:3306/springboot?useSSL=falseusername:postgrespassword:********# username: root# password: ********driver-class-name:org.postgresql.Driver# driver-class-name: com.mysql.cj.jdbc.Driver 其他情况 当然如果您的项目是按照上面的链接搭建的，也可以通过在pom.xml中添加代码，如图。 这里需要注意的一点是，要清楚您使用的Mybaits的依赖包是否符合！ \u003cdependency\u003e \u003cgroupId\u003eorg.postgresql\u003c/groupId\u003e \u003cartifactId\u003epostgresql\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2021-07-28","objectID":"/postgresql-note/:2:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"重置自增序列 分为从43开始、从43开始、从42开始 SELECT setval('myseq', 42); #Next nextval will return 43 SELECT setval('myseq', 42, true); #Same as above SELECT setval('myseq', 42, false); #Next nextval will return 42 alter sequence dataset_id_seq start with 1 ; #只能增大 不能减小 ","date":"2021-07-28","objectID":"/postgresql-note/:3:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back","note"],"content":"schemas问题 PGSql默认的是public,如果用MybatisPlus的内置方法的话,是需要指定连接的CurrentSchema的,否则只会默认查询public,自己写Sql可以在前面加上schemas 但是使用内置方法没有,必须在连接url指定schemsa,否则会报ERROR: relation “item” does not exist表不存在 ","date":"2021-07-28","objectID":"/postgresql-note/:4:0","tags":["DataBase","SQL","PostgreSQL","SpringBoot"],"title":"PostgreSQL相关笔记","uri":"/postgresql-note/"},{"categories":["Back"],"content":"记录Springboot Mybatis Plus解决多数据源的几种办法","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"目标 在开发中经常会遇到一个程序需要调用多个数据库的情况，总得来说分为下面的几种情况： 一个程序会调用不同结构的两个数据库。 读写分离，两个数据结构可能一样高，但是不同的操作针对不同的数据库。 混合情况，既有不同的结构的数据库，也可能存在读写分离的情况。 下面针对第一种情况，提供一个解决方案。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:1:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路1 因为两个数据库的功能和结构不一样，所以可以根据功能和结构把DAO分为两个package。然后再mapperscan中指定不同的package对接不同的数据源，即可达到多个数据源的共存。 配置yml中的数据源设置 spring:datasource:emanage:#SpringBoot 1.xurl:jdbc:mysql://127.0.0.1:3306/emanage?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=true#SpringBoot 2.x# jdbc-url: jdbc:mysql://127.0.0.1:3306/emanage?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=trueusername:rootpassword:******driver-class-name:com.mysql.cj.jdbc.Driverehr:#SpringBoot 1.xurl:jdbc:mysql://127.0.0.1:3306/ehr?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=true#SpringBoot 2.x# jdbc-url: jdbc:mysql://127.0.0.1:3306/ehr?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=true\u0026serverTimezone=UTC\u0026useAffectedRows=trueusername:rootpassword:********driver-class-name:com.mysql.cj.jdbc.Driver 为了不必要的干扰，我把druid数据源的配置部分给删除了。 数据源配置注意事项 多数据源配置的时候，与单数据源不同点在于spring.datasource之后多设置一个数据源名称primary和secondary来区分不同的数据源配置，这个前缀将在后续初始化数据源的时候用到。 数据源连接配置2.x和1.x的配置项是有区别的：2.x使用spring.datasource.secondary.jdbc-url，而1.x版本使用spring.datasource.secondary.url。如果你在配置的时候发生了这个报错java.lang.IllegalArgumentException: jdbcUrl is required with driverClassName.，那么就是这个配置项的问题。 可以看到，不论使用哪一种数据访问框架，对于数据源的配置都是一样的。 建立两个datasource的配置 datasource1的 配置 @Configuration @MapperScan(basePackages = {\"com.emanage.ehr.mapper.emanage\"},sqlSessionTemplateRef = \"sqlTemplate1\") public class DataSourceConfig1 { @Bean(name = \"datasource1\") @ConfigurationProperties(prefix = \"spring.datasource.emanage\") public DruidDataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"sqlFactory1\") public SqlSessionFactory sqlSessionFactory(@Qualifier(\"datasource1\") DruidDataSource dataSource) throws Exception { MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); factoryBean.setMapperLocations(resolver.getResources(\"classpath*:mapper/emanage/**Mapper.xml\")); return factoryBean.getObject(); } @Bean(name = \"sqlTemplate1\") public SqlSessionTemplate sqlSessionTemplate(@Qualifier(\"sqlFactory1\") SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } datasource2的配置 @Configuration @MapperScan(basePackages = {\"com.emanage.ehr.mapper.ehr\"},sqlSessionTemplateRef = \"sqlTemplate2\") public class DataSourceConfig2 { @Bean(name = \"datasource2\") @ConfigurationProperties(prefix = \"spring.datasource.ehr\") public DataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"sqlFactory2\") public SqlSessionFactory sqlSessionFactory(@Qualifier(\"datasource2\") DataSource dataSource) throws Exception { MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); factoryBean.setMapperLocations(resolver.getResources(\"classpath*:mapper/ehr/**Mapper.xml\")); return factoryBean.getObject(); } @Bean(name = \"sqlTemplate2\") public SqlSessionTemplate sqlSessionTemplate(@Qualifier(\"sqlFactory2\") SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } 两个datasource的配置基本上一样。就是建立datasource,sqlsessionFactory，sqlSessionTemplate的注入。然后通过mapperscan来指定具体什么包采用什么数据源。然后再对应包里就和以前单数据源一样操作即可。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"注意事项 如果用myBatis, SqlSessionFactory 部分可以使用SqlSessionFactoryBean来生成。但是如果用mybatis plus一定要用MybatisSqlSessionFactoryBean 来生成SqlSessionFactory。否则会报错 ，无法直接通过BaseMapper去调用查询。 如果要再不同的包中混合上XML进行调用。需要在SqlSessionFactory的配置中设置factoryBean.setMapperLocations(resolver.getResources(“classpath*:mapper/ehr/**Mapper.xml”)); ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"优缺点 优点：简单，通过简单的设置。就可以满足大多数的情况。 缺点：只适合多个数据源的结构完全不一样，通过package可以分来的方式来调用，不能灵活的在一个package下面随心所欲的调用数据源。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:2:2","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路2 总config和各自的config分开，总config用于导入配置数据源，各自config用于Service、Dao层链接数据库使用 总数据源，初始化数据源与MyBatis-Plus配置 完成多数据源的配置信息之后，就来创建个配置类来加载这些配置信息，初始化数据源，以及初始化每个数据源要用的MyBatis配置。 这里我们继续将数据源与框架配置做拆分处理： 单独建一个多数据源的配置类，比如下面这样： @Configuration public class DataSourceConfiguration { @Primary @Bean @ConfigurationProperties(prefix = \"spring.datasource.primary\") public DataSource primaryDataSource() { return DataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.secondary\") public DataSource secondaryDataSource() { return DataSourceBuilder.create().build(); } } 通过@Configuration可以知道这两个数据源分别加载了spring.datasource.primary.*和spring.datasource.secondary.*的配置。@Primary注解指定了主数据源，就是当我们不特别指定哪个数据源的时候，就会使用这个Bean真正差异部分在下面的JPA配置上。 第一个数据源，分别创建两个数据源的MyBatis配置。 Primary数据源的JPA配置： @Configuration @MapperScan( //这里如果单数据源只需写到mysql，会自动寻找mapper，多数据源要写到mapper文件夹否则报错 basePackages = \"cn.edu.hubu.lhy.multiplydatabase.mysql.mapper\", sqlSessionFactoryRef = \"sqlSessionFactoryPrimary\", sqlSessionTemplateRef = \"sqlSessionTemplatePrimary\") public class PrimaryConfig { private DataSource primaryDataSource; public PrimaryConfig(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource) { this.primaryDataSource = primaryDataSource; } @Bean public SqlSessionFactory sqlSessionFactoryPrimary() throws Exception { // SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); MybatisSqlSessionFactoryBean bean = new MybatisSqlSessionFactoryBean(); bean.setDataSource(primaryDataSource); return bean.getObject(); } @Bean public SqlSessionTemplate sqlSessionTemplatePrimary() throws Exception { return new SqlSessionTemplate(sqlSessionFactoryPrimary()); } } 第二个数据源，Secondary数据源的JPA配置： @Configuration @MapperScan( //这里如果单数据源只需写到postgresql，会自动寻找mapper，多数据源要写到mapper文件夹否则报错 basePackages = \"cn.edu.hubu.lhy.multiplydatabase.postgresql.mapper\", sqlSessionFactoryRef = \"sqlSessionFactorySecondary\", sqlSessionTemplateRef = \"sqlSessionTemplateSecondary\") public class SecondaryConfig { private DataSource secondaryDataSource; public SecondaryConfig(@Qualifier(\"secondaryDataSource\") DataSource secondaryDataSource) { this.secondaryDataSource = secondaryDataSource; } @Bean public SqlSessionFactory sqlSessionFactorySecondary() throws Exception { // SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); MybatisSqlSessionFactoryBean bean = new MybatisSqlSessionFactoryBean(); bean.setDataSource(secondaryDataSource); return bean.getObject(); } @Bean public SqlSessionTemplate sqlSessionTemplateSecondary() throws Exception { return new SqlSessionTemplate(sqlSessionFactorySecondary()); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:3:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"注意事项 说明与注意： 配置类上使用@MapperScan注解来指定当前数据源下定义的Entity和Mapper的包路径；另外需要指定sqlSessionFactory和sqlSessionTemplate，这两个具体实现在该配置类中类中初始化。 配置类的构造函数中，通过@Qualifier注解来指定具体要用哪个数据源，其名字对应在DataSourceConfiguration配置类中的数据源定义的函数名。 配置类中定义SqlSessionFactory和SqlSessionTemplate的实现，注意具体使用的数据源正确（如果使用这里的演示代码，只要第二步没问题就不需要修改）。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:3:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"解决思路3 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:0","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"基础的配置 数据源的yml配置和上一结一样，就不在赘述了。 建立一个枚举类来标识两个数据源 public enum DataSourceType { emanage,ehr } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:1","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"建立一个线程和数据源之间的关联类 public class DataBaseContextHolder { private static final ThreadLocal\u003cDataSourceType\u003e contextHolder = new ThreadLocal\u003c\u003e(); public static void setDataSourceType(DataSourceType type) { if(type == null) { throw new NullPointerException(); } contextHolder.set(type); } public static DataSourceType getDataSourceType() { DataSourceType type = contextHolder.get(); if(type == null) { //确定一个默认数据源 return DataSourceType.emanage; } return type; } public static void clearDataSrouceType() { contextHolder.remove(); } } 代码比较简单。就是当我们设置一个Mapper是通过那个数据源去访问数据的时候，把设置的参数保存在contextHolder中，为了处理线程安全，采用ThreadLocal的方式。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:2","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"定义动态数据源 public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DataBaseContextHolder.getDataSourceType(); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:3","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"定义多数据源 @Configuration @MapperScan(\"com.emanage.ehr.mapper\") public class DataSourceConfig { @Autowired private Environment env; @Bean(name = \"datasource1\") @ConfigurationProperties(prefix = \"spring.datasource.emanage\") public DruidDataSource druidDataSource1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"datasource2\") @ConfigurationProperties(prefix = \"spring.datasource.ehr\") public DruidDataSource druidDataSource2() { return DruidDataSourceBuilder.create().build(); } @Bean public DynamicDataSource dynamicDataSource(@Qualifier(\"datasource1\") DruidDataSource ds1, @Qualifier(\"datasource2\") DruidDataSource ds2) { Map\u003cObject, Object\u003e targetDataSource = new HashMap\u003c\u003e(); targetDataSource.put(DataSourceType.emanage, ds1); targetDataSource.put(DataSourceType.ehr, ds2); DynamicDataSource dataSource = new DynamicDataSource(); dataSource.setTargetDataSources(targetDataSource); dataSource.setDefaultTargetDataSource(ds1); return dataSource; } @Bean public SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDataSource) throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); // 指定数据源 bean.setDataSource(dynamicDataSource); bean.setMapperLocations(resolver.getResources(\"classpath*:mapper/**Mapper.xml\")); return bean.getObject(); } @Bean public DataSourceTransactionManager transactionManager(DynamicDataSource dynamicDataSource) { return new DataSourceTransactionManager(dynamicDataSource); } } ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:4","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"使用数据源 在调用mapper之前，在service中执行以下代码，可以灵活的切换数据源。 DataBaseContextHolder.setDataSourceType(DataSourceType.emanage); DataBaseContextHolder.setDataSourceType(DataSourceType.ehr); ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:5","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"优化升级 感觉在sevrice中调用这些代码太过繁琐，可以自己定义两个注解。 public @interface DataSourceEmanage{} public @interface DataSourceEHr{} 然后建立一个aop类让在有些注解的mapper类执行之前，先执行相应的数据源切换。 @Aspect @Component public class DataSourceAop { @Before(\"@annotation(com.example.demo3.config.DataSourceEmanage)\") public void setEmanageDataSource() { DataBaseContextHolder.setDataSourceType(DataSourceType.emanage); } @Before(\"@annotation(com.example.demo3.config.DataSourceEhr)\") public void setEhrDataSource() { DataBaseContextHolder.setDataSourceType(DataSourceType.ehr); } } 只需要在mapper对应的方法上面设置注解，就可以很灵活的实现不同的方法调用不同的数据源。 ","date":"2021-07-28","objectID":"/mybatisplus-multy-datasource/:4:6","tags":["Java","Springboot","MybatisPlus","DataBase","SQL","Mysql"],"title":"Springboot Mybatis Plus解决多数据源","uri":"/mybatisplus-multy-datasource/"},{"categories":["Back"],"content":"记录简单安装PostgreSQL(绿色版)","date":"2021-07-28","objectID":"/postgresql-install/","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"〇.概况 目前版本是PostgreSQL 9.6，它经过以下平台认证： 32位Windows Windows 7,8和10 Windows 2008 Server 64位Windows Windows 7,8和10 Windows 2012 Windows 2008 在windows下可以用安装版安装，也可以用免安装版安装，这里主要是演示免安装版 ","date":"2021-07-28","objectID":"/postgresql-install/:1:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"一.下载 选择免安装版zip版： https://www.postgresql.org/download/windows/ 然后选择你的系统环境，我的是win10 64位所以我选的如下图： https://www.enterprisedb.com/download-postgresql-binaries 点击链接下载 ","date":"2021-07-28","objectID":"/postgresql-install/:2:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"二.安装 1）把下好的zip包解压到你想放的地方： 我放的地方是 D:\\tools\\postgres\\pgsql 文件夹下 2）新建一个data文件夹，用来存放数据 3）初始化数据库 进入bin目录并执行初始化命令 initdb.exe -D D:\\tools\\postgres\\pgsql\\data -E UTF-8 --locale=chs -U postgres -W 注： -D ：指定数据库簇的存储目录D:\\tools\\postgres\\pgsql\\data -E ：指定DB的超级用户的用户名postgres –locale：关于区域设置（chinese-simplified-china） -U ：默认编码格式chs -W ：为超级用户指定密码的提示 期间会提示你输入你要配置的postgres用户的密码！ 4）启动数据库 pg_ctl -D D:\\tools\\postgres\\pgsql\\data -l logfile start 这样就可以简单的安装成功了 5）接下来用它自带的客户端访问： 点击bin目录下的pgAdmin3.exe文件 然后配置下就可以访问 6）注册为系统服务 现在可以用但是不是系统服务，每次启动都得手动起，比较麻烦所以接下来注册为系统服务 在bin目录下用管理员身份执行命令： pg_ctl register -N PostgreSQL -D D:\\tools\\postgres\\pgsql\\data 然后查看是否成功： 查看已经注册的服务：win+R在弹出的运行框中，输入：services.msc，如下： 这样就算在windows下简单安装postgresql成功了！ ","date":"2021-07-28","objectID":"/postgresql-install/:3:0","tags":["DataBase","SQL","PostgreSQL","Install"],"title":"简单安装PostgreSQL","uri":"/postgresql-install/"},{"categories":["Back"],"content":"记录new与newInstance()的区别","date":"2021-07-28","objectID":"/new-newinstance-diff/","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"简单测试 String st = (String)Class.forName(\"java.lang.String\").newInstance(); String st1=new String(); boolean bl=st.getClass()==st1.getClass(); System.out.println(bl); 返回为ture 这两种方法得到的结果是一样的 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:1:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"原因 分析下原因，第一种方法是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化 可以分解开 Class cla=Class.forName(\"java.lang.String\");//初始化 Object obj=cla.newInstance();//实例化为object类 String str=(String)obj;//向下转换回子类 //但 Class.forName();//有它自己的用法 通过 String str =\"\"； Class c = Class.forName(str); c.newInstance(); 可以动态的创建对象 Object st = (String)Class.forName(\"java.lang.String\").newInstance(); 这个方法返回的是一个类，可以强制转换成各种子类 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:2:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"主要作用 因此可以改变强制转换的类型与forName()的参数来创建不同类型的对象，只要他们是Object的子类 在连接数据库时，发现还可以这样用Class.forName(driver); 查找资料了解到，这个方法在使用时，JVM会查找并加载指定的类，也就是说JVM会执行该类的静态代码段 而使用new时，这个类可以没有被加载(是可以不是一定) 测试使用Driver dri=new Driver();一样加载了类 然后测试了下构造方法的调用 class ceshi{ int a=0; public ceshi(){ System.out.println(a); } } Class aaa=Class.forName(\"ceshi\");//没有调用构造方法 aaa.newInstance();//调用 new ceshi();//调用 如果想要调用构造方法，需要调用newInstance.forname()会导致类被初始化，newInstance()才会实例化，而new()初始化+实例化 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:3:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"总结 初始化和实例化的区别，另开一篇再做研究 相比较，new的语句简单，可以在创建时加入参数调用构造函数，而newInstance()把创建对象步骤分开，使得更灵活 ","date":"2021-07-28","objectID":"/new-newinstance-diff/:4:0","tags":["ShellScript","Markdown","GitHub","CodeIt","Blog"],"title":"new与newInstance()的区别","uri":"/new-newinstance-diff/"},{"categories":["Back"],"content":"记录PO,BO,VO和POJO的区别","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"PO persistent object 持久对象 1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。 2 ．在hibernate持久化框架中与insert/delet操作密切相关。 3 ．PO中不应该包含任何对数据库的操作。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:1:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"POJO plain ordinary java object 无规则简单java对象 一个中间对象，可以转化为PO、DTO、VO。 1 ．POJO持久化之后==〉PO （在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。） 2 ．POJO传输过程中==〉DTO 3 ．POJO用作表示层==〉VO PO 和VO都应该属于它。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:2:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"BO business object 业务对象 业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。 建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 这样处理业务逻辑时，我们就可以针对BO去处理。 封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。 关于BO主要有三种概念 1 、只包含业务对象的属性； 2 、只包含业务方法； 3 、两者都包含。 在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:3:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"VO value object 值对象 / view object 表现层对象 1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象。 2 ．可以和表对应，也可以不，这根据业务的需要。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:4:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"DTO（TO） Data Transfer Object 数据传输对象 1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。 2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:5:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"DAO data access object数据访问对象 1 ．主要用来封装对DB的访问（CRUD操作）。 2 ．通过接收Business层的数据，把POJO持久化为PO。 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:6:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"简易的关系图 ","date":"2021-07-28","objectID":"/po-bo-vo-pojo-diff/:7:0","tags":["Java","ORM","Objects","Difference"],"title":"PO,BO,VO和POJO的区别","uri":"/po-bo-vo-pojo-diff/"},{"categories":["Back"],"content":"Windows安装驱动报错：无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","date":"2021-07-27","objectID":"/driver-install-kernel32-error/","tags":["Windows","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"报错 今天，在电脑刚安装完Windows 7系统后准备打驱动，结果所有驱动都无法安装，报错**“无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll”** ","date":"2021-07-27","objectID":"/driver-install-kernel32-error/:1:0","tags":["Windows","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"解决方法 去微软官网下载 windows6.1-kb2533623-x64.msu 补丁程序，安装完成后重启计算机即可，微软官网下载链接已挂，这里提供下载链接： 链接：https://pan.baidu.com/s/1B-TbJ7oJsAgZ_Zg_oBxbYQ 提取码：60j5 ","date":"2021-07-27","objectID":"/driver-install-kernel32-error/:2:0","tags":["Windows","Driver","Error"],"title":"Windows 无法定位程序输入点 AddDllDirectory 于动态链接库 KERNEL32.dll","uri":"/driver-install-kernel32-error/"},{"categories":["Back"],"content":"解决lombok时Mybaties报错 nested exception is org.apache.ibatis.executor.result.ResultMapException","date":"2021-07-27","objectID":"/mybatis-nested-exception/","tags":["Java","ORM","Mybaties","Error"],"title":"Mybaties报错 nested exception is org.apache.ibatis.executor","uri":"/mybatis-nested-exception/"},{"categories":["Back"],"content":"报错 nested exception is org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column ‘user_name’ from result set. Cause: java.lang.NumberFormatException: For input string: “shenzhenhytzb” 原因：使用lambok时使用了@Builder注解导致没有无参构造器，添加注解@NoArgsConstructor @AllArgsConstructor ","date":"2021-07-27","objectID":"/mybatis-nested-exception/:1:0","tags":["Java","ORM","Mybaties","Error"],"title":"Mybaties报错 nested exception is org.apache.ibatis.executor","uri":"/mybatis-nested-exception/"},{"categories":["Back"],"content":"SpringBoot2.0 报错：“jdbcUrl is required with driverClassName.”解决办法！","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"报错 Springboot 升级到2.0之后发现配置多数据源的时候报错 “jdbcUrl is required with driverClassName.”或者Cause: java.lang.IllegalArgumentException: dataSource or dataSourceClassName or jdbcUrl is required.] with root cause ","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/:1:0","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"原因 主要原因是在1.0 配置数据源的过程中主要是写成：spring.datasource.url 和spring.datasource.driverClassName。 而在2.0升级之后需要变更成：spring.datasource.jdbc-url和spring.datasource.driver-class-name即可解决！ ","date":"2021-07-27","objectID":"/springboot2.x-jdbcurl-required-driverclassname-error/:2:0","tags":["Java","SpringBoot","JDBC","Error"],"title":"SpringBoot2.0 报错：“is required with driverClassName.”","uri":"/springboot2.x-jdbcurl-required-driverclassname-error/"},{"categories":["Back"],"content":"使用mybatisplus出现的问题 com.baomidou.mybatisplus.extension.service.IService cannot be inherited with different type arguments: com.sha.code.model.SysRoleEntity and com.sha.code.model.SysRoleMenuEntity","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back"],"content":"报错原因 'com.baomidou.mybatisplus.extension.service.IService' cannot be inherited with different type arguments: 'com.sha.code.model.SysRoleEntity' and 'com.sha.code.model.SysRoleMenuEntity' Error:(17, 8) java: 无法使用以下不同的参数继承com.baomidou.mybatisplus.extension.service.IService: \u003ccom.sha.code.model.SysRoleMenuEntity\u003e 和 \u003ccom.sha.code.model.SysRoleEntity\u003e ","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/:1:0","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back"],"content":"解决方式 SysRoleService.java中IService中参数写错 修改前 public interface SysRoleService extends IService\u003cSysRoleMenuEntity\u003e { } 修改后 public interface SysRoleService extends IService\u003cSysRoleEntity\u003e { } ","date":"2021-07-27","objectID":"/mybatisplus-cannot-inherited-diff-type-arguments-error/:2:0","tags":["Java","ORM","MybatisPlus","Error"],"title":"使用MybatisPlus出现的问题 Cannot be inherited with different type arguments","uri":"/mybatisplus-cannot-inherited-diff-type-arguments-error/"},{"categories":["Back","note"],"content":"记录学习Mybatis的笔记","date":"2021-07-27","objectID":"/mybatis-note/","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"MapperScan注解包含多个包 单个包 @MapperScan(\"com.mysiteforme.admin.dao\") 多个包 @MapperScan({\"com.mysiteforme.admin.dao\",\"com.zipon.tpf.dao\"}) ","date":"2021-07-27","objectID":"/mybatis-note/:1:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back","note"],"content":"实体类忽略映射字段 @TableField(exist = false)//：表示该属性不为数据库表字段，但又是必须使用的。 @TableField(exist = true)//：表示该属性为数据库表字段。 Mybatis-Plus 插件有这个功能，可以看一下 @TableName//：数据库表相关 @TableId//：表主键标识 @TableField//：表字段标识 @TableLogic//：表字段逻辑处理注解（逻辑删除） ","date":"2021-07-27","objectID":"/mybatis-note/:2:0","tags":["Java","ORM","Mybatis"],"title":"Mybatis笔记","uri":"/mybatis-note/"},{"categories":["Back"],"content":"SpringBoot中@Mapper和@Repository的区别","date":"2021-07-27","objectID":"/springboot-mapper-repository-diff/","tags":["Java","Spring","SpringBoot","Difference"],"title":"@Mapper和@Repository的区别","uri":"/springboot-mapper-repository-diff/"},{"categories":["Back"],"content":"前言 　@Mapper和 @Repository是常用的两个注解，两者都是用在dao上，两者功能差不多，容易混淆，有必要清楚其细微区别； ","date":"2021-07-27","objectID":"/springboot-mapper-repository-diff/:1:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"@Mapper和@Repository的区别","uri":"/springboot-mapper-repository-diff/"},{"categories":["Back"],"content":"区别　 　@Repository需要在Spring中配置扫描地址，然后生成Dao层的Bean才能被注入到Service层中：如下，在启动类中配置扫描地址： @SpringBootApplication //添加启动类注解 @MapperScan(\"com.anson.dao\") //配置mapper扫描地址 public class application { public static void main(String[] args) { SpringApplication.run(application.class,args); } } 　@Mapper不需要配置扫描地址，通过xml里面的namespace里面的接口地址，生成了Bean后注入到Service层中。 　也就是@Repository多了一个配置扫描地址的步骤； ","date":"2021-07-27","objectID":"/springboot-mapper-repository-diff/:2:0","tags":["Java","Spring","SpringBoot","Difference"],"title":"@Mapper和@Repository的区别","uri":"/springboot-mapper-repository-diff/"},{"categories":["Back","note"],"content":"记录一些Spring学习的笔记","date":"2021-07-27","objectID":"/spring-annotation-note/","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"注解@service(“service”)括号中的service有什么用 service 是有用的相当于 xml配置中得bean id = service 也可以不指定 不指定相当于 bean id = com. service.service 就是这个类的全限定名,表示给当前类命名一个别名，方便注入到其他需要用到的类中；不加的话，默认别名就是当前类名，但是首字母小写 ","date":"2021-07-27","objectID":"/spring-annotation-note/:1:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"Spring注解@Component、@Repository、@Service、@Controller区别 所以，如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释，而用 @Component 对那些比较中立的类进行注释。 在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 Spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息： Java代码 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cbeansxmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\" \u003e \u003ccontext:component-scan base-package=”com.eric.spring”\u003e \u003c/beans\u003e \\6. 其中base-package为需要扫描的包（含所有子包） @Service用于标注业务层组件，@Controller用于标注控制层组件（如struts中的action）,@Repository用于标注数据访问组件，即DAO组件，而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService{ } Repository public class VentorDaoImpl implements iVentorDao { } getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的， 如果想改变，可以使用 @Service(“beanName”) @Scope(“prototype”)来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { } 注入方式： 把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到action中，注 入时不要new 这个注入的类，因为spring会自动注入，如果手动再new的话会出现错误，然后属性加上 @Autowired后不需要getter()和setter()方法，Spring也会自动注入。至于更具体的内容，等对注入的方式更 加熟练后会做个完整的例子上来。 注解： 在 spring的配置文件里面只需要加上\u003ccontext:annotation-config/\u003e和\u003ccontext:component-scanbase-package=\"需要实现注入的类所在包\"/\u003e， 可以使用base-package=\"*“表示全部的类。 \u003c context:component-scan base-package=”com.eric.spring”\u003e 其中base-package为需要扫描的包（含所有子包） 在接口前面标上@Autowired和@Qualifier注释使得接口可以被容器注入，当接口存在两个实现类的时候必须指定其中一个来注入， 使用实现类首字母小写的字符串来注入，如： @Autowired @Qualifier(\"chinese\") private Man man; 否则可以省略，只写@Autowired。 @Service服务层组件，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean， 例如Chinese实例化为chinese，如果需要自己改名字则:@Service(\"你自己改的bean名\")。 @Controller用于标注控制层组件(如struts中的action) @Repository持久层组件，用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } getBean 的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”) 这样来指定，这种 bean默认是单例的，如果想改变，可以使用@Service(“beanName”)``@Scope(“prototype”)来改变。 可以使用以下方式指定初始化方法和销毁方法（方法名任意）： @PostConstruct public void init() { } @PreDestroy public void destory() { } ","date":"2021-07-27","objectID":"/spring-annotation-note/:2:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back","note"],"content":"Spring中@Autowired注解、@Resource注解的区别 Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 \\1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 \\2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 \\3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 \\4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Autowired 与@Resource的区别： 1、 @Autowired与@Resource都可以用来装配bean.都可以写在字段上,或写在setter方法上。 2、 @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下： 1 @Autowired() @Qualifier(\"baseDao\") 2 private BaseDao baseDao; 3、@Resource（这个注解属于J2EE的），默认安装名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 1 @Resource(name=\"baseDao\") 2 private BaseDao baseDao; 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。 ","date":"2021-07-27","objectID":"/spring-annotation-note/:3:0","tags":["Spring","Annotation"],"title":"Spring学习笔记","uri":"/spring-annotation-note/"},{"categories":["Back"],"content":"Idea中SpringBoot无法自动装配Could not autowire. No beans of 'UserMapper' type found. more...","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"报错 如上图 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:1:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案一 在自动转配的注解后面添加(required=false) @Autowired(required=false) public UserMapper userMapper; 当我们在使用@Autowired注解的时候，默认required=true,表示注入的时候bean必须存在，否则注入失败。 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:2:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案二 效果如图所示 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:3:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Back"],"content":"方案三 在UserMapper上面添加 @Component(value =“userMapper”) 虽然能解决红线的问题， @Component注解，表明当需要创建类时，这个被注解的类是一个候选类。相当于类交给Spring管理，重新起个名字叫userMapper，但是并不推荐这样做。 在SpringBoot中集成MyBatis，可以在mapper接口上添加@Mapper注解，将mapper注入到Spring。但是如果每一给mapper都添加@mapper注解会很麻烦！！！ 这时可以使用@MapperScan注解来扫描包。 所以，一般在Application上面标注了MapperScan，如图所示。 ","date":"2021-07-27","objectID":"/springboot-could-not-autowire-error/:4:0","tags":["Java","SpringBoot","Autowire","Error"],"title":"Could not autowire. No beans of 'UserMapper' type found. more...","uri":"/springboot-could-not-autowire-error/"},{"categories":["Software"],"content":"记录解决VSCode打开会一直黑屏无法使用的办法","date":"2021-07-27","objectID":"/vscode-open-black-error/","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Software"],"content":"问题 VSCode打开会一直黑屏无法使用。 我是黑屏 黑屏结束 ","date":"2021-07-27","objectID":"/vscode-open-black-error/:1:0","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Software"],"content":"解决 右击VSCode打开属性窗口并在【兼容性】标签页内勾上【以兼容模式运行这个程序】。 打次打开VSCode它就恢复正常了。 ","date":"2021-07-27","objectID":"/vscode-open-black-error/:2:0","tags":["Environment","Editer","IDE","VisualStudioCode","Error"],"title":"VSCode打开黑屏无法使用","uri":"/vscode-open-black-error/"},{"categories":["Back","note"],"content":"记录幂等性的笔记","date":"2021-07-27","objectID":"/idempotency-note/","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"幂等性 **就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。 在增删改查4个操作中，尤为注意就是增加或者修改，查询对于结果是不会有改变的，删除只会进行一次，用户多次点击产生的结果一样，修改在大多场景下结果一样，增加在重复提交的场景下会出现。 ","date":"2021-07-27","objectID":"/idempotency-note/:1:0","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"那么如何设计接口才能做到幂等呢？ ","date":"2021-07-27","objectID":"/idempotency-note/:2:0","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"方法一 单次支付请求，也就是直接支付了，不需要额外的数据库操作了，这个时候发起异步请求创建一个唯一的ticketId，就是门票，这张门票只能使用一次就作废，具体步骤如下： 1、异步请求获取门票 2、调用支付，传入门票 3、根据门票ID查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在，支付扣款，保存结果 4、返回结果到客户端 如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的. ","date":"2021-07-27","objectID":"/idempotency-note/:2:1","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"方法二 分布式环境下各个服务相互调用 这边就要举例我们的系统了，我们支付的时候先要扣款，然后更新订单，这个地方就涉及到了订单服务以及支付服务了。用户调用支付，扣款成功后，更新对应订单状态，然后再保存流水。而在这个地方就没必要使用门票ticketId了，因为会比较闲的麻烦（支付状态：未支付，已支付） 步骤： 1、查询订单支付状态 2、如果已经支付，直接返回结果 3、如果未支付，则支付扣款并且保存流水 4、返回支付结果 如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的 对于做过支付的朋友，幂等也可以称之为冲正，保证客户端与服务端的交易一致性，避免多次扣款。 以下为接口文档对于幂等的描述，通过请求id号来判断是否为同一个请求。 ","date":"2021-07-27","objectID":"/idempotency-note/:2:2","tags":["Data","DataBase"],"title":"什么是幂等性","uri":"/idempotency-note/"},{"categories":["Back","note"],"content":"记录@EnableTransactionManagement的使用的笔记","date":"2021-07-20","objectID":"/spring-boot-enabletransactionmanagement/","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/spring-boot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"介绍 Spring Boot 使用事务非常简单，首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可。 关于事务管理器，不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果你添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager 实例。如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。 ","date":"2021-07-20","objectID":"/spring-boot-enabletransactionmanagement/:1:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/spring-boot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"方法 你可以在启动类中添加如下方法，Debug测试，就能知道自动注入的是 PlatformTransactionManager 接口的哪个实现类。 @EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 \u003ctx:annotation-driven /\u003e @SpringBootApplication public class ProfiledemoApplication { @Bean public Object testBean(PlatformTransactionManager platformTransactionManager){ System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\" + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 这些SpringBoot为我们自动做了，这些对我们并不透明，如果你项目做的比较大，添加的持久化依赖比较多，我们还是会选择人为的指定使用哪个事务管理器。 代码如下： @EnableTransactionManagement @SpringBootApplication public class ProfiledemoApplication { // 其中 dataSource 框架会自动为我们注入 @Bean public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean public Object testBean(PlatformTransactionManager platformTransactionManager) { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\" + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 在Spring容器中，我们手工注解@Bean 将被优先加载，框架不会重新实例化其他的 PlatformTransactionManager 实现类。 然后在Service中，被 @Transactional 注解的方法，将支持事务。如果注解在类上，则整个类的所有方法都默认支持事务。 对于同一个工程中存在多个事务管理器要怎么处理，请看下面的实例，具体说明请看代码中的注释。 @EnableTransactionManagement // 开启注解事务管理，等同于xml配置文件中的 \u003ctx:annotation-driven /\u003e @SpringBootApplication public class ProfiledemoApplication implements TransactionManagementConfigurer { @Resource(name=\"txManager2\") private PlatformTransactionManager txManager2; // 创建事务管理器1 @Bean(name = \"txManager1\") public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } // 创建事务管理器2 @Bean(name = \"txManager2\") public PlatformTransactionManager txManager2(EntityManagerFactory factory) { return new JpaTransactionManager(factory); } // 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器 @Override public PlatformTransactionManager annotationDrivenTransactionManager() { return txManager2; } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } @Component public class DevSendMessage implements SendMessage { // 使用value具体指定使用哪个事务管理器 @Transactional(value=\"txManager1\") @Override public void send() { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003eDev Send()\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\"); send2(); } // 在存在多个事务管理器的情况下，如果使用value具体指定 // 则默认使用方法 annotationDrivenTransactionManager() 返回的事务管理器 @Transactional public void send2() { System.out.println(\"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003eDev Send2()\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\"); } } ","date":"2021-07-20","objectID":"/spring-boot-enabletransactionmanagement/:2:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/spring-boot-enabletransactionmanagement/"},{"categories":["Back","note"],"content":"注 如果Spring容器中存在多个 PlatformTransactionManager 实例，并且没有实现接口 TransactionManagementConfigurer 指定默认值，在我们在方法上使用注解 @Transactional 的时候，就必须要用value指定，如果不指定，则会抛出异常。 对于系统需要提供默认事务管理的情况下，实现接口 TransactionManagementConfigurer 指定。 对有的系统，为了避免不必要的问题，在业务中必须要明确指定 @Transactional 的 value 值的情况下。不建议实现接口 TransactionManagementConfigurer，这样控制台会明确抛出异常，开发人员就不会忘记主动指定。 ","date":"2021-07-20","objectID":"/spring-boot-enabletransactionmanagement/:3:0","tags":["Java","SpringBoot","Transaction"],"title":"@EnableTransactionManagement","uri":"/spring-boot-enabletransactionmanagement/"},{"categories":["Back"],"content":"记录@ApiImplicitParams、@ApiImplicitParam使用的笔记","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Back"],"content":"@ApiImplicitParam 作用在方法上，表示单独的请求参数 参数： \\1. name ：参数名。 \\2. value ： 参数的具体意义，作用。 \\3. required ： 参数是否必填。 \\4. dataType ：参数的数据类型。 \\5. paramType ：查询参数类型，这里有几种形式： 类型 作用 path 以地址的形式提交数据 query 直接跟参数完成自动映射赋值 body 以流的形式提交 仅支持POST header 参数在request headers 里边提交 form 以form表单的形式提交 仅支持POST 在这里我被坑过一次：当我发POST请求的时候，当时接受的整个参数，不论我用body还是query，后台都会报Body Missing错误。这个参数和SpringMvc中的@RequestBody冲突，索性我就去掉了paramType，对接口测试并没有影响。 ","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/:1:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Back"],"content":"@ApiImplicitParams 用于方法，包含多个 @ApiImplicitParam： 例： @ApiOperation(\"查询测试\") @GetMapping(\"select\") //@ApiImplicitParam(name=\"name\",value=\"用户名\",dataType=\"String\", paramType = \"query\") @ApiImplicitParams({ @ApiImplicitParam(name=\"name\",value=\"用户名\",dataType=\"string\", paramType = \"query\",example=\"xingguo\"), @ApiImplicitParam(name=\"id\",value=\"用户id\",dataType=\"long\", paramType = \"query\")}) public void select(){ } ","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/:2:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Back"],"content":"paramType 示例详解 path @RequestMapping(value = \"/findById1/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE) @PathVariable(name = \"id\") Long id body @ApiImplicitParams({ @ApiImplicitParam(paramType = \"body\", dataType = \"MessageParam\", name = \"param\", value = \"信息参数\", required = true) }) @RequestMapping(value = \"/findById3\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) @RequestBody MessageParam param 提交的参数是这个对象的一个json，然后会自动解析到对应的字段上去，也可以通过流的形式接收当前的请求数据，但是这个和上面的接收方式仅能使用一个（用@RequestBody之后流就会关闭了） header @ApiImplicitParams({ @ApiImplicitParam(paramType = \"header\", dataType = \"Long\", name = \"id\", value = \"信息id\", required = true) }) String idstr = request.getHeader(\"id\"); if (StringUtils.isNumeric(idstr)) { id = Long.parseLong(idstr); } Form @ApiImplicitParams({ @ApiImplicitParam(paramType = \"form\", dataType = \"Long\", name = \"id\", value = \"信息id\", required = true) }) @RequestMapping(value = \"/findById5\", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE) ","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/:3:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Back"],"content":"总结 (1)对于@ApiImplicitParam的paramType：query、form域中的值需要使用@RequestParam获取， header域中的值需要使用@RequestHeader来获取，path域中的值需要使用@PathVariable来获取，body域中的值使用@RequestBody来获取，否则可能出错；而且如果paramType是body，name就不能是body，否则有问题，与官方文档中的“If paramType is “body”, the name should be “body\"不符。 @ApiImplicitParams：用在方法上包含一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 paramType：参数放在哪个地方 header–\u003e请求参数的获取：@RequestHeader query–\u003e请求参数的获取：@RequestParam path（用于restful接口）–\u003e请求参数的获取：@PathVariable body（不常用） form（不常用） name：参数名 dataType：参数类型 required：参数是否必须传 value：参数的意思 defaultValue：参数的默认值 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如\"请求参数没填好” response：抛出异常的类 以上这些就是最常用的几个注解了。 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import io.swagger.annotations.ApiResponse; import io.swagger.annotations.ApiResponses; @RestController @RequestMapping(\"/user\") @Api(\"userController相关api\") public class UserController { @Autowired private UserService userService; @ApiOperation(\"获取用户信息\") @ApiImplicitParams({ @ApiImplicitParam(paramType=\"header\",name=\"username\",dataType=\"String\",required=true,value=\"用户的姓名\",defaultValue=\"zhaojigang\"), @ApiImplicitParam(paramType=\"query\",name=\"password\",dataType=\"String\",required=true,value=\"用户的密码\",defaultValue=\"wangna\") }) @ApiResponses({ @ApiResponse(code=400,message=\"请求参数没填好\"), @ApiResponse(code=404,message=\"请求路径没有或页面跳转路径不对\") }) @RequestMapping(value=\"/getUser\",method=RequestMethod.GET) public User getUser(@RequestHeader(\"username\") String username, @RequestParam(\"password\") String password) { return userService.getUser(username,password); } } ","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/:4:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Back"],"content":"测试 启动服务，浏览器输入\"http://localhost:8080/swagger-ui.html\" 在上面案例中我们可以知道如果在request域中我们使用reques.getHeader()和使用@RequestHeader注解作用是一样的，其它内容类似。 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如”请求参数没填好” response：抛出异常的类 @ApiOperation(\"获取用户信息\") @ApiImplicitParams({@ApiImplicitParam(paramType=\"header\",name=\"name\",dataType=\"String\",required=true,value=\"用户的姓名\",defaultValue=\"zhaojigang\"), @ApiImplicitParam(paramType=\"query\",name=\"pwd\",dataType=\"String\",required=true,value=\"用户的密码\",defaultValue=\"wangna\") }) @ApiResponses({ @ApiResponse(code=400,message=\"请求参数没填好\"), @ApiResponse(code=404,message=\"请求路径没有或页面跳转路径不对\") }) @RequestMapping(value=\"/getUser\",method= RequestMethod.GET) public User getUser(@RequestHeader(\"name\") String name,@RequestParam(\"pwd\") String pwd) { System.out.println(name); System.out.println(pwd); return userRepository.getUserByNameAndPwd(name,pwd); } ","date":"2021-07-20","objectID":"/spring-cloud-apiimplicitparams/:5:0","tags":["Java","SpringBoot","Swagger","Controller","Params"],"title":"@ApiImplicitParams、@ApiImplicitParam的使用","uri":"/spring-cloud-apiimplicitparams/"},{"categories":["Learning","note"],"content":"转载一篇Martin Flower写的微服务中文翻译文章","date":"2021-07-20","objectID":"/microservices-martin-flower/","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"声明 本文转载于《Microservices（微服务）》——Martin Flower 原文是 Martin Flower 于 2014 年 3 月 25 日写的《Microservices》。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:1:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务 “微服务架构（Microservice Architecture）”一词在过去几年里广泛的传播，它用于描述一种设计应用程序的特别方式，作为一套独立可部署的服务。目前，这种架构方式还没有准确的定义，但是在围绕业务能力的组织、自动部署（automated deployment）、端智能（intelligence in the endpoints）、语言和数据的分散控制，却有着某种共同的特征。 “微服务（Microservices）”——只不过在满大街充斥的软件架构中的一新名词而已。尽管我们非常鄙视这样的东西，但是这玩意所描述的软件风格，越来越引起我们的注意。在过去几年里，我们发现越来越多的项目开始使用这种风格，以至于我们身边的同事在构建企业级应用时，把它理所当然的认为这是一种默认开发形式。然而，很不幸，微服务风格是什么，应该怎么开发，关于这样的理论描述却很难找到。 简而言之，微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API。这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。 在开始介绍微服务风格（microservice style）前，比较一下整体风格（monolithic style）是很有帮助的：一个完整应用程序（monolithic application）构建成一个单独的单元。企业级应用通常被构建成三个主要部分：客户端用户界面（由运行在客户机器上的浏览器的 HTML 页面、Javascript 组成）、数据库（由许多的表构成一个通用的、相互关联的数据管理系统）、服务端应用。服务端应用处理 HTTP 请求，执行领域逻辑（domain logic），检索并更新数据库中的数据，使用适当的 HTML 视图发送给浏览器。服务端应用是完整的 ，是一个单独的的逻辑执行。任何对系统的改变都涉及到重新构建和部署一个新版本的服务端应用程序。 这样的整体服务（monolithic server）是一种构建系统很自然的方式。虽然你可以利用开发语基础特性把应用程序划分成类、函数、命名空间，但所有你处理请求的逻辑都运行在一个单独的进程中。在某些场景中，开发者可以在的笔计本上开发、测试应用，然后利用部署通道来保证经过正常测试的变更，发布到产品中。你也可以使用横向扩展，通过负载均衡将多个应用部署到多台服务器上。 整体应用程序（Monolithic applications）相当成功，但是越来越多的人感觉到有点不妥，特别是在云中部署时。变更发布周期被绑定了——只是变更应用程序的一小部分，却要求整个重新构建和部署。随着时间的推移，很难再保持一个好的模块化结构，使得一个模块的变更很难不影响到其它模块。扩展就需要整个应用程序的扩展，而不能进行部分扩展。 图 1 整理架构与微服务架构\r这导致了微服务架构风格（microservice architectural style）的出现：把应用程序构建为一套服务。事实是，服务可以独立部署和扩展，每个服务提供了一个坚实的模块边界，甚至不同的服务可以用不同的编程语言编写。它们可以被不同的团队管理。 **我们必须说，微服务风格不是什么新东西，它至少可以追溯到 Unix 的设计原则。**但是并没有太多人考虑微服务架构，如果他们用了，那么很多软件都会更好。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:2:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务风格的特性 微服务风格并没有一个正式的定义，但我们可以尝试描述一下微服务风格所具有的共同特点。并不是所有的微服务风格都要具有所有的特性，但我们期望常见的微服务都应该有这些特性。我们的意图是尝试描述我们工作中或者在其它我们了解的组件中所理解的微服务。特别是，我们不依赖于那些已经明确过的定义。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"组件化（Componentization ）与服务（Services） 自从我们开始软件行业以来，一直希望由组件构建系统，就像我们在物理世界所看到的一样。在过去的几十年里，我们已经看到了公共库的大量简编取得了相当的进步，这些库是大部分语言平台的一部分。 当我们谈论组件时，可能会陷入一个困境——什么是组件。我们的定义是，组件（component）是一个可独立替换和升级的软件单元。 微服务架构（Microservice architectures）会使用库（libraries），但组件化软件的主要方式是把它拆分成服务。我们把库（libraries）定义为组件，这些组件被链接到程序，并通过内存中函数调用（in-memory function calls）来调用，而服务（services ）是进程外组件（out-of-process components），他们利用某个机制通信，比如 WebService 请求，或远程过程调用（remote procedure call）。组件和服务在很多面向对象编程中是不同的概念。 把服务当成组件（而不是组件库）的一个主要原因是，服务可以独立部署。如果你的应用程序是由一个单独进程中的很多库组成，那么对任何一个组件的改变都将导致必须重新部署整个应用程序。但是如果你把应用程序拆分成很多服务，那你只需要重新部署那个改变的服务。当然，这也不是绝对的，有些服务会改变导致协调的服务接口，但是一个好的微服务架构的目标就是通过在服务契约（service contracts）中解耦服务的边界和进化机制来避免这些。 另一个考虑是，把服务当组件将拥有更清晰的组件接口。大多数开发语言都没有一个良好的机制来定义一个发布的接口（Published Interface）。发布的接口是指一个类向外公开的成员，比如 Java 中的声明为 Public 的成员，C# 中声明为非 Internal 的成员。通常只有在文档和规范中会说明，这是为了让避免客户端破坏组件的封装性，阻止组件间紧耦合。服务通过使用公开远程调用机制可以很容易避免这些。 像这样使用服务也有不足之处。远程调用比进制内调用更消耗资源，因此远程 API 需要粗粒度（coarser-grained），但这会比较难使用。如果你需要调整组件间的职责分配，当跨越进程边界时，这样做将会很难。 一个可能是，我们看到，服务可以映射到运行时进程（runtime processes）上，但也只是一个可能。服务可以由多个进程组成，它们会同时开发和部署，例如一个应用程序进程和一个只能由这个服务使用的数据库。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:1","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"围绕业务功能的组织 当寻找把一个大的应用程序拆分成小的部分时，通常管理都会集中在技术层面，UI团队、服务端业务逻辑团队和数据库团队。当使用这种标准对团队进行划分时，甚至小小的更变都将导致跨团队项目协作，从而消耗时间和预算审批。一个高效的团队会针对这种情况进行改善，两权相害取其轻。业务逻辑无处不在。实践中，这就是 Conway’s Law 的一个例子。 设计一个系统的任何组织（广义上）都会产生这样一种设计，其结构是组织交流结构的复制。 ——Melvyn Conway, 1967 Melvyn Conway 的意识是，像下图所展示的，设计一个系统时，将人员划分为 UI 团队，中间件团队，DBA 团队，那么相应地，软件系统也就会自然地被划分为 UI 界面，中间件系统，数据库。 图 2 实践中的 Conway's Law\r微服务（microservice ）的划分方法不同，它倾向围绕业务功能的组织来分割服务。这些服务实现商业领域的软件，包括用户界面，持久化存储，任何的外部协作。因此，团队是跨职能的（cross-functional），包含开发过程所要求的所有技能：用户体验（user-experience）、数据库（database）和项目管理（project management）。 图 3 通过团队边界强调服务边界\rwww.comparethemarket.com就是采用这种组织形式。跨职能的团队同时负责构建和运营每个产品，每个产品被分割成许多单个的服务，这些服务通过消息总线（Message Bus）通信。 大型的整体应用程序（monolithic applications）也可以按照业务功能进行模块化（modularized），尽管这样情况不常见。当然，我们可以敦促一个构建整体应用程序（monolithic application ）的大型团队，按业务线来分割自己。我们已经看到的主要问题是，这种组件形式会导致很多的依赖。如果整体应用程序（monolithic applications）跨越很多模块边界（modular boundaries ），那么对于团队的每个成员短期内修复它们是很困难的。此外，我们发现，模块化需要大量的强制规范。服务组件所要求的必需的更明确的分离使得保持团队边界清晰更加容易。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:2","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"产品不是项目 大部分的软件开发者都使用这样的项目模式：至力于提供一些被认为是完整的软件。交付一个他们认为完成的软件。软件移交给运维组织，然后，解散构建软件的团队。 微服务（Microservice ）的支持者认为这种做法是不可取的，并提议团队应该负责产品的整个生命周期。Amazon 理念是“你构建，你运维（you build, you run it）”，要求开发团队对软件产品的整个生命周期负责。这要求开发者每天都关注他们的软件运行如何，增加更用户的联系，同时承担一些售后支持。 产品的理念，跟业务能力联系起来。不是着眼于完成一套功能的软件，而是有一个持续的关系，是如何能够帮助软件及其用户提升业务能力。 为什么相同的方法不能用在整体应用程序（monolithic applications），但更小的服务粒度能够使创建服务的开发者与使用者之间的个人联系更容易。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:3","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"强化终端及弱化通道 当构建不同的进程间通信机制的时候，我们发现有许多的产品和方法能够把更加有效方法强加入的通信机制中。比如企业服务总线（ESB），这样的产品提供更有效的方式改进通信过程中的路由、编码、传输、以及业务处理规则。 微服务倾向于做如下的选择：强化终端及弱化通道。微服务的应用致力松耦合和高内聚：采用单独的业务逻辑，表现的更像经典Unix意义上的过滤器一样，接受请求、处理业务逻辑、返回响应。它们更喜欢简单的REST风格，而不是复杂的协议，如WS或者BPEL或者集中式框架。 有两种协议最经常被使用到：包含资源API的HTTP的请求-响应和轻量级消息通信协议。最为重要的建议为： 善于利用网络，而不是限制（Be of the web, not behind the web）。 ——Ian Robinson 微服务团队采用这样的原则和规范：基于互联网（广义上，包含Unix系统）构建系统。这样经常使用的资源几乎不用什么的代价就可以被开发者或者运行商缓存。 第二种做法是通过轻量级消息总线来发布消息。这种的通信协议非常的单一（单一到只负责消息路由），像RabbitMQ或者ZeroMQ这样的简单的实现甚至像可靠的异步机制都没提供，以至于需要依赖产生或者消费消息的终端或者服务来处理这类问题。 在整体工风格中，组件在进程内执行，进程间的消息通信通常通过调用方法或者回调函数。从整体式风格到微服务框架最大的问题在于通信方式的变更。从内存内部原始的调用变成远程调用，产生的大量的不可靠通信。因此，你需要把粗粒度的方法成更加细粒度的通信。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:4","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"分散治理 集中治理的一种好处是在单一平台上进行标准化。经验表明这种趋势的好处在缩小，因为并不是所有的问题都相同，而且解决方案并不是万能的。我们更加倾向于采用适当的工具解决适当的问题，整体式的应用在一定程度上比多语言环境更有优势，但也适合所有的情况。 把整体式框架中的组件，拆分成不同的服务，我们在构建它们时有更多的选择。你想用Node.js去开发报表页面吗？做吧。用C++来构建时时性要求高的组件？很好。你想以在不同类型的数据库中切换，来提高组件的读取性能？我们现在有技术手段来实现它了。 当然，你是可以做更多的选择，但也不意味的你就可以这样做，因为你的系统使用这种方式进行侵害意味着你已经有的决定。 采用微服务的团队更喜欢不同的标准。他们不会把这些标准写在纸上，而是喜欢这样的思想：开发有用的工具来解决开发者遇到的相似的问题。这些工具通常从实现中成长起来，并进行的广泛范围内分享，当然，它们有时，并不一定，会采用开源模式。现在开源的做法也变得越来越普遍，git或者github成为了它们事实上的版本控制系统。 Netfix就是这样的一个组织，它是非常好的一个例子。分享有用的、尤其是经过实践的代码库激励着其它的开发着也使用相似的方式来解决相似的问题，当然，也保留着根据需要使用不同的方法的权力。共享库更关注于数据存储、进程内通信以及我们接下来做讨论到的自动化等这些问题上。 微服务社区中，开销问题特别引人注意。这并不是说，社区不认为服务交互的价值。相反，正是因为发现到它的价值。这使得他们在寻找各种方法来解决它们。如Tolearant Reader和Consumer-Driven Contracts这样的设计模式就经常被微服务使用。这些模式解决了独立服务在交互过程中的消耗问题。使用Consumer-Driven Contracts增加了你的信心，并实现了快速的反馈机制。事实上，我们知道澳大利亚的一个团队致力使用Consumer-Drvien Contracts开发新的服务。他们使用简单的工程，帮助他们定义服务的接口。使得在新服务的代码开始编写之前，这些接口就成为自动化构建的一个部分。构建出来的服务，只需要指出这些接口适用的范围，一个优雅的方法避免了新软件中的’YAGNI ‘困境。这些技术和工具在使用过程中完善，通过减少服务间的耦合，限制了集中式管理的需求。 也许分散治理普及于亚马逊“编译它，运维它”的理念。团队为他们开发的软件负全部责任，也包含7*24小时的运行。全责任的方式并不常见，但是我们确实发现越来越多的公司在他们的团队中所推广。Netfix是另外一个接受这种理念的组件。每天凌晨3点被闹钟吵醒，因为你非常的关注写的代码质量。这在传统的集中式治理中这是一样多么不思议的事情呀。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:5","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"分散数据管理 对数据的分散管理有多种不同的表现形式。最为抽象层次，它意味着不同系统中的通用概念是不同的。这带来的觉问题是大型的跨系统整合时，用户使用不同的售后支持将得到不同的促销信息。这种情况叫做并没有给用户显示所有的促销手段。不同的语法确实存在相同的词义或者（更差）相同的词义。 应用之间这个问题很普遍，但应用内部这个问题也存在，特别是当应用拆分成不同的组件时。对待这个问题非常有用的方式为Bounded Context的领域驱动设计。DDD把复杂的领域拆分成不同上下文边界以及它们之间的关系。这样的过程对于整体架构和微服务框架都很有用，但是服务间存在着明显的关系，帮助我们对上下文边界进行区分，同时也像我们在业务功能中谈到的，强行拆分。 当对概念模式下决心进行分散管理时，微服务也决定着分散数据管理。当整体式的应用使用单一逻辑数据库对数据持久化时，企业通常选择在应用的范围内使用一个数据库，这些决定也受厂商的商业权限模式驱动。微服务让每个服务管理自己的数据库：无论是相同数据库的不同实例，或者是不同的数据库系统。这种方法叫Polyglot Persistence。你可以把这种方法用在整体架构中，但是它更常见于微服务架构中。 图 4 Polyglot Persistence\r微服务音分散数据现任意味着管理数据更新。处理数据更新的常用方法是使用事务来保证不同的资源修改数据库的一致性。这种方法通常在整体架构中使用。 使用事务是因为它能够帮助处理一至性问题，但对时间的消耗是严重的，这给跨服务操作带来难题。分布式事务非常难以实施，因此微服务架构强调服务间事务的协调，并清楚的认识一致性只能是最终一致性以及通过补偿运算处理问题。 选择处理不一致问题对于开发团队来说是新的挑战，但是也是一个常见的业务实践模式。通常业务上允许一定的不一致以满足快速响应的需求，但同时也采用一些恢复的进程来处理这种错误。当业务上处理强一致性消耗比处理错误的消耗少时，这种付出是值的的。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:6","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"基础设施自动化 基础设施自动化技术在过去几年中得到了长足的发展：云计算，特别是AWS的发展，减少了构建、发布、运维微服务的复杂性。 许多使用微服务架构的产品或者系统，它们的团队拥有丰富的持集部署以及它的前任持续集成的经验。团队使用这种方式构建软件致使更广泛的依赖基础设施自动化技术。下图说明这种构建的流程： 图 5 基本的构建流程\r尽管这不是介绍自动部署的文章，但我们也打算介绍一下它的主要特征。我们希望我们的软件应该这样方便的工作，因此我们需要更多的自动化测试。流程中工作的软件改进意味着我们能自动的部署到各种新的环境中。 整体风格的应用相当开心的在各种环境中构建、测试、发布。事实证明，一旦你打算投资一条整体架构应用自动化的的生产线，那么你会发现发布更多的应用似乎非不那么的可怕。记住，CD（持续部署）的一个目标在于让发布变得无趣，因此无论是一个还是三个应用，它都一样的无趣。 另一个方面，我们发现使用微服务的团队更加依赖于基础设施的自动化。相比之下，在整体架构也微服务架构中，尽管发布的场景不同，但发布工作的无趣并没有多大的区别。 图 6 模块化部署的区别 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:7","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"容错性设计 使用服务作为组件的一个结果在于应用需要有能容忍服务的故障的设计。任务服务可能因为供应商的不可靠而故障，客户端需要尽可能的优化这种场景的响应。跟整体构架相比，这是一个缺点，因为它带来的额外的复杂性。这将让微服务团队时刻的想到服务故障的情况下用户的体验。Netflix 的Simian Army可以为每个应用的服务及数据中心提供日常故障检测和恢复。 这种产品中的自动化测试可以让大部分的运维团队正常的上下班。这并不意味着整体构架的应用没有这么精巧的监控配置，只是在我们的经验中它并不常见。 由于服务可以随时故障，快速故障检测，乃至，自动恢复变更非常重要。微服务应用把实时的监控放在应用的各个阶段中，检测构架元素（每秒数据库的接收的请求数）和业务相关的指标（把分钟接收的定单数）。监控系统可以提供一种早期故障告警系统，让开发团队跟进并调查。 对于微服务框架来说，这相当重要，因为微服务相互的通信可能导致紧急意外行为。许多专家车称赞这种紧急事件的价值，但事实是这种紧急行为有时是灾难。监控是至关重要的，它能快速发现这种紧急不良行为，让我们迅速修复它。 整体架构，跟微服务一样，在构建时是通明的，实情上，它们就是这样子的。它们不同之处在于，你需要清楚的认识到不同进程间运行的服务是不相关的。库对于同一进程是透明的，也因此不那么重要了。 微服务团队期望清楚的监控和记录每个服务的配置，比如使用仪表盘显示上/下线状态、各种运维和业务相关的指标。对断路器（circuit breaker）状态、目前的吞吐量和时延细节，我们也会经常遇到。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:8","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"设计改进 微服务实践者，通常有不断改进设计的背景，他们把服务分解成进一步的工具。这些工具可以让应用开发者在不改变速度情况下，控制都他们的应用的需求变更。变更控制不意味首减少变更，而是使用适当的方式和工具，让它更加频繁，至少，很好让它变得可控。 不论如何，当你试图软件系统拆分成组件时，你将面临着如何拆分的问题。那么我们的决定拆分我们应用的原则是什么呢？首要的因素，组件可以被独立替换和更新的，这意味着我们寻找的关键在于，我们要想象着重写一个组件而不影响它们之前的协作关系。事实上，许多的微服务小组给它进一步的预期：服务应该能够报废的，而不是要长久的发展的。 Guardian网站就是这方面的一个优秀的例子，它初期被设计和构建成一个整体架构，但它已经向微服务的发展了。整体构架仍然是它网站的核心，但是他们使用微服务来增加那些使用整体架构API的新特性。这种方法增加这些临时的特性非常方便，比如运动新闻的特稿。这样站点的一个部分可以使用快速的开发语言迅速整合起来，当它过时后可以一次性移除。我们发现一家金融机构用相似的方法增加新的市场营销活动，数周或者几个月后把它撤销。 可代替是模块化开发中的一个特例，它是用模块来应对需要变更的。你希望让变更是相同模块，相同周期中进行变化而已。系统的某些很小做变更部分，也应该放在不同的服务中，这样它们更容易让它们消亡。如果你发现两个服务一直重复的变更时，这就是一个要合并它们的信号了。 把组件改成服务，增加了细化发布计划的一个机会。整体构架的任务变更需要整个应用的完整的构建和发布。然而，使用微服务，你只需要发布你要修改的服务就可以了。这将简化和加速你的发布周期。缺点是你需要为一个变更服务发布可能中断用户的体验而担心。传统的集成方法是使用版本来处理这些问题，但是微服务版本仅是最后的通告手段。我们需要在设计服务时尽可能的容忍供应商的变更，以避免提供多个版本。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:3:9","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务是未来吗？ 我们写这篇文章的主要目的在于解释微服务的主要思想和原则。但是发时间做这事的时候，我们清醒的认识到微服务构架风格是一个非常重要的想法：一个值得企业应用中认真考虑的东西。我们最近使用这种风格构建了几个系统，认识那些也使用和喜欢这种方法的爱好者。 我们认识的使用这种方式的先行者，包含亚马逊、Netflix、The Guardian、The UK Government Digital Service、realestate.com.au、Forward和comparethemarket.com。2013看的巡回会议充满了向正在想成为微服务一分子的公司，包含Travis CI。此外，大量的组件正在从事我们认为是微服务的事，只是没有使用微服务的名字而已。（通常，它们被打上SOA的标签，尽管，我们认为SOA有许多不同的地方。） 尽管有这些积极的经验，然后，我们也不急于确认微服务是未来软件架构方向。至今为止，我们的经验与整体风格的应该中相比出来的是有优势的，但是我们意识知这样的事实，我们并没有足够的时间来证明我们的论证。 你所使用的架构通常是你开发出来后，使用的几年的实际成果。我们看到这些工程是在一个优秀的团队，带着对模块化的强烈追求，使用在过去几年中已经衰退的整体架构构建出来的。许多人相信，这种衰退不太可能与微服务有关，因为服务边界是清晰的并且很难再完善的。然而，当我们还没看到足够多的系统运行足够长时间时，我们不能肯定微服务构架是成熟的。 当然，还有原因就是，有人期望微服务构架不够成熟。在组件化方面的任何努力，其成功都依赖于软件如何拆分成适合的组件。指出组件化的准确边界应该在那，这是非常困难的。改良设计要承认边界的权益困境和因此带来的易于重构的重要性。但是当你的组件是被远程通信的服务时，重构比进程内的库又要困难的多。服务边界上的代码迁移是困难的，任务接口的变更需要参与者的共同协作，向后兼容的层次需要被增加，测试也变更更加复杂。 另一个问题在于，如果组件并没有清晰的划分，你的工作的复杂性将从组件内部转向组件间的关系。做这事不仅要围绕着复杂，它也要面对着不清晰和更难控制的地方。很容易想到，当你在一个小的、简单的组件内找东西，总比在没有关系的混乱的服务间要容易。 最后，团队技能也是重要的因素。新的技术倾向于被掌握更多的技能的团队使用。但是掌握多技能的团队中使用的技巧在较少技能的团队中并不是必需的。我们发现大量的少技能的团队构建混乱的整合构架，但是它要发时间去证明使用微服务在这种情况下会发生什么。一个糟糕的团队通常开发糟糕的系统：很难说，微服务在这种情况下是否能帮助它们，还是破坏它们。 一个理性的争议在于，我们听说，你不应该从微服务构架开始做。最好从整体构架开发，做模块化开发，然后当整体构架出现问题是再把模块化拆分成服务。（尽管这种建议不是好主意，因为一个好的进程内接口并不是一个好的服务接口。） 因此我们持这种谨慎的乐观。到目前为止，我们还没有足够认识，关于微构架能否被大范围的推广。我们不能肯定的说，我们要终结什么，但是软件开发的挑战在于你只能在不完整的信息中决定你目前要处理的问题。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:4:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"其它 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务系统多大？ 尽管“微服务”一词在架构风格中越来越流行，它的名字很不辛让人关注它的服务大小，以及对“微”这个组成的争议。在我们与微服务实践者的谈话中，我们发现了服务的大小范围。被报道的最大团队遵循亚马逊Tow Pizaa团队理念（比如，一个团队吃两个比萨就可以了。），这意味着不超过20号（一打）人。我们发现最小配置是半打的团队支撑起一打的服务。 这也引发这样的考虑：规模为一个服务一打人到一个服务一个人的团队打上微服务的标签。此刻我们认为，它们是一样的，但是随着对这种风格的深入研究，也存在我们改变我们的想法的可能。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:1","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"微服务与SOA 当前我们谈到微服务时，通常会问，这是不是我们20年前讨论的面向服务架构（SOA）。这是一个很好的观点，因为微服务风格也SOA所提倡的一些优势非常相似。尽管如此，问题在于SOA意味的太多不同的东西了，因此通常时候我们谈的所谓“SOA”时，它与我们谈论的风格不一至，因为它通常是指在整体风格应用中的ESB。 此外，我们发现面向服务的风格是这么的拙劣：从试图使用ESB隐藏复杂性， 到使用多年才认识到发费数百美元却没产生任务价值这样的失败，到集中治理模式抑制变更。而且这些问题往往很难发现。 可以肯定的时，微服务社区中使用的许多的技术都开发者是从大型机构的整合服务经验中发展来的。Tolerant Reader模式就是这样的一个例子。由于互联网的发展，利用简单的协议这种方法，让它从这些经验传达的出来。这是从已经很复杂的集中式标准中的一种反模式，坦白的说，真让人惊叹。（无论何时，当你需要用一个服务来管理你的所有的服务，你就知道这很麻烦。） SOA的这种常见行为让微服务的提倡者拒绝打上SOA的标签，尽管有人认为微服务是从SOA中发展而来的，或许面向服务是对的。无论如何，事实上SOA表达这么多的含义，它给一个团队清醒的认识到这种构架风格就已经值的了。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:2","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"多语言，多选择 JVM做为一个平台，它的增长就是一个平台中运行多语言的最大的例子。过去二十年中，它通常做为更高层次语言的壳，以达到更高层次的抽象。比如，研究它的内部结构，、使用低级的语言写更高效的代码。尽管如此，许多整体风格并不需要这种层次的性能优化或者在语法及高层次上的抽象，这很常见（让我们很失望）。此外整体构架通常意味着使用单一的语言，这也限制着使用技术的数量。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:3","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"实践标准和强制标准 它有点尴尬，微服务团队倾向于避免这种通常由企业架构队伍定制的僵硬的强制标准，但是它们却非常乐于甚至推广这些开放的标准，如HTTP、ATOM、其它微规范。 关键的不同在这些标准是怎么开发出来的，以及它们是怎么被推广的。标准被一些组件管理，如IETF认证标准，仅当它们在互联网上有几个在用的实现，通常源自于开源工程的成功应用。 这些标准单独分离出来，与那种在企业中通常有没有什么编码经验的或者没有什么影响力的厂商标准进行区别。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:4","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"让做对事更容易 一方面，我们发现在持续发布、部署越来越多的使用自动化，是很多有用的工具开发出来帮助开发者和运营商的努力结果。为打包、代码管理、支撑服务的工具，或者增加标准监控的记录的工具，现在都非常常见了。网络中最好的，可能就是Netflix’s的开源工具，但是包含Dropwizard在内的其它工具也被广泛的使用着。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:5","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"断路器(circuit breaker)和产品中现有的代码 断路器(circuit breaker)出现在《Realease It!》一书中，与Bulkhead和Timeout这样的模式放在一起。实施起来，这些模式用于构建通信应用时相当的重要。Netflix的博客在解释它们的应用时，做了大量的工作。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:6","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"同步是有害的 任务时候，你在服务间的调用使用同步的方法，都会遇到宕机时间的乘积效应。简单的说，你的系统宕机时间是你系统的单独组件的宕机时间的乘积。你面临的选择使用异步或者管理宕机时间。在www.guardian.co.uk中，它们在新平台中使用一种简单的规则来实现它：在Netflix中每次用户请求的同步调用，他们重新设计的平台API都会把它构建成异步的API来执行。 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:5:7","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Learning","note"],"content":"参考资料 Martin Flower，Microservices infoQ，微服务架构解析 ","date":"2021-07-20","objectID":"/microservices-martin-flower/:6:0","tags":["Microservices"],"title":"微服务-Martin Flower","uri":"/microservices-martin-flower/"},{"categories":["Operation"],"content":"记录安装Windows系统报错无法继续安装的几种解决办法的笔记","date":"2021-07-19","objectID":"/win-install-error/","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"问题 今天在给朋友安装系统时遇到这样的问题“Windows无法完成安装，若要在此计算机上安装，请重新启动安装”，一看到这瞬间就蒙了，其实这种问题以前也遇到过，而且华硕的主板最多，网上看了下这华硕的主板有时候也不省心啊，真的应了那句2B的华硕主板，出现2B问题，用在了2B的Window7上。其实出现这种问题，很多时候并不是镜像的问题，当然也不排除。但是，其实我们完全有好几种方法可以解决的。下面先来看看具体的解决方法吧。 ","date":"2021-07-19","objectID":"/win-install-error/:1:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"1 ","date":"2021-07-19","objectID":"/win-install-error/:2:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法1 个人是比较懒的那种，能用快速方法解决，就绝不会拐弯抹角的，俗称直肠男。出现这种问题时，首先可以同时按住shift+f10，此时会弹出命令提示对话框。在对话框里输入cd oobe(中间有个空格哈)，此时就进入到了oobe这个目录了，我们再输入msoobe回车，只要等待几秒后就会看到安装在继续了，是不是很神奇呢。 ","date":"2021-07-19","objectID":"/win-install-error/:2:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理1 这是因为这个命令是自动跳过错误继续下一步安装的。如果安装完成后都没有报错能进系统的话那么恭喜你完美解决。 ","date":"2021-07-19","objectID":"/win-install-error/:2:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"2 ","date":"2021-07-19","objectID":"/win-install-error/:3:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法2 如果安装到最后一步还是弹出“Windows安装程序无法将Windows配置未在此计算机的硬件上运行。”，那么真的是躺着也中枪，很不辛，你得继续第二种方法了：修改注册表。继续按住shift+f10，在弹出的对话框里输入regedit回车，此时会弹出注册表。依次找到HKLOCAL MACHINE\\SYSTEM\\SETUP\\STATUS\\ChildCompletion把setup.exe的值从1改成3，然后关掉注册表和命令窗，点错误窗口的确定，重启。重启能进入系统的话那就没问题了，如果还是一样报错的话那就得憋大招了。 ","date":"2021-07-19","objectID":"/win-install-error/:3:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理2 单纯修改注册表配置解决系统问题 ","date":"2021-07-19","objectID":"/win-install-error/:3:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"3 ","date":"2021-07-19","objectID":"/win-install-error/:4:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法3 再次重启一直按delete进入BIOS（按键视主板而定），进入BIOS后找到系统启动项会发现多了一个“windows boot manager”开头的启动项，纠结了吧，什么时候跑出这么一个启动项来了。看来2B主板又在抽风了。不过没关系，他爱怎么抽就怎么抽，我把启动项修改下，改成硬盘为第一启动项再次开机没毛病。 ","date":"2021-07-19","objectID":"/win-install-error/:4:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理3 做系统启动项遗留导致 ","date":"2021-07-19","objectID":"/win-install-error/:4:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"4 ","date":"2021-07-19","objectID":"/win-install-error/:5:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法4 如果还是不行的话那就在BIOS里找到SATS Config这个选项里面把AHCI修改成IDE吧，同时禁用UEFI启动模式，改成只用legacy模式，问题基本都可以解决。或者直接用ghost版本的系统进行安装亦或者是用光驱安装绝对不会出现这种恶心的问题。 ","date":"2021-07-19","objectID":"/win-install-error/:5:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理4 硬盘在BIOS模式不同导致 ","date":"2021-07-19","objectID":"/win-install-error/:5:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"5 ","date":"2021-07-19","objectID":"/win-install-error/:6:0","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"办法5 最后还有一种办法，比较麻烦，但是还是在这里说下吧。首先到一台能上网的电脑上下载 INTEL F6驱动程序，去百度一搜 中关村就有下载，下载完成后 解 压，然后拷贝到U盘中，重新运行PE 把之前的系统盘格式化以后使用WIN7安装工具安装时，选择PNP驱动，点 击后把驱动路径指向 刚才U盘中的F6驱动程序，然后配置完成后提示 重启，重启以后就可以正常安装了。 ","date":"2021-07-19","objectID":"/win-install-error/:6:1","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Operation"],"content":"原理5 缺少驱动 ","date":"2021-07-19","objectID":"/win-install-error/:6:2","tags":["Windows","Windows7","Error"],"title":"安装Windows系统报错无法继续安装","uri":"/win-install-error/"},{"categories":["Back"],"content":"SpringBoot报警告WARNING: An illegal reflective access operation has occurred","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"报警 警告如图所示，该警告是因为jdk版本太高（我用的是10.0，据说9.0的也会这样），具体的原理还没有研究，它不影响项目的正常运行，但是看着很糟心有木有~~~~ 解决方案是把项目jdk降低到1.8及以下，建议1.8。 ","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/:1:0","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"操作步骤 快捷键Ctrl+Alt+Shift+S 进入项目结构设置如图 修改为1.8 然后确认即可。 如果上述方法还没有解决，那请在上图中打开Modules，然后检查一下每一个模块的Dependencies 保证每一个模块的版本都在1.8及以下。 然后确认！ 到现在，问题应该就解决了。 ","date":"2021-07-19","objectID":"/an-illegal-reflective-access-operation-has-occurred/:2:0","tags":["Java","SpringBoot","Error"],"title":"An illegal reflective access operation has occurred","uri":"/an-illegal-reflective-access-operation-has-occurred/"},{"categories":["Back"],"content":"项目启动报错：Error creating bean with name 'flywayInitializer'...org.flywaydb.core.api.FlywayException...","date":"2021-07-19","objectID":"/creating-bean-with-name-error/","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"报错 项目启动报错： org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘flywayInitializer’ defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.FlywayException: Validate failed: Detected failed migration to version 1.0 (xxx yyy zzz) ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:1:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"解决 找到该项目数据库中flyway_schema_history表，没有就新建一个，有就清空表中所有信息 然后项目正常启动 ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:2:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"附件 新建表的字段SQL脚本 CREATE TABLE flyway_schema_history ( installed_rank INT NOT NULL, version VARCHAR(50), description VARCHAR(200) NOT NULL, type VARCHAR(20) NOT NULL, script VARCHAR(1000) NOT NULL, checksum INT, installed_by VARCHAR(100) NOT NULL, installed_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP, execution_time INT NOT NULL, success TINYINT(1) NOT NULL, PRIMARY KEY (installed_rank), INDEX flyway_schema_history_s_idx (success) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; ","date":"2021-07-19","objectID":"/creating-bean-with-name-error/:3:0","tags":["Java","SpringBoot","DataBase","Flyway","Error"],"title":"Error creating bean with name 'flywayInitializer'","uri":"/creating-bean-with-name-error/"},{"categories":["Back"],"content":"记录不同项目使用spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","date":"2021-07-19","objectID":"/spring-cloud-starter-netflix-eureka-server-diff/","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/spring-cloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"发现问题 在学习spring cloud时发现有的引入了spring-cloud-starter-eureka-server，有的引入了spring-cloud-starter-netflix-eureka-server。刚开始还看不懂，特意去查了一下做下总结 ","date":"2021-07-19","objectID":"/spring-cloud-starter-netflix-eureka-server-diff/:1:0","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/spring-cloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"区别 springcloud更新换代比较快； spring-cloud-starter-eureka-server是1.5以前的版本依赖； spring-cloud-starter-netflix-eureka-server是最新版本的依赖（推荐）。 ","date":"2021-07-19","objectID":"/spring-cloud-starter-netflix-eureka-server-diff/:2:0","tags":["Java","SpringCloud","Netflix","Difference"],"title":"spring-cloud-starter-eureka-server 和 spring-cloud-starter-netflix-eureka-server的区别","uri":"/spring-cloud-starter-netflix-eureka-server-diff/"},{"categories":["Back"],"content":"@EnableDiscoveryClient和@EnableEurekaClient这两个注解的区别","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Back"],"content":"他山之石 通过我们看 《springcloud @EnableDiscoveryClient注解作用》这篇文章（https://blog.csdn.net/zheng199172/article/details/82466139）我们看到 要想将一个微服务注册到Eureka Server（或其他服务发现组件，例如Zookeeper、Consul等），Eureka 2.0闭源之后，Consul慢慢会成为主流。 只需： 添加Eureka Client（或其他服务发现组件的Client）依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 写注解：在启动类上添加注解@EnableDiscoveryClient 或@EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ProviderUserApplication { public static void main(String[] args) { SpringApplication.run(ProviderUserApplication.class, args); } } 写配置： spring:application:name:microservice-provider-usereureka:client:serviceUrl:defaultZone:http://localhost:8761/eureka/ ","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/:1:0","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Back"],"content":"区别 重点来了！ @EnableDiscoveryClient和@EnableEurekaClient共同点就是：都是能够让注册中心能够发现，扫描到该服务。 不同点：@EnableEurekaClient只适用于Eureka作为注册中心，@EnableDiscoveryClient 可以是其他注册中心。 ","date":"2021-07-19","objectID":"/enable-discovery-eureka-client-diff/:2:0","tags":["Java","SpringCloud","Eureka","Difference"],"title":"@EnableDiscoveryClient和@EnableEurekaClient区别","uri":"/enable-discovery-eureka-client-diff/"},{"categories":["Back","note"],"content":"记录几种常见磁盘擦写算法的笔记","date":"2021-07-16","objectID":"/disk-clear-algorithm/","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"美国国防部 5220.22-M 美国国防部在 DoD 5220.22-M 规范中规定使用三次覆写算法。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:1:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"美国：NAVSO P-5239-26 （RLL） 美国海军职员办公室发行物（NAVSO Pub）5239—《信息系统 安全（INFOSEC）计划指导原则》由美国海军信息 系统管理中心签发。磁盘控制器采用多种加密技术将计算机数据转换为 磁性数据存储媒体的适用格式。一般情况，ST506 类磁盘驱动器使用改进频率调制（MFM）加密。;SCSI 和 ATA/IDE驱动器使用 游程长度受限（RLL）加密方案。如果对驱动器加密技术不确定，请使用此模式。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:2:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"美国：NAVSO P-5239-26 （MFM） 美国海军职员办公室发行物（NAVSO Pub）5239—《信息系统 安全（INFOSEC）计划指导原则》由美国海军信息 系统管理中心签发。磁盘控制器采用多种加密技术将计算机数据转换为 磁性数据存储媒体的适用格式。一般情况，ST506类磁盘驱动器使用改进频率调制（MFM）；加密。SCSI 和 ATA/IDE 驱动器使用 游程长度受限（RLL）加密方案。该算法采用MFM模式。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:3:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"德国： VSITR 根据 $12 VSITR（指令 #11，1999 年 11 月 29 日）的规定（德国信息安全联邦办公室（BSI）签发），每个扇区都将被 00 和 FF 的三个不同模式覆写，最后一次为AA覆写。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:4:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"俄罗斯：GOST P50739-95 俄罗斯国家技术委员会（Russian State Technical Committee）规定须使 第 6 至第 4 保护类型扇区为零，并在第三至第一个内使用随机字符覆写。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:5:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"Peter Gutmann(古特曼) Peter Gutmann （奥克兰大学计算机科学 系）在第六届 USENIX 安全会议记录上发表了文章（加利福尼亚州圣何塞，1996 年 7 月 22-25 日）。他建议使用一系列方法，以尽可能使黑客很难对此类媒体进行数据 恢复。他提出了35次覆写算法。该算法速度较慢，但极为可靠。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:6:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"Bruce Schneier Bruce Schneier 则在他的《应用 密码术》一书中提出使用七次覆写算法。第一次全部使用一，第二次全部为 零，接下来的五次使用密码安全性较高的假随机序列。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:7:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back","note"],"content":"快速（0填充） 最快但最不安全的数据销毁算法。一次性以“零”覆写所有数据。 ","date":"2021-07-16","objectID":"/disk-clear-algorithm/:8:0","tags":["HardWare","Disk","Clean"],"title":"磁盘擦写算法","uri":"/disk-clear-algorithm/"},{"categories":["Back"],"content":"记录@RequestMapping和@GetMapping的区别","date":"2021-07-16","objectID":"/reqmap-getmap-diff/","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"引言 在Spring4.3版本以后，提供了@GetMapping注解更方便了开发，那么@RequestMapping和@GetMapping有什么区别呢？ @RequestMapping和@GetMapping区别 @RequestMapping可以指定GET、POST请求方式 @GetMapping等价于@RequestMapping的GET请求方式 使用springboot搭建springmvc测试如下： ** * @auther KKKPJSKEY * @data 2018/7/16 0001上午 9:27 */ @RestController @RequestMapping public class HelloController { //@RequestMapping(value = \"hello\", method= RequestMethod.GET ) @GetMapping(\"hello\") public String hello() { return \"hello spring boot\"; } } ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:1:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"springboot搭建springMVC ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:2:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"步骤： maven的 pom.xml中引用springboot父工程、引入启动器web-starter 写main函数； \u003c!-- 父工程 --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.0.0.RELEASE\u003c/version\u003e \u003c/parent\u003e \u003c!-- 引入 starter-web --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 写 main 函数： ** * @auther KKKPJSKEY * @data 2018/7/16 0001上午 9:27 */ @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } controller @RestController @RequestMapping public class HelloController { //@RequestMapping(value = \"hello\", method= RequestMethod.GET ) @GetMapping(\"hello\") public String hello() { return \"hello spring boot\"; } } 启动main函数，浏览器发请求 请求地址：http://localhost:8080/hello 请求结果如下： ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:2:1","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back"],"content":"小结 总结：@GetMapping 在限定使用get请求时候，更为简洁方便 如封面所示其他http方法均有对应的语法糖支持 ","date":"2021-07-16","objectID":"/reqmap-getmap-diff/:3:0","tags":["Java","JavaWeb","SpringBoot","Controller","Difference"],"title":"@RequestMapping和@GetMapping","uri":"/reqmap-getmap-diff/"},{"categories":["Back","note"],"content":"记录JPA @Id 和 @GeneratedValue 注解详解的笔记","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"解释 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"@Id @Id 标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。 @Id标注也可置于属性的getter方法之前。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"@GeneratedValue @GeneratedValue 用于标注主键的生成策略，通过strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer对应identity，MySQL 对应 auto increment。 在javax.persistence.GenerationType中定义了以下几种可供选择的策略： IDENTITY：采用数据库ID自增长的方式来自增主键字段，Oracle 不支持这种方式； AUTO： JPA自动选择合适的策略，是默认选项； SEQUENCE：通过序列产生主键，通过@SequenceGenerator 注解指定序列名，MySql不支持这种方式 TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:1:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"推荐的两种写法： ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"属性之上： @Table(name=\"CUSTOMERS\") @Entity public class Customer { @GeneratedValue(strategy=GenerationType.AUTO) @Id private Integer id; private String name; private String email; private int age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"getter方法之上： @Table(name=\"CUSTOMERS\") @Entity public class Customer { private Integer id; private String name; private String email; private int age; @GeneratedValue(strategy=GenerationType.AUTO) @Id public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"注意 但是不能某个注解在属性之上，某个注解在getter之上，将抛出异常，对其他注解也相同 @Table(name=\"CUSTOMERS\") @Entity public class Customer { @Id private Integer id; private String name; private String email; private int age; @GeneratedValue(strategy=GenerationType.AUTO) public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } 上面的写法是错误的 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:2:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"一、JPA通用策略生成器 通过annotation来映射hibernate实体的,基于annotation的hibernate主键标识为@Id, 其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法, JPA提供四种标准用法,由@GeneratedValue的源代码可以明显看出. Java代码 @Target({METHOD,FIELD}) @Retention(RUNTIME) public @interface GeneratedValue{ GenerationType strategy() default AUTO; String generator() default \"\"; } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1、GenerationType: Java代码 @Id @GeneratedValue(strategy = GenerationType.TABLE, generator=\"payablemoney_gen\") @TableGenerator(name = \"pk_gen\", table=\"tb_generator\", pkColumnName=\"gen_name\", valueColumnName=\"gen_value\", pkColumnValue=\"PAYABLEMOENY_PK\", allocationSize=1 ) 这里应用表tb_generator，定义为 Sql代码 CREATE TABLE tb_generator ( id NUMBER NOT NULL, gen_name VARCHAR2(255) NOT NULL, gen_value NUMBER NOT NULL, PRIMARY KEY(id) ) 插入纪录，供生成主键使用， Sql代码 INSERT INTO tb_generator(id, gen_name, gen_value) VALUES (1,PAYABLEMOENY_PK', 1); 在主键生成后，这条纪录的value值，按allocationSize递增。 @TableGenerator的定义： @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface TableGenerator { String name(); String table() default \"\"; String catalog() default \"\"; String schema() default \"\"; String pkColumnName() default \"\"; String valueColumnName() default \"\"; String pkColumnValue() default \"\"; int initialValue() default 0; int allocationSize() default 50; UniqueConstraint[] uniqueConstraints() default {}; } 其中属性说明： name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。 table属性表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。 catalog属性和schema具体指定表所在的目录名或是数据库名。 pkColumnName属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值 valueColumnName属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值 pkColumnValue属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。 initialValue表示主键初识值，默认为0。 allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 UniqueConstraint与@Table标记中的用法类似。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2、SEQUENCE Java代码 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=\"payablemoney_seq\") @SequenceGenerator(name=\"payablemoney_seq\", sequenceName=\"seq_payment\") @SequenceGenerator定义 Java代码 @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) **public** **@interface** SequenceGenerator { String name(); String sequenceName() **default** \"\"; **int** initialValue() **default** 0; **int** allocationSize() **default** 50; } name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。 sequenceName属性表示生成策略用到的数据库序列名称。 initialValue表示主键初识值，默认为0。 allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3、IDENTITY Java代码 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4、AUTO Java代码 @Id @GeneratedValue(strategy = GenerationType.AUTO) 在指定主键时，如果不指定主键生成策略，默认为AUTO。 Java代码 @Id 跟下面的定义是一样的。 Java代码 @Id @GeneratedValue(strategy = GenerationType.AUTO) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:3:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"二、hibernate主键策略生成器 hibernate提供多种主键生成策略，有点是类似于JPA，有的是hibernate特有： native: 对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server 采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）。 uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）。 hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为integer类型，名称是next_hi（比较少用）。 assigned: 在插入数据的时候主键由程序处理（很常用），这是 元素没有指定时的默认生成策略。等同于JPA中的AUTO。 identity: 使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。 等同于JPA中的INDENTITY。 select: 使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）。 sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用） increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 foreign: 使用另外一个相关联的对象的主键。通常和联合起来使用。 guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 uuid.hex: 看uuid，建议用uuid替换。 sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 hibernate提供了多种生成器供选择,基于Annotation的方式通过@GenericGenerator实现. hibernate每种主键生成策略提供接口org.hibernate.id.IdentifierGenerator的实现类,如果要实现自定义的主键生成策略也必须实现此接口. Java代码 public interface IdentifierGenerator { public static final String ENTITY_NAME = \"entity_name\"; public Serializable generate(SessionImplementor session, Object object) throws HibernateException; } IdentifierGenerator提供一generate方法,generate方法返回产生的主键. ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:4:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"三、@GenericGenerator 自定义主键生成策略，由@GenericGenerator实现。 hibernate在JPA的基础上进行了扩展，可以用一下方式引入hibernate独有的主键生成策略，就是通过@GenericGenerator加入的。 比如说，JPA标准用法 Java代码 @Id @GeneratedValue(GenerationType.AUTO) 就可以用hibernate特有以下用法来实现 Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"assigned\") @GenericGenerator的定义: Java代码 @Target({PACKAGE, TYPE, METHOD, FIELD}) @Retention(RUNTIME) **public** **@interface** GenericGenerator { String name(); String strategy(); Parameter[] parameters() **default** {}; } name属性指定生成器名称。 strategy属性指定具体生成器的类名。 parameters得到strategy指定的具体生成器所用到的参数。 对于这些hibernate主键生成策略和各自的具体生成器之间的关系,在org.hibernate.id.IdentifierGeneratorFacto ry中指定了, Java代码 **static** { GENERATORS.put(\"uuid\", UUIDHexGenerator.**class**); GENERATORS.put(\"hilo\", TableHiLoGenerator.**class**); GENERATORS.put(\"assigned\", Assigned.**class**); GENERATORS.put(\"identity\", IdentityGenerator.**class**); GENERATORS.put(\"select\", SelectGenerator.**class**); GENERATORS.put(\"sequence\", SequenceGenerator.**class**); GENERATORS.put(\"seqhilo\", SequenceHiLoGenerator.**class**); GENERATORS.put(\"increment\", IncrementGenerator.**class**); GENERATORS.put(\"foreign\", ForeignGenerator.**class**); GENERATORS.put(\"guid\", GUIDGenerator.**class**); GENERATORS.put(\"uuid.hex\", UUIDHexGenerator.**class**); //uuid.hex is deprecated GENERATORS.put(\"sequence-identity\", SequenceIdentityGenerator.**class**); } 上面十二种策略，加上native，hibernate一共默认支持十三种生成策略。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1、native Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"native\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2、uuid Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"uuid\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3、hilo Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"hilo\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4、assigned Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"assigned\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"5、identity Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"identity\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:5","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"6、select Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name=\"select\", strategy=\"select\", parameters = { @Parameter(name = \"key\", value = \"idstoerung\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:6","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"7、sequence Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"sequence\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:7","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"8、seqhilo Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"seqhilo\", parameters = { @Parameter(name = \"max_lo\", value = \"5\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:8","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"9、increment Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"increment\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:9","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"10、foreign Java代码 @GeneratedValue(generator = \"idGenerator\") @GenericGenerator(name = \"idGenerator\", strategy = \"foreign\", parameters = { @Parameter(name = \"property\", value = \"employee\") }) 注意：直接使用@PrimaryKeyJoinColumn 报错（?） Java代码 @OneToOne(cascade = CascadeType.ALL) @PrimaryKeyJoinColumn 例如 Java代码 @Entity **public** **class** Employee { @Id Integer id; @OneToOne @PrimaryKeyJoinColumn EmployeeInfo info; ... } 应该为 Java代码 @Entity **public** **class** Employee { @Id @GeneratedValue(generator = \"idGenerator\") @GenericGenerator(name = \"idGenerator\", strategy = \"foreign\", parameters = { @Parameter(name = \"property\", value = \"info\") }) Integer id; @OneToOne EmployeeInfo info; ... } ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:10","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"11、guid Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"guid\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:11","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"12、uuid.hex Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"uuid.hex\") ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:12","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"13、sequence-identity Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"sequence-identity\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:5:13","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"四、通过@GenericGenerator自定义主键生成策略 如果实际应用中，主键策略为程序指定了就用程序指定的主键（assigned），没有指定就从sequence中取。 明显上面所讨论的策略都不满足，只好自己扩展了，集成assigned和sequence两种策略。 Java代码 **public** **class** AssignedSequenceGenerator **extends** SequenceGenerator **implements** PersistentIdentifierGenerator, Configurable { **private** String entityName; **public** **void** configure(Type type, Properties params, Dialect dialect) **throws** MappingException { entityName = params.getProperty(ENTITY_NAME); **if** (entityName==**null**) { **throw** **new** MappingException(\"no entity name\"); } **super**.configure(type, params, dialect); } **public** Serializable generate(SessionImplementor session, Object obj) **throws** HibernateException { Serializable id = session.getEntityPersister( entityName, obj ) .getIdentifier( obj, session.getEntityMode() ); **if** (id==**null**) { id = **super**.generate(session, obj); } **return** id; } } 实际应用中，定义同sequence。 Java代码 @GeneratedValue(generator = \"paymentableGenerator\") @GenericGenerator(name = \"paymentableGenerator\", strategy = \"AssignedSequenceGenerator\", parameters = { @Parameter(name = \"sequence\", value = \"seq_payablemoney\") }) 四种数据库的支持情况如下： 数据库名称 支持的id策略 mysql GenerationType.TABLEGenerationType.AUTOGenerationType.IDENTITY**不支持GenerationType.SEQUENCE* * oracle strategy=GenerationType.AUTOGenerationType.SEQUENCEGenerationType.TABLE**不支持GenerationType.IDENTITY* * postgreSQL GenerationType.TABLEGenerationType.AUTOGenerationType.IDENTITYGenerationType.*SEQUENCE都支持 * kingbase GenerationType.TABLEGenerationType.SEQUENCEGenerationType.IDENTITYGenerationType.AUTO**都支持 JPA的@GeneratedValue注解,在JPA中,@GeneratedValue注解存在的意义主要就是为一个实体生成一个唯一标识的主键(JPA要求每一个实体Entity,必须有且只有一个主键),@GeneratedValue提供了主键的生成策略。@GeneratedValue注解有两个属性,分别是strategy和generator,其中generator属性的值是一个字符串,默认为\"\",其声明了主键生成器的名称(对应于同名的主键生成器@SequenceGenerator和@TableGenerator)。 JPA为开发人员提供了四种主键生成策略,其被定义在枚举类GenerationType中,包括GenerationType.TABLE,GenerationType.SEQUENCE,GenerationType.IDENTITY和GenerationType.AUTO。下面分别介绍这四种主键生成策略。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:0","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"1.GenerationType.TABLE 使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键,这种策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,所以不会优先使用。该策略一般与另外一个注解一起使用@TableGenerator,@TableGenerator注解指定了生成主键的表(可以在实体类上指定也可以在主键字段或属性上指定),然后JPA将会根据注解内容自动生成一张表作为序列表(或使用现有的序列表)。如果不指定序列表,则会生成一张默认的序列表,表中的列名也是自动生成,数据库上会生成一张名为sequence的表(SEQ_NAME,SEQ_COUNT)。序列表一般只包含两个字段:第一个字段是该生成策略的名称,第二个字段是该关系表的最大序号,它会随着数据的插入逐渐累加。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"roleSeq\") @TableGenerator(name = \"roleSeq\", allocationSize = 1, table = \"seq_table\", pkColumnName = \"seq_id\", valueColumnName = \"seq_count\") **private** Integer id; 在以上例子中,roleSeq唯一的标识了该生成器,在@GeneratedValue注解中的generator属性可以根据此标识来声明主键生成器。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:1","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"2.GenerationType.SEQUENCE 在某些数据库中,不支持主键自增长,比如Oracle,其提供了一种叫做\"序列(sequence)“的机制生成主键。此时,GenerationType.SEQUENCE就可以作为主键生成策略。该策略的不足之处正好与TABLE相反,由于只有部分数据库(Oracle,PostgreSQL,DB2)支持序列对象,所以该策略一般不应用于其他数据库。类似的,该策略一般与另外一个注解一起使用@SequenceGenerator,@SequenceGenerator注解指定了生成主键的序列.然后JPA会根据注解内容创建一个序列(或使用一个现有的序列)。如果不指定序列,则会自动生成一个序列SEQ_GEN_SEQUENCE。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"menuSeq\") @SequenceGenerator(name = \"menuSeq\", initialValue = 1, allocationSize = 1, sequenceName = \"MENU_SEQUENCE\") **private** Integer id; 同样,在以上例子中,menuSeq唯一的标识了该生成器,@SequenceGenerator可以理解为将数据库中存在的序列进行了一个映射,在@GeneratedValue注解中的generator属性可以根据此标识来声明主键生成器。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:2","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"3.GenerationType.IDENTITY 此种主键生成策略就是通常所说的主键自增长,数据库在插入数据时,会自动给主键赋值,比如MYSQL可以在创建表时声明\"auto_increment” 来指定主键自增长。该策略在大部分数据库中都提供了支持(指定方法或关键字可能不同),但还是有少数数据库不支持,所以可移植性略差。使用自增长主键生成策略是只需要声明strategy = GenerationType.IDENTITY即可。类似于 Java代码 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) **private** Integer id; 需要注意的是,同一张表中自增列最多只能有一列。 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:3","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back","note"],"content":"4.GenerationType.AUTO 把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。此种主键生成策略比较常用,由于JPA默认的生成策略就是GenerationType.AUTO,所以使用此种策略时.可以显式的指定@GeneratedValue(strategy = GenerationType.AUTO)也可以直接@GeneratedValue 类似于 Java代码 @GeneratedValue(strategy = GenerationType.AUTO) **private** Integer id; 或 Java代码 @GeneratedValue **private** Integer id; 参考资料: http://xiaoyaocao.iteye.com/blog/1874412 http://www.ibm.com/developerworks/cn/java/j-lo-jpaprimarykey/ http://www.oracle.com/technetwork/cn/middleware/ias/toplink-jpa-annotations-100895-zhs.html# 测试实例 http://download.csdn.net/detail/u012493207/9456135 ","date":"2021-07-16","objectID":"/jpa-id-gnrtvlu/:6:4","tags":["Java","Jpa"],"title":"JPA @Id 和 @GeneratedValue 注解详解","uri":"/jpa-id-gnrtvlu/"},{"categories":["Back"],"content":"解决java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized的Error","date":"2021-07-15","objectID":"/mysql-server-time-error/","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"报错 如图报错信息 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:1:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"原因 程序端（访问端）和数据库的时时区不一样报错 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:2:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"解决办法 ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:0","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"方法1 在语句\"jdbc:mysql://localhost:3366/test “后添加”?serverTimezone=GMT%2B8\": ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:1","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"方法2 更改MySQL中的系统时间 Linux 修改my.cnf实现永久修改 vi /etc/mysql/my.cnf # 然后在mysqld下边的配置中添加一行：[mysqld] [mysqld] default-time_zone = '+8:00' # 然后重启mysql service mysql restart Windows 修改my.ini实现永久修改 vi /c/mysql/my.cnf #Git Bash edit C:\\mysql\\my.cnf #CMD # 然后在mysqld下边的配置中添加一行：[mysqld] [mysqld] default-time_zone = '+8:00' # 然后重启mysql net mysql restart ","date":"2021-07-15","objectID":"/mysql-server-time-error/:3:2","tags":["MySql","Time","Error"],"title":"MySql SQLException: The server time zone","uri":"/mysql-server-time-error/"},{"categories":["Back"],"content":"解决Maven操作时Process terminated报错","date":"2021-07-15","objectID":"/maven-process-terminated-error/","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"原因 如图报错，检查报错文件发现xml文件有问题 ","date":"2021-07-15","objectID":"/maven-process-terminated-error/:1:0","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"XML文件报错原因及解决办法 原因 缩进或者空格不一致导致该问题 解决办法 格式化编辑好之后复制再粘贴过来就可以了( 👉XML 在线格式化) ","date":"2021-07-15","objectID":"/maven-process-terminated-error/:2:0","tags":["Maven","Error"],"title":"Maven Process Terminated","uri":"/maven-process-terminated-error/"},{"categories":["Back"],"content":"解决java.lang.NoClassDefFoundError: javax/validation/constraints/Min","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"原因 spring-boot-starter-parent版本不同，部分版本（2.3之后）不包含hibernate-validator，需要额外添加spring-boot-starter-validation依赖 ","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/:1:0","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"parent \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003c!-- 不包含hibernate-validator--\u003e \u003c!-- \u003cversion\u003e2.3.1\u003c/version\u003e--\u003e \u003c!-- 包含hibernate-validator--\u003e \u003cversion\u003e2.2.13.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e 不包含hibernate-validator需要额外添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-validation\u003c/artifactId\u003e \u003c/dependency\u003e 就不报错了 ","date":"2021-07-15","objectID":"/springboot-noclassdeffounderror/:1:1","tags":["SpringBoot","Maven","Error"],"title":"NoClassDefFoundError: javax/validation/constraints/Min","uri":"/springboot-noclassdeffounderror/"},{"categories":["Back"],"content":"解决Mysql closing inbound before receiving peer's close_notify 的Error","date":"2021-07-15","objectID":"/mysql-sslexception-error/","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"错误 EXCEPTION STACK TRACE: ** BEGIN NESTED EXCEPTION ** javax.net.ssl.SSLException MESSAGE: closing inbound before receiving peer's close_notify STACKTRACE: javax.net.ssl.SSLException: closing inbound before receiving peer's close_notify ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:1:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"原因 开启了userSSL ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:2:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"解决 在连接字符串后面拼接?useSSL=false spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false ","date":"2021-07-15","objectID":"/mysql-sslexception-error/:3:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql SSLException Error","uri":"/mysql-sslexception-error/"},{"categories":["Back"],"content":"解决Mysql The last packet sent successfully to the server was 0 milliseconds ago.的Error","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"原因 我的是Mysql服务没启动 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:1:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"解决办法 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:0","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"控制台 net start mysql ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:1","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back"],"content":"手动 进入Window服务界面启动Mysql服务即可 ","date":"2021-07-15","objectID":"/mysql-scss-2-server-error/:2:2","tags":["DataBase","SQL","MySql","Error"],"title":"Mysql successfully to the server Error","uri":"/mysql-scss-2-server-error/"},{"categories":["Back","note"],"content":"记录Java学习路线的笔记","date":"2021-07-14","objectID":"/java-learn-path/","tags":["Java","Path"],"title":"Java学习路线笔记","uri":"/java-learn-path/"},{"categories":["Back","note"],"content":". JavaSE --\u003e MySQL基础 --\u003e JDBC --\u003e JavaWeb --\u003e Spring5 --\u003e SpringMVC --\u003e MyBatis --\u003e Maven --\u003e Ssm框架整合案例 --\u003e Git/GitHub --\u003e Redis6 --\u003e MySQL高级优化 --\u003e MyBatisPlus --\u003e Spring注解驱动开发 --\u003e  ZooKeeper --\u003e Dubbo --\u003e 消息中间件ActiveMQ --\u003e RabbitMQ --\u003eSpringBoot2 --\u003e  SpringCloud --\u003e 尚筹网项目 --\u003e 在线教育项目 --\u003e 谷粒商城项目 --\u003e 尚医通项目 --\u003e 尚融宝项目--\u003e 高频面试题第一季 --\u003e 大厂面试题第二季 --\u003e 大厂面试题第三季  ","date":"2021-07-14","objectID":"/java-learn-path/:0:0","tags":["Java","Path"],"title":"Java学习路线笔记","uri":"/java-learn-path/"},{"categories":["Total","note"],"content":"记录常用编程的缩写的笔记","date":"2021-07-14","objectID":"/conv-prog-abbr-note/","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"EJB 是的Enterprise Java Beans技术的简称, 又被称为企业Java Beans。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:1:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ELT ELT，是英文 Extract-Load-Transform 的缩写。在ELT架构中，ELT只负责提供图形化的界面来设计业务规则，数据的整个加工过程都在目标和源的数据库之间流动，ELT协调相关的数据库系统来执行相关的应用，数据加工过程既可以在源数据库端执行，也可以在目标数据仓库端执行（主要取决于系统的架构设计和数据属性） ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:2:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ESB 企业服务总线，即ESB全称为Enterprise Service Bus ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:3:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"ETL ETL，是英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:4:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"POJO（分类有详解，见这篇文章） （Plain Ordinary Java Object）简单的Java对象。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:5:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"RMI 英文全称是\"Remote Method Invocation\"，它的中文名称是\"远程方法调用\"。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:6:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"RPC 是\"Remote Procedure Call\"的缩写，也就是\"远程过程调用\"。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:7:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"SOA 面向服务的体系结构(Service-Oriented Architecture)是一个组件模型,它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:8:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"JMS JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:9:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Total","note"],"content":"PWA PWA（Progressive Web App）是一种理念，使用多种技术来增强web app的功能，可以让网站的体验变得更好，能够模拟一些原生功能，比如通知推送。 ","date":"2021-07-14","objectID":"/conv-prog-abbr-note/:10:0","tags":["Program","Abbreviate"],"title":"常用编程缩写笔记","uri":"/conv-prog-abbr-note/"},{"categories":["Front","note"],"content":"记录学习NPM的笔记","date":"2021-06-29","objectID":"/nodejs-npm-note/","tags":["NPM","Vue"],"title":"NPM笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"npm的两层含义 NPM是一个第三方模块的托管网站，指的就是https://www.npmjs.com/; NPM 是Node的包管理工具（全名叫做Node package manager），在我们安装Node时候，就已经顺便也安装NPM这个管理工具; ","date":"2021-06-29","objectID":"/nodejs-npm-note/:1:0","tags":["NPM","Vue"],"title":"NPM笔记","uri":"/nodejs-npm-note/"},{"categories":["Front","note"],"content":"安装和卸载全局包 什么是全局的包:通过npm install 包名 -g方式安装的包，都安装到了全局;一般全局的安装目录是 C:\\Users\\自己的用户文件夹\\AppDataRoaming\\npm 带大家演示如何安装一个全局的包：npm install i5ting_toc -g，注意:这里的-g表示全局安装包的意思 注意：一般，只有一些工具，才有全局安装的必要性 如果要全局卸载某个包，比如要卸载i5ting toc了，直接运行’npm uniinstall i5ting_toc -g`就可以全局卸载包了! ","date":"2021-06-29","objectID":"/nodejs-npm-note/:2:0","tags":["NPM","Vue"],"title":"NPM笔记","uri":"/nodejs-npm-note/"},{"categories":["Software"],"content":"解决idea报错 “cannot access xxx”的解决办法","date":"2021-06-29","objectID":"/idea-cannot-access-xxx/","tags":["Idea","Environment","IDE","Error"],"title":"Idea报错 “cannot access xxx”","uri":"/idea-cannot-access-xxx/"},{"categories":["Software"],"content":"使用IEDA在项目中，偶尔会出现报错“cannot access xxx” 此时，执行IDEA重启，就不报错了，应该是IDEA本身的问题 ","date":"2021-06-29","objectID":"/idea-cannot-access-xxx/:0:0","tags":["Idea","Environment","IDE","Error"],"title":"Idea报错 “cannot access xxx”","uri":"/idea-cannot-access-xxx/"},{"categories":["Operation"],"content":"记录集中Windows环境下使用ADB调试AS虚拟机报错的解决办法","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"启动报错 安卓部分内容不能使用git bash，需要使用windows的控制台，android-tools、adb-shell ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:1:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"缺root权限 Permission denied 需要先使用su进行获取root权限 ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:2:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"su报错 关于/system/bin/sh: su: not found的解决办法（安卓模拟器运行） ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:0","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"现象 在了解关于数据库的创建时，无法在android Studio的模拟器运行的条件下运行cmd 窗口下adb shell 命令，adb shell之后su无法转到root权限,导致无法进入data/data/… ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:1","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Operation"],"content":"原因 Android Studio带(Google Play)的模拟器无法获得root权限安装 该换成为带(Google APIs)的模拟器即可，类似于这种 ","date":"2021-06-29","objectID":"/androidstudio-av-adk-adb/:3:2","tags":["Android","Windows","ADB","Error"],"title":"Windows环境下使用ADB调试AS虚拟机报错","uri":"/androidstudio-av-adk-adb/"},{"categories":["Software"],"content":"解决一种VM虚拟机Ping不通问题的办法","date":"2021-06-29","objectID":"/vm-ping-error/","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Software"],"content":"问题及解决思路 发现虚拟机可以ping百度，虚拟机可以ping本机，但是本机就是ping不通虚拟机 查阅很多资料了解到这是Win10的Bug，休眠睡眠关闭机盖等操作再启动，虚拟机的网卡gg ","date":"2021-06-29","objectID":"/vm-ping-error/:1:0","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Software"],"content":"解决办法 1、右键任务栏网络图标，单机{打开\"网络和Internet\"设置} 2、找到网络和共享中心，点击进入 3、找到更改适配器设置，点击进入 4、找到你用的VMware虚拟机网卡右键，先禁用 （我的是Nat模式，是VMnet8；桥接模式应该是是VMnet1，没试过请自行验证） 5、禁用完了长这样 6、同样，再右键启用即可 7、你试试，绝对不一定，和我一样的问题，应该可以ping通了。。。 ","date":"2021-06-29","objectID":"/vm-ping-error/:2:0","tags":["VMware","Net","NetAdapter"],"title":"VM虚拟机Ping不通","uri":"/vm-ping-error/"},{"categories":["Back","note"],"content":"记录Android_Java学习路线的笔记","date":"2021-06-29","objectID":"/android-learn-path-note/","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Java基础 泛型 作用于定义 通配符于嵌套 Rxjava中的泛型 注解 自定义注解与元注解 APT，编译时注解处理器 插桩 反射，运行时动态获取注解信息 Retrofit 并发线程 线程共享与实现实现 CAS原理 Android AsyncTask原理 Java虚拟机 Dalvik虚拟机 CG算法、机制 内存分配策略 Hook技术动态编程 动态代理模式 双亲委托机制 JavaIO体系 IO操作Dex加密 ","date":"2021-06-29","objectID":"/android-learn-path-note/:1:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"数据结构及算法 数据结构 栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） ","date":"2021-06-29","objectID":"/android-learn-path-note/:2:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"算法 分治算法 动态规划 贪心算法 分支限界法 ","date":"2021-06-29","objectID":"/android-learn-path-note/:3:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android基础 Android Activity生命周期 Application生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 ","date":"2021-06-29","objectID":"/android-learn-path-note/:4:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android开发高级 注： Android高级工程师招聘要求： 1.熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 2.有丰富的Android应用架构能力，能够独立主导并架构App； 3.Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多 种开发语言的优先考虑； 4.对Android性能优化，安全，软件加固，自动化测试有深刻认识; 5.博客，开源项目 ","date":"2021-06-29","objectID":"/android-learn-path-note/:5:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android技术难点 AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。 这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 ","date":"2021-06-29","objectID":"/android-learn-path-note/:6:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android框架层源码掌握 Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 ","date":"2021-06-29","objectID":"/android-learn-path-note/:7:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android进程通信以及多进程开发 Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制 Android绘图原理 Android页面恢复 Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState ：当Activity容易被系统销毁时，会触发该方法。具体的说： 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 ","date":"2021-06-29","objectID":"/android-learn-path-note/:8:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"混合开发及Android WebView应用 混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、* WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress ","date":"2021-06-29","objectID":"/android-learn-path-note/:9:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 \u0026 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 ","date":"2021-06-29","objectID":"/android-learn-path-note/:10:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"App启动加载过程 Android虚拟机 Android App运行的沙箱原则 ","date":"2021-06-29","objectID":"/android-learn-path-note/:11:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"Android架构 在Android源码中最重要的三个类：ActivityManagerService／PackageManagerService／View，推荐大家周末的时候可以去阅读下这部分的源码，阅读源码能提高我们今后设计架构自己代码的能力，同时也能从底层了解整个android系统的运行原理，其他一些比如主线程的消息循环、主线程如何和AMS如何跨进程交互、SystemServer进程中的各种Service的工作方式、AsyncTask的工作原理等。这些知识也是作为一个Android高级开发工程师必须掌握的，不能整天沉溺于ui和四大组件的交互，要站在更高的角度去考虑Android的有些问题。 MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） ","date":"2021-06-29","objectID":"/android-learn-path-note/:12:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"移动开发外围 服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术v：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 ","date":"2021-06-29","objectID":"/android-learn-path-note/:13:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"前端开发相关 前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 ","date":"2021-06-29","objectID":"/android-learn-path-note/:14:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Back","note"],"content":"开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 ","date":"2021-06-29","objectID":"/android-learn-path-note/:15:0","tags":["Java","Android"],"title":"Android_Java学习路线","uri":"/android-learn-path-note/"},{"categories":["Total"],"content":"解决Android runOnUiThread android.os.NetworkOnMainThreadException","date":"2021-06-29","objectID":"/android-runonuithread-error/","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"原因 跑老师的代码的时候报这个错，主要内容是编写Android项目时使用OKHttp3网络请求交互，但是老师向我展示了他的代码在他的机器上的正确性。我的就快乐的报错。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"分析 后面经过一定的相关知识进行学习发现，虚拟机的版本不同，导致了这个问题。同时在同学的低版本虚拟机上得到了验证。具体的版本规约并未查询到。我方进行试验的是AndroidStudio的虚拟机，Android11的是会报错或请求返回的body无法显示到ui上。Android7以下版本的虚拟机是可以正确将请求结果返回到ui界面上的 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:2:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"解决办法 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"不操作Android等ui 这是原来的代码 runOnUiThread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } }); 不使用runOnUiThread，改为一个新线程，并启动他 new Thread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } } }).start(); 就完事了。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:1","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"其他情况 一旦有其他内容需要显示到ui上，需要使用线程之间的通信技术，如Message+Bundle发送，(见我的另一篇博客：点我跳转)Hundle进行接收的办法，或者是同Intent+Bundle进行发送，Hundle进行接收等办法，将数据传输至主线程，主线程将他显示到界面上即可。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:3:2","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Back"],"content":"解决Android Java中The BC provider no longer provides for KeyPairGenerator.RSA.的错误","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"发生报错 使用网路相关框架时发生报错 java.lang.AssertionError: java.security.NoSuchAlgorithmException: The BC provider no longer provides an implementation for KeyPairGenerator.RSA. Please see https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html for more details. ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:1:0","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"解决方案 在AndroidManifest.xml文件中填写这段代码 仅需在元application添加配置即可，其他结构代码仅为application说明位置 \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.mypackage.mylibrary\"\u003e \u003capplication android:usesCleartextTraffic=\"true\" /\u003e \u003c/manifest\u003e ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:2:0","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Software","note"],"content":"解决Win系统下窗口跑到屏幕外移动不回来解决办法的笔记","date":"2021-06-29","objectID":"/win-window-out-screen/","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":" 在窗口标题栏右键，点击移动，就可以了 如果标题栏看不到就用下面的快捷键办法 ","date":"2021-06-29","objectID":"/win-window-out-screen/:0:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"切换 切换到那个窗口 ","date":"2021-06-29","objectID":"/win-window-out-screen/:1:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"使用快捷键 标题栏右键快捷键为 alt+space，然后按M ","date":"2021-06-29","objectID":"/win-window-out-screen/:2:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Software","note"],"content":"移动 使用键盘上下左右移动即可 ","date":"2021-06-29","objectID":"/win-window-out-screen/:3:0","tags":["Windows","WinForm"],"title":"Win系统下窗口跑到屏幕外","uri":"/win-window-out-screen/"},{"categories":["Back"],"content":"Java安卓使用本地ip时报错java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":" java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy java.net.ConnectException: failed to connect to localhost/127.0.0.1 (port 8080) 以上两个错误 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:0:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"现象 android虚拟机中访问电脑本地url失败 当你启动Tomcat后，在浏览器中输入http：//127.0.1.1:8080/xxx.xx，你会发现你可以找打你要找的东西。但是当你在Eclipse或者android虚拟机中访问 会一直报出这样的错误： java.net.ConnectException: failed to connect to /127.0.1.1 (port 8080) ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:1:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"分析 原来模拟器默认把127.0.0.1和localhost当做本身了，在模拟器上可以用10.0.2.2代替127.0.0.1和localhost，另外如果是在局域网环境可以用 192.168.0.x或者192.168.1.x(根据具体配置)连接本机,这样应该就不会报错了。 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"解决方法 设置访问的ip为10.0.2.2（本机的网络ip） ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:3:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Total"],"content":"PrintWriter输出到Web页面中呈现乱码现象解决方案","date":"2021-06-28","objectID":"/java-printwriter-random-code/","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"一般情况只使用下面代码： PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:1:0","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"输出到页面上基本会呈现出乱码现象，解决方案如下： response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html; charset=utf-8\"); PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:2:0","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Back"],"content":"Java Android 子线程弹出Toast报错Can't toast on a thread that has not called Looper.prepare()解决办法","date":"2021-06-28","objectID":"/java-android-thread-toast-error/","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"前言 最近一段时间在忙着开发一款自己的APP，将自己常用的功能需求都加入进入，同时在GitHub上跟着大牛们学习新的技术，提升自己的技能，在开发的过程中不断的发现问题和解决问题。 在开发过程遇到了这样一个问题：Can’t toast on a thread that has not called Looper.prepare()，如果在一个线程中没有调用Looper.prepare(),就不能在该线程中创建Toast。这个问题是因为在子线程中弹出Toast导致的。 Android是不能直接在子线程中弹出Toast的，可是如果我们非要这么做，那该怎么办呢？下面就为大家讲解如何在子线程中弹出Toast，以及一些其他类似的子线程中操作的错误。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中调用Toast 在子线程中弹出Toast，会报错：java.lang.RuntimeException: Can’t toast on a thread that has not called Looper.prepare()。 解决方式：先调用Looper.prepare();再调用Toast.makeText().show();最后再调用Looper.loop(); public class ToastUtils { static Toast toast = null; public static void show(Context context, String text) { try { if(toast!=null){ toast.setText(text); }else{ toast= Toast.makeText(context, text, Toast.LENGTH_SHORT); } toast.show(); } catch (Exception e) { //解决在子线程中调用Toast的异常情况处理 Looper.prepare(); Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); Looper.loop(); } } } ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:2:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中更新UI 在子线程中更新UI，会报错：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 解决方式：在子线程中更新UI，一般使用Handler或者runOnUiThread()或者AsyncTask。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:3:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中创建Handler 在子线程中创建Handler，会报错：java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()。 解决方式： new Thread() { public void run() { Looper.prepare(); new Handler().post(runnable);//在子线程中直接去new 一个handler 　Looper.loop();　//这种情况下，Runnable对象是运行在子线程中的，可以进行联网操作，但是不能更新UI 　} }.start(); ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:4:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"写在最后 以上就是在子线程中更新UI、弹出Toast、创建Handler时会遇到的问题，及解决方式。 如果你在参考过程中遇到问题，可以在我的联系方式中给我提问。 后面会继续介绍，Android的相关知识，欢迎继续关注我博客的更新。 参考资源 在子线程中new Handler报错 Android – Looper.prepare()和Looper.loop() —深入版 Toast和Looper、Handler消息循环机制 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:5:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"运行别人的项目报错一些版本冲突问题的解决办法","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"Error:java: 无效的目标发行版: 11 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:0","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"问题 我们在使用Idea开发中如果遇到你的JDK版本有“无效的目标发行版: 11”冲突时，要修改以下JDK版本 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:1","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"解决 1项目Java版本 2模块Java版本 3 Idea设置中Java编译器对每个模块的版本 三个部分都不能高于 使用的java版本号，否则就报错 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:1:2","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"JDK版本过高，非法反射 上面第一部分的项目Java版本若过高，其他部分正常会导致下面的报错。处理办法与上面一致，调成Jdk8即可 ","date":"2021-06-28","objectID":"/java11-invaid-target-release-error/:2:0","tags":["Java","Version","Java11","Error"],"title":"Java开发过程中Jdk版本处理","uri":"/java11-invaid-target-release-error/"},{"categories":["Back"],"content":"错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"报错信息 D:\\apache-tomcat-7.0.54\\bin\\catalina.batrun [2016-10-1402:26:31,540]Artifactink-balance-web:warexploded:Serverisnotconnected.Deployisnotavailable. Connectedtoserver [2016-10-1402:26:31,562]Artifactink-balance-web:warexploded:Artifactisbeingdeployed,pleasewait... UsingCATALINA_BASE:\"C:\\Users\\mrchen\\.IntelliJIdea2016.1\\system\\tomcat\\Unnamed_ink-parent\" UsingCATALINA_HOME:\"D:\\apache-tomcat-7.0.54\" UsingCATALINA_TMPDIR:\"D:\\apache-tomcat-7.0.54\\temp\" UsingJRE_HOME:\"C:\\Program Files\\Java\\jdk1.7.0_17\" UsingCLASSPATH:\"D:\\apache-tomcat-7.0.54\\bin\\bootstrap.jar;D:\\apache-tomcat-7.0.54\\bin\\tomcat-juli.jar\" 错误:代理抛出异常错误:java.rmi.server.ExportException:Portalreadyinuse:1099;nestedexceptionis:java.net.BindException:Addressalreadyinuse:JVM_Bind Disconnectedfromserver ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:1:0","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"容器启动报错处理方案 （1）：运行 cmd 之后输入 netstat -ano 之后会出现列表，在里面找到错误信息中的端口(这里是1099) （2）：找到这一行后 记下进程号：这里是55512，之后打开任务管理器，进入到详细信息页面，找到pid为55512的进程，选中 点右下角的结束任务即可 （3）、执行完以上步骤再重启容器，容器正常启动了，恭喜！ ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:2:0","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["SoftwareDesign"],"content":"用组合模式、策略模式、观察者模式结合来实现一个MVC","date":"2021-06-28","objectID":"/mvc-design-patterns/","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"1 MVC介绍 众所周知MVC不是设计模式，是一个比设计模式更大一点的模式，称作设计模式不合理，应该说MVC它是一种软件开发架构模式，它包含了很多的设计模式，最为密切是以下三种：Observer (观察者模式), Composite（组合模式）和Strategy（策略模式）。所以说MVC模式又称复合模式。MVC(Model-View-Controller) 模式的基本思想是数据，显示和处理相分离。模型(Model)负责数据管理，视图(View)负责数据显示，控制器(Controller)负责业务逻辑和响应策略。 从MVC的形成过程来看，最初只有模型和视图两个元素。模型封装了数据并提供操作接口，视图用来表现数据和接收用户请求。模型是独立的，而视图依赖于模型：从模型获取数据进行显示；向模型发送用户请求，并根据返回结果刷新自己。 需要用多个视图表现同一模型时，情况发生了变化：一个视图修改数据以后，不但本身要刷新，其他所有视图也要刷新。如果由该视图通知其他视图，它就需要知道其他所有视图，由于每个视图都可能发出修改，每个视图都要知道其他所有视图，这种关联过于复杂，不但难以维护，而且不便于增加新的视图。如果让模型通知所有视图更新，可能会影响模型的独立性。用观察者(Observer)模式 可以解决上述矛盾，从而实现：由模型通知视图，而模型不依赖于具体的视图，具体视图之间相互独立。 视图是用户请求的接收者，但不宜作为请求的处理者。因为界面是易变的，如果业务代码和界面代码放在一起，频繁的界面修改可能会破坏比较稳定的业务代码。将业务逻辑分离出来，由一个控制器负责，就是为了避免这种干扰。 模型，视图和控制器的基本协作关系如下图模型在状态变化的时候，直接通知所有视图，视图向模型查询状态数据，然后刷新自身。当用户发出操作时，视图把消息发给控制器，控制器按照业务逻辑进行处理，需要查询或更新数据时，控制器会调用模型。下面是一个更详细的示意图MVC架构把数据处理，程序输入输出控制及数据显示分离开来，并且描述了不同部件的对象间的通信方式。使得软件可维护性，可扩展性，灵活性以及封装性大大提高；MVC(Model-View-Controller)把系统的组成分解为M（模型）、 V（视图）、C（控制器）三种部件。视图表示数据在屏幕上的显示。控制器提供处理过程控制，它在模型和视图之间起连接作用。控制器本身不输出任何信息和做任何处理，它只负责把用户的请求转成针对Model的操作，和调用相应的视图来显示Model处理后的数据。三者之间关系如下图2.1：图2.1 MVC关系图 同样的数据，可以有不同的显示和进行各种处理。显示仅仅是表现数据，而处理是根据用户请求改变数据的过程，不但包含业务逻辑，也要提供响应策略。响应策略由控制器负责，视图可以使用不同的控制器提供不同的响应方式，这是策略(Strategy)模式的应用。 此外，MVC还允许视图嵌套，通过使用组合(Composite)模式，一致地处理组合视图和普通视图。 用多个视图表现一个模型，在视图不变的情况下改变响应策略，允许视图嵌套，这是MVC的三个主要特性。在内部结构上，MVC的主要关系是由观察者模式，策略模式和组合模式给出的。由观察者模式确定的模型视图关系是其中最为重要的。 MVC 模式有许多变体。前述结构中，由模型通知视图刷新，称为主动MVC；如果由控制器更新模型以后通知视图，称为被动MVC结构。在许多应用中，没有明显的控制器角色，也没有视图嵌套。可见根据实际需要，构成MVC的三个模式上都可能出现变化。Web浏览器就是被动MVC结构的一个实例。\" 浏览器是一个交互程序，从概念上讲，它是由一组客户、一组解释器与一个管理它们的控制器所组成。控制器形成了浏览器的中心部件，它解释鼠标点击与键盘输入，并且调用其他组件来执行用户指定的操作。例如，当用户键入一个URL或者点击一个超文本引用时，控制器调用一个客户从所需文档所在的远程服务器上取回该文档，并且调用解释器向用户显示该文档。每个浏览器必须包含一个HTML解释器来显示文档，其他解释器是可选的。HTML解释器的输入由符合HTML语法的文档所组成，输出由位于用户显示器上的格式版本文档所组成。解释器通过将HTML规则转换成适合用户显示硬件的命令来处理版面细节。HTML解释器一个最重要的功能是包含可选项。解释器必须存储关于显示器上位置之间关系的信息和HTML文档中被瞄定的项。当用户用鼠标选定了一个项，浏览器通过当前的光标位置和存储的位置信息来决定哪个项被用户选定。\" ","date":"2021-06-28","objectID":"/mvc-design-patterns/:1:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.为什么要在Web应用中使用MVC架构 用户界面逻辑的更改往往比业务逻辑频繁，尤其是在基于Web的应用程序中。例如，可能添加新的用户界面页，或者可能完全打乱现有的页面布局。对显示的更改，尽可能地不要影响到数据和业务逻辑。 目前大部分Web应用都是将数据代码和表示混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。MVC从根本上强制性的将它们分开。尽管构造MVC应用需要一些额外的工作，但它带来的好处是无庸质疑的。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.1 提高代码重用率 最重要的一点是多个视图能共享一个模型，无论用户想要Flash界面或是 WAP 界面；用一个模型就能处理它们。由于已经将数据和业务规则从表示层分开，所以可以最大化的重用代码。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:1","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.2 提高程序的可维护性 因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变数据层和业务规则 [3]。例如，把数据库从MySQL移植到Oracle，或者把基于RDBMS数据源改变到LDAP，只需改变模型即可。一旦正确的实现了模型，不管数据来自哪里，视图都会正确的显示它们。MVC架构的运用，使得程序的三个部件相互对立，大大提高了程序的可维护性。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:2","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"2.3 有利于团队开发 在开发过程中，可以更好的分工，更好的协作。有利于开发出高质量的软件。良好的项 目架构设计，将减少编码工作量 ：采用MVC结构 + 代码生成器，是大多数Web应用的理想选择。部分模型(Model)、和存储过程一般可用工具自动生成。控制(Controller)器比较稳定，一般由于架构师（也可能是有经验的人）完成；那么整个项目需要手动编写代码的地方就只有视图(View)了。在这种模式下，个人能力不在特别重要，只要懂点语法基础的人都可以编写，无论项目成员写出什么样的代码，都在项目管理者的可控范围内。即使项目中途换人，也不会有太大问题。在个人能力参差不齐的团队开发中，采用MVC开发是非常理想的。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:2:3","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3 MVC架构的优点及不足 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3.1 MVC的优点 MVC的优点体现在以下几个方面： （1） 有利于团队开发分工协作和质量控制，降低开发成本。 （2） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。 （3） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。 （4） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。 （5） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:1","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["SoftwareDesign"],"content":"3.2 MVC的缺点 MVC的不足体现在以下几个方面： （1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 （2）视图对模型数据的访问效率低。视图可能需要多次调用Model才能获得足够的显示数据。 （3）完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困难。 MVC 模式可以分解为以下设计模式 在GOF书的 Introduction中，有一小节是\"Design Patterns in Smalltalk MVC\"即介绍在MVC模式里用到的设计模式。它大概向我们传达了这样的信息：合成模式+策略模式+观察者模式约等于MVC模式（当然MVC模式要多一些东西）。也就是说它在大部分情况下是下面几个模式： 1、观察者模式 类图结构在Gof里的表示如下：2、合成模式 类图结构在Gof里的表示如下： 3、策略模式 类图结构在Gof里的表示如下： 谈 谈 MVC 架构模式中的三个角色 Model （模型端） Mod封装的是数据源和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作这些状态的方法，往往是一系列的公开方法。通过这些公开方法，便可以取得模型端的所有功能。 在这些公开方法中，有些是取值方法，让系统其他部分可以得到模型端的内部状态参数，其他的改值方法则允许外部修改模型端的内部状态。模型端还必须有方法登记视图，以便在模型端的内部状态发生变化时，可以通知视图端。我们可以自己定义一个Subject接口来提供登记和通知视图所需的接口或者继承 Java.util.Observable类，让父类完成这件事。 多个 View( 视图端 ) View封装的是对数据源Model的一种显示。一个模型可以由多个视图，并且可以在需要的时候动态地登记上所需的视图。而一个视图理论上也可以同不同的模型关联起来。 在前言里提到了，MVC模式用到了合成模式，这是因为在视图端里，视图可以嵌套，比如说在一个JFrame组件里面，可以有菜单组件，很多按钮组件等。 多个 Controller( 控制器端 ) 封装的是外界作用于模型的操作。通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法（这个方法就是前面在介绍模型的时候说的改值方法）。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model来更改其状态值。这样 Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。也在前言里提到，MVC用到了策略模式，这是因为View用一个特定的Controller的实例来实现一个特定的响应策略，更换不同的Controller，可以改变View对用户输入的响应。 MVC (Model-View-Controller) : 模型利用\"观察者\"让控制器和视图可以随最新的状态改变而更新。另一方面，视图和控制器则实现了\"策略模式\"。控制器是视图的行为; 视图内部使用\"组合模\"式来管理显示组件。 以下的MVC解释图很好的标示了这种模式： 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。 这些模式携手合作，把MVC模式的三层解耦，这样可以保持设计干净又有弹性。 ","date":"2021-06-28","objectID":"/mvc-design-patterns/:3:2","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc-design-patterns/"},{"categories":["Software"],"content":"Word怎么去掉百度网盘","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/","tags":["Office","Word","Panbaidu"],"title":"Word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Software"],"content":"不知道什么时候Word里面多了一个百度网盘的图标。想去掉，网上也有方法，但是不够细致，基本都是word2010版，我这个是不断更新的最新版，自己倒腾好长时间才解决，仅供大家参考哈。 step1，鼠标选中网盘的图标，右键弹出如图所示对话框，点击自定义功能区即可。 step2，点击加载项，选中选中百度网盘word选项，点击下面的转到即可。 step3，选中可加载项的百度网盘，点击删除，再确定即可。 step4，返回Word，百度网盘的图标消失，大功告成。 祝你愉快！ ","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/:0:0","tags":["Office","Word","Panbaidu"],"title":"Word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Back","note"],"content":"Java后端面试题整理的笔记","date":"2021-06-08","objectID":"/java-audition-note/","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"什么是面向对象? 对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者(对象)、及各自需要做什么 比如:洗衣机洗衣服 ","date":"2021-06-08","objectID":"/java-audition-note/:1:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向过程 面向过程会将任务拆解成一系列的步骤(函数)，1、打开洗衣机—\u003e2、放衣服–\u003e3、放洗衣粉—\u003e4、清洗—–\u003e5、烘干 面向对象会拆出人和洗衣机两个对象: 人:打开洗衣机放衣服放洗衣粉洗衣机:清洗烘干 从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护 ","date":"2021-06-08","objectID":"/java-audition-note/:1:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"封装 封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项内部细节对外部调用透明，外部调用无需修改或者关心内部实现 两个经典的场景 1、javabean举例： javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改 private string name ; public void setName(string name){ this.name = \"tuling_\"+name; } 该name有自己的命名规则，明显不能由外部直接赋值 2、orm框架举例 操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可 ","date":"2021-06-08","objectID":"/java-audition-note/:1:4","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"继承 继承基类的方法，并做出自己的改变和/或扩展 子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的 ","date":"2021-06-08","objectID":"/java-audition-note/:1:5","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"多态 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。 继承，方法重写，父类引用指向子类对象 父类类型变量名=new子类对象; 变量名.方法名(); 无法调用子类特有的功能 ","date":"2021-06-08","objectID":"/java-audition-note/:1:6","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、JVM性能调优实战相关 ","date":"2021-06-08","objectID":"/java-audition-note/:2:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"3、JDK JRE JVM ","date":"2021-06-08","objectID":"/java-audition-note/:3:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JDK Java Develpment Kit java开发工具 ","date":"2021-06-08","objectID":"/java-audition-note/:3:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JRE Java Runtime Environment java运行时环境 ","date":"2021-06-08","objectID":"/java-audition-note/:3:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JVM: java Virtual Machine java虚拟机 ","date":"2021-06-08","objectID":"/java-audition-note/:3:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"4、==equals ==和equals比较==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址 equals: object中默认也是采用==比较，通常会重写 Object pub1ic boolean equals(Object obj) { return (this == obj); } String pub1ic boolean equals (Object anObject) { if(this ==anobject) { return true; } if (anObject instanceof String) i String anotherstring = (String)anobject; int n = value.length; if (n == anotherstring.value.length) { char v1[] = value; char v2[] = anotherstring. value;int i = o; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。 public class StringDemo { public static void main(string args[]) { String str1 = \"He11o\"; String str2 new string ( \"He11o\"); String str3 = str2; //引用传递 System.out.println(str1 == str2); //false System.out.println(str1 == str3); // false System.out.println(str2 == str3); // true System.out.println(str1.equals (str2));// true System.out.println(str1.equals (str3));//true System.out.println(str2.equals (str3)); // true } } ","date":"2021-06-08","objectID":"/java-audition-note/:4:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"5、final ","date":"2021-06-08","objectID":"/java-audition-note/:5:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、简述final作用 最终的 修饰类:表示类不可被继承 修饰方法:表示方法不可被子类覆盖，但是可以重载 修饰变量:表示变量一旦被赋值就不可以更改它的值。 (1)修饰成员变量 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。 (2）修饰局部变量 系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。 因此使用final修饰局部变量时，即可以在定义时指定默认值（后面的代码不能对变量再赋值)，也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次) pub1ic class Fina1var { final static int a = 0;//再声明的时候就需要赋值或者静态代码块赋值 /** static{ a =o; } */ final int b = 0;//再声明的时候就需要赋值或者代码块中赋值或者构造器赋值 /*{ b = 0; } */ public static void main(string[]args) { final int localA;//局部变量只声明没有初始化，不会报错,与fina1无关。 loca1A = 0;//在使用之前一定要赋值I //localA = 1;但是不允许第二次赋值 } } (3）修饰基本类型数据和引用类型数据 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改; 如果是引用类型的变量，则在对某初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。 pub1ic class Fina1ReferenceTest{ public static void main(){ final int[] iArr={1,2,3,4}; iArr[2]=-3;//合法 iArr=nu1;//非法，对iArr不能重新赋值 final Person p = new Person(25); p.setAge(24);//合法 p=null;//非法 } } 为什么局部内部类和匿名内部类只能访问局部final变量? 编译之后会生成两个class文件，Test.class Test1.class public class Test { public static void main(string[] args){} //局部fina1变量a,b public void test(final int b) { final int a = 10; //匿名内部类 new Thread(){ pub1ic void run() i System.out.print1n(a); System.out.print1n(b); }; }.start(); } } c1ass outc1ass { private int age = 12; public void outPrint(final int x) { c1ass Inclass i pub1ic void InPrint() { System. out.println(x); System.out.println(age); } } new Inc1ass(().InPrint(; } } ","date":"2021-06-08","objectID":"/java-audition-note/:5:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、为什么局部内部类和匿名内部类只能访问局部final变量? 首先需要知道的一点是:内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 这里就会产生问题:当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾:内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的\"copy\"。这样就好像延长了局部变量的生命周期 将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的,也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢? 就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。 ","date":"2021-06-08","objectID":"/java-audition-note/:5:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ","date":"2021-06-08","objectID":"/java-audition-note/:6:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ArrayList: 基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) ","date":"2021-06-08","objectID":"/java-audition-note/:6:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"LinkedList: 基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐—遍历 遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexof等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:6:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"6、Stringbuilfer String、StringBuffer、StringBuilder String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和stringBuilder都是在原对象上操作 StringBuffer是线程安全的，StringBuilder线程不安全的 StringBuffer方法都是synchronized修饰的 性能: StringBuilder \u003e StringBuffer \u003e String 场景:经常需要改变字符串内容时使用后面两个 优先使用StringBuilder，多线程使用共享变量时使用StringBuffer ","date":"2021-06-08","objectID":"/java-audition-note/:7:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"7、重载和重写的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:8:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 ","date":"2021-06-08","objectID":"/java-audition-note/:8:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重写 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类就不能重写该方法。 public int add(int a,String b) public string add(int a,String b)//编译报错,产生二义性，并不知道返回什么值 ","date":"2021-06-08","objectID":"/java-audition-note/:8:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"8、接口和抽象类的区别 抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。（java8之前，java9变了） 抽象类只能继承一个，接口可以实现多个。 接口的设计目的，是对类的行为进行约束（更准确的说是一种“有\"约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。 而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来(否则当调用到A-B时，无法执行)。 抽象类是对类本质的抽象，表达的是is a 的关系，比如: BMw is a car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是like a的关系。比如: Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 使用场景:当你关注一个事物的本质的时候，用抽象类;当你关注一个操作的时候，用接口。 抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。 ","date":"2021-06-08","objectID":"/java-audition-note/:9:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"9、List和Set的区别 List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用lterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下表的元素 Set:无序，不可重复，最多允许有一个Nul元素对象，取元素时只能用lterator接口取得所有元素，在逐一遍历各个元素 ","date":"2021-06-08","objectID":"/java-audition-note/:10:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"10、hashCode与equals ","date":"2021-06-08","objectID":"/java-audition-note/:11:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"hashCode介绍 hashCode()的作用是获取哈希码，也称为散列码;它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-value)，它的特点是:能根据\"键\"快速的检索出对应的“值\"。这其中就利用到了散列码!(可以快速找到所需要的对象) ","date":"2021-06-08","objectID":"/java-audition-note/:11:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"为什么要有hashCode 以\"Hashset如何检查重复\"为例子来说明为什么要有hashcode: 对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals ()方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。 如果两个对象相等，则hashcode—定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的·因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 因此,equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如 何都不会相等（即使这两个对象指向相同的数据） ","date":"2021-06-08","objectID":"/java-audition-note/:11:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ArrayList:基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过geti)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:12:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"12、HashMap和HashTable的区别?底层实现是什么? 1.区别: (1) HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全; (2)HashMap允许key和value为null，而HashTable不允许 2.底层实现:数组+链表实现 jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标， 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组， 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表 key为null，存在下标0的位置 数组扩容 ","date":"2021-06-08","objectID":"/java-audition-note/:13:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"13、ConcurrentHashMap原理,jdk7和jdk8版本的区别 jdk7: 数据结构:ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构 元素查询:二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部 锁: Segment分段锁Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度 为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment get方法无需加锁，volatile保证(避免脏数据) jdk8: 数据结构: synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性 查找，替换，赋值操作都使用CAS 锁:锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容 读操作无锁: Node的val和next使用volatile修饰，读写线程对该变量互相可见 数组用volatile修饰，保证扩容时被读线程感知 ","date":"2021-06-08","objectID":"/java-audition-note/:14:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"14、如何实现一个IOC容器 配置文件配置包扫描路径 递归包扫描获取.class文件 反射、确定需要交给IOC管理的类 对需要注入的类进行依赖注入 配置文件中指定需要扫描的包路径 定义一些注解，分别表示访问控制层、业务服务层、数据持久层、 依赖注入注解、获取配置文件注解 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储 遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个lOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入 ","date":"2021-06-08","objectID":"/java-audition-note/:15:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"15、什么是字节码?采用字节码的好处是什么? java中的编译器和解释器: Java中引入了虚拟机的概念，即在机器和编译程序之间加入了 -层抽象的虚拟的机器。这台虚拟的机器在任何平台 上都提供给编译程序一个的共同的接口。 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。 每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。 Java源代码—\u003e编译器—\u003ejvm可执行的Java字节码(即虚拟指令)—\u003ejvm—\u003ejvm中解释器—-\u003e机器可执行的二进制机器码—-\u003e程序运行。 采用字节码的好处: Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 ","date":"2021-06-08","objectID":"/java-audition-note/:16:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"34、谈谈你对AOP的理解 系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用 AOP:将程序中的交叉业务逻辑(比如安全，日志，事务等)，封装成一个切面，然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情 ","date":"2021-06-08","objectID":"/java-audition-note/:17:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"35、谈谈你对IOC的理解 ","date":"2021-06-08","objectID":"/java-audition-note/:18:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"容器概念、控制反转、依赖注入 ioc容器:实际上就是个map (key,value)，里面存的是各种对象（在xml里配置的bean节点、@repository.@service、@controller、@component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。 这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(autowired.resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入; id就是对象名）。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"控制反转: 没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转\"这个名称的由来。 全部对象的控制权全部上缴给\"第三方\"“OC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似\"粘合剂的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂”，对象与对象之间会彼此失去联系，这就是有人把lOC容器比喻成′粘合剂\"的由来。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"依赖注入: “获得依赖对象的过程被反转了\"。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"66、简述MylSAM和InnoDB的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:19:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"MyISAM: 不支持事务，现在支持了，但是每次查询都是原子的;支持表级锁，即每次操作是对整个表加锁;存储表的总行数; 一个MyISAM表有三个文件:索引文件、表结构文件、数据文件; 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯—性。 ","date":"2021-06-08","objectID":"/java-audition-note/:19:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"lnnoDB: 支持ACID的事务，支持事务的四种隔离级别;支持行级锁及外键约束:因此可以支持写并发;不存储总行数; 一个InnoDB引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能 为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为2G)，受操作系统文件大小的限制; ","date":"2021-06-08","objectID":"/java-audition-note/:19:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"88、Spring Cloud和Dubbo的区别 底层协议: springcloud基于http协议，dubbo基于Tcp协议，决定了dubbo的性能相对会比较好 注册中心: Spring Cloud 使用的eureka , dubbo推荐使用zookeeper 模型定义: dubbo将一个接口定义为一个服务，SpringCloud则是将一个应用定义为一个服务 SpringCloud是一个生态，而Dubbo是SpringCloud生态中关于服务调用一种解决方案(服务治理) ","date":"2021-06-08","objectID":"/java-audition-note/:20:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ACID靠什么保证的? A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql C一致性由其他三大特性保证、程序代码要保证业务上的一致性 I隔离性由MVCC来保证 D持久性由内存+redo log来保证，Mysq|修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redolog恢复 InnoDB redo log写盘，InnoDB事务进入prepare状态。 如果前面prepare成功，bin1og 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么、InnoDB事务则进入commit状态(在 redo log 里面写一个commit记录) redolog的刷盘会在系统空闲时进行 ","date":"2021-06-08","objectID":"/java-audition-note/:21:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"end ","date":"2021-06-08","objectID":"/java-audition-note/:22:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Total"],"content":"Error inflating class com.baidu.mapapi.map.MapView关于集成百度地图时的问题","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"快乐报错 Error inflating class com.baidu.mapapi.map.MapView ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:1:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"这个也是百度地图调用过程中的步骤，亦可作为参考 集成百度地图时遇到的问题,纠缠我了半天,网上各种方法都试过了,还是一如既往.最后仔细看了一下开发文档,擦.原来这面出问题了.知道遇到问题的你肯定会很急,闲话不说下面就请看: 看好了啊,如果你的这些都配置好了,见下面这7张图里面的配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:1","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"1.你的app–libs文件夹那个BaiduLBS_Android.jar,有没有放置好 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:2","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"2.app–src–main–jinLibs文件夹有没有放置,并把里面的那几个文件夹复制进去 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:3","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"3.清单文件中百度地图的ak配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:4","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"4.Application的自定义子类有没有在清单文件节点下配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:5","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"5.在自定义的那个Application的onCreate方法中要进行百度地图的初始化 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:6","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"6.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:7","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"7.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:8","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"8.如果上面都配置好了会报那个错误 ,就看看开发文档的这一句话 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:9","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"9（我的问题）模拟器没联网（F*CK） 用虚拟机上的Chrome无法上网 解决办法见我的另一篇文章：Android studio模拟器无法联网问题解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:10","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"Android studio模拟器无法联网问题解决办法","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"出现问题 重装系统后安装了Android studio 4.2.1，记得之前用模拟器联网的时候都是直接在模拟器内部打开网络连接就好，现在不行了，不知道之前怎么操作就能联网，反正当时一点都不纠结。 查阅了网上很多解决方法，结果都调试不通。 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:1:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"解决办法 只有用一个蠢办法，虽然只管一次，模拟器或者cmd一关下次打开就必须这个操作，但是为了官方模拟器的颜值和操作速度，我忍了…. 先配置了一个环境变量，避免每次从cmd中输入指令都要 cd 进入emulator文件夹 C:\\Users\\User(注意换成自己的电脑用户名)\\AppData\\Local\\Android\\Sdk\\emulator 模拟器联网：cmd中输入如下 emulator -avd Pixel_2_API_30 -dns-server 8.8.8.8,114.114.114.114 Pixel_2_API_30 是我的使用的模拟器 备注：模拟器调试快捷 Ctrl+M ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:2:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"闲聊 曾经折腾黑苹果、VM的MacOS虚拟机，MacOS虚拟机也得配置DNS不然无法联网，不懂底层机制，求大佬赐教 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:3:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Learning","note"],"content":"记录回溯算法相关的笔记","date":"2021-06-04","objectID":"/backtracking-note/","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":" 通俗的讲，回溯法约等于递归里面嵌套for循环 ","date":"2021-06-04","objectID":"/backtracking-note/:0:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法问题类型 组合类 数组子数列 切割类 回文子串 子集类 类似组合 排列类 有序的组合 棋盘类 n皇后 ","date":"2021-06-04","objectID":"/backtracking-note/:1:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"问题解决思路 将回溯问题抽象为一棵n叉树，水平方向（广度）的循环使用for循环来解决，垂直方向（深度）的循环使用递归来解决 ","date":"2021-06-04","objectID":"/backtracking-note/:2:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"伪代码 void backTracking(args){ if(termination)//终止条件 collect result;//收集结果 return result;//返回结果 } for(each item in Set){//集合元素 processing node;//处理节点 recurrence function;//递归函数 backTrack operation;//回溯操作 } return final result;//返回最终结果 ","date":"2021-06-04","objectID":"/backtracking-note/:3:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法基本步骤 递归参数返回值 确定终止条件 单层递归逻辑 ","date":"2021-06-04","objectID":"/backtracking-note/:4:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Operation"],"content":"之前编辑文件卡住，再次Vim查看文件报错","date":"2021-06-01","objectID":"/vim-again-swap-error/","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"发现问题 之前使用xshell编辑文件时xshell卡住，无奈关闭xshell标签重新来过，再次vim查看文件报错 E325: ATTENTION Found a swap file by the name \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" owned by: root dated: Tue Jun 1 09:24:28 2021 file name: /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml modified: YES user name: root host name: 111.47.28.118 process ID: 10535 (still running) While opening file \"/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" dated: Thu Apr 8 01:26:02 2021 (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \":recover\" or \"vim -r /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" to recover the changes (see \":help recovery\"). If you did this already, delete the swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" to avoid this message. Swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" already exists! [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: ","date":"2021-06-01","objectID":"/vim-again-swap-error/:1:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决思路 这是由于之前我的编辑这个文件的时候卡顿了，所以在交换区产生了文件，并没有对源文件覆盖， 我修改的东西是按照文档改的，而且并没有很多，于是就把交换区的文件删除了就拉到，要是修改了很多建议看一下对比一下两个文件的区别，在觉得删除或是剪切过来继续用都行，剪切过来记得改名字就行 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:2:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决办法 删除指令 rm /var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp 在编辑就没有报错了 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:3:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"反思 Linux文件修改机制，先再交换区创建副本，进行编辑，执行保存的化就从暂存区把文件弄过来。一旦出现了问题，改变了的文件和源文件都在便于运维人员进行容错管理文件。 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:4:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Learning","note"],"content":"记录动态规划三种题型的笔记","date":"2021-05-29","objectID":"/dynamic-program/","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":" 动态规划满足最优化原理和无后效性 ","date":"2021-05-29","objectID":"/dynamic-program/:0:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划三种题型 ","date":"2021-05-29","objectID":"/dynamic-program/:1:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"1.计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic-program/:1:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"2.求最大最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 ","date":"2021-05-29","objectID":"/dynamic-program/:1:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"3.求存在性 取石子游戏,先手是否必胜 能不能选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic-program/:1:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划四个组成部分 ","date":"2021-05-29","objectID":"/dynamic-program/:2:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"1.确定状态 状态在动态规划中的作用属于定海神针 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么 类似于解数学题中，X，Y，Z代表什么 确定状态需要两个意识: 最后一步 保证最后一个问题减小规模问题不变，且结论不矛盾 子问题：问题一样，规模变小 研究最优策略的最后一步化为子问题 ","date":"2021-05-29","objectID":"/dynamic-program/:2:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"2.转移方程 根据子问题直接得到 ","date":"2021-05-29","objectID":"/dynamic-program/:2:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"3.初始条件和边界条件 不重不漏（易说不易做 ） ","date":"2021-05-29","objectID":"/dynamic-program/:2:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"4.计算顺序 自顶向下或自底向上，整体思路的体现，即能利用之前的结果进行计算，去掉重复计算的步骤 神奇的注意点（动规五部曲） dp数组以及下标的含义？二维一维数组中的i、j是什么意思 递推公式，不言而喻 dp数组的初始化 遍历顺序（0/1背包问题为什么要先遍历背包后遍历物品，反过来是否可以；完全背包问题排列和组合for循环不同） 打印dp数组，用于debug，清晰思路 ","date":"2021-05-29","objectID":"/dynamic-program/:2:4","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划基本类型 坐标型：dp数组下标为原来坐标，代表题型UniquePath 序列型：dp数组下标为前i个，错开一个 划分型：划分数组，每组满足一定性质 区间型：用f[i][j]解决 背包型：各种背包装载问题（区间） 最长子序列型：dp数组下标为原来坐标，代表题型最长上升子序列 博弈型：计算必胜或必败 综合型：综合前面两种（如区间+博弈、动态+划分）或动态和其他算法（如动态+二分查找、动态+子母树 ） ","date":"2021-05-29","objectID":"/dynamic-program/:3:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划时间空间优化 Follow Up常考 滚动数组 降维 ","date":"2021-05-29","objectID":"/dynamic-program/:4:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划打印路径（解） ","date":"2021-05-29","objectID":"/dynamic-program/:5:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"动态规划基本题型 动归基础 斐波那契额数列 爬楼梯问题 背包问题 打家劫舍 树形dp（leetcode就三道题） 股票问题 买卖时间最大利润 子序列问题 最长子序列 最长连续递增子序列 编辑距离问题，两个字符串，最小编辑数使字符串相等。 ","date":"2021-05-29","objectID":"/dynamic-program/:6:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Learning","note"],"content":"拔尖类型题目，与我无关：区间dp、概率dp、 ","date":"2021-05-29","objectID":"/dynamic-program/:6:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic-program/"},{"categories":["Total"],"content":"Android Studio 使用Device File Explorer管理安卓虚拟设备的文件","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":" Android Studio 使用Device File Explorer管理安卓虚拟设备的文件 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:0:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Android Device Monitor 新版的Android Studio已经把Android Device Monitor移除菜单栏了，如果要查看虚拟设备的内部文件，需要在AndroidSDK的安装目录中，右键以管理员身份打开tools文件夹中的monitor.bat。 这样做不太方便。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:1:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Device File Explorer 有两种方式可以打开Device File Explorer 直接点击界面右下角的Device File Explorer 在菜单栏，选择 View–\u003eTool Windows–\u003eDevice File Explorer，即可打开查看虚拟设备内部文件的界面。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:2:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导出文件 在Device File Explorer中，如果想将设备中的文件导出到电脑本地。 选中文件–\u003e右键选择“Save as”（快捷键 ctrl+shift+s），弹出如下界面，选择任意文件夹保存即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:3:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导入文件 选中虚拟设备中的文件夹，右键Upload 选择想要导入的文件，点击OK，即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:4:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"其他支持 使用Device File Explorer非常方便，还支持其他新建文件、文件夹、删除等操作。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:5:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Back","note"],"content":"记录Java开发过程中的一些笔记","date":"2021-05-25","objectID":"/java-note/","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Oracle Java 下载JDK账号 目前在官网下载低于jdk1.8的Java jdk的时候需要登陆，这边分享一个账号，方便下载 账号：2696671285@qq.com 密码：Oracle123 ","date":"2021-05-25","objectID":"/java-note/:1:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java获取系统时间 import java.util.Date; import java.text.SimpleDateFormat; public class NowString { public static void main(String[] args) { SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 System.out.println(df.format(new Date()));// new Date()为获取当前系统时间 } } ","date":"2021-05-25","objectID":"/java-note/:2:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java代码实现double类型数字格式化为百分数 public class PercentTest { public static void main(String[] args) { double rate = 0.26535; NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留位数 nf.setMaximumFractionDigits(2);//小数点前保留位数 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 String percent = nf.format(rate); System.out.println(percent); } } 舍入模式 UP：远离零方向舍入的舍入模式。始终对非零舍弃部分前面的数字加 1。注意，此舍入模式始终不会减少计算值的绝对值。 示例： 输入数字 使用 UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 DOWN：向零方向舍入的舍入模式。从不对舍弃部分前面的数字加 1（即截尾）。注意，此舍入模式始终不会增加计算值的绝对值。 示例： 输入数字 使用 DOWN 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 CEILING：向正无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.UP；如果结果为负，则舍入行为类似于 RoundingMode.DOWN。注意，此舍入模式始终不会减少计算值。 示例： 输入数字 使用 CEILING 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 FLOOR：向负无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.DOWN；如果结果为负，则舍入行为类似于RoundingMode.UP。注意，此舍入模式始终不会增加计算值。 示例： 输入数字 使用 FLOOR 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 HALF_UP： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。如果被舍弃部分 \u003e= 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。注意，此舍入模式就是通常学校里讲的四舍五入。 示例： 输入数字 使用 HALF_UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -3 -5.5 -6 HALF_DOWN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。如果被舍弃部分 \u003e 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。 示例： 输入数字 使用 HALF_DOWN 舍入模式 5.5 5 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -5 HALF_EVEN： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为同 RoundingMode.HALF_UP；如果为偶数，则舍入行为同RoundingMode.HALF_DOWN。注意，在重复进行一系列计算时，此舍入模式可以在统计上将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。此舍入模式类似于 Java 中对float 和double 算法使用的舍入策略。 示例： 输入数字 使用 HALF_EVEN 舍入模式 5.5 6 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -6 UNNECESSARY：用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。如果对生成精确结果的操作指定此舍入模式，则抛出 ArithmeticException。 示例： 输入数字 使用 UNNECESSARY 舍入模式 5.5 抛出 ArithmeticException 2.5 抛出 ArithmeticException 1.6 抛出 ArithmeticException 1.1 抛出 ArithmeticException 1.0 1 -1.0 -1 -1.1 抛出 ArithmeticException -1.6 抛出 ArithmeticException -2.5 抛出 ArithmeticException -5.5 抛出 ArithmeticException ","date":"2021-05-25","objectID":"/java-note/:3:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java双端队列Deque使用详解 Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。 ","date":"2021-05-25","objectID":"/java-note/:4:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Deque有三种用途： 普通队列(一端进另一端出): Queue queue = new LinkedList()或Deque deque = new LinkedList() 双端队列(两端都可进出) Deque deque = new LinkedList() 堆栈 Deque deque = new LinkedList() 注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。 Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。 下表总结了上述 12 种方法： \r\r第一个元素 (头部)\r最后一个元素 (尾部)\r\r\r\r抛出异常\r特殊值\r抛出异常\r特殊值\r\r\r插入\raddFirst(e)\rofferFirst(e)\raddLast(e)\rofferLast(e)\r\r\r删除\rremoveFirst()\rpollFirst()\rremoveLast()\rpollLast()\r\r\r检查\rgetFirst()\rpeekFirst()\rgetLast()\rpeekLast()\r\r\r\rDeque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示： Queue方法 等效Deque方法 add add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示： 堆栈方法 等效Deque方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() ","date":"2021-05-25","objectID":"/java-note/:4:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Queue队列操作 方法名 作用 区别 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false offer 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 ","date":"2021-05-25","objectID":"/java-note/:5:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"数组操作 数组的初始化填充 int[] iL = new int[100]; //将数组填充为100个-1 Arrays.fill(iL,-1) ","date":"2021-05-25","objectID":"/java-note/:6:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"字符串操作 String根据下标访问 String s = \"abcd\" Char c = s.charAt(0)//c结果为a ","date":"2021-05-25","objectID":"/java-note/:7:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java中的« 和 » 和 »\u003e 详细分析 ","date":"2021-05-25","objectID":"/java-note/:8:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"«表示左移移，不分正负数，低位补0；　 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 « 2 　20的二进制补码：0001 0100 　向左移动两位后：0101 0000 　结果：r = 80 负数：r = -20 « 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制反码 ***：*1110 1011 　-20 的二进制补码 ：1110 1100 　左移两位后的补码：1011 0000 　反码：**1010 1111 ** 　原码：**1101 0000 ** 　结果：**r = -80 ** ","date":"2021-05-25","objectID":"/java-note/:8:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"»表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 » 2 　20的二进制补码：0001 0100 　向右移动两位后：0000 0101 　结果：r = 5 负数：r = -20 » 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制反码 **：1110 1011 ** 　-20 的二进制补码 ：1110 1100 　右移两位后的补码：1111 1011 　反码：1111 1010 　原码：1000 0101 　结果：r = -5 ","date":"2021-05-25","objectID":"/java-note/:8:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"»\u003e表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数：　r = 20 »\u003e 2 　的结果与 r = 20 » 2 相同； 负数：　r = -20 »\u003e 2 注：以下数据类型默认为int 32位 　-20:源码：10000000 00000000 00000000 00010100 　反码：11111111 11111111 11111111 11101011 　补码：11111111 11111111 11111111 11101100 　右移：00111111 11111111 11111111 11111011 　结果：r = 1073741819 ","date":"2021-05-25","objectID":"/java-note/:8:3","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"操作系统控制台中查看Java进程 ","date":"2021-05-25","objectID":"/java-note/:9:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"一、Linux篇 方法一 ps -ef|grep java 方法二 jps -l （显示java进程的Id和软件名称） jps -lmv（显示java进程的Id和软件名称；显示启动main输入参数；虚拟机参数） ","date":"2021-05-25","objectID":"/java-note/:9:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"二、Windows篇 jps jps -l（显示java进程的Id和软件路径及名称） ","date":"2021-05-25","objectID":"/java-note/:9:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java8 stream().map().collect()用法 ","date":"2021-05-25","objectID":"/java-note/:10:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"集合 List\u003cUser\u003e users = getList(); //从数据库查询的用户集合 现在想获取User的身份证号码；在后续的逻辑处理中要用； 常用的方法我们大家都知道，用for循环， List\u003cString\u003e idcards=new ArrayList\u003cString\u003e();//定义一个集合来装身份证号码 for(int i=0;i\u003cusers.size();i++){ idcards.add(users.get(i).getIdcard()); } 这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定： List\u003cString\u003e idcards= users.stream().map(User::getIdcard).collect(Collectors.toList()) 解释下一这行代码： users：一个实体类的集合，类型为List\u003cUser\u003e User：实体类 getIdcard：实体类中的get方法，为获取User的idcard ","date":"2021-05-25","objectID":"/java-note/:10:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"stream()优点 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 stream().map()方法的使用示例: ","date":"2021-05-25","objectID":"/java-note/:10:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"其他例子 再看几个例子：数组字母小写变大写 List\u003cString\u003e list= Arrays.asList(\"a\", \"b\", \"c\", \"d\"); List\u003cString\u003e collect =list.stream().map(String::toUpperCase).collect(Collectors.toList()); System.out.println(collect); //[A, B, C, D] 数组所有元素，按某种规律计算： List\u003cInteger\u003e num = Arrays.asList(1,2,3,4,5); List\u003cInteger\u003e collect1 = num.stream().map(n -\u003e n * 2).collect(Collectors.toList()); System.out.println(collect1); //[2, 4, 6, 8, 10] ","date":"2021-05-25","objectID":"/java-note/:10:3","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"深入理解Java双冒号(::)运算符的使用 Jdk8中有好多新的特性，比如引入Lambda，简化代码的书写等等 我们先看一个关于Lambda的使用 /** * 输出list */ @Test public void test() { String[] array = {\"aaaa\", \"bbbb\", \"cccc\"}; List\u003cString\u003e list = Arrays.asList(array); //Java 7 for(String s:list){ System.out.println(s); } //Java 8 list.forEach(System.out::println); } 其中list.forEach(System.out::println);就是Java 8中的Lambda写法之一， 有没有特别注意到输出语句跟我们平时写的syso语句不一样，常规输出语句是这样的： System.out.println(\"流浪地球拍的不错哦！\"); 这里面使用到了::， 有点意思，来认识一下这个新东西！ ","date":"2021-05-25","objectID":"/java-note/:11:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"双冒号（::） 英文：double colon，双冒号（::）运算符在Java 8中被用作方法引用（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。为此，方法引用需要由兼容的函数接口组成的目标类型上下文。 Method References You use lambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it’s often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name. 关于方法引用的描述，摘自oracle官网 大致意思是，使用lambda表达式会创建匿名方法， 但有时候需要使用一个lambda表达式只调用一个已经存在的方法（不做其它）， 所以这才有了方法引用！ 以下是Java 8中方法引用的一些语法： 静态方法引用（static method）语法：classname::methodname 例如：Person::getAge 对象的实例方法引用语法：instancename::methodname 例如：System.out::println 对象的超类方法引用语法： super::methodname 类构造器引用语法： classname::new 例如：ArrayList::new 数组构造器引用语法： typename[]::new 例如： String[]:new 如果上的语法太枯燥，那就通过一些例子来加强对它的理解： 静态方法语法使用例子： import java.util.Arrays; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.ComponentScan; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ @RunWith(SpringJUnit4ClassRunner.class) @ComponentScan(\"com.zhoufy\") public class Demo { @Test public void test() { List\u003cString\u003e list = Arrays.asList(\"aaaa\", \"bbbb\", \"cccc\"); //静态方法语法 ClassName::methodName list.forEach(Demo::print); } public static void print(String content){ System.out.println(content); } } 类实例方法语法使用例子： import java.util.Arrays; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.ComponentScan; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ @RunWith(SpringJUnit4ClassRunner.class) @ComponentScan(\"com.zhoufy\") public class Demo { @Test public void test() { List\u003cString\u003e list = Arrays.asList(\"aaaa\", \"bbbb\", \"cccc\"); //对象实例语法 instanceRef::methodName list.forEach(new Demo()::print); } public void print(String content){ System.out.println(content); } } 超类方法语法使用例子： import java.util.Arrays; import java.util.List; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.ComponentScan; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * @author zhoufy * @date 2019年2月20日 下午2:41:38 */ @RunWith(SpringJUnit4ClassRunner.class) @ComponentScan(\"com.zhoufy\") public class Example extends BaseExample{ @Test public void test() { List\u003cString\u003e list = Arrays.asList(\"aaaa\", \"bbbb\", \"cccc\"); //对象的超类方法语法： super::methodName list.forEach(super::print); } } class BaseExample { public void print(String content){ System.out.println(content); } } 类构造器语法使用例子： import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.context.annotation.ComponentScan; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ @RunWith(SpringJUnit4ClassRunner.class) @ComponentScan(\"com.zhoufy\") public class Example { @Test public void test() { InterfaceExample com = Example::new; Example bean = com.create(); System.out.println(bean); } } interface InterfaceExample{ Example create(); } 如果是带参数的构造器，示例如下： /** * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ public class Example { private String name; Example(String name){ this.name = name; } public static void main(String[] args) { InterfaceExample com = Example::new; Example bean = com.create(\"hello world\"); System.out.println(bean.name); } } interface InterfaceExample{ Example create(String name); } 这里需要特别注意的是：Example 类并没有implements InterfaceExample接口哦！！！ 数组构造器语法使用例子： import java.util.function.Function; /** * @author zhoufy * @date 2019年2月20日 下午2:19:13 */ public class Example { public static void main(String[] args) { Function \u003cInteger, Example[]\u003e function = Example[]::new; Example[] array = function.apply(4); //这里的4是数组的大小 for(Example e:","date":"2021-05-25","objectID":"/java-note/:11:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java this()与super()使用详解 这几天看到类在继承时会用到this和super，这里就做了一点总结，与各位共同交流，有错误请各位指正~ this this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种： 1.普通的直接引用 这种就不用讲了，this相当于是指向当前对象本身。 2.形参与成员名字重名，用this来区分： class Person { private int age =10; public Person(){ System.out.println(\"初始化年龄：\"+age); } public int GetAge(int age){ this.age = age; return this.age; } } public class test1 { public static void main(String[] args) { Person Harry =new Person(); System.out.println(\"Harry's age is \"+Harry.GetAge(12)); } } 运行结果： 初始化年龄：10 Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 3.引用构造函数 这个和super放在一起讲，见下面。 super super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super也有三种用法： 1.普通的直接引用 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名 class Country { String name; void value() { name =\"China\"; } } class Cityextends Country { String name; void value() { name =\"Shanghai\"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); } public static void main(String[] args) { City c=new City(); c.value(); } } 运行结果： Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 3.引用构造函数 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 class Person { public static void prt(String s) { System.out.println(s); } Person() { prt(\"父类·无参数构造方法： \"+\"A Person.\"); }//构造方法(1) Person(String name) { prt(\"父类·含一个参数的构造方法： \"+\"A person's name is \" + name); }//构造方法(2) } public class Chineseextends Person { Chinese() { super();// 调用父类构造方法（1） prt(\"子类·调用父类”无参数构造方法“： \"+\"A chinese coder.\"); } Chinese(String name) { super(name);// 调用父类具有相同形参的构造方法（2） prt(\"子类·调用父类”含一个参数的构造方法“： \"+\"his name is \" + name); } Chinese(String name,int age) { this(name);// 调用具有相同形参的构造方法（3） prt(\"子类：调用子类具有相同形参的构造方法：his age is \" + age); } public static void main(String[] args) { Chinese cn =new Chinese(); cn =new Chinese(\"codersai\"); cn =new Chinese(\"codersai\",18); } } 运行结果： 父类·无参数构造方法： A Person. 子类·调用父类”无参数构造方法“： A chinese coder. 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 ","date":"2021-05-25","objectID":"/java-note/:12:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"JAVA中遍历Map的四种方法-大容量Map迭代推荐 ","date":"2021-05-25","objectID":"/java-note/:13:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"前言 java中的集合主要分为三种类型： Set（集） List（列表） Map（映射） **数组：**几乎所有集合实现的底层都有数据的身影存在，因此我们首先需要了解一下数组。以下这段话摘自《Thinking In Algorithm》，感觉很不错现在拿出来跟大家分享。 《Thinking In Algorithm》之数组 **集合：**接下来是集合，同样我们摘自网络上的一段解释，很不错也通俗易懂，与大家分享： 集合与数组 总结一下上面两段话： 数组的大小是固定不变的，并且同一个数组只能存储相同类型的数据，该数据类型可以是基本类型也可以是引用类型。Java中集合可以存储操作不同类型和大小不固定的数据，但是Java中集合只能存储引用类型，不能存储基本类型。 ","date":"2021-05-25","objectID":"/java-note/:13:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Map遍历的代码示例 一、数据准备 Map数据准备 二、迭代示例 1.第一种方式 二次取值方式 2.第二种方式 Iterator遍历 3.第三种方式 entrySet遍历 4.第四种方式 Map.values取值遍历 三、结果展示及总结 不同长度Map迭代结果 结论： 一般来讲使用entrySet的方式进行遍历是效率最高的，因为hashMap内部的存储结构就是基于Entry的数组，在用这种方式进行遍历时，只需要遍历一次即可。而使用其他方式的时间复杂度可以会提高，例如：keySet方式，每次都需要通过key值去计算对应的hash,然后再通过hash获取对应的结果值，因此效率较低。 ","date":"2021-05-25","objectID":"/java-note/:13:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"谈谈java中遍历Map的几种方法 java中的map遍历有多种方法，从最早的Iterator，到java5支持的foreach,再到java8 Lambda，让我们一起来看下具体的用法以及各自的优缺点 先初始化一个map public class TestMap { public static Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); } ","date":"2021-05-25","objectID":"/java-note/:14:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 // KeySet 获取key public void testKeySet() { for (Integer key : map.keySet()) { System.out.println(key); } } // values 获取value public void testValues() { for (Integer value : map.values()) { System.out.println(value); } } ","date":"2021-05-25","objectID":"/java-note/:14:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 // keySet get(key) 获取key and value public void testKeySetAndGetKey() { for (Integer key : map.keySet()) { System.out.println(key + \":\" + map.get(key)); } } ","date":"2021-05-25","objectID":"/java-note/:14:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"entrySet 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 // entrySet 获取key and value public void testEntry() { for (Map.Entry\u003cInteger, Integer\u003e entry : map.entrySet()) { System.out.println(entry.getKey() + \":\" + entry.getValue()); } } ","date":"2021-05-25","objectID":"/java-note/:14:3","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Iterator 对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 // Iterator entrySet 获取key and value public void testIterator() { Iterator\u003cMap.Entry\u003cInteger, Integer\u003e\u003e it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry\u003cInteger, Integer\u003e entry = it.next(); System.out.println(entry.getKey() + \":\" + entry.getValue()); // it.remove(); 删除元素 } } ","date":"2021-05-25","objectID":"/java-note/:14:4","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Lambda java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 // Lambda 获取key and value public void testLambda() { map.forEach((key, value) -\u003e { System.out.println(key + \":\" + value); }); } ","date":"2021-05-25","objectID":"/java-note/:14:5","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"简单性能测试 用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap static { for (int i = 0; i \u003c 100000; i++) { map.put(i, 1); } } 测试结果如下： KeySet： 392 Values： 320 keySet get(key)： 552 entrySet： 465 entrySet Iterator：508 Lambda： 536 需要说明的是，map存储的数据类型，map的大小，以及map的不同实现方式都会影响遍历的性能，所以该测试结果仅供参考 ","date":"2021-05-25","objectID":"/java-note/:14:6","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"总结 如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 ","date":"2021-05-25","objectID":"/java-note/:14:7","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"BigDecimal ","date":"2021-05-25","objectID":"/java-note/:15:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"几种舍弃精度的算法 测试代码 double i = 2, j = 2.4, k = 2.5, l = 2.6, m = 2.9; System.out.println(\"五舍六入取整:Math.rint(2)=\" + (int) Math.rint(i)); System.out.println(\"五舍六入取整:Math.rint(2.4=\" + (int) Math.rint(j)); System.out.println(\"五舍六入取整:Math.rint(2.5)=\" + (int) Math.rint(k)); System.out.println(\"五舍六入取整:Math.rint(2.6)=\" + (int) Math.rint(l)); System.out.println(\"五舍六入取整:Math.rint(2.9)=\" + (int) Math.rint(m)); System.out.println(\"五舍六入取整: new DecimalFormat(2)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.4)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.5)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整: new DecimalFormat(2.6)=\" + new DecimalFormat(\"0\").format(l)); System.out.println(\"五舍六入取整: new DecimalFormat(2.9)=\" + new DecimalFormat(\"0\").format(i)); System.out.println(\"五舍六入取整:Math.rint(-2)=\" + (int) Math.rint(-i)); System.out.println(\"五舍六入取整:Math.rint(-2.4=\" + (int) Math.rint(-j)); System.out.println(\"五舍六入取整:Math.rint(-2.5)=\" + (int) Math.rint(-k)); System.out.println(\"五舍六入取整:Math.rint(-2.6)=\" + (int) Math.rint(-l)); System.out.println(\"五舍六入取整:Math.rint(-2.9)=\" + (int) Math.rint(-m)); System.out.println(\"五舍六入取整: new DecimalFormat(-2)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.4)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.5)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.6)=\" + new DecimalFormat(\"0\").format(-l)); System.out.println(\"五舍六入取整: new DecimalFormat(-2.9)=\" + new DecimalFormat(\"0\").format(-i)); System.out.println(\"舍掉小数取整:Math.floor(2)=\" + (int) Math.floor(i)); System.out.println(\"舍掉小数取整:Math.floor(2.4)=\" + (int) Math.floor(j)); System.out.println(\"舍掉小数取整:Math.floor(2.5)=\" + (int) Math.floor(k)); System.out.println(\"舍掉小数取整:Math.floor(2.6)=\" + (int) Math.floor(l)); System.out.println(\"舍掉小数取整:Math.floor(2.9)=\" + (int) Math.floor(m)); System.out.println(\"四舍五入取整:new BigDecimal(2).setScale=\" + new BigDecimal(\"2\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.4).setScale=\" + new BigDecimal(\"2.1\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.5).setScale=\" + new BigDecimal(\"2.5\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.6).setScale=\" + new BigDecimal(\"2.6\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(2.9).setScale=\" + new BigDecimal(\"2.9\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"凑整:Math.ceil(2)=\" + (int) Math.ceil(i)); System.out.println(\"凑整:Math.ceil(2.4)=\" + (int) Math.ceil(j)); System.out.println(\"凑整:Math.ceil(2.5)=\" + (int) Math.ceil(k)); System.out.println(\"凑整:Math.ceil(2.6)=\" + (int) Math.ceil(l)); System.out.println(\"凑整:Math.ceil(2.9)=\" + (int) Math.ceil(m)); System.out.println(\"舍掉小数取整:Math.floor(-2)=\" + (int) Math.floor(-i)); System.out.println(\"舍掉小数取整:Math.floor(-2.4)=\" + (int) Math.floor(-j)); System.out.println(\"舍掉小数取整:Math.floor(-2.5)=\" + (int) Math.floor(-k)); System.out.println(\"舍掉小数取整:Math.floor(-2.6)=\" + (int) Math.floor(-l)); System.out.println(\"舍掉小数取整:Math.floor(-2.9)=\" + (int) Math.floor(-m)); System.out.println(\"四舍五入取整:new BigDecimal(-2).setScale=\" + new BigDecimal(\"-2\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.4).setScale=\" + new BigDecimal(\"-2.1\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.5).setScale=\" + new BigDecimal(\"-2.5\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.6).setScale=\" + new BigDecimal(\"-2.6\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"四舍五入取整:new BigDecimal(-2.9).setScale=\" + new BigDecimal(\"-2.9\").setScale(0, BigDecimal.ROUND_HALF_UP)); System.out.println(\"凑整:Math.ceil(-2)=\" + (int) Math.ceil(-i)); System.out.println(\"凑整:Math.ceil(-2.4)=\" + (int) Math.ceil(-j","date":"2021-05-25","objectID":"/java-note/:15:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"特殊的情况 将 double 转换为 BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式。返回的 BigDecimal 的标度是使 $ (10^{scale} × val) $为整数的最小值。 BigDecimal b = new BigDecimal(9.655 ); //double f1 = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); double f1 = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue(); System.out.println(\"f1=\" + f1);//f1=9.65 BigDecimal mData = new BigDecimal(\"9.655\").setScale(2, BigDecimal.ROUND_HALF_UP); System.out.println(\"mData=\" + mData);//mData=9.66 注： 此构造方法的结果有一定的不可预知性。有人可能认为在 Java 中写入 new BigDecimal(0.1) 所创建的 BigDecimal 正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于 0.1000000000000000055511151231257827021181583404541015625。这是因为 0.1 无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入 到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 另一方面，String 构造方法是完全可预知的：写入 new BigDecimal(\"0.1\") 将创建一个 BigDecimal，它正好 等于预期的 0.1。因此，比较而言，通常建议优先使用String` 构造方法。 当 double 必须用作 BigDecimal 的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用 Double.toString(double)方法，然后使用 BigDecimal(String) 构造方法，将 double 转换为 String。要获取该结果，请使用 static valueOf(double) 方法。 ","date":"2021-05-25","objectID":"/java-note/:15:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Map的特点 map 没有无序，不能下标访问，只能通过keyvalue进行访问，能增加随机访问的速度 ","date":"2021-05-25","objectID":"/java-note/:16:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Map的修改 map 直接put进行key，value覆盖修改即可，无需其他操作 ","date":"2021-05-25","objectID":"/java-note/:17:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back"],"content":"解决'Exception in thread 'main' java.util.UnknownFormatConversionException: Conversion = '%''的报错并了解一定的报错机制","date":"2021-05-24","objectID":"/java-pencentage-format-error/","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"问题现象 最近在做一个java项目使用String.format进行控制台打印，结果出现如下错误： 最关键的是这个问题是偶现的，通过google定位到问题还是格式化输出过程中%之间冲突了 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:1:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人类似的问题 百度搜搜发现别人的都是因为System.out.printf引起的。 Java从1.5版本开始才具体格式化输出的功能，才有了printf这个方法，可以通过指定不同的格式来控制输出样式，其中%表示格式说明的起始符号，不可缺少。而我的问题就是因为接口响应的日志中包含了%，导致printf打印时出现异常。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:2:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人解决办法 使用 “%%” 去替换掉字符串中的 “%\",例如： String str = “hello world! % w”; System.out.printf(str.replaceAll(\"%”, “%%\")); ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人结果如下: hello world! % w ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:1","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的解决办法 同样是替换 public class PrintPencentSignalStringError { public static void main(String[] args) { NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留几位 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 // System.out.println(String.format(nf.format(0.67))); System.out.println(String.format(nf.format(0.67).replace(\"%\",\"%%\"))); String str = \"hello world! % w\"; // System.out.printf(str); System.out.printf(str.replace(\"%\",\"%%\")); } } ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:4:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人总结 只要出现了这个错误，不管Conversion = ‘任意字符’ 中是哪个值，那肯定是你使用了printf打印内容，但是其中包括了%这个关键字符，可以使用多加一个百分号来进行转义（%%）就可以正常输出了。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:5:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的想法 这两种输出格式化应该都是因为百分号的冲突问题才报的错，故附上格式化输出的对应表格，看到百分号我才恍然大悟 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:6:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"格式化输出对应表 转换符 详细说明 示例 %s 字符串类型 “喜欢请收藏” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 88 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 8.888 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） 不举例(基本用不到) %h 散列码 不举例(基本用不到) %% 百分比类型 ％(%特殊字符%%才能显示%) %n 换行符 不举例(基本用不到) %tx 日期与时间类型（x代表不同的日期与时间转换符) 不举例(基本用不到) ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:7:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Front","note"],"content":"记录JS笔记和相关示例","date":"2021-05-19","objectID":"/js-note/","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS的padStart()方法,padEnd()方法 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 'abc'.padEnd(10, '0123456789') //\"abc0123456\" 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" '123456'.padStart(10, '0') // \"0000123456\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" ","date":"2021-05-19","objectID":"/js-note/:1:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS获取当前页面源代码 document.documentElement.innerHTML 曾用于Ajax异步请求时，后台返回页面，替换当前页面html代码 Ajax的error用于成功（返回空，代码为404）；success（返回Html，代码为200）用于失败返回页面，替换代码 ","date":"2021-05-19","objectID":"/js-note/:2:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JS 创建变量接收数组 //如字符串的split函数切分后每一个部分为一个数组，存储在arr中 var arr = str.split(\"\"); ","date":"2021-05-19","objectID":"/js-note/:3:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"JavaScript 保留两位小数 ","date":"2021-05-19","objectID":"/js-note/:4:0","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"四舍五入 以下处理结果会四舍五入: var num =2.446242342; num = num.toFixed(2); // 输出结果为 2.45 ","date":"2021-05-19","objectID":"/js-note/:4:1","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Front","note"],"content":"不四舍五入 以下处理结果不会四舍五入。 第一种，先把小数变整数： Math.floor(15.7784514000 * 100) / 100 // 输出结果为 15.77 第二种，当作字符串，使用正则匹配： Number(15.7784514000.toString().match(/^\\d+(?:\\.\\d{0,2})?/)) // 输出结果为 15.77,不能用于整数如 10 必须写为10.0000 **注意：**如果是负数，请先转换为正数再计算，最后转回负数 ","date":"2021-05-19","objectID":"/js-note/:4:2","tags":["JavaScript"],"title":"JS笔记","uri":"/js-note/"},{"categories":["Learning","note\""],"content":"介绍常用的查找表法","date":"2021-05-18","objectID":"/find-table/","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","note\""],"content":"在遍历的同时，记录一些信息，以省去一层循环，这是“以空间换时间”的想法 需要记录已经遍历过的数值和它所对应的下标，可以借助查找表实现 查找表有两个常用的实现: 哈希表 平衡二叉搜索树 ","date":"2021-05-18","objectID":"/find-table/:0:0","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","Note"],"content":"HashMap初始化时为什么建议使用HashMap(int initialCapacity)指定集合大小","date":"2021-05-17","objectID":"/hashmap-initialcapacity/","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"介绍 首先设置一个合理的初始化容量可以提高HashMap的性能 在当我们对HashMap初始化没设置初始化容量时，系统会默认创建一个容量为16的大小的集合。若我们的所需的集合很小则会造成内存浪费，而当HashMap的容量值超过了临界值（threshold)时HashMap将会重新扩容的下一个2的指数幂（16-\u003e32）。HashMap扩容将会重新创建hash表降低性能。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:1:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"方法 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"官方 如果不超过12个键值对，可以不设置 如果超出，按initialCapacity = (需要存储的元素个数 / 负载因子) + 1公式计算后设置 官方的建议是initailCapacity设置成2的n次幂 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:1","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"其他 如何设置一个合理的初始化容量 当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。当HashMap的容量值超过了临界值（threshold)时就会扩容，threshold = HashMap的容量值0.75，比如初始化容量为8的HashMap当大小达到80.75=6时将会扩容到16。当我们设置HashMap的初始化容量是遵循expectedSize /0.75+1，比如expectedSize是6时 6/0.75+1=9，此时jdk处理后会被设置成16，大大降低了HashMap被扩容的几率。 当我们通过HashMap(int initialCapacity)设置初始容量的时候，HashMap并不一定会直接采用我们传入的数值，而是经过计算，得到一个新值，目的是提高hash的效率。(1-\u003e2、3-\u003e4、7-\u003e8、9-\u003e16) HashMap会选择大于初始化值的第一个2的幂作为容量。不然会限制了散列的范围。 HashMap 之所以速度快，因为它使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:2","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"集合介绍 List Set Map 都是接口 List Set继承Collection(Collections是工具类) List子类(有序，可重复)—ArrayList、Vector、LinkedList ArrayList、Vector 底层是数组（查找快，增删慢） 前者线程不安全，后者线程安全 Linkedlist 底层是链表查找慢，增删快 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:3:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"Set（无序，唯一）—HashSet TreeSet LinkedHashSet HashSet 底层是哈希表（hashcode equals） LinkedHashSet 底层是链表和哈希表–插入有序唯一，链表保证有序、哈希表保证唯一 TreeSet 底层结构是红黑树–唯一有序，自然排序、比较器排序 Map HashMap ThreeMap HashTable HashMap HashTable 无序 前者非线程安全，效率高，允许有null（kv），后者线程安全，效率低，不允许null值。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:4:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"TreeMap 有序 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序 \u003c部分整理别人知识点\u003e ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:5:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","note\""],"content":"（详细介绍）什么叫做哈希冲突？什么是负载因子？如何解决哈希冲突？？？","date":"2021-05-16","objectID":"/hash-table/","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"概念： 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为$ O(N) $，平衡树中为树的高度，即$ O(log_2 N) $，搜索的效率取决于搜索过程中元素的比较次数。 理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。 当向该结构中： ","date":"2021-05-16","objectID":"/hash-table/:1:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放 ","date":"2021-05-16","objectID":"/hash-table/:1:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(HashTable)(或者称散列表) 例如：数据集合{1，7，6，4，5，9}； 哈希函数设置为：$ hash(key) = key % capacity$; capacity为存储元素底层空间总的大小。 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快 问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？ ","date":"2021-05-16","objectID":"/hash-table/:1:2","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-概念： 对于两个数据元素的关键字$ k_i $和$ k_j (i != j) $，有$ k_i != k_j $，但有：$ Hash(k_i) == Hash(k_j) $，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。 ","date":"2021-05-16","objectID":"/hash-table/:2:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免： 首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。 两种方式解决冲突 链表式解决（Separate Chaining) 每个数据单元存储数据和next指针，形成链表 开放地址(Open Addressiting) 不用next指针，把其他下标的位置都对外开放。 开放地址的方法: a.线性探测法 冲突后搜索次数线性循环向后放置 b.平方探测(二次方探测) 冲突后根据搜索次数的平方循环向后放置 c.双哈希 ","date":"2021-05-16","objectID":"/hash-table/:3:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-哈希函数设计： 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则： 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间 哈希函数计算出来的地址能均匀分布在整个空间中 哈希函数应该比较简单 常见哈希函数： 1.直接定制法–(常用) 取关键字的某个线性函数为散列地址：$ Hash（Key）= A*Key + B $ 优点：简单、均匀 缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况 2.除留余数法–(常用) 设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：$ Hash(key) = key% p(p\u003c=m)$ ,将关键码转换成哈希地址 还有很多例作为了解：平方取中法，折叠法，随机数法，数学分析法（可以自己查找资料） 注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突 ","date":"2021-05-16","objectID":"/hash-table/:4:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-负载因子调节（重点） 已知哈希表中已有的关键字个数是不可变的，那我们能调整的就只有哈希表中的数组的大小。 ","date":"2021-05-16","objectID":"/hash-table/:5:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决 解决哈希冲突两种常见的方法是：闭散列和开散列 ","date":"2021-05-16","objectID":"/hash-table/:6:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-闭散列： 闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？ 线性探测 比如上面的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，下标为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 插入 通过哈希函数获取待插入元素在哈希表中的位置 如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到 下一个空位置，插入新元素 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他 元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此线性探测采用标 记的伪删除法来删除一个元素。 二次探测： 线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为：$ H_i = (H_0+i^2)% m $，或者： $ H_i = (H_0-i^2)% m $ 其中：i = 1,2,3…， $ H_0 $是通过散列函数Hash(x)对元素的关键码 key进行计算得到的位置，m是表的大小。 对于2.1中如果要插入44，产生冲突，使用解决后的情况为： 研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。 因此：比散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。 ","date":"2021-05-16","objectID":"/hash-table/:6:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-开散列/哈希桶（重点） 开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。 从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。 开散列，可以认为是把一个在大集合中的搜索问题转化为在小集合中做搜索了。 冲突严重时的解决办法： 刚才我们提到了，哈希桶其实可以看作将大集合的搜索问题转化为小集合的搜索问题了，那如果冲突严重，就意味着小集合的搜索性能其实也时不佳的，这个时候我们就可以将这个所谓的小集合搜索问题继续进行转化，例如： 每个桶的背后是另一个哈希表 每个桶的背后是一棵搜索树 ","date":"2021-05-16","objectID":"/hash-table/:7:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"哈希表满了 当哈希表的存储量超过百分之七十（负载因子，默认为0.75），会执行rehashing，即再次哈希，找一个大于原来二倍以上的质数重新进行计算以扩充hash表的容量 代码实现： // key-value 模型 public class HashBucket { private static class Node { private int key; private int value; Node next; public Node(int key, int value) { this.key = key; this.value = value; } } private Node[] array; private int size; // 当前的数据个数 private static final double LOAD_FACTOR = 0.75; public int put(int key, int value) { int index = key % array.length; // 在链表中查找 key 所在的结点 // 如果找到了，更新 // 所有结点都不是 key，插入一个新的结点 for (Node cur = array[index]; cur != null; cur = cur.next) { if (key == cur.key) { int oldValue = cur.value; cur.value = value; return oldValue; } } Node node = new Node(key, value); node.next = array[index]; array[index] = node; size++; if (loadFactor() \u003e= LOAD_FACTOR) { resize(); } return -1; } private void resize() { Node[] newArray = new Node[array.length * 2]; for (int i = 0; i \u003c array.length; i++) { Node next; for (Node cur = array[i]; cur != null; cur = next) { next = cur.next; int index = cur.key % newArray.length; cur.next = newArray[index]; newArray[index] = cur; } } array = newArray; } private double loadFactor() { return size * 1.0 / array.length; } public HashBucket() { array = new Node[8]; size = 0; } public int get(int key) { int index = key % array.length; Node head = array[index]; for (Node cur = head; cur != null; cur = cur.next) { if (key == cur.key) { return cur.value; } } return -1; } } ","date":"2021-05-16","objectID":"/hash-table/:8:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Front"],"content":"解决Uni-App开发组件时控制台报错Error in Created hook: 'TypeError's： Cannot read property 'num' of 'undefined' 的问题","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"Uni-App编写组件的时候，生命周期函数时遇到了使用箭头函数拿不到this的Vue对象的情况 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:0:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"代码 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:1:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"报错 浏览器控制台报下面的错误 created() { } created: () =\u003e { } ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:2:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"原因 箭头函数和普通函数是有区别的，，因为箭头凶数并没有this , this会作为变量一直向上级词法作用域查找，直至找到为止，经常导致Uncaught TypeError: Cannot read property of undefined 或Uncaught TypeError : this.myMethod is not a function之类的错误。 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:3:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"解决 用普通函数替换箭头函数就行了 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:4:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front","note"],"content":"记录使用Vue开发Uni-App小程序的笔记","date":"2021-05-14","objectID":"/vue-uni-app-note/","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"text text组件相当于html的span行布局组件 selectable属性为是否开启可被选中，当前最新版本uni-app的text的selectable属性在小程序端不能使用，暂时测试H5端正常使用 decode属性为开启是否可以解码，当前最新版本uni-app的decode属性现在无论设置为true或false都可以解码（如\u0026amp-\u003e\u0026） ","date":"2021-05-14","objectID":"/vue-uni-app-note/:1:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"view view组件相当于html的div盒子（层、垂直）布局组件，独占一行 hover-start-time、hover-stay-time现在支持字符串的数字，原来需要在属性名前加上冒号:，如:hover-start-time ","date":"2021-05-14","objectID":"/vue-uni-app-note/:2:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"Button 按钮组件，type选择为primary样式后，在H5显示蓝色，在小程序显示绿色 \u003cbutton type=\"primary\"\u003e蓝绿色按钮组件\u003c/button\u003e v-for 需要添加:key作为唯一值否则警告 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:3:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"生命周期 onError只有H5平台支持的生命周期函数，小程序端无效 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:4:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"文件上传 uni.chooseImage在H5端设置count:参数以后是限制不住多的图片上传的，但是在小程序端多的图片不会被上传 previewImage的loop:属性（查看的图片可以循环）在小程序端和H5端不起作用 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:5:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["SoftwareDesign"],"content":"ShellScript（.sh）脚本语法知识，学习编写脚本时的笔记","date":"2021-05-13","objectID":"/powerdesigner-error/","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["SoftwareDesign"],"content":"使用聚合时生成代码以后，需要修改两个role名字为不同，否则a聚合与b时会报a角色名称不唯一 ","date":"2021-05-13","objectID":"/powerdesigner-error/:0:0","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["documentation"],"content":"Hugo生成页面后，本地调试没问题，推到远程发现动画、目录没有生成","date":"2021-05-12","objectID":"/sri-hashes-error/","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"问题来源 Hugo生成页面后，本地调试没问题，推到远程发现首页和文章页面的动画，文章页面的目录没有生成 查看HTML对比并未发现不同怀疑JS 打开控制台，报这个错 Failed to find a valid digest in the 'integrity' attribute for resource 'https://kkkpjskey.github.io/js/theme.min.319518a29ce7d84523d8dfb36ac617794d807f22da6b3a2e11ba33cd8ecfcfc02cf5aabf2034912959a143bdba7573bd.js' with computed SHA-256 integrity 'nvT75FkXevX06WR8vlhFFP02xzhq9qFxLQOuS0LkWyQ='. The resource has been blocked. 查资料发现是SRI不一致的问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:1:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"寻找问题 怀疑Hugo计算SRI的Hashes问题 查看其他CSS等文件，Hashes值是对的，故怀疑主题问题 这是切换主题导致的问题，故还原主题测试发现没问题，怀疑Js文件前后不一致 寻找之前版本的这个js文件，对比，明面上并无差别（Sublime插件对比） 怀疑底层问题，经验所得查看占有的空间大小，差两个字符 不死心于是，使用Winhex肉眼对比，发现了这个 查ASCII表 多了归位键 ","date":"2021-05-12","objectID":"/sri-hashes-error/:2:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"解决 发现有差别就可以用原来的js替换了，问题解决 ","date":"2021-05-12","objectID":"/sri-hashes-error/:3:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"结论 这个字符会影响SRI的计算，本地生成页面时。有这个字符，远程提交时没这个了，前后Hashes值不一样导致了报错，可能是原主题问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:4:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"后续 突发奇想尝试下载ZIP包，结果人家的没问题，SSH下载凭空多了两字符，这就让人顶不住了！！可能是git传输的问题！！ ","date":"2021-05-12","objectID":"/sri-hashes-error/:5:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["Front","note"],"content":"使用SRI保护你的网站免受第三方CDN恶意攻击，记录SRI相关笔记","date":"2021-05-12","objectID":"/sri-note/","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"出于速度和降低服务器负载考虑，有时候我们会选择使用 CDN 加载第三方静态资源。对于一些热门的第三方库，在用户打开你的网页之前就很有可能在浏览别的网站时被浏览器缓存下来，这样就可以极大的提升网页加载速度。 然而使用 CDN 也提高了网站的安全风险：第三方静态资源放在第三方服务器上，CDN 的拥有者有没有可能偷偷的篡改这些文件，加入恶意代码呢？或者 CDN 服务器遭受了黑客攻击，整个文件被替换掉。虽然可能性不高，但不是零。JavaScript 对于当前浏览器页面有完全控制权，他们不仅仅能获取到页面上的任何内容，还能抓取用户输入的一些诸如密码之类的机密信息，还能获取到保存到 Cookie 中的登录票据等等内容，这就是所谓的 XSS 攻击。 我们需要一种机制确保从 CDN 下载的文件未被恶意篡改。某些下载网站就提供下载文件的 MD5 或 SHA1 码用于检查所下载文件的完整性，网页中有没有类似的机制呢？ ","date":"2021-05-12","objectID":"/sri-note/:0:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"What（什么是 SRI） Subresource Integrity (SRI) is a security feature that enables browsers to verify that files they fetch (for example, from a CDN) are delivered without unexpected manipulation. 在 和 link 标签中通过 integrity 属性，浏览器核实所获取的 js 文件（或 css 文件）确实是如 integrity 值规定的，然后再加载 js 文件（或应用css 文件）。 例子 如下是个 script 标签 \u003cscript src=\"https://example.com/example-framework.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"\u003e \u003c/script\u003e 注意 integrity=“sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC”，integrity 的值以 sha384- 开头，表示算法为 sha384, dash (-) 之后跟随的是 base64-encoded hash。 当前所允许的 hash 算法有 sha256, sha384, and sha512 ","date":"2021-05-12","objectID":"/sri-note/:1:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"生成 SRI Hashes值 命令行有两种方法。 ","date":"2021-05-12","objectID":"/sri-note/:2:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法一 cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A ","date":"2021-05-12","objectID":"/sri-note/:2:1","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法二 shasum -b -a 384 FILENAME.js | xxd -r -p | base64 注意，这里 shah 算法是 sha384，如果生成其他的 hash 值，是否也像这样，只需稍作修改即可（可能吧，但是未验证）。 ","date":"2021-05-12","objectID":"/sri-note/:2:2","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法三 $ echo -n \"alert('Hello, world.');\" | openssl dgst -sha384 -binary | openssl base64 -A 使用了 OpenSSL 这个 *nix 中通常都包含的工具计算哈希值。其中 alert('Hello, world.'); 是文件内容，你也可以用 cat Filename.js 直接读取某个文件。 输出 H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO，在此基础上添加前缀 sha384- 就可以了。 还有在线工具 https://srihash.org/ 可以生成不同格式的工具 https://www.xftsoft.com/tool/integrity ","date":"2021-05-12","objectID":"/sri-note/:2:3","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"浏览器如何处理 SRI (Subresource Integrity) 当浏览器遇到一个带有 integrity 的 \u003cscript\u003e 或 \u003cstyle\u003e 标签，在执行其中的 JS 脚本或应用其中的 CSS 样式之前，浏览器会首先计算所下载文件的内容的哈希值是否与 integrity 属性给定的值相同。 如果计算结果与给定值不匹配，浏览器会拒绝执行脚本内容，并报出一个网络错误，类似如下结果： When a browser encounters a \u003cscript\u003e or \u003clink\u003e element with an integrity attribute, before executing the script or before applying any stylesheet specified by the \u003clink\u003e element, the browser must first compare the script or stylesheet to the expected hash given in the integrity value. If the script or stylesheet doesn’t match its associated integrity value, then the browser must refuse to execute the script or apply the stylesheet, and must instead return a network error indicating that fetching of that script or stylesheet failed. Failed to find a valid digest in the ‘integrity’ attribute for resource ‘https://cdnjs.cloudflare.com/ajax/libs/normalize/6.0.0/normalize.min.css' with computed SHA-256 integrity ‘VbcxqgMGQYm3q8qZMd63uETHXXZkqs7ME1bEvAY1xK8=’. The resource has been blocked. 参考 Subresource Integrity https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity ","date":"2021-05-12","objectID":"/sri-note/:3:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"使用 SRI 只需给 script 或 style 标签添加 integrity 属性即可。例如： JavaScript \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e CSS \u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css\" integrity=\"sha384-7tIwW4quYS2+TZCwuAPnUY+dRqg28ylzlIoVXAwpfiTs+CMKsAOSsWYQ96c/ZnV+\" crossorigin=\"anonymous\"\u003e integrity 属性值以 shaXXX- 开头，表示后面的哈希值使用的哈希算法，目前只允许 sha256、sha384 或 sha512 这三种哈希算法，以 sha384 比较多见。后面跟对应的哈希值即可。 值得注意的是，因为启用 SRI 需要获取所下载文件的内容进行计算，所以需要 CDN 服务器启用跨域资源访问（CORS）支持，即返回 Access-Control-Allow-Origin: * 头。客户端需要使用跨域的形式加载指定文件，即添加 crossorigin=\"anonymous\" 属性。就我所知，目前国内相对常用的免费 CDN bootcdn 已经支持 CORS，百度静态 CDN 还不支持。 ","date":"2021-05-12","objectID":"/sri-note/:4:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"CSP 与 SRI 你可以使用 内容安全政策 （CSP）强制要求当前页面所有脚本加载标签启用 SRI。例如 Content-Security-Policy: require-sri-for script; 强制要求所有 script 标签启用 SRI，浏览器会拒绝加载未启用 SRI 的 script 标签。 对应的还有 CSS 版本： Content-Security-Policy: require-sri-for style; 你也可以同时启用两者。 ","date":"2021-05-12","objectID":"/sri-note/:5:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"错误恢复 使用 CDN 时别忘了当尝试从 CDN 加载文件失败后加载本地版本： \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript\u003eif (!window.jQuery) document.write('\u003cscript src=\"/jquery-3.2.1.min.js\"\u003e\u003c\\/script\u003e')\u003c/s ","date":"2021-05-12","objectID":"/sri-note/:6:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["SoftwareDesign","note"],"content":"详细介绍Mybatis中用到的设计模式","date":"2021-05-09","objectID":"/mybatis-designmode/","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["SoftwareDesign","note"],"content":" Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果； 组合模式，例如SqlNode和各个子类ChooseSqlNode等； 模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler； 适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现； 装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现； 迭代器模式，例如迭代器模式PropertyTokenizer； ","date":"2021-05-09","objectID":"/mybatis-designmode/:0:0","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["Total","note"],"content":"记录Android开发笔记","date":"2021-05-01","objectID":"/android-note/","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android5.0常用颜色属性说明 在使用Eclipse的时代，我们很少去在style文件给整个应用或者Activity去设定颜色，那是因为即使设置也不会提升用户的视觉效果。但是材料设计号称让没有设计功底的人也能做出漂亮的App，那我们今天就来看看在Androi5.0中常用的颜色属性。 我们可以先定义一个style，然后在这个style中设定每一个Activity或者整个App的颜色，最后在清单文件中来给某个Activity设置主题即可。代码如下： \u003cstyle name=\"AppTheme.NoActionBar\"\u003e \u003c!--状态栏颜色--\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003c!--控制各个控件被选中时的颜色--\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c!--页面背景色--\u003e \u003citem name=\"android:windowBackground\"\u003e@color/windowBackg\u003c/item\u003e \u003c!--底部导航栏颜色--\u003e \u003citem name=\"android:navigationBarColor\"\u003e@color/navigationColor\u003c/item\u003e \u003c!--Appbar背景色--\u003e \u003citem name=\"android:colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003c!--ToolBar上的Title颜色--\u003e \u003citem name=\"android:textColorPrimary\"\u003e@color/textColorPrimary\u003c/item\u003e \u003c!--各个控制控件的默认颜色--\u003e \u003citem name=\"android:colorControlNormal\"\u003e@color/colorControlNormal\u003c/ item\u003e \u003c/style\u003e 最后再来一张图详细说明每个item设定的到底是哪里的颜色： ","date":"2021-05-01","objectID":"/android-note/:1:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"ConstraintLayout基本使用之toLeftOf 、toTopOf、toRightOf、toBottomOf 关于ConstraintLayout的博客、文章想必大家已经见过很多了，都是很全面的，今天这篇博客主要将ConstraintLayout的 layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintTop_toTopOf ... 以上到底怎么理解呢？下面我将通过图片+文字来解释。 现在假设屏幕中间有个长宽为100dp的红色正方形，屏幕左上方有个宽高为50dp的黑色正方形，如下: 接下来我们一个一个试试这些参数吧! 1、layout_constraintLeft_toLeftOf(可以看出黑色正方形左边和红色正方形左边对齐) 2、layout_constraintLeft_toRightOf(黑色正方形的左边和红色正方形的右边对齐) 3、layout_constraintRight_toLeftOf(黑右对齐红左) 4、layout_constraintRight_toRightOf(黑右对齐红右) 剩余四个: layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf 也是同理。 让我们看一下这个参数的统一命名:layout_constraintA_toBOf， 也即代表当前布局的A方向，对齐目标布局的B方向 ","date":"2021-05-01","objectID":"/android-note/:2:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 沉浸式标题栏设置，顶部view到状态栏 Android 沉浸式标题栏设置，顶部view到状态栏 布局xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroid.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:id=\"@+id/tv_top_bg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:maxHeight=\"140dp\" android:background=\"@drawable/case_resource_transport_top_bg\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e ... \u003c/android.support.constraint.ConstraintLayout\u003e activity AndroidManifest设置 \u003cactivity android:name=\"....xxActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/AppTheme.imgFullScreen\" android:windowSoftInputMode=\"adjustPan\"/\u003e stayles.xml 添加style \u003cstyle name=\"AppTheme.imgFullScreen\"\u003e \u003citem name=\"android:windowTranslucentStatus\"\u003efalse\u003c/item\u003e \u003citem name=\"android:windowTranslucentNavigation\"\u003efalse\u003c/item\u003e \u003citem name=\"android:statusBarColor\"\u003e@android:color/transparent\u003c/item\u003e \u003c/style\u003e xxActivity添加 val decorView = window.decorView val option = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE) decorView.systemUiVisibility = option window.statusBarColor = Color.TRANSPARENT 效果： ","date":"2021-05-01","objectID":"/android-note/:3:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android去除顶部默认的标题栏 当我们在Android Studio中创建一个新的Android项目时，会发现顶部有一个标题栏。我们有的时候并不需要这个标题栏，因此我们就需要把它去掉。 在Android Studio中展开Project模块，会看到里面是一个由文件和文件夹构成的树形图。打开里面的app-\u003emanifests-\u003eAndroidManifest.xml文件，然后找到application标签的android:theme属性，把它的值改为\"@style/Theme.AppCompat.NoActionBar\"，这样就可以解决问题了。 ","date":"2021-05-01","objectID":"/android-note/:4:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android注册服务 broadcastReceiver使用时需要在AndroidManifest.xml注册格式为 package=\"com\"\u003e \u003cactivity android:name=\".MainActivity\"\u003e …… \u003c/activity\u003e \u003cservice android:name=\".XXX\" /\u003e 此处.目录取决于上面package导入的目录 ","date":"2021-05-01","objectID":"/android-note/:5:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android TextView 文字居中 有2种方法可以设置TextView文字居中： 一：在xml文件设置：android:gravity=“center” 二：在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER); ","date":"2021-05-01","objectID":"/android-note/:6:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android给View设置上下左右边框 需求 设置view上下右有边框(左边不要边框)，右上角右下角需要设置为圆角（左边不需要） 实现 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003c!-- This is the main color --\u003e \u003citem\u003e \u003cshape\u003e \u003c!-- 边框颜色 --\u003e \u003csolid android:color=\"@color/flash_text_normal\"/\u003e \u003c/shape\u003e \u003c/item\u003e \u003c!-- 给View的上 下 右设置8dp的边框 --\u003e \u003c!-- http://blog.csdn.net/lowprofile_coding/article/details/47848245--\u003e \u003citem android:top=\"1dip\" android:bottom=\"1dip\" android:right=\"1dip\" \u003e \u003cshape\u003e \u003c!-- View填充颜色 --\u003e \u003csolid android:color=\"@color/public_round_yellow\" /\u003e \u003ccorners android:topRightRadius=\"@dimen/x10\" android:bottomRightRadius=\"@dimen/x10\" /\u003e \u003c/shape\u003e \u003c/item\u003e \u003c/layer-list\u003e ","date":"2021-05-01","objectID":"/android-note/:7:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android 为TextView添加边框 今天需要在TextView上面添加一个边框，但是TextView本身不支持边框，所以只能采用其他方式，在网上查询了一下，主要有三种方式可以实现1.带有边框的透明图片2.使用xml的shape设置3继承TextView覆写onDraw方法。 ","date":"2021-05-01","objectID":"/android-note/:8:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法一 带有透明图片的背景图，这个没有什么好将的，自己制作一个就行 ，然后设置background就可以了 ","date":"2021-05-01","objectID":"/android-note/:8:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法二 通过shape来设置背景图片 首先一个textview_border.xml文件放在drawable文件夹里面 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" \u003e \u003csolid android:color=\"#ffffff\" /\u003e \u003cstroke android:width=\"1dip\" android:color=\"#4fa5d5\"/\u003e \u003c/shape\u003e 为要添加边框的TextView添加一个background android:background=\"@drawable/textview_border\" 效果图片如下: ","date":"2021-05-01","objectID":"/android-note/:8:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法三 编写一个继承TextView类的自定义组件，并在onDraw事件方法中画边框。 package com.example.test; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Canvas; import android.graphics.Paint; import android.util.AttributeSet; import android.widget.TextView; @SuppressLint(\"DrawAllocation\") public class BorderTextView extends TextView{ public BorderTextView(Context context) { super(context); } public BorderTextView(Context context, AttributeSet attrs) { super(context, attrs); } private int sroke_width = 1; @Override protected void onDraw(Canvas canvas) { Paint paint = new Paint(); // 将边框设为黑色 paint.setColor(android.graphics.Color.BLACK); // 画TextView的4个边 canvas.drawLine(0, 0, this.getWidth() - sroke_width, 0, paint); canvas.drawLine(0, 0, 0, this.getHeight() - sroke_width, paint); canvas.drawLine(this.getWidth() - sroke_width, 0, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); canvas.drawLine(0, this.getHeight() - sroke_width, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); super.onDraw(canvas); } } 效果图如下: 使用的Xml布局内容如下: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cRelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" \u003e \u003cTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:background=\"@drawable/textview_border\" android:text=\"方法二\" android:textColor=\"#FF000000\" android:id=\"@+id/test\" android:gravity=\"center\" android:layout_alignParentTop=\"true\" android:layout_marginTop=\"20dp\" android:layout_centerHorizontal=\"true\"/\u003e \u003ccom.example.test.BorderTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:text=\"方法三\" android:id=\"@+id/test3\" android:gravity=\"center\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_centerHorizontal=\"true\"\u003e \u003c/com.example.test.BorderTextView\u003e \u003c/RelativeLayout\u003e ","date":"2021-05-01","objectID":"/android-note/:8:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"全局变量 切换Fragment时有些值需要保存，故需要一个全局变量进行保存 ​ 项目开发的过程中，可能会大量的使用全局变量，在android开发中，大多数人更偏向于使用application来保存全局变量。那么我们就先来了解下在android中，application究竟是什么？有什么作用？ 　Application类是用来维护应用程序全局状态。我们可以提供自己的实现，并在AndroidManifest.xml文件的标签中指出它的名字，这将导致在创建应用程序时去实例化我们自己的Application类。Android系统会为每个程序运行时创建一个Application类的对象且仅创建一个，所以Application可以说是单例模式的一个类。且Application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局唯一的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以，通过Application来进行一些数据传递、数据共享、数据缓存等操作。 　首先创建继承自Application的MusicPlayerStatus类，定义变量update、current,并创建get和set方法。 import android.app.Application; public class MusicPlayerStatus extends Application { private int update=-1; private int current=-1; public int getUpdate() { return update; } public void setUpdate(int update) { this.update = update; } public int getCurrent() { return current; } public void setCurrent(int current) { this.current = current; } } 下面就是如何使用我们创建的全局变量了，在MainActivity中，首先要获得MusicPlayerStatus的对象，因为MusicPlayerStatus继承自Application，所以使用getApplication()方法即可，然后可以调用MusicPlayerStatus的get或set方法进行访问全局变量。 public MusicPlayerStatus musicPlayerStatus=new MusicPlayerStatus(); int update = musicPlayerStatus.getUpdate(); int current = musicPlayerStatus.getCurrent(); musicPlayerStatus.setUpdate(update); musicPlayerStatus.setCurrent(current); 注意，在使用MusicPlayerStatus之前需要修改AndroidManifest.xml文件的中的android:name = “.MusicPlayerStatus”，这样就不会访问系统提供的application，而访问我们自己创建的。 ","date":"2021-05-01","objectID":"/android-note/:9:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 使控件各占屏幕的一半 在xml中将两个要占屏幕一半的控件都加上android:layout_weight=“1”； 注意：weight只能用在LinearLayout布局中。 在LinearLayout布局中weight数值越大显示的优先权就越低。 ","date":"2021-05-01","objectID":"/android-note/:10:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Fragment生命周期 相互切换时调用的方法 ","date":"2021-05-01","objectID":"/android-note/:11:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"一、前言： Fragment生命周期图如下： ","date":"2021-05-01","objectID":"/android-note/:11:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"二、Fragment 1 切换到 Fragment 2时生命周期变化 1. 通过 add hide show 方式来切换 Fragment Fragment1 的生命周期变化为：onCreate（）、onCreateView、onStart（）、onResume（） 回调 onHiddenChanged（） 方法 Fragment2 的生命周期变化为： onCreate（）、onCreateView、onStart（）、onResume（） Fragment 2 再次返回到 Fragment 1：不走任何生命周期方法但是回调 onHiddenChanged（）方法 总结：当以这种方式进行 Fragment 1 与 Fragment 2 的切换时，Fragment 隐藏的时候并不走 onDestroyView，所有的显示也不会走 onCreateView 方法，所有的 view 都会保存在内存。 2. 使用 replace 的方法进行切换时 载入Fragment 1时： Fragment 1的生命周期：onCreate（）、onCreateView（）、onStart（）、onResume（） 切换到Fragment2时： Fragment 1的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 2的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） Fragment 2切换回Fragment 1时： Fragment2的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 1的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） 总结：通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期。 3. 使用 ViewPager 进行切换时 当使用 ViewPager 与 Fragment 进行切换时，Fragment 会进行预加载操作 所有的 Fragment 都会提前初始—\u003e预加载； 初始化时 Fragment 们的生命周期： Fragment 1 的生命周期：onCreate（）、onCreateView（） Fragment 2 的生命周期：onCreate（）、 onCreateView（） Fragment 1 切换到 Fragment 2 的生命周期： Fragment 1 ：不走任何生命周期； Fragment 2 ：走 setUserVisVleHint（）方法 切回去也是一样的 注意： setUserVisVleHint（）方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法。 /** *第一个 Fragment 需要处理 setUserVisVleHint（）方法，设置为 setUserVisibleHint(true); *否则会产空指针异常，因为 setUserVisVleHint（）方法的优先级高于 onCreate（）方法。 * * @param savedInstanceState */ @Override public void onActivityCreated(Bundle savedInstanceState) { setUserVisibleHint(true); super.onActivityCreated(savedInstanceState); } /* 主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题。 setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。 此时要对是否调用了onCreateView（）方法进行标记判断。 */ ","date":"2021-05-01","objectID":"/android-note/:11:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"三、其它切换 1. Activity 切换到 Fragment 的生命周期变化 Fragment 的生命周期变化为：onStart（）、onResume（） 2. 从 Fragment 1 进行锁屏操作 Fragment 的生命周期方法：onPause（）、onSaveInstanceState（）、onStop（）。 3. 从解锁 到 Fragment 1 的生命周期 onStart（）、 onResume（） ","date":"2021-05-01","objectID":"/android-note/:11:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"简单实现ImageView宽度填满屏幕，高度自适应的两种方式 两种方式 ","date":"2021-05-01","objectID":"/android-note/:12:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"1.重写View的onMeasure方法 核心代码 protectedvoidonMeasure(intwidthMeasureSpec,intheightMeasureSpec){ Drawable d = getDrawable(); if(d!=null){ // ceil not round - avoid thin vertical gaps along the left/right edgesintwidth = MeasureSpec.getSize(widthMeasureSpec); //高度根据使得图片的宽度充满屏幕计算而得 intheight = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth()); setMeasuredDimension(width, height); }else{ super.onMeasure(widthMeasureSpec, heightMeasureSpec); } } ","date":"2021-05-01","objectID":"/android-note/:12:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"2.设置ImageView的属性： //宽度填满屏幕 android:layout_width=”match_parent” android:scaleType=”fitXY” android:layout_height=”wrap_content” //保持比例，一定要设置 android:adjustViewBounds=”true” ","date":"2021-05-01","objectID":"/android-note/:12:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android使用Bundle+Message+Hundle进行线程间通信 ","date":"2021-05-01","objectID":"/android-note/:13:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是java自带数据对象（常规八种数据结构） 接收线程 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : String str1 = msg.getData().getString(\"text1\");//接受msg传递过来的参数 String str2 = msg.getData().getString(\"text2\");//接受msg传递过来的参数 initFinishMainActivity(str1, str2); break; default : break; } } }; 发送线程 Message msg = new Message(); msg.what = MainActivity.CANSHU; Bundle bundle = new Bundle(); bundle.putString(\"text1\",\"大明的消息传递参数的例子！\"); //往Bundle中存放数据 bundle.putString(\"text2\",\"Time：2011-09-05\"); //往Bundle中put数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是自定义对象时 自定义类 首先需要自定对象实现Serializable可序列化的接口，如下 public class Persion implements Serializable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 接收线程 getString等改为 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : Persion persion=(Persion)(msg.getData().getSerializable(\"persion\")); //接受msg传递过来的参数 initFinishMainActivity(persion); break; default: break; } } }; 发送线程 putString等改为putSerializable Message msg = new Message(); msg.what = MainActivity.CANSHU; Persion persion=new Persion(); String Name=\"zhangsan\"; persion.setName(Name); Bundle bundle = new Bundle(); bundle.putSerializable(\"persion\",persion); //往Bundle中存放数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android历史版本平台、SDK、版本名称对照（争取持续更新） 平台版本 SDK版本 版本名称 12.0 31 Android 12（Snow Cone）（刨冰） 11.0 30 Red Velvet Cake（Quince Tart）(Android R)（11）（红丝绒蛋糕） 10.0 29 (Android Q)（10） 9.0 28 Pie (Android P)（派/馅饼） 8.1 27 Oreo(Android O)（奥利奥） 8.0 26 [Oreo(Android O)（奥利奥） 7.1 25 Nougat(Android N)（牛轧糖） 7.0 24 Nougat(Android N)（牛轧糖） 6.0 23 Marshmallow(Android M)（棉花糖） 5.1 22 Lollipop(Android L)（棒棒糖） 5.0 21 Lollipop(Android L)（棒棒糖） 4.4W 20 KITKAT Wear（奇巧巧克力） 4.4 19 [KITKAT（奇巧巧克力） 4.3 18 JELLY_BEAN_MR2（软心豆粒糖/果冻豆） 4.2 / 4.2.2 17 JELLY_BEAN_MR1（软心豆粒糖） 4.1 / 4.1.1 16 JELLY_BEAN（软心豆粒糖） 4.0.3 / 4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰淇淋三明治） 4.0 / 4.01 / 4.02 14 ICE_CREAM_SANDWICH（冰淇淋三明治） 3.2 13 HONEYCOMB_MR2（蜂巢） 3.1.X 12 HONEYCOMB_MR1（蜂巢） 3.0.X 11 HONEYCOMB（蜂巢） 2.3.3 / 2.3.4 10 GINGERBREAD_MR1（姜饼） 2.3 9 GINGERBREAD（姜饼） 2.2 / 2.2.1 8 Froyo（冻酸奶） 2.1 7 Eclair_MR2（闪电泡芙） 2.0.1 6 Eclair_MR1（闪电泡芙） 2.0 5 Eclair（闪电泡芙） 1.6 4 Donut（甜甜圈） 1.5 3 Cupcake（纸杯蛋糕） 1.1 2 Petit Four 1.0 1 Astro / Bender(1.0有两版) ","date":"2021-05-01","objectID":"/android-note/:14:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android资源管理器注意事项 /data/user/0是/data/data目录的软连接或者是快捷方式 ","date":"2021-05-01","objectID":"/android-note/:15:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"end ","date":"2021-05-01","objectID":"/android-note/:16:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total"],"content":"详细解释Android中drawable和drawable-v24的区别","date":"2021-04-30","objectID":"/android-diff-drawable-v24/","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"今天调试一个软件，老是找不到资源 android.content.res.Resources$NotFoundException: Resource 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 7.0的关于图片资源的改变 从Android API 24（安卓7.0）开始，自定义Drawables类可以最终在XML中使用（仅在您的包中）。 8.0的关于图片资源的改变 API 26（安卓8.0）中添加了VectorDrawable自适应图标 更多解释 ","date":"2021-04-30","objectID":"/android-diff-drawable-v24/:0:0","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"Android应用使用Kolin开发，解决Kolin：A problem occurred evaluating project ':app'.","date":"2021-04-20","objectID":"/android-kolin/","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total"],"content":"报错 Build file 'C:\\All_Code\\AS_Code\\Bottom-Navigation\\Material-BottomNavigation\\app\\build.gradle' line: 2 A problem occurred evaluating project ':app'. \u003e java.lang.ExceptionInInitializerError (no error message) 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中发现原来的Kolin插件使用了$，我并未配置Kolin环境，因此找不到 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } 访问Gradle官网仓库，我修改为最新版本 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.0-M2\" } 编译运行OK ","date":"2021-04-20","objectID":"/android-kolin/:0:0","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total"],"content":"解决Android App界面与顶部状态栏重叠遮盖问题的方法","date":"2021-03-22","objectID":"/android-topbar-cover/","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Total"],"content":"问题情况截图如下： 觉得toolbar默认高度太高，给toolbar设了一个固定值。测试时发现在4.4系统上会出现与状态栏重叠的现象。给toolbar设了个margin，但是在7.0的系统上又会出现间隙。最后发现只需要在父view里加上下面两行就解决了。 android:clipToPadding=“true” android:fitsSystemWindows=“true” 解释一下上面两个布局属性的意思： android:clipToPadding 定义布局间是否有间距 android:fitsSystemWindows=“true” 意思就是设置应用布局时是否考虑系统窗口布局；如果为true，将调整系统窗口布局以适应你自定义的布局。比如系统有状态栏，应用也有状态栏时。实际就是通过在 View 上设置和系统窗口一样高度的边框（padding）来确保你的内容不会出现到系统窗口下面。 或只 在layout的主布局中加入 android:fitsSystemWindows=“true” 如下： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\" tools:context=\".MainActivity\"\u003e \u003c!-- 布局内容...... --\u003e \u003c/LinearLayout\u003e ","date":"2021-03-22","objectID":"/android-topbar-cover/:0:0","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Software"],"content":"解决AndroidStudio开发Android-Java应用的网络问题","date":"2021-03-15","objectID":"/android-net/","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Software"],"content":"android studio 教你修改Maven仓库地址为国内镜像 android studio 默认国外maven 这我们更改为阿里的maven 打开build.gradle 添加或者修改 allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } }修改buildscript { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' } } 这里有阿里的仓库http://maven.aliyun.com/mvn/view`可以自行查看和替换，速度都比国外快 如图所示 ","date":"2021-03-15","objectID":"/android-net/:1:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Software"],"content":"Android Studio released aar to Jcenter, plug-in could not be found 导入项目控制台报错 Unknown host ‘raw.githubusercontent.com’. You may need to adjust the proxy settings in Gradle. 似乎raw.githubusercontent.com被dns污染了，使用站长工具ping改host做前置代理也无法访问，使用站长工具查ip改host也识别不到，甚至用了魔法，可能AS自己有网络通讯，使用代理依然无效。被迫使用下面的办法（其实可以直接删除，不影响项目运行，据说是文档文件）,该方法适用所有此域名导包问题 获取源码 有大佬上传到GitHub：installv1.gradle、bintrayv1.gradle，或者使用魔法，浏览器访问（我只使用了这一种办法成功访问了）网址获取 bintrayv1.gradle apply plugin: 'com.jfrog.bintray' version = libraryVersion if (project.hasProperty(\"android\")) { // Android libraries task sourcesJar(type: Jar) { classifier = 'sources' from android.sourceSets.main.java.srcDirs } task javadoc(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } } else { // Java libraries task sourcesJar(type: Jar, dependsOn: classes) { classifier = 'sources' from sourceSets.main.allSource } } task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir } artifacts { archives javadocJar archives sourcesJar } // Bintray Properties properties = new Properties() properties.load(project.rootProject.file('local.properties').newDataInputStream()) bintray { user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg { repo = bintrayRepo name = bintrayName desc = libraryDescription websiteUrl = siteUrl vcsUrl = gitUrl licenses = allLicenses publish = true publicDownloadNumbers = true version { desc = libraryDescription gpg { sign = true //Determines whether to GPG sign the files. The default is false passphrase = properties.getProperty(\"bintray.gpg.password\") //Optional. The passphrase for GPG signing' } } } } installv1.gradle apply plugin: 'com.github.dcendents.android-maven' group = publishedGroupId // Maven Group ID for the artifact install { repositories.mavenInstaller { // This generates POM.xml with proper parameters pom { project { packaging 'aar' groupId publishedGroupId artifactId artifact // Changed case // Add your description here name libraryName description libraryDescription url siteUrl // Set your license licenses { license { name licenseName url licenseUrl } } developers { developer { id developerId name developerName email developerEmail } } scm { connection gitUrl developerConnection gitUrl url siteUrl } } } } } 在项目中手动创建installv1.gradle、bintrayv1.gradle文件，我把他们放在项目目录下的library文件夹中，手动拷贝相关的源码 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中修改原来的引用（注释或者删除） //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle' //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle' apply from: \"../library/installv1.gradle\" apply from: \"../library/bintrayv1.gradle\" 重新build即可 ","date":"2021-03-15","objectID":"/android-net/:2:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Software"],"content":"end ","date":"2021-03-15","objectID":"/android-net/:3:0","tags":["Environment","Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Total"],"content":"在AndroidStudio中使用Java开发Android应用-版本更替不兼容报各种错误的修正","date":"2021-03-03","objectID":"/android-incompatible-version/","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"CardView、RecyclerView在buildTools28-\u003e30用法改变 Android开发 CardView卡片视图、RecyclerView回收视图 注意开发工具从28变为30以后即src目录下的bulid.grade文件中的buildTools版本改变 android { compileSdkVersion 28 buildToolsVersion \"28.0.0\" } android { compileSdkVersion 30 buildToolsVersion \"30.0.3\" } CardView、RecyclerView都发生了使用变化 引用： app目录下的bulid.grade文件中依赖dependencies改变 只要将implementation ‘com.android.support:cardview-v7:28.0.0’换成implementation ‘androidx.cardview:cardview’就行了（recyclerview类似改变）； 原因：版本28（面向android pie及以下版本）是遗留支持库的最后一个版本，因此我们建议您在使用android q并继续前进时迁移到androidx库。IDE可以帮助您：重构\u003e迁移到AndroidX…， dependencies { implementation 'com.android.support:cardview-v7:28.0.0' implementation 'com.android.support:recyclerview-v7:28.0.0' } dependencies { implementation \"androidx.cardview:cardview:1.0.0\" implementation \"androidx.recyclerview:recyclerview:1.1.0\" // For control over item selection of both touch and mouse driven selection implementation \"androidx.recyclerview:recyclerview-selection:1.1.0\" } 依赖请看官方文档Cardview、RecyclerView XML文件 主要是CardView、RecyclerView的标题 原来CardView \u003candroid.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_marginRight=\"5dp\" android:layout_marginTop=\"5dp\" android:elevation=\"5dp\" app:cardCornerRadius=\"5dp\"\u003e \u003c/android.support.v7.widget.CardView\u003e RecyclerView \u003candroid.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/android.support.v7.widget.RecyclerView\u003e 变为CardView‘ \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003candroidx.cardview.widget.CardView android:id=\"@+id/card_view\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\"\u003e \u003cTextView android:id=\"@+id/content1\" android:text=\"内容\" android:gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/\u003e \u003c/androidx.cardview.widget.CardView\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e RecyclerView’ \u003c!-- 你的可能是这样的--\u003e \u003candroid.support.v7.widget.RecyclerView \u003c!-- 这才是对的--\u003e \u003candroidx.recyclerview.widget.RecyclerView \u003c!-- xxx--\u003e \u003c!-- xxx--\u003e .../\u003e ","date":"2021-03-03","objectID":"/android-incompatible-version/:1:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Failed to find Build Tools revision 26.0.1 Error:A problem occurred configuring project ':app'. \\\u003e Failed to find Build Tools revision 26.0.1 在build.gradle 中buildToolsVersion 如何修改。看本地安装了哪些版本的 进入文件夹Android SDK 目录下build-tools，修改为里面有的版本 ","date":"2021-03-03","objectID":"/android-incompatible-version/:2:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find method google() for arguments [] on repository container. 问题： 在react native中安装realm数据库后运行react-native run-android 时报如下错： 开发环境： react-native:^0.55.4 reaml:^2.27.0 解决方案： 1、打开项目根目录下android/gradle/wrapper/gradle-wrapper.properties 将distributionUrl=https://services.gradle.org/distributions/gradle-2.14.1-all.zip中的2.14.1改成4.1 2、打开项目根目录下的android/build.gradle 1）、在buildscript和allprojects下的repositories分别添加google() 2）、将dependencies中的classpath ‘com.android.tools.build:gradle:2.2.3’中的2.2.3【具体看自己的是多少】改成3.0.1 重新运行编译项目命令，要下载新的gradle，这个过程有点慢。至此，问题已解决！ ","date":"2021-03-03","objectID":"/android-incompatible-version/:3:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find com.android.support:appcompat-v7:25.0.0 老的Android工程导入as报错如下： 10:36 Gradle sync failed: Could not find com.android.support:appcompat-v7:25.0.0. Required by: FuNongTong:app:unspecified (18 s 207 ms) 如果是gradle4.0及以下，增加maven { url “https://maven.google.com” }，如下： buildscript { repositories { jcenter() maven { url \"https://maven.google.com\" } } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() maven { url \"https://maven.google.com\" } } } 如果是gradle4.0及以上，maven { url “https://maven.google.com” }替换为google() 如下： buildscript { repositories { jcenter() google() } } allprojects { repositories { jcenter() google() } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:4:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=M android studio升级到3.1.4之后gradle里的很多配置也相应发生了一些改变。在打包的时候我就遇到了这样的问题。 报错为：Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 截图如下： 大家可以注意看一下，AS升级到3.0以上版本后，截图上的红框处的代码都要改动，否则是无法正常打包的。那要改成什么样呢，如下图所示： 改成上图所示的样子就可以正常打包了，另外我也把代码贴出来方便大家复制。 //打包后应用名称 applicationVariants.all { variant -\u003e variant.outputs.all { output -\u003e def outputFile = output.outputFile def fileName if (outputFile != null \u0026\u0026 outputFile.name.endsWith('.apk')) { if (variant.buildType.name.equals('release')) {//如果是release包 fileName = \"anjian_release_v${defaultConfig.versionName}.apk\" } else if (variant.buildType.name.equals('debug')) {//如果是debug包 fileName = \"anjian_debug_v${defaultConfig.versionName}.apk\" } outputFileName = fileName } } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:6:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"build.grade.dependence随版本引用关键字改变 // testCompile-\u003etestImplementation // compile-\u003eimplementation // provided-\u003ecompileOnly ","date":"2021-03-03","objectID":"/android-incompatible-version/:7:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use ‘annotationProce AS从2.3.3升级到3.0后，项目没有任何改动就出现了这个错误，解决步骤如下： 一、把module/build.gradle下的apt插件应用全部注释掉 二、把dependencies下的apt全部改为annotationProcessor annotationProcessor 在as最新版本也失效，要如下操作 annotationProcessor ‘org.projectlombok:lombok:1.18.6’ 修改为 compile ‘org.projectlombok:lombok:1.18.6’ 即可 三、把project/build.gradle中的apt插件声明注释 ","date":"2021-03-03","objectID":"/android-incompatible-version/:8:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"更新Gradle项目时报错Gradle sync failed: Unsupported method: BaseConfig.getApplicationIdSuffix 查看Android Gradle 插件版本说明。 https://developer.android.google.cn/studio/releases/gradle-plugin.html#updating-plugin 修改对应的项目根目录下的build.gradle的依赖（dependencies）下的gradle的build工具版本 dependencies {classpath \"com.android.tools.build:gradle:4.1.3\"} 和项目根目录下的gradle文件夹中的wrapper文件夹中的build.gradle文件中的gradle版本 distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip 注意：第一个文件要在原来jcenter（）位置加上google（） repositories{ google() jcenter()} ","date":"2021-03-03","objectID":"/android-incompatible-version/:9:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not resolve all files for configuration ‘:app:debugRuntimeClasspath’. Could not find com.android.support:appcompat-v7:23.2.1. Searched in the following locations: repositories { google() maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'}//加上这行 //jcenter() } ","date":"2021-03-03","objectID":"/android-incompatible-version/:10:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"end ","date":"2021-03-03","objectID":"/android-incompatible-version/:11:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信实例讲解（通过获取对象，调用方法）","date":"2021-03-01","objectID":"/android-activity-fragment-connect/","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信 效果显现： 实现步骤： 1.创建MainActivity，FragmentA，FragmnetB在activity_main.xml中静态加载FragmentA，FragmnetB 2.在MainActivity中获取FragmentA对象，再用对象，调用FragmentA中的方法，实现Activity与Fragment通信之间的通信 3.在FragmentA中获取MainActivity的对象，在通过MainActivity的对象获取FragmnetB对象，最后调用FragmnetB中方法，实现Fragment之间互相通信。 代码实现： 1.创建FragmentA，FragmnetB和相应的布局，这里我就不多解释了： 1.a_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#d41313\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is a fragent\" android:gravity=\"center\"/\u003e \u003cTextView android:id=\"@+id/a_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:text=\"show text\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/a_frag_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/a_frag_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentB\"/\u003e \u003c/LinearLayout\u003e 2.FragmentA： public class FragmentA extends Fragment { private TextView showTv; private EditText toBEt; private Button toBBtn; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.a_fragment, container, false); bindID(view); return view; } private void bindID(View view) { showTv = view.findViewById(R.id.a_frag_tv); toBEt = view.findViewById(R.id.a_frag_et); toBBtn = view.findViewById(R.id.a_frag_btn); } } 3.b_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#3dd526\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"this is b fragment\" android:textColor=\"#fff\" android:background=\"#000\" android:textSize=\"25sp\"/\u003e \u003cTextView android:id=\"@+id/b_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"show text\" android:textSize=\"25sp\"/\u003e \u003c/LinearLayout\u003e 4.FragmentB： public class FragmentB extends Fragment { private TextView showTv; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.b_fragment,container,false); showTv = view.findViewById(R.id.b_frag_tv); return view; } } 2.在activity_main.xml中加载之前的两个碎片： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" tools:context=\"com.example.communicationfragment.MainActivity\"\u003e \u003cLinearLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:layout_weight=\"1\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is Activity\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/main_to_a_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/main_to_a_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentA\"/\u003e \u003c/LinearLayout\u003e \u003cFrameLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\"\u003e \u003cfragmen","date":"2021-03-01","objectID":"/android-activity-fragment-connect/:1:0","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Total","note"],"content":"Android Studio 开发Android App时需要修改项目名称和包名方法","date":"2021-02-28","objectID":"/androidstudio-rename/","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":" 平时项目开发中，有时候维护项目多，有的项目结构需要改变，这就需要我们去修改项目名称或者修改包名。下面介绍一下怎样修改项目名称和包名。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:0:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"1. 修改项目名称 1）打开项目根目录下的setting.gradle文件，修改该文件中的rootProject.name='新项目名'； 2）点击 Sync Now 重新编译项目； ★ 如果只是简单修改至此，会发现项目名称后依然备注着旧项目名，并没有彻底更换新的项目名。紧接着下面操作： 3）关闭 Android Studio； 4）修改项目所在路径的文件名为新的项目名； 5）打开AS，重新导入修改后的项目即可； ★ 如果是 AS 4.0之后 的版本，修改至此就算修改完成；如果是 AS 4.0之前 的版本，会出现一些配置文件信息还是引用原来的项目名，并没有更换为新的项目名。紧接着下面操作： 6）找到项目根目录下的xx.iml文件，右键 Refactor —— Rename 打开修改编辑框； 7）输入新的项目名，点击 Refactor 修改； 8）打开项目根目录下的xx.iml文件，修改该文件中的project.id字段：external.linked.project.id=\"新项目名\" 9）打开项目下.idea/modules.xml文件，修改该文件中的fileurl和filepath字段：\u003cmodule fileurl=\"file://$PROJECT_DIR$/新项目名.iml\" filepath=\"$PROJECT_DIR$/新项目名.iml\" /\u003e 10）点击 Rebuild Project 重构项目，即可修改完成项目名称。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:1:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"2. 修改项目包名 1）选中项目中药修改的包名； 2）更改项目结构显示方式，取消 Compact Middle Packages 选项； 3）右键要修改的包名，选择 Refactor —— Rename 打开修改编辑框； 4）点击 Rename package 修改包名； 5）输入新的包名，点击 Refactor 修改； 6）点击 Do Refactor 确定修改； 7）打开项目 app/main 目录下的AndroidManifest.xml文件，修改该文件中的package=\"新包名\"字段； 8）修改项目 app 下的 build.gradle 中的applicationId \"新包名\"字段； 9）点击 Sync Now 同步，即可修改完成项目包名。 注意： 修改完包名，项目出现错误无法运行，解决方法请移步 —— 《Android Studio修改包名导致引用R文件报错问题》 ","date":"2021-02-28","objectID":"/androidstudio-rename/:2:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total"],"content":"Android Studio 导入图片标红,记录图片文件命名规则","date":"2021-02-09","objectID":"/androidstudio-picture-error/","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":" as图片不能使用\"-\"，只能使用\"_“代替 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:0:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况一 直接修改会直接提示不能带有”-\" ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:1:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况二 在系统资源管理器中拷贝进带\"-“的文件名的图片，标红报错 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:2:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"记录findViewById返回null的常见原因和解决办法","date":"2021-02-01","objectID":"/android-findviewbyid-null/","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["Total"],"content":"1.在另一个view的元素应该用baseView.findViewById()来拿 findViewById()是要指定view的，也就是说你要找的view 必须是包含在baseView里面的布局（控件） 如果在该父控件下找不到，就会报null。 2.findViewById在setContentView(R.layout.main);之前.即在setContentView调用之前，view要从父类布局里面找，父类布局还没有加载之前找，必然会返回空。 3.写的该布局（控件） ，还没有保存，导致工具不能加载到。自然也是null； 4.工具出现异常，这就是很偶然的情况，一般clean、重启 ","date":"2021-02-01","objectID":"/android-findviewbyid-null/:0:0","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["documentation","note"],"content":"Hogo使用CodeIT主题并配置Algolia作为站内搜索","date":"2021-01-10","objectID":"/hugo-algolia/","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置，以中文配置作为示例 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"KKKPJSKEY's-Case-Archives\" appID = \"algolia.com.API Keys.Application ID\" searchKey = \"algolia.com.API Keys.Admin API Key\" ","date":"2021-01-10","objectID":"/hugo-algolia/:1:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2 Algolia 配置 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “example”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.2 我这里选择香港作为存储地区 查看自己的网速 选择网速较快的地区 点击下一步 勾选 勾选 点击创建 我就跳过新手教程了 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面（见2.1） ","date":"2021-01-10","objectID":"/hugo-algolia/:2:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.2 安装 atomic-algolia（在任意目录下） npm -g install atomic-algolia --save ","date":"2021-01-10","objectID":"/hugo-algolia/:3:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.3 创建 .env 文件存放 algolia 配置（在网站根目录下） ALGOLIA_APP_ID=\"algolia.com.API Keys.Application ID\" ALGOLIA_ADMIN_KEY=\"algolia.com.API Keys.Admin API Key\" ALGOLIA_INDEX_NAME=\"example\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-01-10","objectID":"/hugo-algolia/:3:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.4 修改网站根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-01-10","objectID":"/hugo-algolia/:3:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:5","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.脚本 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.1定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.2我的脚本 分析可知仅上传流程中需要两步顺序操作，其他调试普通指令一步基本可以解决，故略去其他脚本，仅使用生成索引并上传，将GitHub Pages上传至Github仓库两步操作脚本 update.sh #!/bin/sh # If a command fails then the deploy stops set -e update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull origin master # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push origin master fi } update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.3我的最新脚本 脚本顺序弄错，应该先生成Hugo页面，再生成algolia 索引，最后将页面推上去就行 update.sh #!/bin/sh # If a command fails then the deploy stops set -e generate_pages(){ hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m已经重新生成 hugo 页面！！！\\033[0m\\n\" } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia 索引！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push fi } generate_pages update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"5结果 仓库代码检验： algolia 的索引: ","date":"2021-01-10","objectID":"/hugo-algolia/:5:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2021-01-01","objectID":"/hugo-github/","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"近些年GoLang语言逐渐火爆起来，Golang语言所做的静态博客固然也映入眼帘。相比于动态博客，静态博客的好处不言而喻，开发难度极低，不需要后台和数据库，更不需要昂贵的服务器成本和花费运维成本去维护。应老师要求以及个人未来发展，故学习静态博客的部署(补充，最近挖矿潮，比特币价格上涨，对于我等穷人，服务器的开销还是能省一点是一点)。本文因此介绍hugo和GitHub.io的初次使用搭建个人博客 ","date":"2021-01-01","objectID":"/hugo-github/:0:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1 本地部署blog ","date":"2021-01-01","objectID":"/hugo-github/:1:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.1 快速开始 1.1.1、安装方法介绍 hugo_GitHub:https://github.com/gohugoio/hugo Official_Website:https://gohugo.io/ 不同的操作系统有着不同的安装方式，官方推荐Linux或者Mac下可以使用brew或者port 进行安装Windows推荐使用Chocolatey或者Scoop进行安装，或者使用GitHub中的源码进行安装，我选择GitHub的Relaeases包进行安装，因为它不需要其他包管理工具进行安装。其他安装方式请参阅官方安装文档 https://gohugo.io/getting-started/installing 可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或csdn相关加速服务~~，甚至孙悟空的魔法~~ git clone [ssh address][http address] #示例 git clone git@github.com:gohugoio/hugo.git #SSH #或者 git clone https://github.com/gohugoio/hugo.git #HTTP 1.1.2、我的办法 https://github.com/gohugoio/hugo/releases此链接选择最新版，选择对应系统版本下载即可（我的是windows） 下载后进行解压只有三个文件，个人将hugo.exe文件放入bin目录，将网站问建放入sites目录，其他文件放在根目录 在当前目录执行（未配置环境变量） 任意处执行（配置环境变量） cd bin hugo version 单击环境变量（1），创建HOGO_HOME（2），填写路径（3），在原来Path下（4）添加bin目录（5） 执行命令后有类似返回结果（6）说明安装hugo成功（在系统环境变量中（Windows可以在Cotana直接搜索环境变量）） ","date":"2021-01-01","objectID":"/hugo-github/:1:1","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.2 创建网站 #返回上一级目录下的网站目录 cd ../sites hugo new site [site nme] #示例 hugo new site KKKPJSKEY's-Case-Archives ","date":"2021-01-01","objectID":"/hugo-github/:1:2","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.3 选择主题 在https://themes.gohugo.io/这个网址选择你喜欢的主题 https://themes.gohugo.io/material-design/这是我的选择 点击download进入对应的GitHub页面，可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或Csdn相关加速服务~~，甚至孙悟空的魔法~~ #切换到新建的网站目录下 cd KKKPJSKEY's-Case-Archives git clone [ssh address][http address] #示例 git clone git@github.com:pdevty/material-design.git themes/material-design #SSH #或者 git clone https://github.com/pdevty/material-design.git themes/material-design #HTTP （自行下载的压缩请手动解压到theme目录） ","date":"2021-01-01","objectID":"/hugo-github/:1:3","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.4 配置主题 1.4.1、metadata 请将主题目录（1）下的默认配置文件（2）中的内容（3）与网站目录（4）下的默认配置文件（5）中的内容（6）进行整合，以网站目录下的默认配置文件为准，最终成河成（7）的样子即可 1.4.2、其他配置 将根目录（1）下的config.toml文件（2）中的内容改为自己网站的内容（3） 我个人主题配置如上图所示，其他配置请自行参照主题文档进行配置 ","date":"2021-01-01","objectID":"/hugo-github/:1:4","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.5 生成模板MarkDown（带有metadata） 注意metadata中不能使用英文的双引号,可以使用英文单引号或者中文单双引号代替 hugo new [类别]/[文件名] #示例 hugo new blog/使用hugo、GitHub.io搭建个人静态博客.md 执行以上指令即可在以下路径生成对应的文件content/类别/文件名（生成一次后也可手动在content/类别/文件名创建文件，手动拷贝对应的metadata）（这里没有切换路径，但必须在网站根目录下进行） ","date":"2021-01-01","objectID":"/hugo-github/:1:5","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.6编写MarkDown 项目中其他请参照MarkDown语法规范，其中图片需要注意：图片应放到网站根目录下的static中。我为了国立不同静态资源，创建了imags和文章名两级文件夹，图片在MarkDown中应使用，同时使用顺斜杠替换原来反斜杠， /[分类名]/[项目名]/图片名.格式 #个人分类法，非强制要求 #示例 ./1.png 同时使用顺斜杠替换原来反斜杠， ","date":"2021-01-01","objectID":"/hugo-github/:1:6","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.7 本地预览与部署 1.7.1、本地预览 hugo server [-D]（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 22 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 8 Sitemaps | 1 Cleaned | 0 Built in 52 ms Watching for changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 执行后在http://localhost:1313/可以进行访问（-D参数表示无论metadata（1.4.1）是否为true都进行发布，不加参数则只发布为false的项目，下面huge生成静态文件相同） 1.7.2、生成静态文件用于发布 使用hugo [-D]生成静态文件，-D参数在1.6.1介绍的功能相同（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 15 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 5s Sitemaps | 1 Cleaned | 0 Total in 167 ms 以上结果会在网站根目录下的public下生成静态页面 ","date":"2021-01-01","objectID":"/hugo-github/:1:7","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"2 GitHub创建仓库 来到GitHub主页https://github.com/（自行注册登录） 点击左上角新建仓库 输入自己的仓库名（1，我已经创建过不能使用相同的名字因此报错，仓库名没有格式限制，请自行发挥），设置仓库分类（2，公有是所有人能看到，私有是只有项目内成员能看到），点击创建即可（3） ","date":"2021-01-01","objectID":"/hugo-github/:2:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"3 使用Git提交生成的静态页面（1.6.2） #切换到网站名字下的public下 cd public #以下为git指令 ##git 初始化 git init ##添加当前目录下的所有文件到暂存区 git add [.][-u][-A][-all] ##提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息 git commit [-m \"{message}\"] ##从将本地的分支版本上传到远程并合并。 git push 详细Git教程、参数解释在Git笔记（填坑，挖新坑）中，请移步 ","date":"2021-01-01","objectID":"/hugo-github/:3:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"4在GitHub中进行页面展示设置 在你的仓库页面点击Settings（1），在新的页面向下滑动找到GitHub Pages下的Branch（2），选择master（3，或自己的分支），在对应的网址即可访问（4） ","date":"2021-01-01","objectID":"/hugo-github/:4:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"5 结语 至此使用hugo、Github.io搭建个人静态博客彻底完成 ","date":"2021-01-01","objectID":"/hugo-github/:5:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["Operation","note"],"content":"记录Docker常用指令的笔记","date":"2020-12-21","objectID":"/docker-command-note/","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"容器管理指令 # 进入docker容器内部 docker exec -it id /bash/bin # 退出容器 exit # 启动docker容器 sudo systemctl start docker # 设置docker容器开机启动 sudo systemctl enable docker ","date":"2020-12-21","objectID":"/docker-command-note/:1:0","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"记录CentOS7 查询的几种方式和区别解释","date":"2020-12-12","objectID":"/cnetos7-shell-search/","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"1. find 　Java代码 　find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。与查询数据库（/var/lib/locatedb）文件不同，find查找磁盘空间 　find的使用格式如下： $ find \u003c指定目录\u003e \u003c指定条件\u003e \u003c指定动作\u003e 　- \u003c指定目录\u003e: 所要搜索的目录及其所有子目录。默认为当前目录。 　- \u003c指定条件\u003e: 所要搜索的文件的特征。 　- \u003c指定动作\u003e: 对搜索结果进行特定的处理。 　如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。 　find的使用实例： $ find . -name 'my*' 　搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 $ find . -name 'my*' -ls 　搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。 $ find . -type f -mmin -10 　搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。 根据文件名查询 find -name [文件名] 根据文件夹名查询 find [文件夹名] ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:1:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"2. locate 　Java代码 　locate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 　locate命令的使用实例： $ locate /etc/sh 　搜索etc目录下所有以sh开头的文件。 $ locate ~/m 　搜索用户主目录下，所有以m开头的文件。 $ locate -i ~/m 　搜索用户主目录下，所有以m开头的文件，并且忽略大小写。 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:2:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"3. whereis 　Java代码 　whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。同locate一样，查询数据库（/var/lib/locatedb）文件 　whereis命令的使用实例： $ whereis grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:3:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"4. which 　Java代码 　which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 　which命令的使用实例： $ which grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:4:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"5. type 　Java代码 　type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 　type命令的使用实例： $ type cd 　系统会提示，cd是shell的自带命令（build-in）。 $ type grep 　系统会提示，grep是一个外部命令，并显示该命令的路径。 $ type -p grep 　加上-p参数后，就相当于which命令 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:5:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"Linux的CentOS7 中对文件管理的指令笔记","date":"2020-11-27","objectID":"/centos7-file-mange-note/","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"修改文件权限和群组 sudo chmod -R 777 etc(文件名|文件夹名) # -R 要大写，代表递归作用，文件夹下所有子目录权限一致 修改组群的命令使chgrp，即change group，那么修改文件拥有者的命令自然就是chown，即change owner。chown功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数。 语法如下： chown [-R]** #**账号名称** **文件****/****目录 chown [-R]** # **账号名称**:**组群** **文件****/****目录** ","date":"2020-11-27","objectID":"/centos7-file-mange-note/:1:0","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"从末尾查看文件（tail 命令） tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。 tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 ","date":"2020-11-27","objectID":"/centos7-file-mange-note/:2:0","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"命令格式 tail [参数] [文件] ","date":"2020-11-27","objectID":"/centos7-file-mange-note/:2:1","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"参数 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c\u003c数目\u003e 显示的字节数 -n\u003c行数\u003e 显示文件的尾部 n 行内容 –pid=PID 与-f合用,表示在进程ID,PID死掉之后结束 -q, –quiet, –silent 从不输出给出文件名的首部 -s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 ","date":"2020-11-27","objectID":"/centos7-file-mange-note/:2:2","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"实例 要显示 notes.log 文件的最后 10 行，请输入以下命令： tail notes.log # 默认显示最后 10 行 要跟踪名为 notes.log 的文件的增长情况，请输入以下命令： tail -f notes.log 此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。 显示文件 notes.log 的内容，从第 20 行至文件末尾: tail -n +20 notes.log 显示文件 notes.log 的最后 10 个字符: tail -c 10 notes.log 其他示例 tail -n 100 /etc/cron #显示最后100行数据 tail -n -100 /etc/cron #除了前99行不显示外，显示第100行到末尾行 #--------------------------------------------------------------------- tail -n -5 /test001/text001 #与 tail -n 5 /test001/text001 #显示的结果相同，均是文件末尾最后 5 行内容。 tail -n +5 /test001/text001 #显示的内容为从第 5 行开始，直到末尾的内容。tail -n 后面的数字有效输入只有单个数字（5）或者加号连接数字（+5）两种。 ","date":"2020-11-27","objectID":"/centos7-file-mange-note/:2:3","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件管理","uri":"/centos7-file-mange-note/"},{"categories":["Operation","note"],"content":"在Linux和Windows环境中为Git配置生成公私密钥","date":"2020-11-02","objectID":"/git-ssh-key/","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"Windows 所有执行命令的地方都是在管理员模式下进行，即打开cmd，Git Bash客户端用管理员身份运行程序。 ","date":"2020-11-02","objectID":"/git-ssh-key/:1:0","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"单个 在Windows下查看**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]**下是否有*“id_rsa、id_rsa.pub”*文件，如果没有需要从第一步开始手动生成,有的话直接跳到第二步。 第1步：创建SSH Key 打开Git Bash，在控制台中输入以下命令: ssh-keygen -t rsa -C \"youremail@example.com\" 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行,当然，如果不想要这些可以直接输入： ssh-keygen 我一般就是这么做的。 输入完毕后按回车，程序会要求输入一个密码，输入完密码后按回车会要求再确认一次密码，如果不想要密码可以在要求输入密码的时候按两次回车，表示密码为空，并且确认密码为空，此时**[c盘\u003e用户\u003e自己的用户名\u003e.ssh]**目录下已经生成好了。 第2步：将SSH添加到版本管理仓库 不同的版本管理代码仓库都大同小异，这里以Github举例，登录Github。打开setting-\u003eSSH keys，点击右上角 New SSH key，把**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]**目录下生成好的公钥*“id_rsa.pub”*文件以文本打开复制放进 key输入框中，再为当前的key起一个title来区分每个key ","date":"2020-11-02","objectID":"/git-ssh-key/:1:1","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"多个 单个创建工程中不要直接连按回车，修改一下对应的文件名即可（可以不要密码） 然后在两个ssh之间挑选一个用的相对较少的ssh，在对应的文件夹配置当前文件夹local级别的用户名和邮箱，邮箱需要与ssh相对应 备注 Git的用户信息配置 Git的配置一共有三个级别：system(系统级)、global(用户级)和local(版本库)。system的配置整个系统只有一个，global的配置每个账户只有一个，local的配置取决于Git版本库数量，在版本库才能看到。 从Git官网的资料来看，这三个级别是逐层覆盖的。首先去查找system配置，其次查找global配置，最后查找local配置。逐层查找的过程中若查到配置值，则会覆盖上一层的配置。假如三个级别都配置了用户信息，则最后生效的配置是local(版本库)级的。 Git配置用户名邮箱的命令 system配置 git config --system user.name \"username\" git config --system user.email user@email.com global配置 git config --global user.name \"username\" git config --global user.email user@email.com local配置 git config --local user.name \"username\" git config --local user.email user@email.com ","date":"2020-11-02","objectID":"/git-ssh-key/:1:2","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"记录CentOS7 防火墙操作指令笔记","date":"2020-10-10","objectID":"/cnetos7-firewall/","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":" #防火墙端口列表 firewall-cmd --list-port #添加规则 firewall-cmd --zone=public --add-port=80/tcp --permanent #重启防火墙 systemctl restart firewalld.service #移除端口: firewall-cmd --zone=public --remove-port=80/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent #centos7启动防火墙 systemctl start firewalld.service #centos7停止防火墙/关闭防火墙 systemctl stop firewalld.service #centos7重启防火墙 systemctl restart firewalld.service #设置开机启用防火墙 systemctl enable firewalld.service #设置开机不启动防火墙 systemctl disable firewalld.service # 开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 命令含义： # --zone #作用域 # --add-port=80/tcp #添加端口，格式为：端口/通讯协议 # --permanent #永久生效，没有此参数重启后失效 # 重启防火墙 firewall-cmd --reload #常用命令介绍 firewall-cmd --state ##查看防火墙状态，是否是running firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones ##列出支持的zone firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd --add-service=ftp ##临时开放ftp服务 firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务 firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务 firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 # 更多命令，使用 firewall-cmd --help # 查看帮助文件 #\u003e\u003e\u003eCentOS 7默认使用的是firewall作为防火墙，使用iptables必须重新设置下 #直接关闭防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 # 设置 iptables service yum -y install iptables-services # 如果要修改防火墙配置，如增加防火墙端口3306 vi /etc/sysconfig/iptables # 增加规则 # -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 保存退出后 systemctl restart iptables.service #重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 # 最后重启系统使设置生效即可。 # 查询端口号80 是否开启： firewall-cmd --query-port=80/tcp ","date":"2020-10-10","objectID":"/cnetos7-firewall/:0:0","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":"记录CentOS7 端口管理指令的笔记","date":"2020-10-02","objectID":"/centos-port/","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation","note"],"content":" lsof -i tcp:80 # 查看80端口占用情况 netstat -ntlp # 列出所有端口 ","date":"2020-10-02","objectID":"/centos-port/:0:0","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation"],"content":"解决 CentOS7下 javac:未找到命令 问题 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"问题描述： 在linux下编译java程序，执行javac编译生成class文件时，在centos7终端输入如，javac hello.java 会提示未找到指令，但用java -verison测试环境变量是没问题的。 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:1:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"尝试解决： 重新再linux配置环境变量，输入 vi /etc/profile进入，添加以下代码： export JAVA_HOME=/usr/local/jdk1.8.0_144 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:2:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"再测试，最后也没有成功 后来在stackoverflow上看到了这个 84 down vote accepted You installed the Java Runtime Environment (JRE) only, which does not contain javac. For javac, you have to install the OpenJDK Development Environment. You can install java-devel or java-1.6.0-openjdk-devel, which both include javac. By the way: you can find out which package provides javac with a yum search, e.g. su -c ‘yum provides javac’ Another note: using yum and openjdk is only one possibility to install the JDK. Many people prefer Sun/Oracle’s “original” SDK. See How to install Java SDK on CentOS? and links for alternatives. 大意就是我们用yum来装原生的就行了 在终端输入 yum install java-devel 执行安装，再测试就行了 补充：Vi编辑常用快捷键 复制：ctrl+insert 粘贴：shift+insert 按Esc保存退出编译，shift+zz退出 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:3:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation","note"],"content":"记录CentOS7 管理MariaDB指令的笔记","date":"2020-09-09","objectID":"/centos7-mariadb/","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"基本管理指令 systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 ","date":"2020-09-09","objectID":"/centos7-mariadb/:1:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"连接数据库报错Too Many Connectionsbaocuo 重启数据库即可 ","date":"2020-09-09","objectID":"/centos7-mariadb/:2:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation"],"content":"修改Tomcat配置文件导致Tomcat部署Jstl项目报错","date":"2020-08-30","objectID":"/tomcat-jstl-error/","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"问题来源 原Tomcat启动有一条警告，由于看着不爽就查了办法去掉了 办法是修改Tomcat根目录下的conf文件夹下的catalina.properties文件（我这个版本的Tomcat大概在110行） apache-tomcat-9.0.41\\conf\\catalina.properties 改成如下图的样子，报错就消失了 改的时候还很年轻，并不知道自己改了什么，觉得还不错，于是天坑就挖好了 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:1:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"翻车 后面跟着老师开发jsp的时候使用了jstl，然后就死活报错 四处百度无果，向老师求助，老师怀疑是未正确导包，加上我正使用最新版idea，没有j2ee创建web项目了，只能创建普通项目，进入后在添加web模块，加深了老师怀疑导包问题。 期间曾将tld文件直接解压出来使用，被老师喊停，并劝我用maven，我于是转普通j2ee项目为Maven的Web项目，结果肯定问题没解决。 后有尝试创建普通Maven项目，再加入Web组件，依然没解决。 后由于课程时间有限，老师放弃了我。 不甘心，只能解压出tld文件直接使用，熬夜追赶任务进度 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:2:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"解决 项目部署时，同学没有服务器，委托我进行部署，巧妙的发现同学的项目在我这也有问题，将我的代码发给同学，同学可以运行。同时发现部署在服务器上没有任何问题，故深刻怀疑Tomcat的问题。 经过这个思路的稍作搜索，下载了新的tomcat，发现警告，想起了我对Tomcat配置文件下手的事情，所以恢复修改 系统顺利运行！！！问题终于解决。鬼问题纠结了我许久 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:3:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"云服务器安装软件（端口）连接失败解决办法,附各种常用默认端口","date":"2020-08-20","objectID":"/server-port-cant-connect/","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Operation"],"content":" 服务器需要进行控制面板对服务器端口进行放行如3306、8080 软件 默认、常用端口 协议 HTTP协议代理服务器 80/8080/3128/8081/9080 HTTP SOCKS代理协议服务器 1080 FTP（文件传输）协议代理服务器 21 Telnet（远程登录）协议代理服务器 23 HTTP服务器，默认的端口号（木马Executor开放此端口） 80 tcp HTTPS（securely transferring web pages）服务器 443 tcp /udp Telnet（不安全的文本传送）（木马Tiny Telnet Server所开放的端口） 23 tcp FTP（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； 21 tcp TFTP（Trivial File Transfer Protocol ） 69 udp SSH（安全登录）、SCP（文件传输）、端口重定向， 22 tcp SMTP Simple Mail Transfer Protocol (E-mail)，（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； 25 tcp POP3 Post Office Protocol (E-mail) 110 tcp WebLogic 7001 WebSphere应用程序 9080 WebSphere管理工具 9090 JBOSS 8080 TOMCAT 8080 WIN2003远程登陆 3389 Symantec AV/Filter for MSE 8081 Mysql数据库 3306 Oracle 数据库 1521 ORACLE EMCTL 1158 Oracle XDB（ XML 数据库） 8080 Oracle XDB FTP服务 2100 MS SQL SERVER数据库server 1433 tcp /udp MS SQL*SERVER数据库monitor 1434 tcp /udp QQ 1080 udp ","date":"2020-08-20","objectID":"/server-port-cant-connect/:0:0","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Software","note"],"content":"两种VSCode代码行检测插件，支持多种语言","date":"2020-07-28","objectID":"/vscode-count-line/","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"VSCode Counter 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:0","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"使用 ctrl + shift +p，输入counter，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:1","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"loc 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:0","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Software","note"],"content":"使用 ctrl + shift +p，输入LineCount，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:1","tags":["Environment","Editor","VisualStudioCode","Plugin","Code-Line"],"title":"VSCode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Operation","note"],"content":"记录CentOS7 查看系统参数指令","date":"2020-07-01","objectID":"/centos7-version/","tags":["Linux","CentOS7","System"],"title":"CentOS7  查看系统参数","uri":"/centos7-version/"},{"categories":["Operation","note"],"content":"CentOS7 查看系统版本 cat /etc/redhat-release ","date":"2020-07-01","objectID":"/centos7-version/:1:0","tags":["Linux","CentOS7","System"],"title":"CentOS7  查看系统参数","uri":"/centos7-version/"},{"categories":["Operation"],"content":"分析/bin、/usr/bin、/sbin、/usr/sbin的主要区别","date":"2020-06-15","objectID":"/linux-bin-sbin/","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":" /bin: bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。 /usr/bin:主 要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。 /sbin: 主 要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。 /usr/sbin:放置一些网路管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。 ","date":"2020-06-15","objectID":"/linux-bin-sbin/:0:0","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":"项目中途添加.gitignore不生效的办法","date":"2020-06-03","objectID":"/git-mid-gitignore/","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法一 # 清除 缓存区 git rm -r --cached . # 再执行正常的提交流程即可 # 我的 gitignore **/*.md ","date":"2020-06-03","objectID":"/git-mid-gitignore/:1:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法二 删除.git文件，重新执行 # 初始化 git init 即可 ","date":"2020-06-03","objectID":"/git-mid-gitignore/:2:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation","note"],"content":"使用管理工具宝塔面板创建部署网站","date":"2020-05-31","objectID":"/bt-site/","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"1、请自行装好宝塔面板以及Nginx、PHP（其他项目请装对应的服务器以及应用服务器） ","date":"2020-05-31","objectID":"/bt-site/:1:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"2、进入对应的宝塔面板页面点击左侧导航栏的网站（1），再点击添加站点（2）， ","date":"2020-05-31","objectID":"/bt-site/:2:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"3、一下添加对应的数据，并点击提交即可 ","date":"2020-05-31","objectID":"/bt-site/:3:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"在Linux的CentOS8上更换国内yum源","date":"2020-04-29","objectID":"/centos8-change-source/","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":" cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo_back vi CentOS-Base.repo ","date":"2020-04-29","objectID":"/centos8-change-source/:0:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # [BaseOS] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=BaseOS\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/BaseOS/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=extras\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=centosplus\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [AppStream] name=CentOS-$releasever - AppStream #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=AppStream\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/AppStream/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [PowerTools] name=CentOS-$releasever - PowerTools #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=PowerTools\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/PowerTools/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial yum clean all yum makecache ","date":"2020-04-29","objectID":"/centos8-change-source/:1:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"在Linux的Centos7系统上安装Docker","date":"2020-03-20","objectID":"/docker-centos7/","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。 社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。 ","date":"2020-03-20","objectID":"/docker-centos7/:0:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"一、安装docker 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0 $ sudo yum install \u003cFQPN\u003e # 例如：sudo yum install docker-ce-17.12.0.ce 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version ","date":"2020-03-20","objectID":"/docker-centos7/:1:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"二、问题 1、因为之前已经安装过旧版本的docker，在安装的时候报错如下： Transaction check error: file /usr/bin/docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 2、卸载旧版本的包 $ sudo yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 3、再次安装docker $ sudo yum install docker-ce ","date":"2020-03-20","objectID":"/docker-centos7/:2:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation"],"content":"解决centos安装不上apache:No match for argument: httpd","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"找到yum.conf [root@d78acc291c9e var]# find / -name yum.conf /etc/yum.conf ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:1:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"注释掉exclude那行，也可只删除httpd [main] gpgcheck=1 installonly_limit=3 clean_requirements_on_remove=True best=True #exclude=httpd nginx php mysql mairadb python-psutil python2-psutil //重新安装yum install httpd -y systemctl enable httpd systemctl start httpd systemctl status httpd 　Active: active (running) 　Status: “Started, listening on: port 80” [root@d78acc291c9e var]# httpd -v Server version: Apache/2.4.37 (centos) Server built: Dec 23 2019 20:45:34 ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:2:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Total","note"],"content":"Idea设置XML模板并创建xml文件","date":"2020-01-11","objectID":"/idea-xml/","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Total","note"],"content":"1、File—-\u003eSettings 2、Editor(3)—-\u003eFile And Code Templates(4) —\u003e中间选中Files(5) —–\u003e点击左边+号(6)，右边是建立子模版（7），添加模板 —–\u003e输入模板名字：Name:XML File.xml （8，name可以自定义） ——\u003e后缀名extension：xml （9）—\u003e在面板中间输入内容（10，内容请根据自己需求更改，或建立子模版）： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cconfig\u003e \u003cclassName\u003eclassName\u003c/className\u003e \u003c/config\u003e —–\u003e把enable live Template(激活模板)勾选上（11） ——\u003e点击Apply（12）—ok 3、选中文件夹（1）—–\u003eNew（2）——–\u003e找到XML File（3），输入名字，点击确定，就可以创建xml文件了 ","date":"2020-01-11","objectID":"/idea-xml/:0:0","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Operation"],"content":"Docker 容器常见故障排查及处理，将常见问题分类","date":"2019-12-30","objectID":"/docker-error-by-type/","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"Docker是一种相对使用较简单的容器，我们可以通过以下几种方式获取信息： 1、通过docker run执行命令，或许返回信息 2、通过docker logs 去获取日志，做有针对性的筛选 3、通过systemctl status docker查看docker服务状态 4、通过journalctl -u docker.service 查看日志 ","date":"2019-12-30","objectID":"/docker-error-by-type/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"以下是整理的docker容器类问题故障，分为9个类 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"一、启动类故障 1、docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 原因：Docker未正常启动 解决方式： systemctl start docker 2、can’t create unix socket /var/run/docker.sock: is a directory 原因：docker.sock不能创建 解决方式： rm -rf /var/run/docker.sock 然后重新启动docker 3、Job for docker.service failed. Failed to start Docker Application 原因：Selinux引起 解决方式： /etc/sysconfig/selinux , 把 selinux 值改为disabled 重启docker解决 4、docker: Error response from daemon: /var/lib/docker/overlay/XXXXXXXXXXXXXXXXXXXXXXX: no such file or directory. 原因：docker没有指定目录或文件 解决方式： systemctl stop docker rm -rf /var/lib/docker/* systemctl start docker 重启run镜像启动容器 5、docker: Error response from daemon: Conflict. The container name “XXX” is already in use by container “XXX”. You have to remove (or rename) that container to be able to reuse that name. 原因：docker name重名 解决方式： 改名容器或者删除重建容器 6、Error: Connection activation failed: No suitable device found for this connection 原因：网卡配置问题 解决方式： 重启网卡 7、系统重启后docker无法启动 报错为：docker0: iptables: No chain/target/match by that name 原因：docker服务iptables问题 解决方式： 重启docker服务system restart docker 8、Error starting daemon: error initializing graphdriver: driver not supported 使用overlay2存储驱动启动docker daemon报错 原因：daemon缺少配置 解决方式： 添加配置： /etc/docker/daemon.json {“storage-driver”: “overlay2”, “storage-opts”: [“overlay2.override_kernel_check=true”]} 9、Failed to start docker.service: Unit docker.service is masked. 未知原因：docker 被mask 解决方式： systemctl unmask docker.service systemctl unmask docker.socket systemctl start docker.service 10、Failed to start docker.service: Unit is not loaded properly: Invalid argument. 未知原因：docker服务无法正常load 解决方式： 卸载docker， 删除docker.service 重新安装docker 11、docker-compose启动容器时报错： /usr/lib/python2.7/site-packages/requests/init.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn’t match a supported version! RequestsDependencyWarning) 未知原因：pip相应组件版本不支持 解决方式： pip uninstall urllib3 pip uninstall chardet pip install requests 12、docker容器重启故障 强杀docker进程后，重启docker。docker中的容器无法启动并报错 docker restart XXXXXXX Error response from daemon: Cannot restart container XXXXXXX: container “XXXXXXXXXXXXXXXX”: already exists 原因：旧容器未安全退出 解决方式： docker-containerd-ctr –address /run/docker/containerd/docker-containerd.sock –namespace c rm \u003c容器hash_id\u003e docker start 容器 13、docker重启错误-重启命令一直卡住 systemctl restart docker 卡住 未知原因：可能是启动的容器数量过多，或者磁盘IO问题 解决方式： systemctl start docker-cleanup.service systemctl start docker ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:1","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"二、权限问题报错 14、Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock 解决方式： 查看 /var/run/docker.sock所在用户组 将用户重新加入docker组中，usermod -aG docker ${USER} 15、chown socket at step GROUP: No such process 原因：docker无法找到Group组信息，docker组有可能被误删除， 解决方式： groupadd docker 16、Post http:///var/run/docker.sock/v1.XXX /auth: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS-enabled daemon without TLS? 原因：非Root用户管理Docker时，权限不足 解决方式： groupadd docker usermod -a -G docker user 17、docker commit镜像时报错 Error processing tar file(exit status 1): unexpected EOF 原因：可能是权限问题引起 解决方式： chmod +x 加一个执行权限 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:2","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"三、镜像和仓库问题报错 18、Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io 原因：Docker仓库无法访问 解决方式： 修改Docker仓库源为国内或者自建的仓库源 修改/etc/docker/daemon.json 19、推送本地镜像报错 The push refers to a repository [XXXX] Get https://xxx/v1/_ping: http: server gave HTTP response to HTTPS client 原因：docker registry未采用https服务所致 解决方式： /etc/docker/daemon.json 文件写入： { “insecure-registries”:[\"\"] } 20、/usr/bin/docker-current: Error response from daemon: oci runtime error: container_linux.go: starting container process caused “exec: “/bin/bash”: executable file not found in $PATH”. 原因：Docker镜像自身问题或者Docker引擎版本比较低导致 解决方式： 可以升级Docker版本服务 21、构建镜像，执行chown -R非常慢 原因：Docker使用写时复制策略，所以chown命令执行时，会将上层镜像文件全部复制到当前层，然后再修改权限，再写入文件系统。 解决方式： 不应该使用chown -R 这类大批量修改文件的命令 22、docker build构建镜像的时候报错： Message from syslogd kernel:unregister_netdevice: waiting for lo to become free. Usage count = 1 原因：docker engine版本过高 解决方式： docker engine版本需要和docker内部镜像的内核版本匹配 23、docker: Error response from daemon: containerd: container did not start before the specified time-out.ERRO[0133] error getting events from daemon: context canceled 原因：修改完docker root dir，重启后，下载镜像报错 解决方式： 重启docker服务 或者重启服务器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:3","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"四、资源问题报错 25、Docker no space left on device 原因：空间不足 解决方式：清理空间,删除未被使用的容器，镜像等资源 docker system prune -a 26、/var/lib/docker/containers 占用过大 原因：日志文件占用过大 解决方式： cat /dev/null \u003e *-json.log 或者 增加dockerd启动参数，/etc/docker/daemon.json {“log-driver”:“json-file”, “log-opts”: {“max-size”:“2G”, “max-file”:“10”} 27、max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 原因：系统参数默认配置过小 解决方式： 修改/etc/sysctl.conf里面的vm.max_map_count 调大 28、Got starting container process caused “process_linux.go:301:running exec setns process for init caused “exit status 40””: unknown.from time to time 原因：可能是cache问题引起 解决方式： echo 1 \u003e /proc/sys/vm/drop_caches 29、docker本机启动多台容器导致出现后续容器启动失败 原因：查看硬盘空间是否满，如果不是硬盘空间问题引起 解决方式： vim /etc/sysctl.conf 添加参数 fs.aio-max-nr = 1048576 sysctl -p 30、Docker启动异常，状态反复restarting Docker logs 容器名，查看异常日志 查看/var/log/messages 原因：内存跑满，引起OOM 解决方式： 释放内存后，再启动容器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:4","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"五、版本不兼容报错 31、overlayfs: Can’t delete file moved from base layer to newly created dir even on ext4 原因：Centos 提供的文件系统 XFS 和 Overlay 兼容问题导致, 解决方式： 这个问题的修复在内核 4.4.6以上 32、docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused “process_linux.go:297: getting the final child’s pid from pipe caused “read init-p: connection reset by peer””: unknown. 原因：Docker版本和操作系统版本不匹配 解决方式： 重新安装和操作系统内核支持的docker 版本 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:5","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"六、网络或端口问题报错 33、WARNING: IPv4 forwarding is disabled. Networking will not work. 原因：ipv4网络无法转发 解决方式: /usr/lib/sysctl.d/00-system.conf 在最后一行添加net.ipv4.ip_forward=1 重启network服务。删除错误的容器，再次创建新容器 34、Creating network “xxxxxxx” with the default driver 原因：docker网关冲突 启动容器、docker-compose启动容器后，断网问题 解决方式： 配置 docker-compose.yml内给启动的容器配置参数network_mode: “bridge” 35、Unable to find a node that satisfies the following conditions [port xxxx] 原因：当容器使用端口映射(docker run -p xxxx:xxxx或 compose模板中的 ports)之后 系统会在宿主机上创建一个port，通过NAT来访问容器的指定port。如果宿主机上的端口被容器或者系统进程占用，就会导致端口分配失败。 解决方式： 清除占用端口的容器或者进程，或调整容器端口映射的宿主机端口避免冲突 36、Error response from daemon: service endpoint with name xxx already 原因：端口已经被占用 解决方式： 重启docker容器 37、docker: Error response from daemon: driver failed programming external connectivity on endpoint XXXXX: Bind for 0.0.0.0:80 failed: port is already allocated 原因：容器端口冲突 解决方式： 更换宿主机绑定端口 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:6","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"七、Docker安装报错 38、安装docker报Requires: container-selinux \u003e= 2.9 原因：container-selinux版本低或者是没安装的原因 解决方式： wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install epel-release yum makecache yum install container-selinux 39、安装docker-compose时报错 “ImportError: ‘module’ object has no attribute ‘check_specifier’” 原因：setuptools版本问题 解决方式： 升级setuptools到30.1.0版本以上版本 pip install –upgrade setuptools 40、安装docker-compose时报错 DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7. 原因：python2.7提示升级 解决方式： pip install -i https://pypi.douban.com/simple docker-compose ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:7","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"八、Docker删除报错 41、docker删除容器报错 Error response from daemon:Driver overlay failed to remove root filesystem xxxxx: remove/var/lib/docker/overlay2/xxxxx/merged: device or resource busy 原因：容器挂载数据卷，无法直接删除 解决方式： grep docker /proc/*/mountinfo | grep xxxxx kill进程后 再重新删除容器 42、状态dead的容器删除报错 Error response from daemon: Driver aufs failed to remove root filesystem XXXXXXXXXXXXXXXX: aufs: unmount error after retries: /var/lib/docker/aufs/mnt/xxxxxxxx: device or resource busy 原因：dead状态容器无法删除，还在占用资源 解决方式： docker rm -fv 容器id 过几分钟后会自动删除 43、docker删除镜像报错 Error response from daemon: conflict: unable to remove repository reference “XXXX” (must force) - container XXXX is using its referenced image YYYY 原因：镜像正在被某容器使用 解决方式： 需要删除相关ID容器后，才能删除镜像 44、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXXXXXXXXX (must be forced) - image is referenced in multiple repositories 原因：镜像login push 了远端其他仓库 解决方式： 如果不需要此镜像， docker rmi -f 强删 45、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXX (cannot be forced) - image has dependent child images 原因：存在依赖于父镜像的子镜像 解决方式： 强制删除镜像或者批量删除容器，再删除镜像 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:8","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"九、其他报错 46、docker: Error response from daemon: driver failed programming external connectivity on end-point XXXXXXX: (iptables failed: iptables –wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 –dport 8080 -j ACCEPT: iptables: No chain/target/match by that name. 原因：防火墙问题引起 解决方式： 关闭防火墙，重启docker 47、执行docker info出现如下警告 WARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled 原因：配置问题引起，需要启用bridge-nf-call-iptables 解决方式： vi /etc/sysctl.conf 添加以下内容 net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-arptables = 1 48、docker数据库相关报错 使用Docker创建mysql容器闪退 Database is uninitialized and password option is not specified 解决方式： docker run -d -e MYSQL_ROOT_PASSWORD=[密码] -p 3306:3306 mysql镜像 Docker使用规范建议 尽量使用最近1-2年的新的稳定的docker版本 不要去安装今年前很老的版本，大量的bug已经被新版本更新解决掉了 尽量不要去创建非常大的镜像，比如5G10G以上的 镜像要尽量轻量化，去除不必要的软件，数据等 容器内挂载宿主机配置，使用只读 容器需要-v 宿主机的配置文件，尽量使用ro只读 数据要挂载宿主机物理硬盘或存储节点上 不要直接在容器里run，避免容器宕机引起数据丢失 应用日志一定要挂到宿主机上 不要直接打印到容器内，避免只能docker logs方式查看，避免去vulume目录里查看日志 不要只使用latest标签 Tag要有个管理标准，可以根据tag查找对应版本 不要使用容器ip，配置里更不能写死（默认172.17.0.x） 容器重启后，ip很可能会变 尽量不要在单容器内跑多进程 容器不是虚拟机，尽量做到1个容器，1个进程 跨环境镜像保持一致 不论是测试，UAT，生产环境，尽量保持同一个镜像，不要变更，环境变更只需要变更环境变量参数做区分 一定监控docker容器，即使发现问题 建议使用prometheus监控容器 一定要限制docker容器的资源， 尤其是CPU、内存、硬盘空间，甚至是网络等，避免侵占宿主机的硬件资源 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:9","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"解决Git提交错误怎么办的集中办法和相关知识","date":"2019-12-05","objectID":"/git-commit-error/","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"方法: ","date":"2019-12-05","objectID":"/git-commit-error/:1:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"reset git reset --hard \u003ccommit_id\u003e git push origin HEAD --force # 或 git push origin HEAD --force 其他: #根据–soft –mixed –hard，会对working tree和index和HEAD进行重置: git reset --mixed #此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset --soft #回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset --hard #彻底回退到某个版本，本地的源码也会变为上一个版本的内容 HEAD 最近一个提交 HEAD^ 上一次 \u003ccommit_id\u003e 每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到. reset的结果是完全回复到某次提交的状态，但是有可能再多人开发时，不能及时通知导致冲突 ","date":"2019-12-05","objectID":"/git-commit-error/:1:1","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"revert 2.使用“git revert -n 版本号”反做，并使用“git commit -m 版本名”提交： （1）反做，使用“git revert -n 版本号”命令。如下命令，我们反做版本号为8b89621的版本： git revert -n 8b89621019c9adc6fc4d242cd41daeb13aeb9861 注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。 （2）提交，使用“git commit -m 版本名”，如： git commit -m \"revert add text.txt\" 此时可以用“git log”查看本地的版本信息，可见多生成了一个新的版本，该版本反做了“add text.txt”版本，但是保留了“add text2.txt”版本： 3.使用“git push”推上远程库： git push ","date":"2019-12-05","objectID":"/git-commit-error/:1:2","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"commit合并 有时commit太多，而且可能一个commit只是提交一个小bug，那么合并commit势在必行。 有两种方法： 一是在提交最后一个修改的commit使用参数，这时之前的一个commit将会合并到这个即将提交的commit中来： git commit -a --amend -m \"my message here\"如果之前有一个提交，并且信息为: git commit -a -m \"my last commit message\" 则这个commit message将不存在。但该commit的信息已经合并到\"my message here\"中了。 第二个是，如果你提交了最后的修改，这时可用： git reset --soft HEAD^ #或HEAD^意为取消最后commit git commit --amend 这将会把最后一个commit合并到前一个提交中去，例如（由上往下读）： git add b.text git commit -a -m \"my message here\" git add a.text git commit -a -m \"my last commit message\" 那么最后存在的将是\"my last commit message\"。也可后退n个，合并到前面第n+1个commit中去： $ git reset --soft HEAD~n #后退到第n，我也不清楚具体含义。 $ git commit --amend [-m \"new message\"] 我觉得最方面的是调用reflog查看操作历史，找到具体的commit id，然后直接git reset –hard [commit_id]就回到你要的版本！ ","date":"2019-12-05","objectID":"/git-commit-error/:2:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"强制Push注意事项 本地回复后需要使用–force强制push到远程仓库 git push origin --force 会报如下错误： You are not allowed to force push code to a protected branch on this project 如果用的是gitlab版本库，这说明gitlab对仓库启用了保护，需要在仓库中设置一下： GitLab Community Edition 11.7.5 \"Settings\" -\u003e \"Repository\" -\u003e scroll down to \"Protected branches\". \"设置\" -\u003e \"仓库\" -\u003e 滑动到 \"Protected branches\". 番外：语言设置 \"User Name\" -\u003e \"Settings\" -\u003e \"Profile\" -\u003e scroll down to \"Main settings\" \"用户名\" -\u003e \"设置\" -\u003e \"用户资料\" -\u003e 滑到 \"主要设置\" GitLab Community Edition 13.7.4 \"Admin Area\" -\u003e \"Settings\" -\u003e \"Genneal\" -\u003e scroll down to \"Visibility and access controls\". \"管理中心\" -\u003e \"设置\" -\u003e \"通用\" -\u003e 滑到 \"可见性与访问控制\". 番外：语言设置 \"User Name\" -\u003e \"Settings\" -\u003e \"Preferences\" scroll down to -\u003e \"Localization\" \"用户名\" -\u003e \"设置\" -\u003e \"偏好设置\" 滑到 -\u003e \"本地化\" ","date":"2019-12-05","objectID":"/git-commit-error/:3:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-error/"},{"categories":["Operation"],"content":"解决CentOS7运行Docker报错 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\" 问题","date":"2019-11-01","objectID":"/docker-daemon-is-running/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Operation"],"content":"执行命令：sudo dockerd –debug 注意此条指令不能Ctrl+C停止，否则还会出现一样的错误 之后重启docker：systemctl restart docker就可以了 在网上搜了半天，有的是去编辑 /etc/docker/daemon.json 文件，而有的是在 docker.service 如果在 /etc/docker/daemon.json 的解决办法：添加 insecure-registries 即可 sudo vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://zydiol88.mirror.aliyuncs.com\"], \"insecure-registries\": [\"161.17.60.38:85\"] } 如果是在 docker.service 解决办法：在 ExecStart 添加 –insecure-registry find / -name docker.service -type f /usr/lib/systemd/system/docker.service # 在 ExecStart 这行后面加上 -insecure-registry=Harbor登录地址 sudo vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --insecure-registry=161.17.60.38:85 sudo systemctl daemon-reload sudo systemctl restart docker 重启完成后重新登录即可 # 在linux总端登录Harbor： sudo docker login -u tens -p Tens123456 161.17.60.38:85 ","date":"2019-11-01","objectID":"/docker-daemon-is-running/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Back","note"],"content":"Idea在Maven中和手动导入Jar包中直接查看Jar包源码","date":"2019-10-03","objectID":"/idea-jar-src/","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"Maven 1、从maven相关仓库添加依赖到Pom文件 2、点击Idea中的Maven（1）下的依赖文件夹（2）下的你想找源码的包（3），右键单击download source（下载源码） 3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:1:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"手动导jar包 1、自行手动导jar包到项目 2、直接使用Maven分类的全局搜索即可 Maven：3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:2:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Operation","note"],"content":"GitLab（私服）修改仓库成员可见属性","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Operation","note"],"content":"在 UI 界面中，选择 Settings \u003e General。 在弹出的界面中，选择 Visibility, project features, permissions 后面的 Expand 按钮。 然后在弹出的界面中，将 Project Visibility 下面从 Private 选择为 Public。 你的项目就可以被 Public 访问到了。 最后，不要忘记将你的修改保存以便于生效。 ","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/:0:0","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Software","note"],"content":"记录常用的Vim笔记","date":"2019-08-31","objectID":"/vim-note/","tags":["Environment","Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Software","note"],"content":"指令模式下的指令 # vim高亮搜索 /名字 或 选中后 shift+3（非小键盘） # 关闭vim搜索高亮 输入:nohlsearch 或:set nohlsearch； # vim增加页码 ：set num # 或 ：set number ","date":"2019-08-31","objectID":"/vim-note/:1:0","tags":["Environment","Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Operation","note"],"content":"在Linux的CentOS7系统中使用shell指令查看Git安装的路径","date":"2019-07-01","objectID":"/centos7-git-path/","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation","note"],"content":" command -v git ","date":"2019-07-01","objectID":"/centos7-git-path/:0:0","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation"],"content":"解决CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）报错","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":" # service docker start Redirecting to /bin/systemctl start docker.service Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details. # systemctl status docker.service ● docker.service - Docker Application Container Engine Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled) Drop-In: /usr/lib/systemd/system/docker.service.d └─flannel.conf Active: failed (Result: exit-code) since Wed 2018-08-29 04:54:57 UTC; 20s ago Docs: https://docs.docker.com Process: 10689 ExecStart=/usr/bin/dockerd (code=exited, status=1/FAILURE) Main PID: 10689 (code=exited, status=1/FAILURE) ****** systemd[1]: Starting Docker Application Container Engine... ****** dockerd[10689]: can't create unix socket /var/run/docker.sock: is a directory ****** systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE ******systemd[1]: Failed to start Docker Application Container Engine. ******systemd[1]: Unit docker.service entered failed state. ******systemd[1]: docker.service failed. ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":"解决 # 删除docker.sock rm -rf /var/run/docker.sock # 重新启动即可 service docker restart ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation","note"],"content":"Git-Branch分支操作的常用指令笔记","date":"2019-05-01","objectID":"/git-branch/","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"创建分支 # 根据名称创建分支,并切换分支 git checkout -b {name} # 示例 git checkout -b zhangsan # 这条指令是 git checkout zhangsan # 和 git branch zhangsan # 两条指令的结合体 ","date":"2019-05-01","objectID":"/git-branch/:1:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"查看分支 # 查看所有分支，当前分支为绿色 git branch [-a] # -a 所有分支 # 创建分支 git branch mybranch # 切换分支 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:2:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改分支名称 # 需要将分支br_rename_old修改为br_rename_new，执行如下步骤： ## 1、切换到br_rename_old分支，如果已经在这个分支下，可以不执行此步骤 git checkout br_rename_old ## 2、将代码更新到和远程仓库一致 git pull origin br_rename_old ## 3.1、将本地仓库的br_rename_old的名称修改为br_rename_new git branch -m br_rename_old br_rename_new ## 3.2、将本地仓库的当前分支的名称修改为br_rename_new git branch -m br_rename_new ## 4、将远程分支br_rename_old删除 git push origin --delete br_rename_old ## 5、将本地分支push到远程仓库 git push --set-upstream origin br_rename_new ","date":"2019-05-01","objectID":"/git-branch/:3:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"备份分支 根据git当前提交节点创建分支button-and-input，继承之前所有提交代码 git branch button-and-input ","date":"2019-05-01","objectID":"/git-branch/:4:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法一 将本地创建的button-and-input分支提交到远程，名字为button-and-input git push origin button-and-input:button-and-input ","date":"2019-05-01","objectID":"/git-branch/:4:1","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法二 正常提交代码流程但最后一步提交到新创建的仓库或之前做过直接可以提交至新创建的远程仓库分支 git add . git commit -m \"Message\" git push origin button-and-input 二者都能达到备份代码目的 ","date":"2019-05-01","objectID":"/git-branch/:4:2","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"其他 合并分支：(merge from) $ git checkout master $ git merge mybranch (merge from mybranch) 删除本地分支： $ git branch -d mybranch 强制删除分支： $ git branch -D mybranch 列出所有分支： $ git branch ","date":"2019-05-01","objectID":"/git-branch/:5:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"非绝对必要且明白产生其他后果时才能进行的操作 # 切换分支 在没有commit时请备份代码或者commit、push后再进行提交否则，会导致当前代码全部丢失 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:6:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改","date":"2019-04-30","objectID":"/git-package-rename/","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":" “修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改 git mv -f [file] [newfile] #示例 git mv -f Github GitHub #-f=--forse,即使目标存在，也强制重命名或移动文件 ","date":"2019-04-30","objectID":"/git-package-rename/:0:0","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":"展示Git仓库交互流程方法和部分参数之间的区别","date":"2019-03-15","objectID":"/git-push-ways/","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"简单Git仓库交互 一般小项目交互 # 0.拉取代码 git clone [仓库地址] # 或 git init git remote add [仓库地址] # git remote add 只是在您的git config中创建一个条目，指定特定URL的名称。你必须有一个现有的git仓库来使用它。需要init # git clone通过复制位于您指定的URI上的现有git存储库来创建新的git存储库。不需要init ################################################################################################ # 开发 ################################################################################################ # 1.添加当前目录下的所有文件到暂存区： git add [.][-u][-A][-all] # -u 将文件的修改、文件的删除，添加到暂存区。 # . 将文件的修改，文件的新建，添加到暂存区。 # -A/-all 将文件的修改，文件的删除，文件的新建，添加到暂存区。 # 2.提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息，不添加-m参数会弹出问价，要求填写message git commit [-m \"{message}\"] # 示例 git commit -m \"这是个标签1\" # 3.从将本地的分支版本上传到远程并合并。不添加origin master会提交到默认分支，添加后可以分开分支进行开发互不干扰 git push [origin {master}] ","date":"2019-03-15","objectID":"/git-push-ways/:1:0","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"大型项目Git仓库交互 ","date":"2019-03-15","objectID":"/git-push-ways/:2:0","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"Fork原项目 一般的Git仓库自带，将其复制一份到自己的仓库，称为Remote ","date":"2019-03-15","objectID":"/git-push-ways/:2:1","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"拉取代码 拉去自己仓库的Remote代码，本地称为Local git clone [仓库地址] # 或 git init git remote add [仓库地址] ","date":"2019-03-15","objectID":"/git-push-ways/:2:2","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"开发 ","date":"2019-03-15","objectID":"/git-push-ways/:2:3","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"提交（合并） 第一种：将自己仓库中原来fork的项目删掉 (delete deletethis repository)，然后在重新到原作者仓库中(fork)一份最新代码（不推荐方式），这似乎达到了我们的最终目的，但是自己改变的代码没合并进来。 第二种：在本地建立两个库的中介，把两个远程库都clone到本地，然后拉取原项目更新到本地，合并更新，最后push到你的github就完成。（推荐方式） 第二种实现 查看关联仓库信息 git remote -v 添加原仓库关联 git remote add upstream [原仓库地址] git remote -v upstream相当于一个别名，名字随便取。 再次查看关联仓库信息 git remote -v 获取原仓库代码 这时有两个远程分支，我们继续 fetch，然后把原项目更新的内容fetch到本地 git fetch upstream 查看下分支 git branch -av 一个本地分支master，三个远程分支，画红线的就是要合并的 merge git checkout master git merge hunter/master 冲突 如果有冲突的话，需要丢掉本地分支 git reset –hard hunter/master 提交 这时你的当前本地的项目变成和原作者的主项目一样了，可以把它提交到你的GitHub库 git commit -am ‘更新到原作者的主分支’ git push origin git push -u origin master -f –强制提交 合并到原仓库 发起合并请求 以GitHub为例，先点击Pull requsets（1），再点击New pull requset（2）创建合并请求 选择本地和远程仓库（1）（2），点击Create pull requset发起合并请求，等待原仓库作者测试同意合并即可 至此项目提交圆满结束 再次接到开发任务后(第二种实现) Loop 先更新原仓库 git fetch upstream 切换自己开发分支 git checkout master 将原仓库合并到自己仓库分支 git merge upstream/master 将更新推送到自己的Remote git add [.][-u][-A][-all] git commit -m \"这是个标签1\" git push [origin {master}] 是否合并 有开发内容则发起PR，无开发内容（仅更新原作者代码）直接跳过此步骤 开发 …… End Loop 如此仅需从获取源仓库代码开始循环即可 循环 ","date":"2019-03-15","objectID":"/git-push-ways/:2:4","tags":["Git","Repository","Commit"],"title":"Git仓库交互流程方法","uri":"/git-push-ways/"},{"categories":["Operation","note"],"content":"Git在本地初始化仓库流程","date":"2019-02-04","objectID":"/git-repo-init/","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":" 自行在系统环境中安装Git，这里不做介绍 #Git 本地仓库初始化，生成.git的隐藏文件 git init # 配置个人信息邮箱、姓名 --global是指全局有效，无论在哪个仓库均有效 ## 姓名 git config --global user.name \"{name}\" # 示例 git config --global user.name \"zhangsan\" ## 邮箱 git config --global user.email {email.example.com} # 示例 git config --global user.name \"{zhangsan.qq.com}\" # 查看配置信息 git config --list # 修改配置信息 # 重新添加一次即可覆盖 # 或 git config --global configName configValue # 删除 git config --global --unset configName (只针对存在唯一值的情况) ","date":"2019-02-04","objectID":"/git-repo-init/:0:0","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":"从底层解释yum makecache的作用","date":"2019-01-24","objectID":"/yum-makecache/","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Operation","note"],"content":"疑问： yum makecache 的作用到底是什么呢? 查看了很多的资料，都说是会从服务器中下载一些信息，但是我做了一个测试。 [root@localhost 7]# yum clean all [root@localhost 7]# yum install createrepo -y [root@localhost 7]# yum remove createrepo -y 断网之后 [root@localhost 7]# yum install createrepo -y #安装成功 #发现还是可以安装成功，所以可以判断这时通过缓存安装的。但是为了严谨再执行以下命令。 [root@localhost 7]# yum clean all #清理缓存再安装 [root@localhost 7]# yum install createrepo -y #安装失败 根据上述实验，我们可以判断yum 安装软件包的时候就已经把该软件包缓存起来了，而不需要执行yum makecache 进行额外的缓存。 但是很多资料中都说安装好软件之后需要执行yum makecache 这个命令进行缓存。(不知道是什么原因) 总结：yum安装的时候会将安装包进行缓存，不过最好还是再执行一下yum makecache命令。 ","date":"2019-01-24","objectID":"/yum-makecache/:0:0","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Hardware"],"content":"Win10鼠标出现延迟现象","date":"2018-12-31","objectID":"/windows-mouse-delay/","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"1、修改控制面板电源选项 控制面板下的电源选项 找到自己当前的电源计划，点击更改计划设置 点击更改高级电源设置 在Usb设置下的USB选择性暂停设置下的使用电池和接通电源均禁用（该操作可能耗电，情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:1:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"2、由于连接在扩展坞上，切换至USB无此情况，怀疑扩展坞问题，更换扩展坞情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:2:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"3、随着Win10 更新，原扩展坞和鼠标延迟现象彻底消失，最新版的Win10还是有Bug的 ","date":"2018-12-31","objectID":"/windows-mouse-delay/:3:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Operation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2018-11-11","objectID":"/shell-script-note/","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"set -e的作用 #!/bin/bash set -e ... command 1 command 2 ... exit 0 你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。 这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。 ","date":"2018-11-11","objectID":"/shell-script-note/:1:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"特殊变量（$0、$1、$2、 $?、 $# 、$@、 $*） shell编程中有一些特殊的变量可以使用。这些变量在脚本中可以作为全局变量来使用。 名称 说明 $0 脚本名称 $1-9 脚本执行时的参数1到参数9 $? 脚本的返回值 $# 脚本执行时，输入的参数的个数 $@ 输入的参数的具体内容（将输入的参数作为一个多个对象，即是所有参数的一个列表） $* 输入的参数的具体内容（将输入的参数作为一个单词） $@与$*的区别： 　$@与$*都可以使用一个变量来来表示所有的参数内容，但这两个变量之间有一些不同之处。 　$@：将输入的参数作为一个列表对象 　$*：将输入的参数作为一个单词 #源代码： echo \"脚本的名字是：\"$0 n=1 echo \"使用\\$@的参数列表为：\"$@ for temstr in \"$@\" do echo \"第$n个参数是：\" $temstr let n+=1 done n=1 echo \"使用\\$*的参数列表为：\"$* for temstr in \"$*\" do echo \"第$n个参数是：\" $temstr let n+=1 done #执行结果： $ ./test.sh 1 2 3 4 脚本的名字是：./test.sh 使用$@的参数列表为：1 2 3 4 第1个参数是： 1 第2个参数是： 2 第3个参数是： 3 第4个参数是： 4 使用$*的参数列表为：1 2 3 4 第1个参数是： 1 2 3 4 在上面的例子中，使用$@与$*是，都是用双引号引起来，但当$*不使用双引号时，结果与$@的结果相同。 　原因分析： 　当都使用双引号时，我们可以看到参数列表输出都是一样的，说明确实两个变量都可以存储所有的参数内容，也就显示出来两个变量之间的对参数处理的不同，即一个将其作为列表处理，一个讲所有参数作为一个单词处理。 　当$*不适用双引号时，执行到for语句时，会首先将$*的值（1 2 3 4 ）取出来，然后循环语句就变成了　for tem in 1 2 3 4 ，最后的输出结果也就变成了列表的循环输出。 #源码： #!/bin/bash n=1 for tem in $* do echo $n is $tem let n+=1 done 执行结果： # ./test.sh 1 2 3 4 1 is 1 2 is 2 3 is 3 4 is 4 　在这里补充一下单引号、双引号以及没有引号的区别： 单引号： 　可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看见的是什么就会输出什么。 双引号： 　把双引号内的内容输出出来；如果内容中有命令，变量等，会先把变量，命令解析出结果，然后在输出最终内容来。 　双引号内命令或变量的写法为命令或变量或$（命令或变量）。 无引号： 　把内容输出出来，可能不会讲含有空格的字符串视为一个整体输出； 　如果内容中有命令、变量等，会先把变量、命令解析结果，然后在输出最终内容来； 　如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用，不过最好用双引号替代之 ","date":"2018-11-11","objectID":"/shell-script-note/:2:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"Shell脚本IF条件判断和判断条件总结 这里有IF条件判断的语法和常用的判断条件总结,需要的朋友可以参考下 ","date":"2018-11-11","objectID":"/shell-script-note/:3:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"前言: 无论什么编程语言都离不开条件判断。SHELL也不例外。 代码如下: if list then do something here elif list then do another thing here else do something else here fi ","date":"2018-11-11","objectID":"/shell-script-note/:3:1","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"EX: 代码如下: \\#!/bin/sh SYSTEM=`uname -s` #获取操作系统类型，我本地是linux if [ $SYSTEM = \"Linux\" ] ; then #如果是linux的话打印linux字符串 echo \"Linux\" elif [ $SYSTEM = \"FreeBSD\" ] ; then echo \"FreeBSD\" elif [ $SYSTEM = \"Solaris\" ] ; then echo \"Solaris\" else echo \"What?\" fi #ifend 基本上和其他脚本语言一样。没有太大区别。不过值得注意的是。[]里面的条件判断。 ","date":"2018-11-11","objectID":"/shell-script-note/:3:2","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"1、字符串判断 条件 解释 str1 = str2 当两个串有相同内容、长度时为真 str1 != str2 当串str1和str2不等时为真 -n str1 当串的长度大于0时为真(串非空) -z str1 当串的长度为0时为真(空串) str1 当串str1为非空时为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:3","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"2、数字的判断 条件 解释 int1 -eq int2 两数相等为真 int1 -ne int2 两数不等为真 int1 -gt int2 int1大于int2为真 int1 -ge int2 int1大于等于int2为真 int1 -lt int2 int1小于int2为真 int1 -le int2 int1小于等于int2为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:4","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"3、文件的判断 参数 解释 -r file 用户可读为真 -w file 用户可写为真 -x file 用户可执行为真 -f file 文件为正规文件为真 -d file 文件为目录为真 -c file 文件为字符特殊文件为真 -b file 文件为块特殊文件为真 -s file 文件大小非0时为真 -t file 当文件描述符(默认为1)指定的设备为终端时为真 ","date":"2018-11-11","objectID":"/shell-script-note/:3:5","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"4、复杂逻辑判断 参数 解释 -a 与 -o 或 ! 非 ","date":"2018-11-11","objectID":"/shell-script-note/:3:6","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"结尾： 语法虽然简单，但是在SHELL里使用的时候，他的功能变得强大了。 ================================================================== ","date":"2018-11-11","objectID":"/shell-script-note/:3:7","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"附 表： 参数 解释 [ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 [ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。 [ STRING1 != STRING2 ] 如果字符串不相等则为真。 [ STRING1 \u003c STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 [ STRING1 \u003e STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 [ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. ","date":"2018-11-11","objectID":"/shell-script-note/:3:8","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Operation","note"],"content":"运行 在Linux系统下运行.sh文件有两种方法，比如我在root目录下有个datelog.sh文件 第一种（这种办法需要用chmod使得文件具备执行条件(x): chmod u+x datelog.sh）： 1、在任何路径下，输入该文件的绝对路径/root/datelog.sh就可执行该文件（当然要在权限允许情况下） 2、cd到datelog.sh文件的目录下，然后执行./datelog.sh 第二种（这种办法不需要文件具备可执行的权限也可运行）： 1、在该文件路径下sh加上文件名字即可，sh datelog.sh 2、在任意路径下，sh 加上文件路径及文件名称：sh /root/ datelog.sh ","date":"2018-11-11","objectID":"/shell-script-note/:4:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script-note/"},{"categories":["Front","note"],"content":"在火狐浏览器设置禁用js","date":"2018-10-15","objectID":"/firefox-forbid-js/","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器禁用js","uri":"/firefox-forbid-js/"},{"categories":["Front","note"],"content":"首先打开火狐浏览器 接着再地址栏输入about:config，点击回车键 接着看到如下画面。去掉下次任显示此警告前面的方框里的钩，再点击我 保证会小心按钮 点击后看到如下画面，在搜索地址栏中输入javascript.enabled 接着就会看到如下图，原来有很多的内容变成之后两个了。 鼠标右键第一个，弹出菜单。再点击切换 当一行的中的，值由trun变成false。时候说明已经关闭了。 如下图只要打开有javascript，页面就会无法使用了。有些页面还会提示。 ","date":"2018-10-15","objectID":"/firefox-forbid-js/:0:0","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器禁用js","uri":"/firefox-forbid-js/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错","date":"2018-09-15","objectID":"/win10-update-80070003/","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错 关闭Windows Update服务 删除C:\\Windows\\SoftwareDistribution\\Download下的内容 启动Windows Update服务 再次更新即可 ","date":"2018-09-15","objectID":"/win10-update-80070003/:1:0","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Hardware","note"],"content":"记录键盘符号中英文对照表","date":"2018-08-20","objectID":"/keyboard-chinese-english/","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["Hardware","note"],"content":" 键 英文 中文 ~ tilde 波浪符 ` back quote 反引号 ! exclamation mark or bang 叹号 @ at 艾特 # hash or number or sharp 井号 $ dollar 美元符 % percent 百分号 ^ caret 脱字符、插入符 \u0026 and or ampersand 与和符 ***** asterisk 星号 ( ) parentheses 圆括号、小括号 [ ] brackets 方括号、中括号 { } curly brackets 花括号、大括号 - hyphen or dash or minus 连字符、减号 _ underscore 下划线 + plus 加号 = equal 等号 / slash 斜线 ** back slask 反斜线 | pipe or bar 竖线 : colon 冒号 ; semicolon 分号 ' single quote 单引号 \" “ quote 双引号 \u003c less than or angle brackets 小于 \u003e greater than or angle brackets 大于 , comma 逗号 . period or dot 句号 ? question mark 问号 ESC escape key 跳离键 Backspace backspace key 退格键 Insert insert key 插入建 Home home key 原位键 Delete delete key 删除键 End end key 结尾键 Page Up page up key 向上翻页键 Page Down page down key 向下翻页键 Enter enter key 回车键 Tab tab key 制表键 Caps Lock caps lock key 大写锁定键 ALT alternate key 可选键 CTRL control key 控制键 SHIFT shift key 上档键 Space space bar 空格键 Num num lock key 数字键盘锁定键 ","date":"2018-08-20","objectID":"/keyboard-chinese-english/:0:0","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.78.1). 推荐使用 Hugo extended 版本\r\r由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 CodeIT 主题的仓库是: https://github.com/sunt-programator/CodeIT. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/sunt-programator/CodeIT.git themes/CodeIT 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/sunt-programator/CodeIT.git themes/CodeIT ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 CodeIT 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"CodeIT\" [params] # CodeIT 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/sunt-programator/CodeIT/issues/158) noClasses = false 注意\r\r在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意\r\r默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \"\r基本配置下的预览\r 技巧\r\r当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\r\r 注意\r\r由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender \r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧\r\r网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多…\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, CodeIT 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # CodeIT 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"CodeIT\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # (HTML format is supported) # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意\r\rHugo extended 版本对于自定义样式是必需的.\r\r 通过定义自定义 .scss 样式文件, CodeIT 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/CodeIT/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url(\"https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext\"); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n CodeIT 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \"\r语言切换\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo 如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意\r\r请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容.\r\r 技巧\r\r也可以使用 文章前置参数 来翻译网址.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/CodeIT/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, CodeIT 主题支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎?\r\r以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. \r\r 关于 algolia 的使用技巧\r\r你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json…\r\r","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\" \u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.1 instagram(旧版) instagram 的文档 instagram官方文档（Facebook） 一个 instagram 示例: {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} 呈现的输出效果如下: 这个instagram的shortcode功能依赖于 Instagram的一个API, 然而自从2020年10月24日起就被弃用了。因此，无法从此API端点获取任何图像，从而导致在使用instagram的shortcode时出错。有关更多信息，请查看GitHub问题[#7879] #7879. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.2 instagram(我搜索并根据官方文档的办法) instagram 的文档（Hugo官方未更新） instagram官方文档（Facebook） #1.在开发者官方注册 #在开发者工具中创建任务获取app-id和app-secret，填入下面的请求地址 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id={your-app-id} \u0026client_secret={your-app-secret} \u0026grant_type=client_credentials\" # 示例 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id=123\u0026client_secret={456} \u0026grant_type=client_credentials\" #获得token后填入下面的地址，即可获得返回的html代码 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url={url}\u0026access_token={access-token}\" # 示例 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url=https://www.instagram.com/p/fA9uwTtkSN/\u0026access_token=IGQVJ...\" 总结如下，新版无法进行直接内嵌完成，需要完成以下步骤（两种方式均可）参考前端大佬js获取的方式 Instagram oEmbed 嵌入 IG 貼文 Facebook：应用程式、ID、密钥、URL 4.2.1直接使用手机客户端应用打开，找到对应的文章，点击三点，再点击内嵌即可生成对应的访问地址 4.2.2使用代码方式步骤 到Facebook for Developers上建立一个应用程序，取得编号、密钥 要在Firebase 开启Facebook 登入功能，需要有一组Facebook 应用程式的ID、密钥。 本篇建立的应用程式是示范用，本篇上线时就会删除，因此应用程式编号、密钥都会不存在。 进到FACEBOOK for Developers的页面并登入FB帐号后，点击「建立应用程式」： 工作的部份选「更多选项」： 下一个是要填写应用程式的显示名称，就填一个我们看得懂在做什么的名称： 填完后按下「建立应用程式」，就会建立完成。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"应用程式编号、密钥、OAuth URL 应用程式建立完，进到应用程式，左侧选单点击「设定\u003e 基本资料」，就会看到「应用程式编号」、「应用程式密钥」，以及一些需要填写的栏位： 应用程序上新增产品：oEmbed，并把应用程序调整成「上线」 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增产品：oEmbed 应用程式建立完成后，左侧选单点击「产品」旁边的「+」： 然后找到「oEmbed」这项，点击「设定」： 会跳一个确认框，打勾后按下「确认」，左侧的产品清单就会新增oEmbed，代表新增成功。 最后顶部那条有一个显示为「调整中」的Toggle 按钮： 我们点一下按钮，并确认要切换模式，让它变成「上线」，这个应用程式就可以对外使用了： 在Google云端硬盘上新增Google Apps Script的档案，档案中写取得Access Token的代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增GAS 档案当后端，取得FB Access Token 为了要能够使用FB 的应用程式，必须要有一个Access Token 才能够被FB 放行，因为取Token 的过程会用到密钥，因此要写在后端，写在前端会被看光光。 最快写一支后端的方式就是用Google 云端硬碟里的Google Apps Script 档案，以下简称GAS。 进到Google 云端硬碟，点左上角的「新增\u003e 更多\u003e Google Apps Script」： 进到档案后，我们先改个档名进行存档，滑到左上角的档案名称上，点击一次就可以开始改档名 右侧预设会有一个myFunction，整个删掉后，贴上以下程式码，主要是来取得Access Token的： var appId = '从FB后台取得的「应用程式编号」' ; var secret = '从FB后台取得的「应用程式密钥」' ; var uri = 'https://graph.facebook.com/oauth/access_token?client_id=' + appId + '\u0026client_secret=' + secret + '\u0026grant_type=client_credentials' ; function doGet ( e ) { var response = UrlFetchApp . fetch ( uri ) ; return ContentService . createTextOutput ( response ) . setMimeType ( ContentService . MimeType . JSON ) ; } appId、secret这二个变数记得要修改。 doGet指的是当这个GAS预到GET时要执行哪些动作，function里面写的是向FB取得Access Token。 程式码贴上并更新好变数后，按下右上角的「部署\u003e 新增部署作业」： 点击「选取类型」右边的齿轮icon，选择「网页应用程式」： 接着右侧「谁可以存取」的地方改为所有人： 按下「部署」后，第一次部署会需要开存取权： 点击上图的「授予存取权」后，会出现一个警告视窗： 因为这个应用程式是我们自己写的，是可以相信的，点击上图左上角的「进阶」后，会展开一小行字： 点击上图左下角的「前往XXX（不安全）」，因为我们的应用程式没向Google 请求验证过，这边就会一直秀出不安全的字样。 点击了以后会要授予存取权： 按下「允许」，这个GAS 档就成功部署，并且会给一串网址： 这个网址很重要，就像API一样，GET这个网址，就会回传一组Access Token回来。 用JavaScript、Postman、浏览器等取Access Token，并用Access Token取得Instagram贴文的嵌入代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"取Token、取IG 贴文 在上一步的最后我们取得了部署的网址，首先我们先用GET取得Access Token回来： const getToken = '部署完取得的网址' ; fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) Console 出来的response 资料会像这样： { access_token: \"405342487221016|50nqwaePxasUkpNVyIwrJpoA2H0\", token_type: \"bearer\" } 所以我们可以知道，response.access_token就是我们要的Access Token。 接下来就是拿这个Access Token 去取得IG 的贴文内容。 首先我们要先有IG 贴文的网址，在贴文上面点右上角的点点点，在点击「复制连结」，就取到贴文的网址了： 有了贴文的网址，也有了Token，我们可以用一个GET来取得贴文的资讯： const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //要不要隐藏描述，true隐藏、false不隐藏 fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e response . access_token ) . then ( token =\u003e { fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }` ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) } ) ; 从API 的URL 上可以看到，需要的参数有：IG 贴文网址、Access Token，跟hidecaption 是否要隐藏描述。 hidecaption 没有写在新的文件里，神奇的是却有写在旧文件里，这是Augustus 看了前一篇的文章后试出来的，所以如果哪天FB 把这参数拿掉也不用意外。 另外，复制出的IG 贴文网址本身会带一个参数，像这样： https://www.instagram.com/p/CK6wSwfpuVi/?igshid=1wy9n8xgtbe89 实测后，有没有写到igshid 这个参数都没关系，都抓得到贴文资料回来。 除了上面三个参数，还有二个参数是官方文件有提供的：maxwidth、omitscript。 maxwidth 是可以指定嵌入贴文时的最大宽度。 omitscript是Boolean值，预设为false，一般来说我们在嵌入IG贴文时，IG会自动把贴文的资料载入，如果我们想要有另外执行载入贴文的需求，这边就可以写true，之后再执行：instgrm.Embeds.process()就可以把贴文载进页面中。 But！实作时，不确定是不是Augustus有写错，不论omitscript是true或false，如果没执行instgrm.Embeds.process()那贴文就会是呈现白白的样子，像这样： 而且旧的方法吐回来的html，里面会自行引用IG 的embed.js，新的看起来是跟FB 整并所以就没有了，要自行引用： \u003cscript src=\"https://www.instagram.com/embed.js\"\u003e\u003c/script\u003e console 出来的response 会长这样： 可以看到的值有： author_name html provider_name provider_url thumbnail_height thumbnail_url thumbnail_width type version width 其中html就是我们要嵌入IG贴文的程式码，整段放到我们要放的地方就行，这篇的Demo是放在\u003cdiv id=\"ig-iframe\"\u003e\u003c/div\u003e这个div中。 完整嵌入IG 贴文的程式码如下： \u003c div id =\" ig-iframe \" \u003e \u003c/ div \u003e \u003c script src =\" https://www.instagram.com/embed.js \" \u003e \u003c/ script \u003e \u003c script \u003e const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //选填，要不要隐藏描述，true隐藏、false不隐藏，预设为false const maxWidth = 400 ; //选填，贴文的最大宽度是多少 fetch ( getToken ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const token = res . access_token ; fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }\u0026maxwidth= ${ maxWidth }` ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const wrap = document . getElementById ( 'ig-iframe' ) ; wrap . insertAdjacentHTML ( 'afterbegin' , res . html ) ; instgrm . Embeds . process ( ) ; } ) . catch ( err =\u003e { throw Error ( e ) } ) } ) . catch ( err =\u003e { throw Error ( e ) } ) ; \u003c/ script \u003e 完成的IG 贴文嵌入就完成啦~ 如此两种方式并不能简洁快速的嵌入instagram，需要同一般资源一样进行嵌入，Hugo官方表示不能继续使用，且暂时并未做出修改适配，若已经适配请联系我。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} 呈现的输出效果如下: Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ## 8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用\r\r有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意\r\r不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做.\r\r 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧\r\rfeaturedImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 CodeIT 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \"\r文章摘要预览\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意\r\r请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 CodeIT 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意\r\r不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 CodeIT 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 CodeIT 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧\r\r有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单.\r\r 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int\\_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧\r\r你可以在 网站配置 中自定义公式块和行内公式的分割符.\r\r Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 CodeIT 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 CodeIT 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome CodeIT 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧\r\r这个方法可以间接解决一个还未解决的 Hugo 的 issue.\r\r 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意\r\rHugo extended 版本对于 style shortcode 是必需的.\r\r style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\"\rLighthouse (image)\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip\r\r一个 技巧 横幅\r\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 _-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --_ C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K 线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: \r如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r\r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意\r\r脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库.\r\r 一个 script 示例: {{\u003c script \u003e}} console.log('Hello CodeIT!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation","note"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 CodeIT 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003e Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. \u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e这是 \u003cb\u003eHTML\u003c/b\u003e\u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** **渲染为粗体** 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. _渲染为斜体_ _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. **_加粗和斜体_** ~~**删除线和加粗**~~ ~~_删除线和斜体_~~ ~~**_加粗, 斜体和删除线_**~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel \u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del \u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. \u003e Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e \u003e \u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor \u003e \u003e odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: - 一项内容 * 一项内容 - 一项内容 例如: - Lorem ipsum dolor sit amet - Consectetur adipiscing elit - Integer molestie lorem at massa - Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at - Faucibus porta lacus fringilla vel - Aenean sit amet erat nunc - Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003e Nulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ------------------------------------------------------------------------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003e path to data files to supply the data that will be passed into templates. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003e engine to be used for processing templates. Handlebars is the default. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | | :----: | ------------------------------------------------------------------------: | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents - [Chapter 1](#chapter-1) - [Chapter 2](#chapter-2) - [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rCodeIT 主题提供了一个包含更多功能的 图片的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"14 转义 文档中一下部分字符特别是类似于\u003cscript\u003e、\u003clink\u003e这样的标签等符号不能直接写大于小于号，需要进行转义，否则会使页面报错 显示结果 描述 实体名称 实体编号 空格     \u003c 小于号 \u003c \u003c \u003e 大于号 \u003e \u003e \u0026 与和号 \u0026 \u0026 \" 双引号 \" \" ' 单引号 '(IE不支持) ' 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:14:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"Hugo 和 CodeIT 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人与身体 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"活动 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"符号 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旗帜 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Back","note"],"content":"记录Mysql数据库相关的笔记","date":"2021-07-15","objectID":"/mysql-note/","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"下载 ","date":"2021-07-15","objectID":"/mysql-note/:1:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"最新版本 https://dev.mysql.com/downloads/mysql/ ","date":"2021-07-15","objectID":"/mysql-note/:1:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"历史版本 https://downloads.mysql.com/archives/community/ ","date":"2021-07-15","objectID":"/mysql-note/:1:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"安装 ","date":"2021-07-15","objectID":"/mysql-note/:2:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"Windows 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 下。 接下来我们需要配置下 MySQL 的配置文件 打开刚刚解压的文件夹 C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： [client] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=C:\\\\Program_Green\\\\Java_env\\\\mysql-5.7.33-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=C:\\\\Program_Green\\\\Java_env\\\\mysql-5.7.33-winx64\\\\data # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 配置环境变量 在系统变量处新建MYSQL_HOME项 MYSQL_HOME C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 在Path处添加%MYSQL_HOME%\\bin（或者用;（英文）分割，Append到最后） 接下来我们来启动下 MySQL 数据库： 以管理员身份打开 cmd 命令行工具，切换目录： cd C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64\\bin 初始化数据库： mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码，如： ... 2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws\u0026hjQ ... APWCY5ws\u0026hjQ 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。 输入以下安装命令： mysqld install 启动输入以下命令即可： net start mysql 注意: 在 5.7 需要初始化 data 目录： C:\\Program_Green\\Java_env\\mysql-5.7.33-winx64 mysqld --initialize-insecure 初始化后再运行 net start mysql 即可启动 mysql。 登录 MySQL 当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名: mysql -h 主机名 -u 用户名 -p 参数说明： -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可： mysql -u root -p 按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应: Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysq\u003e 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 修改初始密码 不重置初始密码什么都不能做 ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 修改密码的方法： mysql\u003e alter user root@localhost identified by 'ZfL001!'; ","date":"2021-07-15","objectID":"/mysql-note/:2:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"Linux Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址： MySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。 MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。 MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。 MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。 MySQL-bench - MySQL数据库服务器的基准和性能测试工具。 安装前，我们可以检测系统是否自带安装 MySQL: rpm -qa | grep mysql 如果你系统有安装，那可以选择进行卸载: rpm -e mysql　// 普通删除模式 rpm -e --nodeps mysql　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 安装 MySQL： 接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server 权限设置： chown mysql:mysql -R /var/lib/mysql 初始化 MySQL： mysqld --initialize 启动 MySQL： systemctl start mysqld 查看 MySQL 运行状态： systemctl status mysqld **注意：**如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 此外,你也可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。 yum install mariadb-server mariadb mariadb数据库的相关命令是： systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 验证 MySQL 安装 在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。 使用 mysqladmin 工具来获取服务器状态： 使用 mysqladmin 命令来检查服务器的版本, 在 linux 上该二进制文件位于 /usr/bin 目录，在 Windows 上该二进制文件位于C:\\mysql\\bin 。 [root@host]# mysqladmin --version linux上该命令将输出以下结果，该结果基于你的系统信息： mysqladmin Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386 如果以上命令执行后未输出任何信息，说明你的Mysql未安装成功。 使用 MySQL Client(Mysql客户端) 执行简单的SQL命令 你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到 MySQL 服务器上，默认情况下 MySQL 服务器的登录密码为空，所以本实例不需要输入密码。 命令如下： [root@host]# mysql 以上命令执行后会输出 mysql\u003e提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql\u003e 提示符执行SQL命令： mysql\u003e SHOW DATABASES; +----------+ | Database | +----------+ | mysql | | test | +----------+ 2 rows in set (0.13 sec) Mysql安装后需要做的 Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： [root@host]# mysqladmin -u root password \"new_password\"; 现在你可以通过以下命令来连接到Mysql服务器： [root@host]# mysql -u root -p Enter password:******* **注意：**在输入密码时，密码是不会显示了，你正确输入即可。 ","date":"2021-07-15","objectID":"/mysql-note/:2:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"管理 ","date":"2021-07-15","objectID":"/mysql-note/:3:0","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"Windows 在 Windows 系统下，打开命令窗口(cmd)，进入 MySQL 安装目录的 bin 目录。 启动： cd c:/mysql/bin net start mysql #管理员模式控制台 # 或 mysqld --console #(服务不启动，需要在手动去服务界面启动或执行上面一条指令) 关闭： cd c:/mysql/bin net stop mysql #管理员模式控制台 # 或 mysqladmin -u root shutdown #无密码 mysqladmin -u root -p shutdown # 要输入密码 在安装mysql时系统会添加服务，可以通过管理工具里面的 \u003c服务\u003e 一项来停止和启动mysql。这样修改的my.ini就会生效了。 ","date":"2021-07-15","objectID":"/mysql-note/:3:1","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":["Back","note"],"content":"Linux 首先，我们需要通过以下命令来检查MySQL服务器是否启动： ps -ef | grep mysqld 如果MySql已经启动，以上命令将输出mysql进程列表， 如果mysql未启动，你可以使用以下命令来启动mysql服务器: root@host# cd /usr/bin ./mysqld_safe \u0026 如果你想关闭目前运行的 MySQL 服务器, 你可以执行以下命令: root@host# cd /usr/bin ./mysqladmin -u root -p shutdown Enter password: ****** ","date":"2021-07-15","objectID":"/mysql-note/:3:2","tags":["DataBase","SQL","MySql"],"title":"Mysql数据库笔记","uri":"/mysql-note/"},{"categories":null,"content":" 警告\r\rSorry, this article has not been completely translated into French. Welcome to take the time to propose a translation by  making a PR to the theme!\r\r  CodeIT is a clean, elegant but advanced blog theme for Hugo. It is based on the original LoveIt Theme, LeaveIt Theme, and KeepIt Theme. Hugo Theme CodeITHugo Theme CodeIT \"\rHugo Theme CodeIT\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"许可协议 CodeIT 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 CodeIT 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 CodeIT","uri":"/about/"}]