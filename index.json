[{"categories":["Total","note"],"content":"基于广播和服务功能的音乐播放器","date":"2021-05-11","objectID":"/android-music-box/","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1、应用知识点 ","date":"2021-05-11","objectID":"/android-music-box/:1:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.1、Android 广播接收器(Broadcast Receivers) 广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。例如，应用程序可以初始化广播来让其他的应用程序知道一些数据已经被下载到设备，并可以为他们所用。这样广播接收器可以定义适当的动作来拦截这些通信。 有以下两个重要的步骤来使系统的广播意图配合广播接收器工作。 创建广播接收器 注册广播接收器 还有一个附加的步骤，要实现自定义的意图，你必须创建并广播这些意图。 ","date":"2021-05-11","objectID":"/android-music-box/:1:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"1.2、服务（Service） 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。服务基本上包含两种状态 状态 描述 Started Android的应用程序组件，如活动，通过startService()启动了服务，则服务是Started状态。一旦启动，服务可以在后台无限期运行，即使启动它的组件已经被销毁。 Bound 当Android的应用程序组件通过bindService()绑定了服务，则服务是Bound状态。Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。 ","date":"2021-05-11","objectID":"/android-music-box/:1:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、原型图 老师要求的原型图仅包括四个按钮和两个文本。 四个按钮分别为上一曲、播放暂停、停止、下一曲；两个文本为曲名和歌手。 我在老师要求的基础上，结合上次实验RecyclerView进行更新，目的如图所示，实现一个类似常规音乐播放器的界面。 左侧包括歌曲的图片，上方时每首歌的列表。 ","date":"2021-05-11","objectID":"/android-music-box/:2:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"2、需求 编写音乐盒代码，参考群文件-源码-Musicbox，掌握源码后在其基础上添加音乐播放的 上一首 和 下一首 控制，也可以增加更多的功能。 ","date":"2021-05-11","objectID":"/android-music-box/:3:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"3、思路 在真正的代码撰写中，广播就是内嵌于activity和service的。在界面中绘制四个按钮、一个图片和两个文本，填入数据。监听不同按钮点击事件，绑定对应的广播函数或服务。 ","date":"2021-05-11","objectID":"/android-music-box/:4:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-05-11","objectID":"/android-music-box/:5:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.1、fragment_mes.xml（在原基础上添加即可） \u003candroidx.constraintlayout.widget.ConstraintLayout android:id=\"@+id/constraintLayout_mes_mp\" android:layout_width=\"match_parent\" android:layout_height=\"70dp\" android:layout_gravity=\"bottom\" android:background=\"#99BB86FC\" android:orientation=\"horizontal\"\u003e \u003cImageButton android:id=\"@+id/iB_ablum\" android:layout_width=\"70dp\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/flower1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.0\" /\u003e \u003cTextView android:id=\"@+id/tV_musicName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"15dp\" android:text=\"Inside the Lines\" android:textColor=\"#FFFFFFFF\" android:textSize=\"16sp\" android:textStyle=\"bold\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.333\" /\u003e \u003cTextView android:id=\"@+id/tV_singerName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"5dp\" android:layout_marginBottom=\"5dp\" android:text=\"Mike Perry\" android:textColor=\"#DDFFFFFF\" android:textSize=\"14sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/iB_ablum\" app:layout_constraintTop_toBottomOf=\"@+id/tV_musicName\" /\u003e \u003cImageButton android:id=\"@+id/iB_lastPiece\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_left_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_playPause\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_playPause\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_drop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/iB_stop\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cImageButton android:id=\"@+id/iB_stop\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"#00BB86FC\" android:src=\"@drawable/stop_circle_outline\" app:layout_constraintBottom_toBottomOf=\"@+id/iB_lastPiece\" app:layout_constraintEnd_toStartOf=\"@+id/iB_nextPlay\" app:layout_constraintTop_toTopOf=\"@+id/iB_lastPiece\" /\u003e \u003cImageButton android:id=\"@+id/iB_nextPlay\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#00BB86FC\" android:src=\"@drawable/arrow_right_thin_circle_outline\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-05-11","objectID":"/android-music-box/:5:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.2、MesFragment.java（仅展示在原来recyclerView之后的内容） public class MesFragment extends Fragment implements View.OnClickListener { // 获取界面中显示歌曲标题、作者文本框 TextView title, author; // 播放/暂停、停止按钮、上一曲按钮，下一曲按钮 ImageButton play, stop, next, last; ActivityReceiver activityReceiver; public static final String CTL_ACTION = \"org.xr.action.CTL_ACTION\"; public static final String UPDATE_ACTION = \"org.xr.action.UPDATE_ACTION\"; // 定义音乐的播放状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; String[] titleStrs = new String[]{\"Inside the Lines\", \"Landslide\", \"Life\", \"Symphony\", \"The Spectre\"}; String[] authorStrs = new String[]{\"Mike Perry\", \"Headhunterz\", \"Tobu\", \"Clean Bandit\", \"Alan Walker\"}; // 获取程序界面界面中的两个按钮 play = (ImageButton) view.findViewById(R.id.iB_playPause); stop = (ImageButton) view.findViewById(R.id.iB_stop); title = (TextView) view.findViewById(R.id.tV_musicName); author = (TextView) view.findViewById(R.id.tV_singerName); //获取上一首、下一首按钮 last = (ImageButton) view.findViewById(R.id.iB_lastPiece); next = (ImageButton) view.findViewById(R.id.iB_nextPlay); // 为两个按钮的单击事件添加监听器 play.setOnClickListener(this); stop.setOnClickListener(this); //为上一首、下一首按钮添加监听器 last.setOnClickListener(this); next.setOnClickListener(this); activityReceiver = new ActivityReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); // 指定BroadcastReceiver监听的Action filter.addAction(UPDATE_ACTION); // 注册BroadcastReceiver getActivity().registerReceiver(activityReceiver, filter); Intent intent = new Intent(getActivity(), MusicService.class); // 启动后台Service getActivity().startService(intent); return view; } // 自定义的BroadcastReceiver，负责监听从Service传回来的广播 public class ActivityReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 获取Intent中的update消息，update代表播放状态 int update = intent.getIntExtra(\"update\", -1); // 获取Intent中的current消息，current代表当前正在播放的歌曲 int current = intent.getIntExtra(\"current\", -1); if (current \u003e= 0) { title.setText(titleStrs[current]); author.setText(authorStrs[current]); } switch (update) { case 0x11: play.setImageResource(R.drawable.arrow_right_drop_circle_outline); status = 0x11; break; //控制系统进入播放状态 case 0x12: // 播放状态下设置使用暂停图标 play.setImageResource(R.drawable.pause_circle_outline); // 设置当前状态 status = 0x12; break; // 控制系统进入暂停状态 case 0x13: // 暂停状态下设置使用播放图标 play.setImageResource(R.drawable.arrow_right_drop_circle_outline); // 设置当前状态 status = 0x13; break; } } } @Override public void onClick(View source) { // 创建Intent Intent intent = new Intent(\"org.xr.action.CTL_ACTION\"); switch (source.getId()) { // 按下播放/暂停按钮 case R.id.iB_playPause: intent.putExtra(\"control\", 1); break; // // 按下停止按钮 case R.id.iB_stop: intent.putExtra(\"control\", 2); break; // 按下上一曲按钮 case R.id.iB_lastPiece: intent.putExtra(\"control\", 3); break; // 按下下一曲按钮 case R.id.iB_nextPlay: intent.putExtra(\"control\", 4); break; } // 发送广播，将被Service组件中的BroadcastReceiver接收到 getActivity().sendBroadcast(intent); } } ","date":"2021-05-11","objectID":"/android-music-box/:5:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"4.3、MusicService.java（播放音乐服务） public class MusicService extends Service { MyReceiver serviceReceiver; AssetManager am; String[] musics = new String[]{\"insidethelines.mp3\", \"landslide.mp3\", \"life.mp3\", \"symphony.mp3\", \"thespectre.mp3\"}; // String[] musics = new String[] {\"liangliang.mp3\", \"wuhangya.mp3\",\"three.mp3\" ,\"four.mp3\",\"fif.mp3\"}; MediaPlayer mPlayer; // 当前的状态，0x11代表没有播放；0x12代表正在播放；0x13代表暂停 int status = 0x11; // 记录当前正在播放的音乐 int current = 0; @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); am = getAssets(); // 创建BroadcastReceiver serviceReceiver = new MyReceiver(); // 创建IntentFilter IntentFilter filter = new IntentFilter(); filter.addAction(MesFragment.CTL_ACTION); registerReceiver(serviceReceiver, filter); // 创建MediaPlayer mPlayer = new MediaPlayer(); // 为MediaPlayer播放完成事件绑定监听器 mPlayer.setOnCompletionListener(new OnCompletionListener() // ① { @Override public void onCompletion(MediaPlayer mp) { current++; if (current \u003e= 5) { current = 0; } //发送广播通知Activity更改文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); // 准备并播放音乐 prepareAndPlay(musics[current]); } }); } public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(final Context context, Intent intent) { int control = intent.getIntExtra(\"control\", -1); switch (control) { // 播放或暂停 case 1: // 原来处于没有播放状态 if (status == 0x11) { // 准备并播放音乐 prepareAndPlay(musics[current]); status = 0x12; } // 原来处于播放状态 else if (status == 0x12) { // 暂停 mPlayer.pause(); // 改变为暂停状态 status = 0x13; } // 原来处于暂停状态 else if (status == 0x13) { // 播放 mPlayer.start(); // 改变状态 status = 0x12; } break; // 停止声音 case 2: // 如果原来正在播放或暂停 if (status == 0x12 || status == 0x13) { // 停止播放 current++; mPlayer.stop(); status = 0x11; } case 3: current--; if (current \u003c 0) { current = 4; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; case 4: current++; if (current \u003e 4) { current = 0; } if (status == 0x11 || status == 0x13) { prepareAndPlay(musics[current]); mPlayer.stop(); status = 0x11; } else { prepareAndPlay(musics[current]); status = 0x12; } break; } // 广播通知Activity更改图标、文本框 Intent sendIntent = new Intent(MesFragment.UPDATE_ACTION); sendIntent.putExtra(\"update\", status); sendIntent.putExtra(\"current\", current); // 发送广播，将被Activity组件中的BroadcastReceiver接收到 sendBroadcast(sendIntent); } } private void prepareAndPlay(String music) { try { // 打开指定音乐文件 AssetFileDescriptor afd = am.openFd(music); mPlayer.reset(); // 使用MediaPlayer加载指定的声音文件。 mPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()); // 准备声音 mPlayer.prepare(); // 播放 mPlayer.start(); } catch (IOException e) { e.printStackTrace(); } } } ","date":"2021-05-11","objectID":"/android-music-box/:5:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-05-11","objectID":"/android-music-box/:6:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.1、初始状态，暂停未进行播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:1","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.2、点击播放按钮，按钮变为等待暂停状态，音乐播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:2","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.3、点击上一曲按钮，保存当前状态（播放或暂停）切换到上一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:3","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.4、点击下一曲按钮，保存当前状态（播放或暂停）切换到下一曲 ","date":"2021-05-11","objectID":"/android-music-box/:6:4","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"5.5、点击暂停则停止播放，点击继续则从刚才的位置继续播放，点击停止按钮停止播放 ","date":"2021-05-11","objectID":"/android-music-box/:6:5","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"6、结语 本次实验感想颇多，在不同的学习渠道，加上百度搜索，请教同学最终仅仅完成了一个初步的成果。后续需要改进和维护的东西还有很多很多。音乐的图标需要更换，切换歌曲应该随之切换图片，recyclerView的数据并没有与歌曲一同绑定。本人水平一般，能力有限，精力也有限，随着时间的推移慢慢完善吧。 ","date":"2021-05-11","objectID":"/android-music-box/:7:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"7、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design 注： 源码中为了实现某些功能，减少大面积重命名文件的情况，信息和朋友页面进行对调（id），朋友改为音乐（title和icon），请读者注意！ 在下次实验完成前，master分支和本次实验分支（Music_Box）会有一样的本次实验代码，下次实验完成后会新创建分支，保存新实验的代码啊，更新master分支代码 ","date":"2021-05-11","objectID":"/android-music-box/:8:0","tags":["Android","Java","XML","Material-Design","BroadcastReceivers","Service"],"title":"基于广播和服务功能的音乐播放器","uri":"/android-music-box/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换","date":"2021-04-04","objectID":"/android-bottom-navigation/","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"使用Meterial_Design的BottomNavigationView组件构建底类似微信的四个底部导航栏的切换 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:0:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"1、原型图 顶部一个导航栏，，加号按钮的下拉菜单，下面是四个Tab页面，点击下方按钮，每个页面的上下两个导航栏之间的内容会随之发生变化，同时点击状态下的图标样式也随之变化。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:1:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"2、需求 请根据课堂展示结果设计APP门户界面，包含4个tab切换效果。 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:2:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"3、思路 为了使用上课讲到的Material Design设计模式，我们分别使用了TopAppBar，一个ButtomNavigationMenu以及四个Fragment。同时采用了java语言作为点击按钮后界面内容的改变控制 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:3:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4、代码 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.1、创建一个Empty项目 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.2、页面-activity_main.xml-四个界面的主（公共）组件 根据官方文档，导航栏有四种模式，auto、labeled、selected、unlabeled,对应关系如下 参数 解释 auto 当有3个或更少的项目时，标签的行为为“labeled”；当有4个或更多的项目时，标签的行为为“selected”。 labeled 标签显示在所有导航项目上 selected（default） 标签显示在所选的导航项目上。（默认） unlabeled 标签未显示在任何导航项目上。 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:visibility=\"visible\" tools:context=\".MainActivity\"\u003e \u003cLinearLayout android:id=\"@+id/linearLayout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintBottom_toTopOf=\"@+id/bottom_navigation_menu\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"\u003e \u003cFrameLayout android:id=\"@+id/frameLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e \u003ccom.google.android.material.bottomnavigation.BottomNavigationView android:id=\"@+id/bottom_navigation_menu\" style=\"@style/Widget.MaterialComponents.BottomNavigationView.Colored\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:labelVisibilityMode=\"labeled\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"1.0\" app:layout_constraintStart_toStartOf=\"parent\" app:menu=\"@menu/bottom_navigation_menu\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.3、页面-fragment_ctt.xml-联系人组件（朋友、信息、设置都差不多，不再过多展示，GitHub源码地址在本文最后） \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MesFragment\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/cttText\" /\u003e \u003c/FrameLayout\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.4、页面-bottom_navigation_menu.xml-底部导航栏组件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"\u003e \u003citem android:id=\"@+id/page_Mes\" android:enabled=\"true\" android:icon=\"@drawable/tab_weixin_normal\" android:title=\"@string/message\" /\u003e \u003citem android:id=\"@+id/page_Fri\" android:enabled=\"true\" android:icon=\"@drawable/tab_find_frd_normal\" android:title=\"@string/friends\" /\u003e \u003citem android:id=\"@+id/page_Ctt\" android:enabled=\"true\" android:icon=\"@drawable/tab_address_normal\" android:title=\"@string/contacts\" /\u003e \u003citem android:id=\"@+id/page_Set\" android:enabled=\"true\" android:icon=\"@drawable/tab_settings_normal\" android:title=\"@string/settings\" /\u003e \u003c/menu\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.5、页面-color.xml-颜色配置文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources\u003e \u003ccolor name=\"purple_200\"\u003e#FFBB86FC\u003c/color\u003e \u003ccolor name=\"purple_500\"\u003e#FF6200EE\u003c/color\u003e \u003ccolor name=\"purple_700\"\u003e#FF3700B3\u003c/color\u003e \u003ccolor name=\"teal_200\"\u003e#FF03DAC5\u003c/color\u003e \u003ccolor name=\"teal_700\"\u003e#FF018786\u003c/color\u003e \u003ccolor name=\"black\"\u003e#FF000000\u003c/color\u003e \u003ccolor name=\"white\"\u003e#FFFFFFFF\u003c/color\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:5","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.6、页面-strings.xml-文字字符串配置文件 \u003cresources\u003e \u003c!-- app标题--\u003e \u003cstring name=\"app_name\"\u003e微信80.0\u003c/string\u003e \u003c!-- 导航栏标题--\u003e \u003cstring name=\"message\"\u003e信息\u003c/string\u003e \u003cstring name=\"friends\"\u003e朋友\u003c/string\u003e \u003cstring name=\"contacts\"\u003e联系人\u003c/string\u003e \u003cstring name=\"settings\"\u003e设置\u003c/string\u003e \u003c!-- 界面二级标题--\u003e \u003cstring name=\"mesText\"\u003e这是信息页面！\u003c/string\u003e \u003cstring name=\"friText\"\u003e这是朋友页面！\u003c/string\u003e \u003cstring name=\"cttText\"\u003e这是联系人页面！\u003c/string\u003e \u003cstring name=\"setText\"\u003e这是设置页面！\u003c/string\u003e \u003c!-- TODO: Remove or change this placeholder text --\u003e \u003cstring name=\"hello_blank_fragment\"\u003eHello blank fragment\u003c/string\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:6","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.7、页面-theme.xml-主题配置文件 \u003cresources xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"Theme.Bottom_Navigation\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\"\u003e \u003c!-- Primary brand color. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/purple_500\u003c/item\u003e \u003citem name=\"colorPrimaryVariant\"\u003e@color/purple_700\u003c/item\u003e \u003citem name=\"colorOnPrimary\"\u003e@color/white\u003c/item\u003e \u003c!-- Secondary brand color. --\u003e \u003citem name=\"colorSecondary\"\u003e@color/teal_200\u003c/item\u003e \u003citem name=\"colorSecondaryVariant\"\u003e@color/teal_700\u003c/item\u003e \u003citem name=\"colorOnSecondary\"\u003e@color/black\u003c/item\u003e \u003c!-- Status bar color. --\u003e \u003citem name=\"android:statusBarColor\" tools:targetApi=\"l\"\u003e?attr/colorPrimaryVariant\u003c/item\u003e \u003c!-- Customize your theme here. --\u003e \u003c/style\u003e \u003c/resources\u003e ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:7","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.8后台-MainActivity.java-控制逻辑代码 package cn.edu.hubu.lhy.bottom_navigation; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentTransaction; import android.os.Bundle; import android.view.Menu; import android.view.MenuInflater; import android.view.MenuItem; import android.widget.Toast; import com.google.android.material.bottomnavigation.BottomNavigationView; public class MainActivity extends AppCompatActivity { private MesFragment mesFragment = null; private FriFragment friFragment = null; private CttFragment cttFragment = null; private SetFragment setFragment = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BottomNavigationView bottom_navigation_menu = (BottomNavigationView) findViewById(R.id.bottom_navigation_menu); bottom_navigation_menu.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener); mesFragment = new MesFragment(); changeFrameLayout(\"您好\", mesFragment); } private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener = new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.page_Mes: if (mesFragment == null) { mesFragment = new MesFragment(); } changeFrameLayout(\"信息\", mesFragment); return true; case R.id.page_Fri: if (friFragment == null) { friFragment = new FriFragment(); } changeFrameLayout(\"朋友\", friFragment); return true; case R.id.page_Ctt: if (cttFragment == null) { cttFragment = new CttFragment(); } changeFrameLayout(\"联系人\", cttFragment); return true; case R.id.page_Set: if (setFragment == null) { setFragment = new SetFragment(); } changeFrameLayout(\"设置\", setFragment); return true; } return false; } }; /** * 使用Fragment组件替换原界面上的FragLayout * * @param string 提示信息 * @param fraGment 要替换成的fragment */ private void changeFrameLayout(String string, Fragment fraGment) { //弹窗 Toast.makeText(MainActivity.this, string, Toast.LENGTH_SHORT).show(); //每一次都要重新创建事务和管理工具 FragmentManager fagmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fagmentManager.beginTransaction(); //替换操作 fragmentTransaction.replace(R.id.frameLayout, fraGment); //事务具有原子性，类似数据库，每一次操作完成需要提交操作 fragmentTransaction.commit(); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:8","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"4.9、后台-CttFragment.java-联系人组件代码 创建Fragment自动生成的构造方法、newInstance()、onCreate()方法啊需要禁掉不然会产生一些问题 package cn.edu.hubu.lhy.bottom_navigation; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; /** * A simple {@link Fragment} subclass. * Use the {@link FriFragment#newInstance} factory method to * create an instance of this fragment. */ public class FriFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_fri, container, false); } } ","date":"2021-04-04","objectID":"/android-bottom-navigation/:4:9","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5、最终效果 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.1、信息页面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:1","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.2、朋友界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:2","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.3、联系人界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:3","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"5.4、设置界面 ","date":"2021-04-04","objectID":"/android-bottom-navigation/:5:4","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total","note"],"content":"6、Github源码 https://github.com/KKKPJSKEY/Weixin_Meterial_Design ","date":"2021-04-04","objectID":"/android-bottom-navigation/:6:0","tags":["Android","Java","XML","Material-Design","BottomNavigation","View","Activity","Fragment"],"title":"类微信界面设计","uri":"/android-bottom-navigation/"},{"categories":["Total"],"content":"解决Android runOnUiThread android.os.NetworkOnMainThreadException","date":"2021-06-29","objectID":"/android-runonuithread-error/","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"android.os.NetworkOnMainThreadException ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:0","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"原因 跑老师的代码的时候报这个错，主要内容是编写Android项目时使用OKHttp3网络请求交互，但是老师向我展示了他的代码在他的机器上的正确性。我的就快乐的报错。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:1","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"分析 后面经过一定的相关知识进行学习发现，虚拟机的版本不同，导致了这个问题。同时在同学的低版本虚拟机上得到了验证。具体的版本规约并未查询到。我方进行试验的是AndroidStudio的虚拟机，Android11的是会报错或请求返回的body无法显示到ui上。Android7以下版本的虚拟机是可以正确将请求结果返回到ui界面上的 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:2","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Total"],"content":"解决办法 不操作Android等ui 这是原来的代码 runOnUiThread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } }); 不使用runOnUiThread，改为一个新线程，并启动他 new Thread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub HttpApiClient api = new HttpApiClient(); String ValidityDate; try { ValidityDate = api.validate(mobile); Log.i(\"id\", mobile); Log.i(\"ValidityDate\", ValidityDate); Intent intent = new Intent(); intent.putExtra(\"id\", mobile); intent.setClass(IndexActivity.this, LoginActivity.class); IndexActivity.this.startActivity(intent); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); wView.loadUrl(\"javascript:setMsg('手机号码错误，请重新输入！')\"); } } }).start(); 就完事了。 其他情况 一旦有其他内容需要显示到ui上，需要使用线程之间的通信技术，如Message+Bundle发送，(见我的另一篇博客：点我跳转)Hundle进行接收的办法，或者是同Intent+Bundle进行发送，Hundle进行接收等办法，将数据传输至主线程，主线程将他显示到界面上即可。 ","date":"2021-06-29","objectID":"/android-runonuithread-error/:1:3","tags":["Android","Java","Thread","UI","Error"],"title":"android.os.NetworkOnMainThreadException","uri":"/android-runonuithread-error/"},{"categories":["Back"],"content":"解决Android Java中The BC provider no longer provides for KeyPairGenerator.RSA.的错误","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"The BC provider no longer provides for KeyPairGenerator.RSA. ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:1:0","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"发生报错 使用网路相关框架时发生报错 java.lang.AssertionError: java.security.NoSuchAlgorithmException: The BC provider no longer provides an implementation for KeyPairGenerator.RSA. Please see https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html for more details. ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:1:1","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"解决方案 在AndroidManifest.xml文件中填写这段代码 仅需在元application添加配置即可，其他结构代码仅为application说明位置 \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.mypackage.mylibrary\"\u003e \u003capplication android:usesCleartextTraffic=\"true\" /\u003e \u003c/manifest\u003e ","date":"2021-06-29","objectID":"/java-android-lang-assertionerror/:1:2","tags":["Java","Android","Error"],"title":"The BC provider no longer provides for KeyPairGenerator.RSA.","uri":"/java-android-lang-assertionerror/"},{"categories":["Back"],"content":"Java安卓使用本地ip时报错java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:1:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"java.net.ConnectException: failed to connect to localhost/127.0.0.1 (port 8080) 以上两个错误 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:0","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"现象： android虚拟机中访问电脑本地url失败 当你启动Tomcat后，在浏览器中输入http：//127.0.1.1:8080/xxx.xx，你会发现你可以找打你要找的东西。但是当你在Eclipse或者android虚拟机中访问 会一直报出这样的错误： java.net.ConnectException: failed to connect to /127.0.1.1 (port 8080) ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:1","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"分析： 原来模拟器默认把127.0.0.1和localhost当做本身了，在模拟器上可以用10.0.2.2代替127.0.0.1和localhost，另外如果是在局域网环境可以用 192.168.0.x或者192.168.1.x(根据具体配置)连接本机,这样应该就不会报错了。 ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:2","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Back"],"content":"解决方法： 设置访问的ip为10.0.2.2（本机的网络ip） ","date":"2021-06-28","objectID":"/java-android-net-unknownserviceexception/:2:3","tags":["Java","Android","Ip","Error"],"title":"java.net.UnknownServiceException: CLEARTEXT communication to 127.0.0.1 not permitted by network security policy","uri":"/java-android-net-unknownserviceexception/"},{"categories":["Total"],"content":"PrintWriter输出到Web页面中呈现乱码现象解决方案","date":"2021-06-28","objectID":"/java-printwriter-random-code/","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"PrintWriter Web页面乱码 ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:1:0","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"一般情况只使用下面代码： PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:1:1","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Total"],"content":"输出到页面上基本会呈现出乱码现象，解决方案如下： response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html; charset=utf-8\"); PrintWriter out = response.getWriter()； out.print(\"爱死费崇政\"); ","date":"2021-06-28","objectID":"/java-printwriter-random-code/:1:2","tags":["Java","Html","RandomCode","Error"],"title":"PrintWriter Web页面乱码","uri":"/java-printwriter-random-code/"},{"categories":["Back"],"content":"Java Android 子线程弹出Toast报错Can't toast on a thread that has not called Looper.prepare()解决办法","date":"2021-06-28","objectID":"/java-android-thread-toast-error/","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"Can’t toast on a thread that has not called Looper.prepare() ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:0","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"前言 最近一段时间在忙着开发一款自己的APP，将自己常用的功能需求都加入进入，同时在GitHub上跟着大牛们学习新的技术，提升自己的技能，在开发的过程中不断的发现问题和解决问题。 在开发过程遇到了这样一个问题：Can’t toast on a thread that has not called Looper.prepare()，如果在一个线程中没有调用Looper.prepare(),就不能在该线程中创建Toast。这个问题是因为在子线程中弹出Toast导致的。 Android是不能直接在子线程中弹出Toast的，可是如果我们非要这么做，那该怎么办呢？下面就为大家讲解如何在子线程中弹出Toast，以及一些其他类似的子线程中操作的错误。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:1","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中调用Toast 在子线程中弹出Toast，会报错：java.lang.RuntimeException: Can’t toast on a thread that has not called Looper.prepare()。 解决方式：先调用Looper.prepare();再调用Toast.makeText().show();最后再调用Looper.loop(); public class ToastUtils { static Toast toast = null; public static void show(Context context, String text) { try { if(toast!=null){ toast.setText(text); }else{ toast= Toast.makeText(context, text, Toast.LENGTH_SHORT); } toast.show(); } catch (Exception e) { //解决在子线程中调用Toast的异常情况处理 Looper.prepare(); Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); Looper.loop(); } } } ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:2","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中更新UI 在子线程中更新UI，会报错：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 解决方式：在子线程中更新UI，一般使用Handler或者runOnUiThread()或者AsyncTask。 ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:3","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"在子线程中创建Handler 在子线程中创建Handler，会报错：java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()。 解决方式： new Thread() { public void run() { Looper.prepare(); new Handler().post(runnable);//在子线程中直接去new 一个handler 　Looper.loop();　//这种情况下，Runnable对象是运行在子线程中的，可以进行联网操作，但是不能更新UI 　} }.start(); ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:4","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"写在最后 以上就是在子线程中更新UI、弹出Toast、创建Handler时会遇到的问题，及解决方式。 如果你在参考过程中遇到问题，可以在我的联系方式中给我提问。 后面会继续介绍，Android的相关知识，欢迎继续关注我博客的更新。 参考资源 在子线程中new Handler报错 Android – Looper.prepare()和Looper.loop() —深入版 Toast和Looper、Handler消息循环机制 sh ./update.sh ","date":"2021-06-28","objectID":"/java-android-thread-toast-error/:1:5","tags":["Java","Android","Thread","Error"],"title":"Can't toast on a thread that has not called Looper.prepare()","uri":"/java-android-thread-toast-error/"},{"categories":["Back"],"content":"运行别人的项目报错 Error:java: 无效的目标发行版: 11 的解决办法","date":"2021-06-28","objectID":"/java11-invaid-target-release/","tags":["Java","Version","Java11","Error"],"title":"Error:java: 无效的目标发行版: 11","uri":"/java11-invaid-target-release/"},{"categories":["Back"],"content":"Error:java: 无效的目标发行版: 11 我们在使用Idea开发中如果遇到你的JDK版本有“无效的目标发行版: 11”冲突时，要修改以下JDK版本 ","date":"2021-06-28","objectID":"/java11-invaid-target-release/:1:0","tags":["Java","Version","Java11","Error"],"title":"Error:java: 无效的目标发行版: 11","uri":"/java11-invaid-target-release/"},{"categories":["Back"],"content":"1项目java版本 ","date":"2021-06-28","objectID":"/java11-invaid-target-release/:1:1","tags":["Java","Version","Java11","Error"],"title":"Error:java: 无效的目标发行版: 11","uri":"/java11-invaid-target-release/"},{"categories":["Back"],"content":"2模块java版本 ","date":"2021-06-28","objectID":"/java11-invaid-target-release/:1:2","tags":["Java","Version","Java11","Error"],"title":"Error:java: 无效的目标发行版: 11","uri":"/java11-invaid-target-release/"},{"categories":["Back"],"content":"3 idea设置中java编译器对每个模块的版本 三个部分都不能高于 使用的java版本号，否则就报错 ","date":"2021-06-28","objectID":"/java11-invaid-target-release/:1:3","tags":["Java","Version","Java11","Error"],"title":"Error:java: 无效的目标发行版: 11","uri":"/java11-invaid-target-release/"},{"categories":["Back"],"content":"错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"java.rmi.server.ExportException: Port already in use: 1099 ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:1:0","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"报错信息 D:\\apache-tomcat-7.0.54\\bin\\catalina.batrun [2016-10-1402:26:31,540]Artifactink-balance-web:warexploded:Serverisnotconnected.Deployisnotavailable. Connectedtoserver [2016-10-1402:26:31,562]Artifactink-balance-web:warexploded:Artifactisbeingdeployed,pleasewait... UsingCATALINA_BASE:\"C:\\Users\\mrchen\\.IntelliJIdea2016.1\\system\\tomcat\\Unnamed_ink-parent\" UsingCATALINA_HOME:\"D:\\apache-tomcat-7.0.54\" UsingCATALINA_TMPDIR:\"D:\\apache-tomcat-7.0.54\\temp\" UsingJRE_HOME:\"C:\\Program Files\\Java\\jdk1.7.0_17\" UsingCLASSPATH:\"D:\\apache-tomcat-7.0.54\\bin\\bootstrap.jar;D:\\apache-tomcat-7.0.54\\bin\\tomcat-juli.jar\" 错误:代理抛出异常错误:java.rmi.server.ExportException:Portalreadyinuse:1099;nestedexceptionis:java.net.BindException:Addressalreadyinuse:JVM_Bind Disconnectedfromserver ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:1:1","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["Back"],"content":"容器启动报错处理方案 （1）：运行 cmd 之后输入 netstat -ano 之后会出现列表，在里面找到错误信息中的端口(这里是1099) （2）：找到这一行后 记下进程号：这里是55512，之后打开任务管理器，进入到详细信息页面，找到pid为55512的进程，选中 点右下角的结束任务即可 （3）、执行完以上步骤再重启容器，容器正常启动了，恭喜！ sh ./update.sh ","date":"2021-06-28","objectID":"/java-tomcat-port-already-in-use-1099/:1:2","tags":["Java","Tomcat","Port","Error"],"title":"java.rmi.server.ExportException: Port already in use: 1099","uri":"/java-tomcat-port-already-in-use-1099/"},{"categories":["SoftwareDesign"],"content":"用组合模式、策略模式、观察者模式结合来实现一个MVC","date":"2021-06-28","objectID":"/mvc_design_patterns/","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc_design_patterns/"},{"categories":["SoftwareDesign"],"content":"用组合模式、策略模式、观察者模式结合来实现一个MVC ","date":"2021-06-28","objectID":"/mvc_design_patterns/:1:0","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc_design_patterns/"},{"categories":["SoftwareDesign"],"content":"1 MVC介绍 众所周知MVC不是设计模式，是一个比设计模式更大一点的模式，称作设计模式不合理，应该说MVC它是一种软件开发架构模式，它包含了很多的设计模式，最为密切是以下三种：Observer (观察者模式), Composite（组合模式）和Strategy（策略模式）。所以说MVC模式又称复合模式。MVC(Model-View-Controller) 模式的基本思想是数据，显示和处理相分离。模型(Model)负责数据管理，视图(View)负责数据显示，控制器(Controller)负责业务逻辑和响应策略。 从MVC的形成过程来看，最初只有模型和视图两个元素。模型封装了数据并提供操作接口，视图用来表现数据和接收用户请求。模型是独立的，而视图依赖于模型：从模型获取数据进行显示；向模型发送用户请求，并根据返回结果刷新自己。 需要用多个视图表现同一模型时，情况发生了变化：一个视图修改数据以后，不但本身要刷新，其他所有视图也要刷新。如果由该视图通知其他视图，它就需要知道其他所有视图，由于每个视图都可能发出修改，每个视图都要知道其他所有视图，这种关联过于复杂，不但难以维护，而且不便于增加新的视图。如果让模型通知所有视图更新，可能会影响模型的独立性。用观察者(Observer)模式 可以解决上述矛盾，从而实现：由模型通知视图，而模型不依赖于具体的视图，具体视图之间相互独立。 视图是用户请求的接收者，但不宜作为请求的处理者。因为界面是易变的，如果业务代码和界面代码放在一起，频繁的界面修改可能会破坏比较稳定的业务代码。将业务逻辑分离出来，由一个控制器负责，就是为了避免这种干扰。 模型，视图和控制器的基本协作关系如下图模型在状态变化的时候，直接通知所有视图，视图向模型查询状态数据，然后刷新自身。当用户发出操作时，视图把消息发给控制器，控制器按照业务逻辑进行处理，需要查询或更新数据时，控制器会调用模型。下面是一个更详细的示意图MVC架构把数据处理，程序输入输出控制及数据显示分离开来，并且描述了不同部件的对象间的通信方式。使得软件可维护性，可扩展性，灵活性以及封装性大大提高；MVC(Model-View-Controller)把系统的组成分解为M（模型）、 V（视图）、C（控制器）三种部件。视图表示数据在屏幕上的显示。控制器提供处理过程控制，它在模型和视图之间起连接作用。控制器本身不输出任何信息和做任何处理，它只负责把用户的请求转成针对Model的操作，和调用相应的视图来显示Model处理后的数据。三者之间关系如下图2.1：图2.1 MVC关系图 同样的数据，可以有不同的显示和进行各种处理。显示仅仅是表现数据，而处理是根据用户请求改变数据的过程，不但包含业务逻辑，也要提供响应策略。响应策略由控制器负责，视图可以使用不同的控制器提供不同的响应方式，这是策略(Strategy)模式的应用。 此外，MVC还允许视图嵌套，通过使用组合(Composite)模式，一致地处理组合视图和普通视图。 用多个视图表现一个模型，在视图不变的情况下改变响应策略，允许视图嵌套，这是MVC的三个主要特性。在内部结构上，MVC的主要关系是由观察者模式，策略模式和组合模式给出的。由观察者模式确定的模型视图关系是其中最为重要的。 MVC 模式有许多变体。前述结构中，由模型通知视图刷新，称为主动MVC；如果由控制器更新模型以后通知视图，称为被动MVC结构。在许多应用中，没有明显的控制器角色，也没有视图嵌套。可见根据实际需要，构成MVC的三个模式上都可能出现变化。Web浏览器就是被动MVC结构的一个实例。\" 浏览器是一个交互程序，从概念上讲，它是由一组客户、一组解释器与一个管理它们的控制器所组成。控制器形成了浏览器的中心部件，它解释鼠标点击与键盘输入，并且调用其他组件来执行用户指定的操作。例如，当用户键入一个URL或者点击一个超文本引用时，控制器调用一个客户从所需文档所在的远程服务器上取回该文档，并且调用解释器向用户显示该文档。每个浏览器必须包含一个HTML解释器来显示文档，其他解释器是可选的。HTML解释器的输入由符合HTML语法的文档所组成，输出由位于用户显示器上的格式版本文档所组成。解释器通过将HTML规则转换成适合用户显示硬件的命令来处理版面细节。HTML解释器一个最重要的功能是包含可选项。解释器必须存储关于显示器上位置之间关系的信息和HTML文档中被瞄定的项。当用户用鼠标选定了一个项，浏览器通过当前的光标位置和存储的位置信息来决定哪个项被用户选定。\" ","date":"2021-06-28","objectID":"/mvc_design_patterns/:1:1","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc_design_patterns/"},{"categories":["SoftwareDesign"],"content":"2.为什么要在Web应用中使用MVC架构 用户界面逻辑的更改往往比业务逻辑频繁，尤其是在基于Web的应用程序中。例如，可能添加新的用户界面页，或者可能完全打乱现有的页面布局。对显示的更改，尽可能地不要影响到数据和业务逻辑。 目前大部分Web应用都是将数据代码和表示混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。MVC从根本上强制性的将它们分开。尽管构造MVC应用需要一些额外的工作，但它带来的好处是无庸质疑的。 2.1 提高代码重用率 最重要的一点是多个视图能共享一个模型，无论用户想要Flash界面或是 WAP 界面；用一个模型就能处理它们。由于已经将数据和业务规则从表示层分开，所以可以最大化的重用代码。 2.2 提高程序的可维护性 因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变数据层和业务规则 [3]。例如，把数据库从MySQL移植到Oracle，或者把基于RDBMS数据源改变到LDAP，只需改变模型即可。一旦正确的实现了模型，不管数据来自哪里，视图都会正确的显示它们。MVC架构的运用，使得程序的三个部件相互对立，大大提高了程序的可维护性。 2.3 有利于团队开发 在开发过程中，可以更好的分工，更好的协作。有利于开发出高质量的软件。良好的项 目架构设计，将减少编码工作量 ：采用MVC结构 + 代码生成器，是大多数Web应用的理想选择。部分模型(Model)、和存储过程一般可用工具自动生成。控制(Controller)器比较稳定，一般由于架构师（也可能是有经验的人）完成；那么整个项目需要手动编写代码的地方就只有视图(View)了。在这种模式下，个人能力不在特别重要，只要懂点语法基础的人都可以编写，无论项目成员写出什么样的代码，都在项目管理者的可控范围内。即使项目中途换人，也不会有太大问题。在个人能力参差不齐的团队开发中，采用MVC开发是非常理想的。 ","date":"2021-06-28","objectID":"/mvc_design_patterns/:1:2","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc_design_patterns/"},{"categories":["SoftwareDesign"],"content":"3 MVC架构的优点及不足 3.1 MVC的优点 MVC的优点体现在以下几个方面： （1） 有利于团队开发分工协作和质量控制，降低开发成本。 （2） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步。 （3） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。 （4） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的修改。 （5） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。 3.2 MVC的缺点 MVC的不足体现在以下几个方面： （1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 （2）视图对模型数据的访问效率低。视图可能需要多次调用Model才能获得足够的显示数据。 （3）完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困难。 MVC 模式可以分解为以下设计模式 在GOF书的 Introduction中，有一小节是\"Design Patterns in Smalltalk MVC\"即介绍在MVC模式里用到的设计模式。它大概向我们传达了这样的信息：合成模式+策略模式+观察者模式约等于MVC模式（当然MVC模式要多一些东西）。也就是说它在大部分情况下是下面几个模式： 1、观察者模式 类图结构在Gof里的表示如下：2、合成模式 类图结构在Gof里的表示如下： 3、策略模式 类图结构在Gof里的表示如下： 谈 谈 MVC 架构模式中的三个角色 Model （模型端） Mod封装的是数据源和所有基于对这些数据的操作。在一个组件中，Model往往表示组件的状态和操作这些状态的方法，往往是一系列的公开方法。通过这些公开方法，便可以取得模型端的所有功能。 在这些公开方法中，有些是取值方法，让系统其他部分可以得到模型端的内部状态参数，其他的改值方法则允许外部修改模型端的内部状态。模型端还必须有方法登记视图，以便在模型端的内部状态发生变化时，可以通知视图端。我们可以自己定义一个Subject接口来提供登记和通知视图所需的接口或者继承 Java.util.Observable类，让父类完成这件事。 多个 View( 视图端 ) View封装的是对数据源Model的一种显示。一个模型可以由多个视图，并且可以在需要的时候动态地登记上所需的视图。而一个视图理论上也可以同不同的模型关联起来。 在前言里提到了，MVC模式用到了合成模式，这是因为在视图端里，视图可以嵌套，比如说在一个JFrame组件里面，可以有菜单组件，很多按钮组件等。 多个 Controller( 控制器端 ) 封装的是外界作用于模型的操作。通常，这些操作会转发到模型上，并调用模型中相应的一个或者多个方法（这个方法就是前面在介绍模型的时候说的改值方法）。一般Controller在Model和View之间起到了沟通的作用，处理用户在View上的输入，并转发给Model来更改其状态值。这样 Model和View两者之间可以做到松散耦合，甚至可以彼此不知道对方，而由Controller连接起这两个部分。也在前言里提到，MVC用到了策略模式，这是因为View用一个特定的Controller的实例来实现一个特定的响应策略，更换不同的Controller，可以改变View对用户输入的响应。 MVC (Model-View-Controller) : 模型利用\"观察者\"让控制器和视图可以随最新的状态改变而更新。另一方面，视图和控制器则实现了\"策略模式\"。控制器是视图的行为; 视图内部使用\"组合模\"式来管理显示组件。 以下的MVC解释图很好的标示了这种模式： 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件，像面板、框架和按钮。 这些模式携手合作，把MVC模式的三层解耦，这样可以保持设计干净又有弹性。 ","date":"2021-06-28","objectID":"/mvc_design_patterns/:1:3","tags":["MVC"],"title":"用组合模式、策略模式、观察者模式结合来实现一个MVC","uri":"/mvc_design_patterns/"},{"categories":["Software"],"content":"word怎么去掉百度网盘","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/","tags":["Office","Word","Panbaidu"],"title":"word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Software"],"content":"word怎么去掉百度网盘 不知道什么时候word里面多了一个百度网盘的图标。想去掉，网上也有方法，但是不够细致，基本都是word2010版，我这个是不断更新的最新版，自己倒腾好长时间才解决，仅供大家参考哈。 step1，鼠标选中网盘的图标，右键弹出如图所示对话框，点击自定义功能区即可。 step2，点击加载项，选中选中百度网盘word选项，点击下面的转到即可。 step3，选中可加载项的百度网盘，点击删除，再确定即可。 step4，返回word，百度网盘的图标消失，大功告成。 祝你愉快！ ","date":"2021-06-28","objectID":"/office-orrbit-pan-baidu/:1:0","tags":["Office","Word","Panbaidu"],"title":"word怎么去掉百度网盘","uri":"/office-orrbit-pan-baidu/"},{"categories":["Back","note"],"content":"Java后端面试题整理的笔记","date":"2021-06-08","objectID":"/java-audition-note/","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"什么是面向对象? 对比面向过程，是两种不同的处理问题的角度 面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者(对象)、及各自需要做什么 比如:洗衣机洗衣服 ","date":"2021-06-08","objectID":"/java-audition-note/:1:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向过程 面向过程会将任务拆解成一系列的步骤(函数)，1、打开洗衣机—\u003e2、放衣服–\u003e3、放洗衣粉—\u003e4、清洗—–\u003e5、烘干 面向对象会拆出人和洗衣机两个对象: 人:打开洗衣机放衣服放洗衣粉洗衣机:清洗烘干 从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护 ","date":"2021-06-08","objectID":"/java-audition-note/:1:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"面向对象 ","date":"2021-06-08","objectID":"/java-audition-note/:1:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"封装 封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项内部细节对外部调用透明，外部调用无需修改或者关心内部实现 两个经典的场景 1、javabean举例： javabean的属性私有，提供getset对外访问，因为属性的赋值或者获取逻辑只能由javabean本身决定。而不能由外部胡乱修改 private string name ; public void setName(string name){ this.name = \"tuling_\"+name; } 该name有自己的命名规则，明显不能由外部直接赋值 2、orm框架举例 操作数据库，我们不需要关心链接是如何建立的、sql是如何执行的，只需要引入mybatis，调方法即可 ","date":"2021-06-08","objectID":"/java-audition-note/:1:4","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"继承 继承基类的方法，并做出自己的改变和/或扩展 子类共性的方法或者属性直接使用父类的，而不需要自己再定义，只需扩展自己个性化的 ","date":"2021-06-08","objectID":"/java-audition-note/:1:5","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"多态 基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。 继承，方法重写，父类引用指向子类对象 父类类型变量名=new子类对象; 变量名.方法名(); 无法调用子类特有的功能 ","date":"2021-06-08","objectID":"/java-audition-note/:1:6","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、JVM性能调优实战相关 ","date":"2021-06-08","objectID":"/java-audition-note/:2:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"3、JDK JRE JVM ","date":"2021-06-08","objectID":"/java-audition-note/:3:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JDK Java Develpment Kit java开发工具 ","date":"2021-06-08","objectID":"/java-audition-note/:3:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JRE Java Runtime Environment java运行时环境 ","date":"2021-06-08","objectID":"/java-audition-note/:3:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"JVM: java Virtual Machine java虚拟机 ","date":"2021-06-08","objectID":"/java-audition-note/:3:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"4、==equals ==和equals比较==对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址 equals: object中默认也是采用==比较，通常会重写 Object pub1ic boolean equals(Object obj) { return (this == obj); } String pub1ic boolean equals (Object anObject) { if(this ==anobject) { return true; } if (anObject instanceof String) i String anotherstring = (String)anobject; int n = value.length; if (n == anotherstring.value.length) { char v1[] = value; char v2[] = anotherstring. value;int i = o; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。 public class StringDemo { public static void main(string args[]) { String str1 = \"He11o\"; String str2 new string ( \"He11o\"); String str3 = str2; //引用传递 System.out.println(str1 == str2); //false System.out.println(str1 == str3); // false System.out.println(str2 == str3); // true System.out.println(str1.equals (str2));// true System.out.println(str1.equals (str3));//true System.out.println(str2.equals (str3)); // true } } ","date":"2021-06-08","objectID":"/java-audition-note/:4:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"5、final ","date":"2021-06-08","objectID":"/java-audition-note/:5:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"1、简述final作用 最终的 修饰类:表示类不可被继承 修饰方法:表示方法不可被子类覆盖，但是可以重载 修饰变量:表示变量一旦被赋值就不可以更改它的值。 (1)修饰成员变量 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。 (2）修饰局部变量 系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。 因此使用final修饰局部变量时，即可以在定义时指定默认值（后面的代码不能对变量再赋值)，也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次) pub1ic class Fina1var { final static int a = 0;//再声明的时候就需要赋值或者静态代码块赋值 /** static{ a =o; } */ final int b = 0;//再声明的时候就需要赋值或者代码块中赋值或者构造器赋值 /*{ b = 0; } */ public static void main(string[]args) { final int localA;//局部变量只声明没有初始化，不会报错,与fina1无关。 loca1A = 0;//在使用之前一定要赋值I //localA = 1;但是不允许第二次赋值 } } (3）修饰基本类型数据和引用类型数据 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改; 如果是引用类型的变量，则在对某初始化之后便不能再让其指向另一个对象。但是引用的值是可变的。 pub1ic class Fina1ReferenceTest{ public static void main(){ final int[] iArr={1,2,3,4}; iArr[2]=-3;//合法 iArr=nu1;//非法，对iArr不能重新赋值 final Person p = new Person(25); p.setAge(24);//合法 p=null;//非法 } } 为什么局部内部类和匿名内部类只能访问局部final变量? 编译之后会生成两个class文件，Test.class Test1.class public class Test { public static void main(string[] args){} //局部fina1变量a,b public void test(final int b) { final int a = 10; //匿名内部类 new Thread(){ pub1ic void run() i System.out.print1n(a); System.out.print1n(b); }; }.start(); } } c1ass outc1ass { private int age = 12; public void outPrint(final int x) { c1ass Inclass i pub1ic void InPrint() { System. out.println(x); System.out.println(age); } } new Inc1ass(().InPrint(; } } ","date":"2021-06-08","objectID":"/java-audition-note/:5:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"2、为什么局部内部类和匿名内部类只能访问局部final变量? 首先需要知道的一点是:内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 这里就会产生问题:当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾:内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的\"copy\"。这样就好像延长了局部变量的生命周期 将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的,也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢? 就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。 ","date":"2021-06-08","objectID":"/java-audition-note/:5:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ","date":"2021-06-08","objectID":"/java-audition-note/:6:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ArrayList: 基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) ","date":"2021-06-08","objectID":"/java-audition-note/:6:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"LinkedList: 基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐—遍历 遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexof等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:6:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"6、Stringbuilfer String、StringBuffer、StringBuilder String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和stringBuilder都是在原对象上操作 StringBuffer是线程安全的，StringBuilder线程不安全的 StringBuffer方法都是synchronized修饰的 性能: StringBuilder \u003e StringBuffer \u003e String 场景:经常需要改变字符串内容时使用后面两个 优先使用StringBuilder，多线程使用共享变量时使用StringBuffer ","date":"2021-06-08","objectID":"/java-audition-note/:7:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"7、重载和重写的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:8:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 ","date":"2021-06-08","objectID":"/java-audition-note/:8:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"重写 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类就不能重写该方法。 public int add(int a,String b) public string add(int a,String b)//编译报错,产生二义性，并不知道返回什么值 ","date":"2021-06-08","objectID":"/java-audition-note/:8:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"8、接口和抽象类的区别 抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。（java8之前，java9变了） 抽象类只能继承一个，接口可以实现多个。 接口的设计目的，是对类的行为进行约束（更准确的说是一种“有\"约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。 而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来(否则当调用到A-B时，无法执行)。 抽象类是对类本质的抽象，表达的是is a 的关系，比如: BMw is a car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是like a的关系。比如: Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 使用场景:当你关注一个事物的本质的时候，用抽象类;当你关注一个操作的时候，用接口。 抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。 ","date":"2021-06-08","objectID":"/java-audition-note/:9:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"9、List和Set的区别 List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用lterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下表的元素 Set:无序，不可重复，最多允许有一个Nul元素对象，取元素时只能用lterator接口取得所有元素，在逐一遍历各个元素 ","date":"2021-06-08","objectID":"/java-audition-note/:10:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"10、hashCode与equals ","date":"2021-06-08","objectID":"/java-audition-note/:11:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"hashCode介绍 hashCode()的作用是获取哈希码，也称为散列码;它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-value)，它的特点是:能根据\"键\"快速的检索出对应的“值\"。这其中就利用到了散列码!(可以快速找到所需要的对象) ","date":"2021-06-08","objectID":"/java-audition-note/:11:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"为什么要有hashCode 以\"Hashset如何检查重复\"为例子来说明为什么要有hashcode: 对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals ()方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。 如果两个对象相等，则hashcode—定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的·因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 因此,equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如 何都不会相等（即使这两个对象指向相同的数据） ","date":"2021-06-08","objectID":"/java-audition-note/:11:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"11、ArrayList和LinkedList区别 ArrayList:基于动态数组，连续内存存储，适合下标访问（随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象) LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐一遍历遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过geti)取得某一元素时都需要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。 ","date":"2021-06-08","objectID":"/java-audition-note/:12:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"12、HashMap和HashTable的区别?底层实现是什么? 1.区别: (1) HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全; (2)HashMap允许key和value为null，而HashTable不允许 2.底层实现:数组+链表实现 jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标， 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组， 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表 key为null，存在下标0的位置 数组扩容 ","date":"2021-06-08","objectID":"/java-audition-note/:13:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"13、ConcurrentHashMap原理,jdk7和jdk8版本的区别 jdk7: 数据结构:ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构 元素查询:二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部 锁: Segment分段锁Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度 为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment get方法无需加锁，volatile保证(避免脏数据) jdk8: 数据结构: synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性 查找，替换，赋值操作都使用CAS 锁:锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容 读操作无锁: Node的val和next使用volatile修饰，读写线程对该变量互相可见 数组用volatile修饰，保证扩容时被读线程感知 ","date":"2021-06-08","objectID":"/java-audition-note/:14:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"14、如何实现一个IOC容器 配置文件配置包扫描路径 递归包扫描获取.class文件 反射、确定需要交给IOC管理的类 对需要注入的类进行依赖注入 配置文件中指定需要扫描的包路径 定义一些注解，分别表示访问控制层、业务服务层、数据持久层、 依赖注入注解、获取配置文件注解 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储 遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个lOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入 ","date":"2021-06-08","objectID":"/java-audition-note/:15:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"15、什么是字节码?采用字节码的好处是什么? java中的编译器和解释器: Java中引入了虚拟机的概念，即在机器和编译程序之间加入了 -层抽象的虚拟的机器。这台虚拟的机器在任何平台 上都提供给编译程序一个的共同的接口。 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。 每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。 Java源代码—\u003e编译器—\u003ejvm可执行的Java字节码(即虚拟指令)—\u003ejvm—\u003ejvm中解释器—-\u003e机器可执行的二进制机器码—-\u003e程序运行。 采用字节码的好处: Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 ","date":"2021-06-08","objectID":"/java-audition-note/:16:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"34、谈谈你对AOP的理解 系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用 AOP:将程序中的交叉业务逻辑(比如安全，日志，事务等)，封装成一个切面，然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情 ","date":"2021-06-08","objectID":"/java-audition-note/:17:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"35、谈谈你对IOC的理解 ","date":"2021-06-08","objectID":"/java-audition-note/:18:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"容器概念、控制反转、依赖注入 ioc容器:实际上就是个map (key,value)，里面存的是各种对象（在xml里配置的bean节点、@repository.@service、@controller、@component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。 这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入(autowired.resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入; id就是对象名）。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"控制反转: 没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转\"这个名称的由来。 全部对象的控制权全部上缴给\"第三方\"“OC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似\"粘合剂的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个粘合剂”，对象与对象之间会彼此失去联系，这就是有人把lOC容器比喻成′粘合剂\"的由来。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"依赖注入: “获得依赖对象的过程被反转了\"。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 ","date":"2021-06-08","objectID":"/java-audition-note/:18:3","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"66、简述MylSAM和InnoDB的区别 ","date":"2021-06-08","objectID":"/java-audition-note/:19:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"MyISAM: 不支持事务，现在支持了，但是每次查询都是原子的;支持表级锁，即每次操作是对整个表加锁;存储表的总行数; 一个MyISAM表有三个文件:索引文件、表结构文件、数据文件; 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯—性。 ","date":"2021-06-08","objectID":"/java-audition-note/:19:1","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"lnnoDB: 支持ACID的事务，支持事务的四种隔离级别;支持行级锁及外键约束:因此可以支持写并发;不存储总行数; 一个InnoDB引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能 为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为2G)，受操作系统文件大小的限制; ","date":"2021-06-08","objectID":"/java-audition-note/:19:2","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"88、Spring Cloud和Dubbo的区别 底层协议: springcloud基于http协议，dubbo基于Tcp协议，决定了dubbo的性能相对会比较好 注册中心: Spring Cloud 使用的eureka , dubbo推荐使用zookeeper 模型定义: dubbo将一个接口定义为一个服务，SpringCloud则是将一个应用定义为一个服务 SpringCloud是一个生态，而Dubbo是SpringCloud生态中关于服务调用一种解决方案(服务治理) ","date":"2021-06-08","objectID":"/java-audition-note/:20:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"ACID靠什么保证的? A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql C一致性由其他三大特性保证、程序代码要保证业务上的一致性 I隔离性由MVCC来保证 D持久性由内存+redo log来保证，Mysq|修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redolog恢复 InnoDB redo log写盘，InnoDB事务进入prepare状态。 如果前面prepare成功，bin1og 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么、InnoDB事务则进入commit状态(在 redo log 里面写一个commit记录) redolog的刷盘会在系统空闲时进行 ","date":"2021-06-08","objectID":"/java-audition-note/:21:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Back","note"],"content":"end ","date":"2021-06-08","objectID":"/java-audition-note/:22:0","tags":["Java","Mysql","Audition","Spring","SpringCloud","Dubbo"],"title":"Java后端面试题整理","uri":"/java-audition-note/"},{"categories":["Total"],"content":"Error inflating class com.baidu.mapapi.map.MapView关于集成百度地图时的问题","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"快乐报错 Error inflating class com.baidu.mapapi.map.MapView ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:1:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:0","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"这个也是百度地图调用过程中的步骤，亦可作为参考 集成百度地图时遇到的问题,纠缠我了半天,网上各种方法都试过了,还是一如既往.最后仔细看了一下开发文档,擦.原来这面出问题了.知道遇到问题的你肯定会很急,闲话不说下面就请看: 看好了啊,如果你的这些都配置好了,见下面这7张图里面的配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:1","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"1.你的app–libs文件夹那个BaiduLBS_Android.jar,有没有放置好 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:2","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"2.app–src–main–jinLibs文件夹有没有放置,并把里面的那几个文件夹复制进去 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:3","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"3.清单文件中百度地图的ak配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:4","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"4.Application的自定义子类有没有在清单文件节点下配置 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:5","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"5.在自定义的那个Application的onCreate方法中要进行百度地图的初始化 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:6","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"6.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:7","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"7.这面只是查看你上面那个有没有依赖ok ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:8","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"8.如果上面都配置好了会报那个错误 ,就看看开发文档的这一句话 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:9","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"9（我的问题）模拟器没联网（F*CK） 用虚拟机上的Chrome无法上网 解决办法见我的另一篇文章：Android studio模拟器无法联网问题解决办法 ","date":"2021-06-06","objectID":"/android-baidumap-inflating-error/:2:10","tags":["Android","AndroidStudio","AndroidvirtualDevice","Java","BaiduMap","Error","Net"],"title":"Error inflating class com.baidu.mapapi.map.MapView","uri":"/android-baidumap-inflating-error/"},{"categories":["Total"],"content":"Android studio模拟器无法联网问题解决办法","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"出现问题 重装系统后安装了Android studio 4.2.1，记得之前用模拟器联网的时候都是直接在模拟器内部打开网络连接就好，现在不行了，不知道之前怎么操作就能联网，反正当时一点都不纠结。 查阅了网上很多解决方法，结果都调试不通。 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:1:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"解决办法 只有用一个蠢办法，虽然只管一次，模拟器或者cmd一关下次打开就必须这个操作，但是为了官方模拟器的颜值和操作速度，我忍了…. 先配置了一个环境变量，避免每次从cmd中输入指令都要 cd 进入emulator文件夹 C:\\Users\\User(注意换成自己的电脑用户名)\\AppData\\Local\\Android\\Sdk\\emulator 模拟器联网：cmd中输入如下 emulator -avd Pixel_2_API_30 -dns-server 8.8.8.8,114.114.114.114 Pixel_2_API_30 是我的使用的模拟器 备注：模拟器调试快捷 Ctrl+M ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:2:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Total"],"content":"闲聊 曾经折腾黑苹果、VM的MacOS虚拟机，MacOS虚拟机也得配置DNS不然无法联网，不懂底层机制，求大佬赐教 ","date":"2021-06-06","objectID":"/androidstudio-avd-disconnect/:3:0","tags":["AndroidStudio","Android","AndroidvirtualDevice","Error","Net","DNS"],"title":"Android studio模拟器无法联网问题解决办法","uri":"/androidstudio-avd-disconnect/"},{"categories":["Learning","note"],"content":"记录回溯算法相关的笔记","date":"2021-06-04","objectID":"/backtracking-note/","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":" 通俗的讲，回溯法约等于递归里面嵌套for循环 ","date":"2021-06-04","objectID":"/backtracking-note/:0:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法问题类型 组合类 数组子数列 切割类 回文子串 子集类 类似组合 排列类 有序的组合 棋盘类 n皇后 ","date":"2021-06-04","objectID":"/backtracking-note/:1:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"问题解决思路 将回溯问题抽象为一棵n叉树，水平方向（广度）的循环使用for循环来解决，垂直方向（深度）的循环使用递归来解决 ","date":"2021-06-04","objectID":"/backtracking-note/:2:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"伪代码 void backTracking(args){ if(termination)//终止条件 collect result;//收集结果 return result;//返回结果 } for(each item in Set){//集合元素 processing node;//处理节点 recurrence function;//递归函数 backTrack operation;//回溯操作 } return final result;//返回最终结果 ","date":"2021-06-04","objectID":"/backtracking-note/:3:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Learning","note"],"content":"回溯法基本步骤 递归参数返回值 确定终止条件 单层递归逻辑 ","date":"2021-06-04","objectID":"/backtracking-note/:4:0","tags":["Algorithm","BackTracking"],"title":"回溯算法笔记","uri":"/backtracking-note/"},{"categories":["Operation"],"content":"之前编辑文件卡住，再次Vim查看文件报错","date":"2021-06-01","objectID":"/vim-again-swap-error/","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"发现问题 之前使用xshell编辑文件时xshell卡住，无奈关闭xshell标签重新来过，再次vim查看文件报错 E325: ATTENTION Found a swap file by the name \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" owned by: root dated: Tue Jun 1 09:24:28 2021 file name: /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml modified: YES user name: root host name: 111.47.28.118 process ID: 10535 (still running) While opening file \"/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" dated: Thu Apr 8 01:26:02 2021 (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \":recover\" or \"vim -r /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\" to recover the changes (see \":help recovery\"). If you did this already, delete the swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" to avoid this message. Swap file \"/var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp\" already exists! [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: ","date":"2021-06-01","objectID":"/vim-again-swap-error/:1:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决思路 这是由于之前我的编辑这个文件的时候卡顿了，所以在交换区产生了文件，并没有对源文件覆盖， 我修改的东西是按照文档改的，而且并没有很多，于是就把交换区的文件删除了就拉到，要是修改了很多建议看一下对比一下两个文件的区别，在觉得删除或是剪切过来继续用都行，剪切过来记得改名字就行 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:2:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"解决办法 删除指令 rm /var/opt/gitlab/gitlab-rails/etc/.gitlab.yml.swp 在编辑就没有报错了 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:3:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Operation"],"content":"反思 Linux文件修改机制，先再交换区创建副本，进行编辑，执行保存的化就从暂存区把文件弄过来。一旦出现了问题，改变了的文件和源文件都在便于运维人员进行容错管理文件。 ","date":"2021-06-01","objectID":"/vim-again-swap-error/:4:0","tags":["Linux","CentOS7","Vim","Swap","Error"],"title":"Vim查看文件报错","uri":"/vim-again-swap-error/"},{"categories":["Learning","note"],"content":"记录动态规划三种题型的笔记","date":"2021-05-29","objectID":"/dynamic_program/","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":" 动态规划满足最优化原理和无后效性 ","date":"2021-05-29","objectID":"/dynamic_program/:0:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划三种题型 ","date":"2021-05-29","objectID":"/dynamic_program/:1:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"1.计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic_program/:1:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"2.求最大最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 ","date":"2021-05-29","objectID":"/dynamic_program/:1:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"3.求存在性 取石子游戏,先手是否必胜 能不能选出k个数使得和是Sum ","date":"2021-05-29","objectID":"/dynamic_program/:1:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划四个组成部分 ","date":"2021-05-29","objectID":"/dynamic_program/:2:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"1.确定状态 状态在动态规划中的作用属于定海神针 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么 类似于解数学题中，X，Y，Z代表什么 确定状态需要两个意识: 最后一步 保证最后一个问题减小规模问题不变，且结论不矛盾 子问题：问题一样，规模变小 研究最优策略的最后一步化为子问题 ","date":"2021-05-29","objectID":"/dynamic_program/:2:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"2.转移方程 根据子问题直接得到 ","date":"2021-05-29","objectID":"/dynamic_program/:2:2","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"3.初始条件和边界条件 不重不漏（易说不易做 ） ","date":"2021-05-29","objectID":"/dynamic_program/:2:3","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"4.计算顺序 自顶向下或自底向上，整体思路的体现，即能利用之前的结果进行计算，去掉重复计算的步骤 神奇的注意点（动规五部曲） dp数组以及下标的含义？二维一维数组中的i、j是什么意思 递推公式，不言而喻 dp数组的初始化 遍历顺序（0/1背包问题为什么要先遍历背包后遍历物品，反过来是否可以；完全背包问题排列和组合for循环不同） 打印dp数组，用于debug，清晰思路 ","date":"2021-05-29","objectID":"/dynamic_program/:2:4","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划基本类型 坐标型：dp数组下标为原来坐标，代表题型UniquePath 序列型：dp数组下标为前i个，错开一个 划分型：划分数组，每组满足一定性质 区间型：用f[i][j]解决 背包型：各种背包装载问题（区间） 最长子序列型：dp数组下标为原来坐标，代表题型最长上升子序列 博弈型：计算必胜或必败 综合型：综合前面两种（如区间+博弈、动态+划分）或动态和其他算法（如动态+二分查找、动态+子母树 ） ","date":"2021-05-29","objectID":"/dynamic_program/:3:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划时间空间优化 Follow Up常考 滚动数组 降维 ","date":"2021-05-29","objectID":"/dynamic_program/:4:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划打印路径（解） ","date":"2021-05-29","objectID":"/dynamic_program/:5:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"动态规划基本题型 动归基础 斐波那契额数列 爬楼梯问题 背包问题 打家劫舍 树形dp（leetcode就三道题） 股票问题 买卖时间最大利润 子序列问题 最长子序列 最长连续递增子序列 编辑距离问题，两个字符串，最小编辑数使字符串相等。 ","date":"2021-05-29","objectID":"/dynamic_program/:6:0","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Learning","note"],"content":"拔尖类型题目，与我无关：区间dp、概率dp、 ","date":"2021-05-29","objectID":"/dynamic_program/:6:1","tags":["Algorithm","DynamicProgramming"],"title":"动态规划笔记（贝尔曼算法）","uri":"/dynamic_program/"},{"categories":["Total"],"content":"Android Studio 使用Device File Explorer管理安卓虚拟设备的文件","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":" Android Studio 使用Device File Explorer管理安卓虚拟设备的文件 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:0:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Android Device Monitor 新版的Android Studio已经把Android Device Monitor移除菜单栏了，如果要查看虚拟设备的内部文件，需要在AndroidSDK的安装目录中，右键以管理员身份打开tools文件夹中的monitor.bat。 这样做不太方便。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:1:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"Device File Explorer 有两种方式可以打开Device File Explorer 直接点击界面右下角的Device File Explorer 在菜单栏，选择 View–\u003eTool Windows–\u003eDevice File Explorer，即可打开查看虚拟设备内部文件的界面。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:2:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导出文件 在Device File Explorer中，如果想将设备中的文件导出到电脑本地。 选中文件–\u003e右键选择“Save as”（快捷键 ctrl+shift+s），弹出如下界面，选择任意文件夹保存即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:3:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"导入文件 选中虚拟设备中的文件夹，右键Upload 选择想要导入的文件，点击OK，即可。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:4:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Total"],"content":"其他支持 使用Device File Explorer非常方便，还支持其他新建文件、文件夹、删除等操作。 ","date":"2021-05-29","objectID":"/androidstudio-device-file-explorer/:5:0","tags":["Android","Java","XML","DeviceFileExplorer"],"title":"Android Studio 使用Device File Explorer","uri":"/androidstudio-device-file-explorer/"},{"categories":["Back","note"],"content":"记录Java开发过程中的一些笔记","date":"2021-05-25","objectID":"/java-note/","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java获取系统时间 import java.util.Date; import java.text.SimpleDateFormat; public class NowString { public static void main(String[] args) { SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 System.out.println(df.format(new Date()));// new Date()为获取当前系统时间 } } ","date":"2021-05-25","objectID":"/java-note/:1:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java代码实现double类型数字格式化为百分数 public class PercentTest { public static void main(String[] args) { double rate = 0.26535; NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留位数 nf.setMaximumFractionDigits(2);//小数点前保留位数 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 String percent = nf.format(rate); System.out.println(percent); } } 舍入模式 UP：远离零方向舍入的舍入模式。始终对非零舍弃部分前面的数字加 1。注意，此舍入模式始终不会减少计算值的绝对值。 示例： 输入数字 使用 UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 DOWN：向零方向舍入的舍入模式。从不对舍弃部分前面的数字加 1（即截尾）。注意，此舍入模式始终不会增加计算值的绝对值。 示例： 输入数字 使用 DOWN 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 CEILING：向正无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.UP；如果结果为负，则舍入行为类似于 RoundingMode.DOWN。注意，此舍入模式始终不会减少计算值。 示例： 输入数字 使用 CEILING 舍入模式 5.5 6 2.5 3 1.6 2 1.1 2 1.0 1 -1.0 -1 -1.1 -1 -1.6 -1 -2.5 -2 -5.5 -5 FLOOR：向负无限大方向舍入的舍入模式。如果结果为正，则舍入行为类似于 RoundingMode.DOWN；如果结果为负，则舍入行为类似于RoundingMode.UP。注意，此舍入模式始终不会增加计算值。 示例： 输入数字 使用 FLOOR 舍入模式 5.5 5 2.5 2 1.6 1 1.1 1 1.0 1 -1.0 -1 -1.1 -2 -1.6 -2 -2.5 -3 -5.5 -6 HALF_UP： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。如果被舍弃部分 \u003e= 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。注意，此舍入模式就是通常学校里讲的四舍五入。 示例： 输入数字 使用 HALF_UP 舍入模式 5.5 6 2.5 3 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -3 -5.5 -6 HALF_DOWN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。如果被舍弃部分 \u003e 0.5，则舍入行为同 RoundingMode.UP；否则舍入行为同RoundingMode.DOWN。 示例： 输入数字 使用 HALF_DOWN 舍入模式 5.5 5 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -5 HALF_EVEN： 向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为同 RoundingMode.HALF_UP；如果为偶数，则舍入行为同RoundingMode.HALF_DOWN。注意，在重复进行一系列计算时，此舍入模式可以在统计上将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。此舍入模式类似于 Java 中对float 和double 算法使用的舍入策略。 示例： 输入数字 使用 HALF_EVEN 舍入模式 5.5 6 2.5 2 1.6 2 1.1 1 1.0 1 -1.0 -1 -1.1 -1 -1.6 -2 -2.5 -2 -5.5 -6 UNNECESSARY：用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。如果对生成精确结果的操作指定此舍入模式，则抛出 ArithmeticException。 示例： 输入数字 使用 UNNECESSARY 舍入模式 5.5 抛出 ArithmeticException 2.5 抛出 ArithmeticException 1.6 抛出 ArithmeticException 1.1 抛出 ArithmeticException 1.0 1 -1.0 -1 -1.1 抛出 ArithmeticException -1.6 抛出 ArithmeticException -2.5 抛出 ArithmeticException -5.5 抛出 ArithmeticException ","date":"2021-05-25","objectID":"/java-note/:2:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java双端队列Deque使用详解 Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。 ","date":"2021-05-25","objectID":"/java-note/:3:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Deque有三种用途： 普通队列(一端进另一端出): Queue queue = new LinkedList()或Deque deque = new LinkedList() 双端队列(两端都可进出) Deque deque = new LinkedList() 堆栈 Deque deque = new LinkedList() 注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。 Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。 下表总结了上述 12 种方法： \r\r第一个元素 (头部)\r最后一个元素 (尾部)\r\r\r\r抛出异常\r特殊值\r抛出异常\r特殊值\r\r\r插入\raddFirst(e)\rofferFirst(e)\raddLast(e)\rofferLast(e)\r\r\r删除\rremoveFirst()\rpollFirst()\rremoveLast()\rpollLast()\r\r\r检查\rgetFirst()\rpeekFirst()\rgetLast()\rpeekLast()\r\r\r\rDeque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示： Queue方法 等效Deque方法 add add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示： 堆栈方法 等效Deque方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() ","date":"2021-05-25","objectID":"/java-note/:3:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Queue队列操作 方法名 作用 区别 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false offer 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 ","date":"2021-05-25","objectID":"/java-note/:4:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"数组操作 数组的初始化填充 int[] iL = new int[100]; //将数组填充为100个-1 Arrays.fill(iL,-1) ","date":"2021-05-25","objectID":"/java-note/:5:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"字符串操作 String根据下标访问 String s = \"abcd\" Char c = s.charAt(0)//c结果为a ","date":"2021-05-25","objectID":"/java-note/:6:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"Java中的« 和 » 和 »\u003e 详细分析 ","date":"2021-05-25","objectID":"/java-note/:7:0","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"«表示左移移，不分正负数，低位补0；　 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 « 2 　20的二进制补码：0001 0100 　向左移动两位后：0101 0000 　结果：r = 80 负数：r = -20 « 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制反码 ***：*1110 1011 　-20 的二进制补码 ：1110 1100 　左移两位后的补码：1011 0000 　反码：**1010 1111 ** 　原码：**1101 0000 ** 　结果：**r = -80 ** ","date":"2021-05-25","objectID":"/java-note/:7:1","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"»表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 » 2 　20的二进制补码：0001 0100 　向右移动两位后：0000 0101 　结果：r = 5 负数：r = -20 » 2 　-20 的二进制原码 ：1001 0100 　-20 的二进制反码 **：1110 1011 ** 　-20 的二进制补码 ：1110 1100 　右移两位后的补码：1111 1011 　反码：1111 1010 　原码：1000 0101 　结果：r = -5 ","date":"2021-05-25","objectID":"/java-note/:7:2","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back","note"],"content":"»\u003e表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数：　r = 20 »\u003e 2 　的结果与 r = 20 » 2 相同； 负数：　r = -20 »\u003e 2 注：以下数据类型默认为int 32位 　-20:源码：10000000 00000000 00000000 00010100 　反码：11111111 11111111 11111111 11101011 　补码：11111111 11111111 11111111 11101100 　右移：00111111 11111111 11111111 11111011 　结果：r = 1073741819 ","date":"2021-05-25","objectID":"/java-note/:7:3","tags":["Java","SimpleDate","Date","System","Double","Pencentage"],"title":"Java开发笔记","uri":"/java-note/"},{"categories":["Back"],"content":"解决'Exception in thread 'main' java.util.UnknownFormatConversionException: Conversion = '%''的报错并了解一定的报错机制","date":"2021-05-24","objectID":"/java-pencentage-format-error/","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"问题现象 最近在做一个java项目使用String.format进行控制台打印，结果出现如下错误： 最关键的是这个问题是偶现的，通过google定位到问题还是格式化输出过程中%之间冲突了 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:1:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人类似的问题 百度搜搜发现别人的都是因为System.out.printf引起的。 Java从1.5版本开始才具体格式化输出的功能，才有了printf这个方法，可以通过指定不同的格式来控制输出样式，其中%表示格式说明的起始符号，不可缺少。而我的问题就是因为接口响应的日志中包含了%，导致printf打印时出现异常。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:2:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人解决办法 使用 “%%” 去替换掉字符串中的 “%\",例如： String str = “hello world! % w”; System.out.printf(str.replaceAll(\"%”, “%%\")); ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人结果如下: hello world! % w ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:3:1","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的解决办法 同样是替换 public class PrintPencentSignalStringError { public static void main(String[] args) { NumberFormat nf = NumberFormat.getPercentInstance(); nf.setMinimumFractionDigits(2);//设置保留小数位,小数点后保留几位 nf.setRoundingMode(RoundingMode.HALF_UP); //设置舍入模式 // System.out.println(String.format(nf.format(0.67))); System.out.println(String.format(nf.format(0.67).replace(\"%\",\"%%\"))); String str = \"hello world! % w\"; // System.out.printf(str); System.out.printf(str.replace(\"%\",\"%%\")); } } ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:4:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"别人总结 只要出现了这个错误，不管Conversion = ‘任意字符’ 中是哪个值，那肯定是你使用了printf打印内容，但是其中包括了%这个关键字符，可以使用多加一个百分号来进行转义（%%）就可以正常输出了。 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:5:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"我的想法 这两种输出格式化应该都是因为百分号的冲突问题才报的错，故附上格式化输出的对应表格，看到百分号我才恍然大悟 ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:6:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Back"],"content":"格式化输出对应表 转换符 详细说明 示例 %s 字符串类型 “喜欢请收藏” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 88 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 8.888 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） 不举例(基本用不到) %h 散列码 不举例(基本用不到) %% 百分比类型 ％(%特殊字符%%才能显示%) %n 换行符 不举例(基本用不到) %tx 日期与时间类型（x代表不同的日期与时间转换符) 不举例(基本用不到) ","date":"2021-05-24","objectID":"/java-pencentage-format-error/:7:0","tags":["Java","Pencentage","String","fromat","Printf","Error"],"title":"java.util.UnknownFormatConversionException: Conversion = '%'","uri":"/java-pencentage-format-error/"},{"categories":["Front","note"],"content":"JS的padStart()方法,padEnd()方法的笔记和示例","date":"2021-05-19","objectID":"/js-padstart-padend/","tags":["JavaScript","padStart","padEnd"],"title":"JS的padStart()方法,padEnd()方法","uri":"/js-padstart-padend/"},{"categories":["Front","note"],"content":"ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 'abc'.padEnd(10, '0123456789') //\"abc0123456\" 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 '1'.padStart(10, '0') // \"0000000001\" '12'.padStart(10, '0') // \"0000000012\" '123456'.padStart(10, '0') // \"0000123456\" 另一个用途是提示字符串格式。 '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" ","date":"2021-05-19","objectID":"/js-padstart-padend/:0:0","tags":["JavaScript","padStart","padEnd"],"title":"JS的padStart()方法,padEnd()方法","uri":"/js-padstart-padend/"},{"categories":["Learning","note\""],"content":"介绍常用的查找表法","date":"2021-05-18","objectID":"/find-table/","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","note\""],"content":"在遍历的同时，记录一些信息，以省去一层循环，这是“以空间换时间”的想法 需要记录已经遍历过的数值和它所对应的下标，可以借助查找表实现 查找表有两个常用的实现: 哈希表 平衡二叉搜索树 ","date":"2021-05-18","objectID":"/find-table/:0:0","tags":["Algorithm","Hash","BinaryTree"],"title":"查找表法","uri":"/find-table/"},{"categories":["Learning","Note"],"content":"HashMap初始化时为什么建议使用HashMap(int initialCapacity)指定集合大小","date":"2021-05-17","objectID":"/hashmap-initialcapacity/","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"介绍 首先设置一个合理的初始化容量可以提高HashMap的性能 在当我们对HashMap初始化没设置初始化容量时，系统会默认创建一个容量为16的大小的集合。若我们的所需的集合很小则会造成内存浪费，而当HashMap的容量值超过了临界值（threshold)时HashMap将会重新扩容的下一个2的指数幂（16-\u003e32）。HashMap扩容将会重新创建hash表降低性能。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:1:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"方法 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"官方 如果不超过12个键值对，可以不设置 如果超出，按initialCapacity = (需要存储的元素个数 / 负载因子) + 1公式计算后设置 官方的建议是initailCapacity设置成2的n次幂 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:1","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"其他 如何设置一个合理的初始化容量 当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。当HashMap的容量值超过了临界值（threshold)时就会扩容，threshold = HashMap的容量值0.75，比如初始化容量为8的HashMap当大小达到80.75=6时将会扩容到16。当我们设置HashMap的初始化容量是遵循expectedSize /0.75+1，比如expectedSize是6时 6/0.75+1=9，此时jdk处理后会被设置成16，大大降低了HashMap被扩容的几率。 当我们通过HashMap(int initialCapacity)设置初始容量的时候，HashMap并不一定会直接采用我们传入的数值，而是经过计算，得到一个新值，目的是提高hash的效率。(1-\u003e2、3-\u003e4、7-\u003e8、9-\u003e16) HashMap会选择大于初始化值的第一个2的幂作为容量。不然会限制了散列的范围。 HashMap 之所以速度快，因为它使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:2:2","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"集合介绍 List Set Map 都是接口 List Set继承Collection(Collections是工具类) List子类(有序，可重复)—ArrayList、Vector、LinkedList ArrayList、Vector 底层是数组（查找快，增删慢） 前者线程不安全，后者线程安全 Linkedlist 底层是链表查找慢，增删快 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:3:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"Set（无序，唯一）—HashSet TreeSet LinkedHashSet HashSet 底层是哈希表（hashcode equals） LinkedHashSet 底层是链表和哈希表–插入有序唯一，链表保证有序、哈希表保证唯一 TreeSet 底层结构是红黑树–唯一有序，自然排序、比较器排序 Map HashMap ThreeMap HashTable HashMap HashTable 无序 前者非线程安全，效率高，允许有null（kv），后者线程安全，效率低，不允许null值。 ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:4:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","Note"],"content":"TreeMap 有序 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序 \u003c部分整理别人知识点\u003e ","date":"2021-05-17","objectID":"/hashmap-initialcapacity/:5:0","tags":["Java","Algorithm","HashMap","Hash"],"title":"HashMap(int initialCapacity)指定集合大小","uri":"/hashmap-initialcapacity/"},{"categories":["Learning","note\""],"content":"（详细介绍）什么叫做哈希冲突？什么是负载因子？如何解决哈希冲突？？？","date":"2021-05-16","objectID":"/hash-table/","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"概念： 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为$ O(N) $，平衡树中为树的高度，即$ O(log_2 N) $，搜索的效率取决于搜索过程中元素的比较次数。 理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。 当向该结构中： ","date":"2021-05-16","objectID":"/hash-table/:1:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放 ","date":"2021-05-16","objectID":"/hash-table/:1:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(HashTable)(或者称散列表) 例如：数据集合{1，7，6，4，5，9}； 哈希函数设置为：$ hash(key) = key % capacity$; capacity为存储元素底层空间总的大小。 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快 问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？ ","date":"2021-05-16","objectID":"/hash-table/:1:2","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-概念： 对于两个数据元素的关键字$ k_i $和$ k_j (i != j) $，有$ k_i != k_j $，但有：$ Hash(k_i) == Hash(k_j) $，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。 ","date":"2021-05-16","objectID":"/hash-table/:2:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免： 首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。 两种方式解决冲突 链表式解决（Separate Chaining) 每个数据单元存储数据和next指针，形成链表 开放地址(Open Addressiting) 不用next指针，把其他下标的位置都对外开放。 开放地址的方法: a.线性探测法 冲突后搜索次数线性循环向后放置 b.平方探测(二次方探测) 冲突后根据搜索次数的平方循环向后放置 c.双哈希 ","date":"2021-05-16","objectID":"/hash-table/:3:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-哈希函数设计： 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。 哈希函数设计原则： 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间 哈希函数计算出来的地址能均匀分布在整个空间中 哈希函数应该比较简单 常见哈希函数： 1.直接定制法–(常用) 取关键字的某个线性函数为散列地址：$ Hash（Key）= A*Key + B $ 优点：简单、均匀 缺点：需要事先知道关键字的分布情况 使用场景：适合查找比较小且连续的情况 2.除留余数法–(常用) 设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：$ Hash(key) = key% p(p\u003c=m)$ ,将关键码转换成哈希地址 还有很多例作为了解：平方取中法，折叠法，随机数法，数学分析法（可以自己查找资料） 注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突 ","date":"2021-05-16","objectID":"/hash-table/:4:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-避免-负载因子调节（重点） 已知哈希表中已有的关键字个数是不可变的，那我们能调整的就只有哈希表中的数组的大小。 ","date":"2021-05-16","objectID":"/hash-table/:5:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决 解决哈希冲突两种常见的方法是：闭散列和开散列 ","date":"2021-05-16","objectID":"/hash-table/:6:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-闭散列： 闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？ 线性探测 比如上面的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，下标为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 插入 通过哈希函数获取待插入元素在哈希表中的位置 如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到 下一个空位置，插入新元素 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他 元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此线性探测采用标 记的伪删除法来删除一个元素。 二次探测： 线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，找下一个空位置的方法为：$ H_i = (H_0+i^2)% m $，或者： $ H_i = (H_0-i^2)% m $ 其中：i = 1,2,3…， $ H_0 $是通过散列函数Hash(x)对元素的关键码 key进行计算得到的位置，m是表的大小。 对于2.1中如果要插入44，产生冲突，使用解决后的情况为： 研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。 因此：比散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。 ","date":"2021-05-16","objectID":"/hash-table/:6:1","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"冲突-解决-开散列/哈希桶（重点） 开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。 从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。 开散列，可以认为是把一个在大集合中的搜索问题转化为在小集合中做搜索了。 冲突严重时的解决办法： 刚才我们提到了，哈希桶其实可以看作将大集合的搜索问题转化为小集合的搜索问题了，那如果冲突严重，就意味着小集合的搜索性能其实也时不佳的，这个时候我们就可以将这个所谓的小集合搜索问题继续进行转化，例如： 每个桶的背后是另一个哈希表 每个桶的背后是一棵搜索树 ","date":"2021-05-16","objectID":"/hash-table/:7:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Learning","note\""],"content":"哈希表满了 当哈希表的存储量超过百分之七十（负载因子，默认为0.75），会执行rehashing，即再次哈希，找一个大于原来二倍以上的质数重新进行计算以扩充hash表的容量 代码实现： // key-value 模型 public class HashBucket { private static class Node { private int key; private int value; Node next; public Node(int key, int value) { this.key = key; this.value = value; } } private Node[] array; private int size; // 当前的数据个数 private static final double LOAD_FACTOR = 0.75; public int put(int key, int value) { int index = key % array.length; // 在链表中查找 key 所在的结点 // 如果找到了，更新 // 所有结点都不是 key，插入一个新的结点 for (Node cur = array[index]; cur != null; cur = cur.next) { if (key == cur.key) { int oldValue = cur.value; cur.value = value; return oldValue; } } Node node = new Node(key, value); node.next = array[index]; array[index] = node; size++; if (loadFactor() \u003e= LOAD_FACTOR) { resize(); } return -1; } private void resize() { Node[] newArray = new Node[array.length * 2]; for (int i = 0; i \u003c array.length; i++) { Node next; for (Node cur = array[i]; cur != null; cur = next) { next = cur.next; int index = cur.key % newArray.length; cur.next = newArray[index]; newArray[index] = cur; } } array = newArray; } private double loadFactor() { return size * 1.0 / array.length; } public HashBucket() { array = new Node[8]; size = 0; } public int get(int key) { int index = key % array.length; Node head = array[index]; for (Node cur = head; cur != null; cur = cur.next) { if (key == cur.key) { return cur.value; } } return -1; } } ","date":"2021-05-16","objectID":"/hash-table/:8:0","tags":["DataStructure","Hash","HashTable"],"title":"哈希表","uri":"/hash-table/"},{"categories":["Front"],"content":"解决Uni-App开发组件时控制台报错Error in Created hook: 'TypeError's： Cannot read property 'num' of 'undefined' 的问题","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"Uni-App编写组件的时候，生命周期函数时遇到了使用箭头函数拿不到this的Vue对象的情况 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:0:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"代码 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:1:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"报错 浏览器控制台报下面的错误 created() { } created: () =\u003e { } ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:2:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"原因 箭头函数和普通函数是有区别的，，因为箭头凶数并没有this , this会作为变量一直向上级词法作用域查找，直至找到为止，经常导致Uncaught TypeError: Cannot read property of undefined 或Uncaught TypeError : this.myMethod is not a function之类的错误。 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:3:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front"],"content":"解决 用普通函数替换箭头函数就行了 ","date":"2021-05-15","objectID":"/vue-uni-app-hood-var-undefined/:4:0","tags":["Vue","Uni-App","Error"],"title":"Error in Created hook: 'TypeError's: Cannot read property 'num' of 'undefined'","uri":"/vue-uni-app-hood-var-undefined/"},{"categories":["Front","note"],"content":"记录使用Vue开发Uni-App小程序的笔记","date":"2021-05-14","objectID":"/vue-uni-app-note/","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"text text组件相当于html的span行布局组件 selectable属性为是否开启可被选中，当前最新版本uni-app的text的selectable属性在小程序端不能使用，暂时测试H5端正常使用 decode属性为开启是否可以解码，当前最新版本uni-app的decode属性现在无论设置为true或false都可以解码（如\u0026amp-\u003e\u0026） ","date":"2021-05-14","objectID":"/vue-uni-app-note/:1:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"view view组件相当于html的div盒子（层、垂直）布局组件，独占一行 hover-start-time、hover-stay-time现在支持字符串的数字，原来需要在属性名前加上冒号:，如:hover-start-time ","date":"2021-05-14","objectID":"/vue-uni-app-note/:2:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"Button 按钮组件，type选择为primary样式后，在H5显示蓝色，在小程序显示绿色 \u003cbutton type=\"primary\"\u003e蓝绿色按钮组件\u003c/button\u003e v-for 需要添加:key作为唯一值否则警告 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:3:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"生命周期 onError只有H5平台支持的生命周期函数，小程序端无效 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:4:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["Front","note"],"content":"文件上传 uni.chooseImage在H5端设置count:参数以后是限制不住多的图片上传的，但是在小程序端多的图片不会被上传 previewImage的loop:属性（查看的图片可以循环）在小程序端和H5端不起作用 ","date":"2021-05-14","objectID":"/vue-uni-app-note/:5:0","tags":["Vue","Uni-App"],"title":"Vue开发UniApp笔记","uri":"/vue-uni-app-note/"},{"categories":["SoftwareDesign"],"content":"ShellScript（.sh）脚本语法知识，学习编写脚本时的笔记","date":"2021-05-13","objectID":"/powerdesigner-error/","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["SoftwareDesign"],"content":"使用聚合时生成代码以后，需要修改两个role名字为不同，否则a聚合与b时会报a角色名称不唯一 ","date":"2021-05-13","objectID":"/powerdesigner-error/:0:0","tags":["PowerDesigner","Association","Error"],"title":"PowerDesigner生成Java代码时出现的错误","uri":"/powerdesigner-error/"},{"categories":["documentation"],"content":"Hugo生成页面后，本地调试没问题，推到远程发现动画、目录没有生成","date":"2021-05-12","objectID":"/sri-hashes-error/","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"问题来源 Hugo生成页面后，本地调试没问题，推到远程发现首页和文章页面的动画，文章页面的目录没有生成 查看HTML对比并未发现不同怀疑JS 打开控制台，报这个错 Failed to find a valid digest in the 'integrity' attribute for resource 'https://kkkpjskey.github.io/js/theme.min.319518a29ce7d84523d8dfb36ac617794d807f22da6b3a2e11ba33cd8ecfcfc02cf5aabf2034912959a143bdba7573bd.js' with computed SHA-256 integrity 'nvT75FkXevX06WR8vlhFFP02xzhq9qFxLQOuS0LkWyQ='. The resource has been blocked. 查资料发现是SRI不一致的问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:1:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"寻找问题 怀疑Hugo计算SRI的Hashes问题 查看其他CSS等文件，Hashes值是对的，故怀疑主题问题 这是切换主题导致的问题，故还原主题测试发现没问题，怀疑Js文件前后不一致 寻找之前版本的这个js文件，对比，明面上并无差别（Sublime插件对比） 怀疑底层问题，经验所得查看占有的空间大小，差两个字符 不死心于是，使用Winhex肉眼对比，发现了这个 查ASCII表 多了归位键 ","date":"2021-05-12","objectID":"/sri-hashes-error/:2:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"解决 发现有差别就可以用原来的js替换了，问题解决 ","date":"2021-05-12","objectID":"/sri-hashes-error/:3:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"结论 这个字符会影响SRI的计算，本地生成页面时。有这个字符，远程提交时没这个了，前后Hashes值不一样导致了报错，可能是原主题问题 ","date":"2021-05-12","objectID":"/sri-hashes-error/:4:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["documentation"],"content":"后续 突发奇想尝试下载ZIP包，结果人家的没问题，SSH下载凭空多了两字符，这就让人顶不住了！！可能是git传输的问题！！ ","date":"2021-05-12","objectID":"/sri-hashes-error/:5:0","tags":["Blog","Hugo","HTML","SRI","Error"],"title":"远程Hugo缺少功能","uri":"/sri-hashes-error/"},{"categories":["Front","note"],"content":"使用SRI保护你的网站免受第三方CDN恶意攻击，记录SRI相关笔记","date":"2021-05-12","objectID":"/sri-note/","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"出于速度和降低服务器负载考虑，有时候我们会选择使用 CDN 加载第三方静态资源。对于一些热门的第三方库，在用户打开你的网页之前就很有可能在浏览别的网站时被浏览器缓存下来，这样就可以极大的提升网页加载速度。 然而使用 CDN 也提高了网站的安全风险：第三方静态资源放在第三方服务器上，CDN 的拥有者有没有可能偷偷的篡改这些文件，加入恶意代码呢？或者 CDN 服务器遭受了黑客攻击，整个文件被替换掉。虽然可能性不高，但不是零。JavaScript 对于当前浏览器页面有完全控制权，他们不仅仅能获取到页面上的任何内容，还能抓取用户输入的一些诸如密码之类的机密信息，还能获取到保存到 Cookie 中的登录票据等等内容，这就是所谓的 XSS 攻击。 我们需要一种机制确保从 CDN 下载的文件未被恶意篡改。某些下载网站就提供下载文件的 MD5 或 SHA1 码用于检查所下载文件的完整性，网页中有没有类似的机制呢？ ","date":"2021-05-12","objectID":"/sri-note/:0:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"What（什么是 SRI） Subresource Integrity (SRI) is a security feature that enables browsers to verify that files they fetch (for example, from a CDN) are delivered without unexpected manipulation. 在 和 link 标签中通过 integrity 属性，浏览器核实所获取的 js 文件（或 css 文件）确实是如 integrity 值规定的，然后再加载 js 文件（或应用css 文件）。 例子 如下是个 script 标签 \u003cscript src=\"https://example.com/example-framework.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"\u003e \u003c/script\u003e 注意 integrity=“sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC”，integrity 的值以 sha384- 开头，表示算法为 sha384, dash (-) 之后跟随的是 base64-encoded hash。 当前所允许的 hash 算法有 sha256, sha384, and sha512 ","date":"2021-05-12","objectID":"/sri-note/:1:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"生成 SRI Hashes值 命令行有两种方法。 ","date":"2021-05-12","objectID":"/sri-note/:2:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法一 cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A ","date":"2021-05-12","objectID":"/sri-note/:2:1","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法二 shasum -b -a 384 FILENAME.js | xxd -r -p | base64 注意，这里 shah 算法是 sha384，如果生成其他的 hash 值，是否也像这样，只需稍作修改即可（可能吧，但是未验证）。 ","date":"2021-05-12","objectID":"/sri-note/:2:2","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"方法三 $ echo -n \"alert('Hello, world.');\" | openssl dgst -sha384 -binary | openssl base64 -A 使用了 OpenSSL 这个 *nix 中通常都包含的工具计算哈希值。其中 alert('Hello, world.'); 是文件内容，你也可以用 cat Filename.js 直接读取某个文件。 输出 H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO，在此基础上添加前缀 sha384- 就可以了。 还有在线工具 https://srihash.org/ 可以生成不同格式的工具 https://www.xftsoft.com/tool/integrity ","date":"2021-05-12","objectID":"/sri-note/:2:3","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"浏览器如何处理 SRI (Subresource Integrity) 当浏览器遇到一个带有 integrity 的 \u003cscript\u003e 或 \u003cstyle\u003e 标签，在执行其中的 JS 脚本或应用其中的 CSS 样式之前，浏览器会首先计算所下载文件的内容的哈希值是否与 integrity 属性给定的值相同。 如果计算结果与给定值不匹配，浏览器会拒绝执行脚本内容，并报出一个网络错误，类似如下结果： When a browser encounters a \u003cscript\u003e or \u003clink\u003e element with an integrity attribute, before executing the script or before applying any stylesheet specified by the \u003clink\u003e element, the browser must first compare the script or stylesheet to the expected hash given in the integrity value. If the script or stylesheet doesn’t match its associated integrity value, then the browser must refuse to execute the script or apply the stylesheet, and must instead return a network error indicating that fetching of that script or stylesheet failed. Failed to find a valid digest in the ‘integrity’ attribute for resource ‘https://cdnjs.cloudflare.com/ajax/libs/normalize/6.0.0/normalize.min.css' with computed SHA-256 integrity ‘VbcxqgMGQYm3q8qZMd63uETHXXZkqs7ME1bEvAY1xK8=’. The resource has been blocked. 参考 Subresource Integrity https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity ","date":"2021-05-12","objectID":"/sri-note/:3:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"使用 SRI 只需给 script 或 style 标签添加 integrity 属性即可。例如： JavaScript \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e CSS \u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css\" integrity=\"sha384-7tIwW4quYS2+TZCwuAPnUY+dRqg28ylzlIoVXAwpfiTs+CMKsAOSsWYQ96c/ZnV+\" crossorigin=\"anonymous\"\u003e integrity 属性值以 shaXXX- 开头，表示后面的哈希值使用的哈希算法，目前只允许 sha256、sha384 或 sha512 这三种哈希算法，以 sha384 比较多见。后面跟对应的哈希值即可。 值得注意的是，因为启用 SRI 需要获取所下载文件的内容进行计算，所以需要 CDN 服务器启用跨域资源访问（CORS）支持，即返回 Access-Control-Allow-Origin: * 头。客户端需要使用跨域的形式加载指定文件，即添加 crossorigin=\"anonymous\" 属性。就我所知，目前国内相对常用的免费 CDN bootcdn 已经支持 CORS，百度静态 CDN 还不支持。 ","date":"2021-05-12","objectID":"/sri-note/:4:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"CSP 与 SRI 你可以使用 内容安全政策 （CSP）强制要求当前页面所有脚本加载标签启用 SRI。例如 Content-Security-Policy: require-sri-for script; 强制要求所有 script 标签启用 SRI，浏览器会拒绝加载未启用 SRI 的 script 标签。 对应的还有 CSS 版本： Content-Security-Policy: require-sri-for style; 你也可以同时启用两者。 ","date":"2021-05-12","objectID":"/sri-note/:5:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["Front","note"],"content":"错误恢复 使用 CDN 时别忘了当尝试从 CDN 加载文件失败后加载本地版本： \u003cscript src=\"https://code.jquery.com/jquery-3.2.1.min.js\" integrity=\"sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e \u003cscript\u003eif (!window.jQuery) document.write('\u003cscript src=\"/jquery-3.2.1.min.js\"\u003e\u003c\\/script\u003e')\u003c/s ","date":"2021-05-12","objectID":"/sri-note/:6:0","tags":["HTML","SRI","CDN","CSP"],"title":"使用SRI保护你的网站免受第三方CDN恶意攻击","uri":"/sri-note/"},{"categories":["SoftwareDesign","note"],"content":"详细介绍Mybatis中用到的设计模式","date":"2021-05-09","objectID":"/mybatis-designmode/","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["SoftwareDesign","note"],"content":" Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果； 组合模式，例如SqlNode和各个子类ChooseSqlNode等； 模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler； 适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现； 装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现； 迭代器模式，例如迭代器模式PropertyTokenizer； ","date":"2021-05-09","objectID":"/mybatis-designmode/:0:0","tags":["DesignMode","ORM","Mybatis"],"title":"Mybatis中用到的设计模式","uri":"/mybatis-designmode/"},{"categories":["Total","note"],"content":"记录Android开发笔记","date":"2021-05-01","objectID":"/android-note/","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android5.0常用颜色属性说明 在使用Eclipse的时代，我们很少去在style文件给整个应用或者Activity去设定颜色，那是因为即使设置也不会提升用户的视觉效果。但是材料设计号称让没有设计功底的人也能做出漂亮的App，那我们今天就来看看在Androi5.0中常用的颜色属性。 我们可以先定义一个style，然后在这个style中设定每一个Activity或者整个App的颜色，最后在清单文件中来给某个Activity设置主题即可。代码如下： \u003cstyle name=\"AppTheme.NoActionBar\"\u003e \u003c!--状态栏颜色--\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003c!--控制各个控件被选中时的颜色--\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c!--页面背景色--\u003e \u003citem name=\"android:windowBackground\"\u003e@color/windowBackg\u003c/item\u003e \u003c!--底部导航栏颜色--\u003e \u003citem name=\"android:navigationBarColor\"\u003e@color/navigationColor\u003c/item\u003e \u003c!--Appbar背景色--\u003e \u003citem name=\"android:colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003c!--ToolBar上的Title颜色--\u003e \u003citem name=\"android:textColorPrimary\"\u003e@color/textColorPrimary\u003c/item\u003e \u003c!--各个控制控件的默认颜色--\u003e \u003citem name=\"android:colorControlNormal\"\u003e@color/colorControlNormal\u003c/ item\u003e \u003c/style\u003e 最后再来一张图详细说明每个item设定的到底是哪里的颜色： ","date":"2021-05-01","objectID":"/android-note/:1:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"ConstraintLayout基本使用之toLeftOf 、toTopOf、toRightOf、toBottomOf 关于ConstraintLayout的博客、文章想必大家已经见过很多了，都是很全面的，今天这篇博客主要将ConstraintLayout的 layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintTop_toTopOf ... 以上到底怎么理解呢？下面我将通过图片+文字来解释。 现在假设屏幕中间有个长宽为100dp的红色正方形，屏幕左上方有个宽高为50dp的黑色正方形，如下: 接下来我们一个一个试试这些参数吧! 1、layout_constraintLeft_toLeftOf(可以看出黑色正方形左边和红色正方形左边对齐) 2、layout_constraintLeft_toRightOf(黑色正方形的左边和红色正方形的右边对齐) 3、layout_constraintRight_toLeftOf(黑右对齐红左) 4、layout_constraintRight_toRightOf(黑右对齐红右) 剩余四个: layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf 也是同理。 让我们看一下这个参数的统一命名:layout_constraintA_toBOf， 也即代表当前布局的A方向，对齐目标布局的B方向 ","date":"2021-05-01","objectID":"/android-note/:2:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 沉浸式标题栏设置，顶部view到状态栏 Android 沉浸式标题栏设置，顶部view到状态栏 布局xml文件： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroid.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:id=\"@+id/tv_top_bg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:maxHeight=\"140dp\" android:background=\"@drawable/case_resource_transport_top_bg\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e ... \u003c/android.support.constraint.ConstraintLayout\u003e activity AndroidManifest设置 \u003cactivity android:name=\"....xxActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/AppTheme.imgFullScreen\" android:windowSoftInputMode=\"adjustPan\"/\u003e stayles.xml 添加style \u003cstyle name=\"AppTheme.imgFullScreen\"\u003e \u003citem name=\"android:windowTranslucentStatus\"\u003efalse\u003c/item\u003e \u003citem name=\"android:windowTranslucentNavigation\"\u003efalse\u003c/item\u003e \u003citem name=\"android:statusBarColor\"\u003e@android:color/transparent\u003c/item\u003e \u003c/style\u003e xxActivity添加 val decorView = window.decorView val option = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE) decorView.systemUiVisibility = option window.statusBarColor = Color.TRANSPARENT 效果： ","date":"2021-05-01","objectID":"/android-note/:3:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android去除顶部默认的标题栏 当我们在Android Studio中创建一个新的Android项目时，会发现顶部有一个标题栏。我们有的时候并不需要这个标题栏，因此我们就需要把它去掉。 在Android Studio中展开Project模块，会看到里面是一个由文件和文件夹构成的树形图。打开里面的app-\u003emanifests-\u003eAndroidManifest.xml文件，然后找到application标签的android:theme属性，把它的值改为\"@style/Theme.AppCompat.NoActionBar\"，这样就可以解决问题了。 ","date":"2021-05-01","objectID":"/android-note/:4:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android注册服务 broadcastReceiver使用时需要在AndroidManifest.xml注册格式为 package=\"com\"\u003e \u003cactivity android:name=\".MainActivity\"\u003e …… \u003c/activity\u003e \u003cservice android:name=\".XXX\" /\u003e 此处.目录取决于上面package导入的目录 ","date":"2021-05-01","objectID":"/android-note/:5:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android TextView 文字居中 有2种方法可以设置TextView文字居中： 一：在xml文件设置：android:gravity=“center” 二：在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER); ","date":"2021-05-01","objectID":"/android-note/:6:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android给View设置上下左右边框 需求 设置view上下右有边框(左边不要边框)，右上角右下角需要设置为圆角（左边不需要） 实现 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003c!-- This is the main color --\u003e \u003citem\u003e \u003cshape\u003e \u003c!-- 边框颜色 --\u003e \u003csolid android:color=\"@color/flash_text_normal\"/\u003e \u003c/shape\u003e \u003c/item\u003e \u003c!-- 给View的上 下 右设置8dp的边框 --\u003e \u003c!-- http://blog.csdn.net/lowprofile_coding/article/details/47848245--\u003e \u003citem android:top=\"1dip\" android:bottom=\"1dip\" android:right=\"1dip\" \u003e \u003cshape\u003e \u003c!-- View填充颜色 --\u003e \u003csolid android:color=\"@color/public_round_yellow\" /\u003e \u003ccorners android:topRightRadius=\"@dimen/x10\" android:bottomRightRadius=\"@dimen/x10\" /\u003e \u003c/shape\u003e \u003c/item\u003e \u003c/layer-list\u003e ","date":"2021-05-01","objectID":"/android-note/:7:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"android 为TextView添加边框 今天需要在TextView上面添加一个边框，但是TextView本身不支持边框，所以只能采用其他方式，在网上查询了一下，主要有三种方式可以实现1.带有边框的透明图片2.使用xml的shape设置3继承TextView覆写onDraw方法。 ","date":"2021-05-01","objectID":"/android-note/:8:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法一 带有透明图片的背景图，这个没有什么好将的，自己制作一个就行 ，然后设置background就可以了 ","date":"2021-05-01","objectID":"/android-note/:8:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法二 通过shape来设置背景图片 首先一个textview_border.xml文件放在drawable文件夹里面 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" \u003e \u003csolid android:color=\"#ffffff\" /\u003e \u003cstroke android:width=\"1dip\" android:color=\"#4fa5d5\"/\u003e \u003c/shape\u003e 为要添加边框的TextView添加一个background android:background=\"@drawable/textview_border\" 效果图片如下: ","date":"2021-05-01","objectID":"/android-note/:8:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"方法三 编写一个继承TextView类的自定义组件，并在onDraw事件方法中画边框。 package com.example.test; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Canvas; import android.graphics.Paint; import android.util.AttributeSet; import android.widget.TextView; @SuppressLint(\"DrawAllocation\") public class BorderTextView extends TextView{ public BorderTextView(Context context) { super(context); } public BorderTextView(Context context, AttributeSet attrs) { super(context, attrs); } private int sroke_width = 1; @Override protected void onDraw(Canvas canvas) { Paint paint = new Paint(); // 将边框设为黑色 paint.setColor(android.graphics.Color.BLACK); // 画TextView的4个边 canvas.drawLine(0, 0, this.getWidth() - sroke_width, 0, paint); canvas.drawLine(0, 0, 0, this.getHeight() - sroke_width, paint); canvas.drawLine(this.getWidth() - sroke_width, 0, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); canvas.drawLine(0, this.getHeight() - sroke_width, this.getWidth() - sroke_width, this.getHeight() - sroke_width, paint); super.onDraw(canvas); } } 效果图如下: 使用的Xml布局内容如下: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cRelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" \u003e \u003cTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:background=\"@drawable/textview_border\" android:text=\"方法二\" android:textColor=\"#FF000000\" android:id=\"@+id/test\" android:gravity=\"center\" android:layout_alignParentTop=\"true\" android:layout_marginTop=\"20dp\" android:layout_centerHorizontal=\"true\"/\u003e \u003ccom.example.test.BorderTextView android:layout_width=\"120dp\" android:layout_height=\"80dp\" android:text=\"方法三\" android:id=\"@+id/test3\" android:gravity=\"center\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_centerHorizontal=\"true\"\u003e \u003c/com.example.test.BorderTextView\u003e \u003c/RelativeLayout\u003e ","date":"2021-05-01","objectID":"/android-note/:8:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"全局变量 切换Fragment时有些值需要保存，故需要一个全局变量进行保存 ​ 项目开发的过程中，可能会大量的使用全局变量，在android开发中，大多数人更偏向于使用application来保存全局变量。那么我们就先来了解下在android中，application究竟是什么？有什么作用？ 　Application类是用来维护应用程序全局状态。我们可以提供自己的实现，并在AndroidManifest.xml文件的标签中指出它的名字，这将导致在创建应用程序时去实例化我们自己的Application类。Android系统会为每个程序运行时创建一个Application类的对象且仅创建一个，所以Application可以说是单例模式的一个类。且Application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局唯一的，所以在不同的Activity,Service中获得的对象都是同一个对象。所以，通过Application来进行一些数据传递、数据共享、数据缓存等操作。 　首先创建继承自Application的MusicPlayerStatus类，定义变量update、current,并创建get和set方法。 import android.app.Application; public class MusicPlayerStatus extends Application { private int update=-1; private int current=-1; public int getUpdate() { return update; } public void setUpdate(int update) { this.update = update; } public int getCurrent() { return current; } public void setCurrent(int current) { this.current = current; } } 下面就是如何使用我们创建的全局变量了，在MainActivity中，首先要获得MusicPlayerStatus的对象，因为MusicPlayerStatus继承自Application，所以使用getApplication()方法即可，然后可以调用MusicPlayerStatus的get或set方法进行访问全局变量。 public MusicPlayerStatus musicPlayerStatus=new MusicPlayerStatus(); int update = musicPlayerStatus.getUpdate(); int current = musicPlayerStatus.getCurrent(); musicPlayerStatus.setUpdate(update); musicPlayerStatus.setCurrent(current); 注意，在使用MusicPlayerStatus之前需要修改AndroidManifest.xml文件的中的android:name = “.MusicPlayerStatus”，这样就不会访问系统提供的application，而访问我们自己创建的。 ","date":"2021-05-01","objectID":"/android-note/:9:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android 使控件各占屏幕的一半 在xml中将两个要占屏幕一半的控件都加上android:layout_weight=“1”； 注意：weight只能用在LinearLayout布局中。 在LinearLayout布局中weight数值越大显示的优先权就越低。 ","date":"2021-05-01","objectID":"/android-note/:10:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Fragment生命周期 相互切换时调用的方法 ","date":"2021-05-01","objectID":"/android-note/:11:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"一、前言： Fragment生命周期图如下： ","date":"2021-05-01","objectID":"/android-note/:11:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"二、Fragment 1 切换到 Fragment 2时生命周期变化 1. 通过 add hide show 方式来切换 Fragment Fragment1 的生命周期变化为：onCreate（）、onCreateView、onStart（）、onResume（） 回调 onHiddenChanged（） 方法 Fragment2 的生命周期变化为： onCreate（）、onCreateView、onStart（）、onResume（） Fragment 2 再次返回到 Fragment 1：不走任何生命周期方法但是回调 onHiddenChanged（）方法 总结：当以这种方式进行 Fragment 1 与 Fragment 2 的切换时，Fragment 隐藏的时候并不走 onDestroyView，所有的显示也不会走 onCreateView 方法，所有的 view 都会保存在内存。 2. 使用 replace 的方法进行切换时 载入Fragment 1时： Fragment 1的生命周期：onCreate（）、onCreateView（）、onStart（）、onResume（） 切换到Fragment2时： Fragment 1的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 2的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） Fragment 2切换回Fragment 1时： Fragment2的生命周期：onPause（）、onStop()、onDestroyView（）、onDestroy（） Fragment 1的生命周期：onCreate（）、onCreateV（）、onStart（）、onResume（） 总结：通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期。 3. 使用 ViewPager 进行切换时 当使用 ViewPager 与 Fragment 进行切换时，Fragment 会进行预加载操作 所有的 Fragment 都会提前初始—\u003e预加载； 初始化时 Fragment 们的生命周期： Fragment 1 的生命周期：onCreate（）、onCreateView（） Fragment 2 的生命周期：onCreate（）、 onCreateView（） Fragment 1 切换到 Fragment 2 的生命周期： Fragment 1 ：不走任何生命周期； Fragment 2 ：走 setUserVisVleHint（）方法 切回去也是一样的 注意： setUserVisVleHint（）方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法。 /** *第一个 Fragment 需要处理 setUserVisVleHint（）方法，设置为 setUserVisibleHint(true); *否则会产空指针异常，因为 setUserVisVleHint（）方法的优先级高于 onCreate（）方法。 * * @param savedInstanceState */ @Override public void onActivityCreated(Bundle savedInstanceState) { setUserVisibleHint(true); super.onActivityCreated(savedInstanceState); } /* 主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题。 setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。 此时要对是否调用了onCreateView（）方法进行标记判断。 */ ","date":"2021-05-01","objectID":"/android-note/:11:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"三、其它切换 1. Activity 切换到 Fragment 的生命周期变化 Fragment 的生命周期变化为：onStart（）、onResume（） 2. 从 Fragment 1 进行锁屏操作 Fragment 的生命周期方法：onPause（）、onSaveInstanceState（）、onStop（）。 3. 从解锁 到 Fragment 1 的生命周期 onStart（）、 onResume（） ","date":"2021-05-01","objectID":"/android-note/:11:3","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"简单实现ImageView宽度填满屏幕，高度自适应的两种方式 两种方式 ","date":"2021-05-01","objectID":"/android-note/:12:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"1.重写View的onMeasure方法 核心代码 protectedvoidonMeasure(intwidthMeasureSpec,intheightMeasureSpec){ Drawable d = getDrawable(); if(d!=null){ // ceil not round - avoid thin vertical gaps along the left/right edgesintwidth = MeasureSpec.getSize(widthMeasureSpec); //高度根据使得图片的宽度充满屏幕计算而得 intheight = (int) Math.ceil((float) width * (float) d.getIntrinsicHeight() / (float) d.getIntrinsicWidth()); setMeasuredDimension(width, height); }else{ super.onMeasure(widthMeasureSpec, heightMeasureSpec); } } ","date":"2021-05-01","objectID":"/android-note/:12:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"2.设置ImageView的属性： //宽度填满屏幕 android:layout_width=”match_parent” android:scaleType=”fitXY” android:layout_height=”wrap_content” //保持比例，一定要设置 android:adjustViewBounds=”true” ","date":"2021-05-01","objectID":"/android-note/:12:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android使用Bundle+Message+Hundle进行线程间通信 ","date":"2021-05-01","objectID":"/android-note/:13:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是java自带数据对象（常规八种数据结构） 接收线程 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : String str1 = msg.getData().getString(\"text1\");//接受msg传递过来的参数 String str2 = msg.getData().getString(\"text2\");//接受msg传递过来的参数 initFinishMainActivity(str1, str2); break; default : break; } } }; 发送线程 Message msg = new Message(); msg.what = MainActivity.CANSHU; Bundle bundle = new Bundle(); bundle.putString(\"text1\",\"大明的消息传递参数的例子！\"); //往Bundle中存放数据 bundle.putString(\"text2\",\"Time：2011-09-05\"); //往Bundle中put数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:1","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"数据是自定义对象时 自定义类 首先需要自定对象实现Serializable可序列化的接口，如下 public class Persion implements Serializable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 接收线程 getString等改为 public Handler mHandler=new Handler(){ public void handleMessage(Message msg) { switch(msg.what){ case CANSHU : Persion persion=(Persion)(msg.getData().getSerializable(\"persion\")); //接受msg传递过来的参数 initFinishMainActivity(persion); break; default: break; } } }; 发送线程 putString等改为putSerializable Message msg = new Message(); msg.what = MainActivity.CANSHU; Persion persion=new Persion(); String Name=\"zhangsan\"; persion.setName(Name); Bundle bundle = new Bundle(); bundle.putSerializable(\"persion\",persion); //往Bundle中存放数据 msg.setData(bundle);//mes利用Bundle传递数据 activity.mHandler.sendMessage(msg);//用activity中的handler发送消息 ","date":"2021-05-01","objectID":"/android-note/:13:2","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"Android历史版本平台、SDK、版本名称对照（争取持续更新） 平台版本 SDK版本 版本名称 12.0 31 Android 12（Snow Cone）（刨冰） 11.0 30 Red Velvet Cake（Quince Tart）(Android R)（11）（红丝绒蛋糕） 10.0 29 (Android Q)（10） 9.0 28 Pie (Android P)（派/馅饼） 8.1 27 Oreo(Android O)（奥利奥） 8.0 26 [Oreo(Android O)（奥利奥） 7.1 25 Nougat(Android N)（牛轧糖） 7.0 24 Nougat(Android N)（牛轧糖） 6.0 23 Marshmallow(Android M)（棉花糖） 5.1 22 Lollipop(Android L)（棒棒糖） 5.0 21 Lollipop(Android L)（棒棒糖） 4.4W 20 KITKAT Wear（奇巧巧克力） 4.4 19 [KITKAT（奇巧巧克力） 4.3 18 JELLY_BEAN_MR2（软心豆粒糖/果冻豆） 4.2 / 4.2.2 17 JELLY_BEAN_MR1（软心豆粒糖） 4.1 / 4.1.1 16 JELLY_BEAN（软心豆粒糖） 4.0.3 / 4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰淇淋三明治） 4.0 / 4.01 / 4.02 14 ICE_CREAM_SANDWICH（冰淇淋三明治） 3.2 13 HONEYCOMB_MR2（蜂巢） 3.1.X 12 HONEYCOMB_MR1（蜂巢） 3.0.X 11 HONEYCOMB（蜂巢） 2.3.3 / 2.3.4 10 GINGERBREAD_MR1（姜饼） 2.3 9 GINGERBREAD（姜饼） 2.2 / 2.2.1 8 Froyo（冻酸奶） 2.1 7 Eclair_MR2（闪电泡芙） 2.0.1 6 Eclair_MR1（闪电泡芙） 2.0 5 Eclair（闪电泡芙） 1.6 4 Donut（甜甜圈） 1.5 3 Cupcake（纸杯蛋糕） 1.1 2 Petit Four 1.0 1 Astro / Bender(1.0有两版) ","date":"2021-05-01","objectID":"/android-note/:14:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total","note"],"content":"end ","date":"2021-05-01","objectID":"/android-note/:15:0","tags":["Android","XMl","Kotlin","Service","Theme","layout","ConstraintLayout","Activity"],"title":"Android开发笔记","uri":"/android-note/"},{"categories":["Total"],"content":"详细解释Android中drawable和drawable-v24的区别","date":"2021-04-30","objectID":"/android-diff-drawable-v24/","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"今天调试一个软件，老是找不到资源 android.content.res.Resources$NotFoundException: Resource 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 断点调试可以看到是有的，当然项目的目录里面也有该资源， 最后找到原因是我将图片资源放到drawable-v24里面，导致7.0以下不能找到图片 不同的drawable文件夹用于为设备兼容性和不同的Android版本提供不同的屏幕密度。 7.0的关于图片资源的改变 从Android API 24（安卓7.0）开始，自定义Drawables类可以最终在XML中使用（仅在您的包中）。 8.0的关于图片资源的改变 API 26（安卓8.0）中添加了VectorDrawable自适应图标 更多解释 ","date":"2021-04-30","objectID":"/android-diff-drawable-v24/:0:0","tags":["Android","XML","drawable","drawable-v24","Difference"],"title":"关于drawable和drawable-v24","uri":"/android-diff-drawable-v24/"},{"categories":["Total"],"content":"Android应用使用Kolin开发，解决Kolin：A problem occurred evaluating project ':app'.","date":"2021-04-20","objectID":"/android-kolin/","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total"],"content":"报错 Build file 'C:\\All_Code\\AS_Code\\Bottom-Navigation\\Material-BottomNavigation\\app\\build.gradle' line: 2 A problem occurred evaluating project ':app'. \u003e java.lang.ExceptionInInitializerError (no error message) 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中发现原来的Kolin插件使用了$，我并未配置Kolin环境，因此找不到 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } 访问Gradle官网仓库，我修改为最新版本 dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.0-M2\" } 编译运行OK ","date":"2021-04-20","objectID":"/android-kolin/:0:0","tags":["Android","Kolin","Config","Error"],"title":"Kolin：A problem occurred evaluating project ':app'.","uri":"/android-kolin/"},{"categories":["Total"],"content":"解决Android App界面与顶部状态栏重叠遮盖问题的方法","date":"2021-03-22","objectID":"/android-topbar-cover/","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Total"],"content":"问题情况截图如下： 觉得toolbar默认高度太高，给toolbar设了一个固定值。测试时发现在4.4系统上会出现与状态栏重叠的现象。给toolbar设了个margin，但是在7.0的系统上又会出现间隙。最后发现只需要在父view里加上下面两行就解决了。 android:clipToPadding=“true” android:fitsSystemWindows=“true” 解释一下上面两个布局属性的意思： android:clipToPadding 定义布局间是否有间距 android:fitsSystemWindows=“true” 意思就是设置应用布局时是否考虑系统窗口布局；如果为true，将调整系统窗口布局以适应你自定义的布局。比如系统有状态栏，应用也有状态栏时。实际就是通过在 View 上设置和系统窗口一样高度的边框（padding）来确保你的内容不会出现到系统窗口下面。 或只 在layout的主布局中加入 android:fitsSystemWindows=“true” 如下： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\" tools:context=\".MainActivity\"\u003e \u003c!-- 布局内容...... --\u003e \u003c/LinearLayout\u003e ","date":"2021-03-22","objectID":"/android-topbar-cover/:0:0","tags":["Android","XML","LinearLayout","Bug"],"title":"Android App界面与顶部状态栏重叠遮盖问题","uri":"/android-topbar-cover/"},{"categories":["Environment"],"content":"解决AndroidStudio开发Android-Java应用的网络问题","date":"2021-03-15","objectID":"/android-net/","tags":["Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Environment"],"content":"android studio 教你修改Maven仓库地址为国内镜像 android studio 默认国外maven 这我们更改为阿里的maven 打开build.gradle 添加或者修改 allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } }修改buildscript { repositories { maven { url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter'} } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' } } 这里有阿里的仓库http://maven.aliyun.com/mvn/view`可以自行查看和替换，速度都比国外快 如图所示 ","date":"2021-03-15","objectID":"/android-net/:1:0","tags":["Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Environment"],"content":"Android Studio released aar to Jcenter, plug-in could not be found 导入项目控制台报错 Unknown host ‘raw.githubusercontent.com’. You may need to adjust the proxy settings in Gradle. 似乎raw.githubusercontent.com被dns污染了，使用站长工具ping改host做前置代理也无法访问，使用站长工具查ip改host也识别不到，甚至用了魔法，可能AS自己有网络通讯，使用代理依然无效。被迫使用下面的办法（其实可以直接删除，不影响项目运行，据说是文档文件）,该方法适用所有此域名导包问题 获取源码 有大佬上传到GitHub：installv1.gradle、bintrayv1.gradle，或者使用魔法，浏览器访问（我只使用了这一种办法成功访问了）网址获取 bintrayv1.gradle apply plugin: 'com.jfrog.bintray' version = libraryVersion if (project.hasProperty(\"android\")) { // Android libraries task sourcesJar(type: Jar) { classifier = 'sources' from android.sourceSets.main.java.srcDirs } task javadoc(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } } else { // Java libraries task sourcesJar(type: Jar, dependsOn: classes) { classifier = 'sources' from sourceSets.main.allSource } } task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir } artifacts { archives javadocJar archives sourcesJar } // Bintray Properties properties = new Properties() properties.load(project.rootProject.file('local.properties').newDataInputStream()) bintray { user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg { repo = bintrayRepo name = bintrayName desc = libraryDescription websiteUrl = siteUrl vcsUrl = gitUrl licenses = allLicenses publish = true publicDownloadNumbers = true version { desc = libraryDescription gpg { sign = true //Determines whether to GPG sign the files. The default is false passphrase = properties.getProperty(\"bintray.gpg.password\") //Optional. The passphrase for GPG signing' } } } } installv1.gradle apply plugin: 'com.github.dcendents.android-maven' group = publishedGroupId // Maven Group ID for the artifact install { repositories.mavenInstaller { // This generates POM.xml with proper parameters pom { project { packaging 'aar' groupId publishedGroupId artifactId artifact // Changed case // Add your description here name libraryName description libraryDescription url siteUrl // Set your license licenses { license { name licenseName url licenseUrl } } developers { developer { id developerId name developerName email developerEmail } } scm { connection gitUrl developerConnection gitUrl url siteUrl } } } } } 在项目中手动创建installv1.gradle、bintrayv1.gradle文件，我把他们放在项目目录下的library文件夹中，手动拷贝相关的源码 在项目根目录下的app目录（可能被改为项目名）下的build.gradle文件中修改原来的引用（注释或者删除） //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle' //apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle' apply from: \"../library/installv1.gradle\" apply from: \"../library/bintrayv1.gradle\" 重新build即可 ","date":"2021-03-15","objectID":"/android-net/:2:0","tags":["Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Environment"],"content":"end ","date":"2021-03-15","objectID":"/android-net/:3:0","tags":["Android","IDE","AndroidStudio","Java","Config","Error"],"title":"AndroidStudio网络问题","uri":"/android-net/"},{"categories":["Total"],"content":"在AndroidStudio中使用Java开发Android应用-版本更替不兼容报各种错误的修正","date":"2021-03-03","objectID":"/android-incompatible-version/","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"CardView、RecyclerView在buildTools28-\u003e30用法改变 Android开发 CardView卡片视图、RecyclerView回收视图 注意开发工具从28变为30以后即src目录下的bulid.grade文件中的buildTools版本改变 android { compileSdkVersion 28 buildToolsVersion \"28.0.0\" } android { compileSdkVersion 30 buildToolsVersion \"30.0.3\" } CardView、RecyclerView都发生了使用变化 引用： app目录下的bulid.grade文件中依赖dependencies改变 只要将implementation ‘com.android.support:cardview-v7:28.0.0’换成implementation ‘androidx.cardview:cardview’就行了（recyclerview类似改变）； 原因：版本28（面向android pie及以下版本）是遗留支持库的最后一个版本，因此我们建议您在使用android q并继续前进时迁移到androidx库。IDE可以帮助您：重构\u003e迁移到AndroidX…， dependencies { implementation 'com.android.support:cardview-v7:28.0.0' implementation 'com.android.support:recyclerview-v7:28.0.0' } dependencies { implementation \"androidx.cardview:cardview:1.0.0\" implementation \"androidx.recyclerview:recyclerview:1.1.0\" // For control over item selection of both touch and mouse driven selection implementation \"androidx.recyclerview:recyclerview-selection:1.1.0\" } 依赖请看官方文档Cardview、RecyclerView XML文件 主要是CardView、RecyclerView的标题 原来CardView \u003candroid.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_marginRight=\"5dp\" android:layout_marginTop=\"5dp\" android:elevation=\"5dp\" app:cardCornerRadius=\"5dp\"\u003e \u003c/android.support.v7.widget.CardView\u003e RecyclerView \u003candroid.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/android.support.v7.widget.RecyclerView\u003e 变为CardView‘ \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003candroidx.cardview.widget.CardView android:id=\"@+id/card_view\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\"\u003e \u003cTextView android:id=\"@+id/content1\" android:text=\"内容\" android:gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/\u003e \u003c/androidx.cardview.widget.CardView\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e RecyclerView’ \u003c!-- 你的可能是这样的--\u003e \u003candroid.support.v7.widget.RecyclerView \u003c!-- 这才是对的--\u003e \u003candroidx.recyclerview.widget.RecyclerView \u003c!-- xxx--\u003e \u003c!-- xxx--\u003e .../\u003e ","date":"2021-03-03","objectID":"/android-incompatible-version/:1:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Failed to find Build Tools revision 26.0.1 Error:A problem occurred configuring project ':app'. \\\u003e Failed to find Build Tools revision 26.0.1 在build.gradle 中buildToolsVersion 如何修改。看本地安装了哪些版本的 进入文件夹Android SDK 目录下build-tools，修改为里面有的版本 ","date":"2021-03-03","objectID":"/android-incompatible-version/:2:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find method google() for arguments [] on repository container. 问题： 在react native中安装realm数据库后运行react-native run-android 时报如下错： 开发环境： react-native:^0.55.4 reaml:^2.27.0 解决方案： 1、打开项目根目录下android/gradle/wrapper/gradle-wrapper.properties 将distributionUrl=https://services.gradle.org/distributions/gradle-2.14.1-all.zip中的2.14.1改成4.1 2、打开项目根目录下的android/build.gradle 1）、在buildscript和allprojects下的repositories分别添加google() 2）、将dependencies中的classpath ‘com.android.tools.build:gradle:2.2.3’中的2.2.3【具体看自己的是多少】改成3.0.1 重新运行编译项目命令，要下载新的gradle，这个过程有点慢。至此，问题已解决！ ","date":"2021-03-03","objectID":"/android-incompatible-version/:3:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not find com.android.support:appcompat-v7:25.0.0 老的Android工程导入as报错如下： 10:36 Gradle sync failed: Could not find com.android.support:appcompat-v7:25.0.0. Required by: FuNongTong:app:unspecified (18 s 207 ms) 如果是gradle4.0及以下，增加maven { url “https://maven.google.com” }，如下： buildscript { repositories { jcenter() maven { url \"https://maven.google.com\" } } dependencies { classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() maven { url \"https://maven.google.com\" } } } 如果是gradle4.0及以上，maven { url “https://maven.google.com” }替换为google() 如下： buildscript { repositories { jcenter() google() } } allprojects { repositories { jcenter() google() } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:4:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=M android studio升级到3.1.4之后gradle里的很多配置也相应发生了一些改变。在打包的时候我就遇到了这样的问题。 报错为：Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl. 截图如下： 大家可以注意看一下，AS升级到3.0以上版本后，截图上的红框处的代码都要改动，否则是无法正常打包的。那要改成什么样呢，如下图所示： 改成上图所示的样子就可以正常打包了，另外我也把代码贴出来方便大家复制。 //打包后应用名称 applicationVariants.all { variant -\u003e variant.outputs.all { output -\u003e def outputFile = output.outputFile def fileName if (outputFile != null \u0026\u0026 outputFile.name.endsWith('.apk')) { if (variant.buildType.name.equals('release')) {//如果是release包 fileName = \"anjian_release_v${defaultConfig.versionName}.apk\" } else if (variant.buildType.name.equals('debug')) {//如果是debug包 fileName = \"anjian_debug_v${defaultConfig.versionName}.apk\" } outputFileName = fileName } } } ","date":"2021-03-03","objectID":"/android-incompatible-version/:6:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"build.grade.dependence随版本引用关键字改变 // testCompile-\u003etestImplementation // compile-\u003eimplementation // provided-\u003ecompileOnly ","date":"2021-03-03","objectID":"/android-incompatible-version/:7:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use ‘annotationProce AS从2.3.3升级到3.0后，项目没有任何改动就出现了这个错误，解决步骤如下： 一、把module/build.gradle下的apt插件应用全部注释掉 二、把dependencies下的apt全部改为annotationProcessor annotationProcessor 在as最新版本也失效，要如下操作 annotationProcessor ‘org.projectlombok:lombok:1.18.6’ 修改为 compile ‘org.projectlombok:lombok:1.18.6’ 即可 三、把project/build.gradle中的apt插件声明注释 ","date":"2021-03-03","objectID":"/android-incompatible-version/:8:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"更新Gradle项目时报错Gradle sync failed: Unsupported method: BaseConfig.getApplicationIdSuffix 查看Android Gradle 插件版本说明。 https://developer.android.google.cn/studio/releases/gradle-plugin.html#updating-plugin 修改对应的项目根目录下的build.gradle的依赖（dependencies）下的gradle的build工具版本 dependencies {classpath \"com.android.tools.build:gradle:4.1.3\"} 和项目根目录下的gradle文件夹中的wrapper文件夹中的build.gradle文件中的gradle版本 distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip 注意：第一个文件要在原来jcenter（）位置加上google（） repositories{ google() jcenter()} ","date":"2021-03-03","objectID":"/android-incompatible-version/:9:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"Could not resolve all files for configuration ‘:app:debugRuntimeClasspath’. Could not find com.android.support:appcompat-v7:23.2.1. Searched in the following locations: repositories { google() maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'}//加上这行 //jcenter() } ","date":"2021-03-03","objectID":"/android-incompatible-version/:10:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Total"],"content":"end ","date":"2021-03-03","objectID":"/android-incompatible-version/:11:0","tags":["Android","Java","XML","Config","Version","Error"],"title":"Android-版本更替不兼容修正","uri":"/android-incompatible-version/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信实例讲解（通过获取对象，调用方法）","date":"2021-03-01","objectID":"/android-activity-fragment-connect/","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Back"],"content":"Activity与Fragment通信，Fragment之间互相通信 效果显现： 实现步骤： 1.创建MainActivity，FragmentA，FragmnetB在activity_main.xml中静态加载FragmentA，FragmnetB 2.在MainActivity中获取FragmentA对象，再用对象，调用FragmentA中的方法，实现Activity与Fragment通信之间的通信 3.在FragmentA中获取MainActivity的对象，在通过MainActivity的对象获取FragmnetB对象，最后调用FragmnetB中方法，实现Fragment之间互相通信。 代码实现： 1.创建FragmentA，FragmnetB和相应的布局，这里我就不多解释了： 1.a_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#d41313\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is a fragent\" android:gravity=\"center\"/\u003e \u003cTextView android:id=\"@+id/a_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:text=\"show text\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/a_frag_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/a_frag_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentB\"/\u003e \u003c/LinearLayout\u003e 2.FragmentA： public class FragmentA extends Fragment { private TextView showTv; private EditText toBEt; private Button toBBtn; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.a_fragment, container, false); bindID(view); return view; } private void bindID(View view) { showTv = view.findViewById(R.id.a_frag_tv); toBEt = view.findViewById(R.id.a_frag_et); toBBtn = view.findViewById(R.id.a_frag_btn); } } 3.b_fragment.xml： \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:background=\"#3dd526\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"this is b fragment\" android:textColor=\"#fff\" android:background=\"#000\" android:textSize=\"25sp\"/\u003e \u003cTextView android:id=\"@+id/b_frag_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"show text\" android:textSize=\"25sp\"/\u003e \u003c/LinearLayout\u003e 4.FragmentB： public class FragmentB extends Fragment { private TextView showTv; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.b_fragment,container,false); showTv = view.findViewById(R.id.b_frag_tv); return view; } } 2.在activity_main.xml中加载之前的两个碎片： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\" tools:context=\"com.example.communicationfragment.MainActivity\"\u003e \u003cLinearLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:layout_weight=\"1\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:background=\"#000\" android:textColor=\"#fff\" android:text=\" this is Activity\" android:gravity=\"center\"/\u003e \u003cEditText android:id=\"@+id/main_to_a_et\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cButton android:id=\"@+id/main_to_a_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textAllCaps=\"false\" android:text=\"send to FragmentA\"/\u003e \u003c/LinearLayout\u003e \u003cFrameLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\"\u003e \u003cfragmen","date":"2021-03-01","objectID":"/android-activity-fragment-connect/:1:0","tags":["Android","Java","Activity","Fragment"],"title":"Activity与Fragment通信，Fragment之间互相通信","uri":"/android-activity-fragment-connect/"},{"categories":["Total","note"],"content":"Android Studio 开发Android App时需要修改项目名称和包名方法","date":"2021-02-28","objectID":"/androidstudio-rename/","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":" 平时项目开发中，有时候维护项目多，有的项目结构需要改变，这就需要我们去修改项目名称或者修改包名。下面介绍一下怎样修改项目名称和包名。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:0:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"1. 修改项目名称 1）打开项目根目录下的setting.gradle文件，修改该文件中的rootProject.name='新项目名'； 2）点击 Sync Now 重新编译项目； ★ 如果只是简单修改至此，会发现项目名称后依然备注着旧项目名，并没有彻底更换新的项目名。紧接着下面操作： 3）关闭 Android Studio； 4）修改项目所在路径的文件名为新的项目名； 5）打开AS，重新导入修改后的项目即可； ★ 如果是 AS 4.0之后 的版本，修改至此就算修改完成；如果是 AS 4.0之前 的版本，会出现一些配置文件信息还是引用原来的项目名，并没有更换为新的项目名。紧接着下面操作： 6）找到项目根目录下的xx.iml文件，右键 Refactor —— Rename 打开修改编辑框； 7）输入新的项目名，点击 Refactor 修改； 8）打开项目根目录下的xx.iml文件，修改该文件中的project.id字段：external.linked.project.id=\"新项目名\" 9）打开项目下.idea/modules.xml文件，修改该文件中的fileurl和filepath字段：\u003cmodule fileurl=\"file://$PROJECT_DIR$/新项目名.iml\" filepath=\"$PROJECT_DIR$/新项目名.iml\" /\u003e 10）点击 Rebuild Project 重构项目，即可修改完成项目名称。 ","date":"2021-02-28","objectID":"/androidstudio-rename/:1:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total","note"],"content":"2. 修改项目包名 1）选中项目中药修改的包名； 2）更改项目结构显示方式，取消 Compact Middle Packages 选项； 3）右键要修改的包名，选择 Refactor —— Rename 打开修改编辑框； 4）点击 Rename package 修改包名； 5）输入新的包名，点击 Refactor 修改； 6）点击 Do Refactor 确定修改； 7）打开项目 app/main 目录下的AndroidManifest.xml文件，修改该文件中的package=\"新包名\"字段； 8）修改项目 app 下的 build.gradle 中的applicationId \"新包名\"字段； 9）点击 Sync Now 同步，即可修改完成项目包名。 注意： 修改完包名，项目出现错误无法运行，解决方法请移步 —— 《Android Studio修改包名导致引用R文件报错问题》 ","date":"2021-02-28","objectID":"/androidstudio-rename/:2:0","tags":["Android","IDE","AndroidStudio","Project","Config"],"title":"Android Studio 修改项目名称和包名方法","uri":"/androidstudio-rename/"},{"categories":["Total"],"content":"Android Studio 导入图片标红,记录图片文件命名规则","date":"2021-02-09","objectID":"/androidstudio-picture-error/","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":" as图片不能使用\"-\"，只能使用\"_“代替 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:0:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况一 直接修改会直接提示不能带有”-\" ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:1:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"情况二 在系统资源管理器中拷贝进带\"-“的文件名的图片，标红报错 ","date":"2021-02-09","objectID":"/androidstudio-picture-error/:2:0","tags":["Android","IDE","AndroidStudio","File","Error"],"title":"Android Studio 导入图片标红","uri":"/androidstudio-picture-error/"},{"categories":["Total"],"content":"记录findViewById返回null的常见原因和解决办法","date":"2021-02-01","objectID":"/android-findviewbyid-null/","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["Total"],"content":"1.在另一个view的元素应该用baseView.findViewById()来拿 findViewById()是要指定view的，也就是说你要找的view 必须是包含在baseView里面的布局（控件） 如果在该父控件下找不到，就会报null。 2.findViewById在setContentView(R.layout.main);之前.即在setContentView调用之前，view要从父类布局里面找，父类布局还没有加载之前找，必然会返回空。 3.写的该布局（控件） ，还没有保存，导致工具不能加载到。自然也是null； 4.工具出现异常，这就是很偶然的情况，一般clean、重启 ","date":"2021-02-01","objectID":"/android-findviewbyid-null/:0:0","tags":["Android","Java","XML","layout","view","Error"],"title":"findViewById返回null的常见原因","uri":"/android-findviewbyid-null/"},{"categories":["documentation","note"],"content":"Hogo使用CodeIT主题并配置Algolia作为站内搜索","date":"2021-01-10","objectID":"/hugo-algolia/","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置，以中文配置作为示例 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"KKKPJSKEY's-Case-Archives\" appID = \"algolia.com.API Keys.Application ID\" searchKey = \"algolia.com.API Keys.Admin API Key\" ","date":"2021-01-10","objectID":"/hugo-algolia/:1:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2 Algolia 配置 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “example”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.2 我这里选择香港作为存储地区 查看自己的网速 选择网速较快的地区 点击下一步 勾选 勾选 点击创建 我就跳过新手教程了 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-01-10","objectID":"/hugo-algolia/:2:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面（见2.1） ","date":"2021-01-10","objectID":"/hugo-algolia/:2:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.2 安装 atomic-algolia（在任意目录下） npm -g install atomic-algolia --save ","date":"2021-01-10","objectID":"/hugo-algolia/:3:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.3 创建 .env 文件存放 algolia 配置（在网站根目录下） ALGOLIA_APP_ID=\"algolia.com.API Keys.Application ID\" ALGOLIA_ADMIN_KEY=\"algolia.com.API Keys.Admin API Key\" ALGOLIA_INDEX_NAME=\"example\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-01-10","objectID":"/hugo-algolia/:3:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.4 修改网站根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-01-10","objectID":"/hugo-algolia/:3:4","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-01-10","objectID":"/hugo-algolia/:3:5","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.脚本 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.1定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 ","date":"2021-01-10","objectID":"/hugo-algolia/:4:1","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.2我的脚本 分析可知仅上传流程中需要两步顺序操作，其他调试普通指令一步基本可以解决，故略去其他脚本，仅使用生成索引并上传，将GitHub Pages上传至Github仓库两步操作脚本 update.sh #!/bin/sh # If a command fails then the deploy stops set -e update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull origin master # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push origin master fi } update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:2","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"4.3我的最新脚本 脚本顺序弄错，应该先生成Hugo页面，再生成algolia 索引，最后将页面推上去就行 update.sh #!/bin/sh # If a command fails then the deploy stops set -e generate_pages(){ hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m已经重新生成 hugo 页面！！！\\033[0m\\n\" } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia 索引！！！\\033[0m\\n\" sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/KKKPJSKEY/KKKPJSKEY.github.io/\"\\033[0m\\n\" # Build the project. # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" #param num \u003e 1 if [ \"$#\" -gt 1 ]; then printf \"参数个数错误,只能传一个参数为提交的信息！\" exit 0 else git commit -m \"$1\" # Push source and build repos. git push fi } generate_pages update_algolia push_public $* ","date":"2021-01-10","objectID":"/hugo-algolia/:4:3","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"5结果 仓库代码检验： algolia 的索引: ","date":"2021-01-10","objectID":"/hugo-algolia/:5:0","tags":["Blog","Hugo","Search","Algolia","CodeIT","Config"],"title":"Hogo配置Algolia","uri":"/hugo-algolia/"},{"categories":["documentation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2021-01-01","objectID":"/hugo-github/","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"近些年GoLang语言逐渐火爆起来，Golang语言所做的静态博客固然也映入眼帘。相比于动态博客，静态博客的好处不言而喻，开发难度极低，不需要后台和数据库，更不需要昂贵的服务器成本和花费运维成本去维护。应老师要求以及个人未来发展，故学习静态博客的部署(补充，最近挖矿潮，比特币价格上涨，对于我等穷人，服务器的开销还是能省一点是一点)。本文因此介绍hugo和GitHub.io的初次使用搭建个人博客 ","date":"2021-01-01","objectID":"/hugo-github/:0:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1 本地部署blog ","date":"2021-01-01","objectID":"/hugo-github/:1:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.1 快速开始 1.1.1、安装方法介绍 hugo_GitHub:https://github.com/gohugoio/hugo Official_Website:https://gohugo.io/ 不同的操作系统有着不同的安装方式，官方推荐Linux或者Mac下可以使用brew或者port 进行安装Windows推荐使用Chocolatey或者Scoop进行安装，或者使用GitHub中的源码进行安装，我选择GitHub的Relaeases包进行安装，因为它不需要其他包管理工具进行安装。其他安装方式请参阅官方安装文档 https://gohugo.io/getting-started/installing 可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或csdn相关加速服务~~，甚至孙悟空的魔法~~ git clone [ssh address][http address] #示例 git clone git@github.com:gohugoio/hugo.git #SSH #或者 git clone https://github.com/gohugoio/hugo.git #HTTP 1.1.2、我的办法 https://github.com/gohugoio/hugo/releases此链接选择最新版，选择对应系统版本下载即可（我的是windows） 下载后进行解压只有三个文件，个人将hugo.exe文件放入bin目录，将网站问建放入sites目录，其他文件放在根目录 在当前目录执行（未配置环境变量） 任意处执行（配置环境变量） cd bin hugo version 单击环境变量（1），创建HOGO_HOME（2），填写路径（3），在原来Path下（4）添加bin目录（5） 执行命令后有类似返回结果（6）说明安装hugo成功（在系统环境变量中（Windows可以在Cotana直接搜索环境变量）） ","date":"2021-01-01","objectID":"/hugo-github/:1:1","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.2 创建网站 #返回上一级目录下的网站目录 cd ../sites hugo new site [site nme] #示例 hugo new site KKKPJSKEY's-Case-Archives ","date":"2021-01-01","objectID":"/hugo-github/:1:2","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.3 选择主题 在https://themes.gohugo.io/这个网址选择你喜欢的主题 https://themes.gohugo.io/material-design/这是我的选择 点击download进入对应的GitHub页面，可以使用Git工具进行下载源码，或者使用GitHub自带的Donwload Zip进行下载速度慢的话考虑码云转移仓库加速或Csdn相关加速服务~~，甚至孙悟空的魔法~~ #切换到新建的网站目录下 cd KKKPJSKEY's-Case-Archives git clone [ssh address][http address] #示例 git clone git@github.com:pdevty/material-design.git themes/material-design #SSH #或者 git clone https://github.com/pdevty/material-design.git themes/material-design #HTTP （自行下载的压缩请手动解压到theme目录） ","date":"2021-01-01","objectID":"/hugo-github/:1:3","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.4 配置主题 1.4.1、metadata 请将主题目录（1）下的默认配置文件（2）中的内容（3）与网站目录（4）下的默认配置文件（5）中的内容（6）进行整合，以网站目录下的默认配置文件为准，最终成河成（7）的样子即可 1.4.2、其他配置 将根目录（1）下的config.toml文件（2）中的内容改为自己网站的内容（3） 我个人主题配置如上图所示，其他配置请自行参照主题文档进行配置 ","date":"2021-01-01","objectID":"/hugo-github/:1:4","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.5 生成模板MarkDown（带有metadata） 注意metadata中不能使用英文的双引号,可以使用英文单引号或者中文单双引号代替 hugo new [类别]/[文件名] #示例 hugo new blog/使用hugo、GitHub.io搭建个人静态博客.md 执行以上指令即可在以下路径生成对应的文件content/类别/文件名（生成一次后也可手动在content/类别/文件名创建文件，手动拷贝对应的metadata）（这里没有切换路径，但必须在网站根目录下进行） ","date":"2021-01-01","objectID":"/hugo-github/:1:5","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.6编写MarkDown 项目中其他请参照MarkDown语法规范，其中图片需要注意：图片应放到网站根目录下的static中。我为了国立不同静态资源，创建了imags和文章名两级文件夹，图片在MarkDown中应使用，同时使用顺斜杠替换原来反斜杠， /[分类名]/[项目名]/图片名.格式 #个人分类法，非强制要求 #示例 ./1.png 同时使用顺斜杠替换原来反斜杠， ","date":"2021-01-01","objectID":"/hugo-github/:1:6","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"1.7 本地预览与部署 1.7.1、本地预览 hugo server [-D]（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 22 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 8 Sitemaps | 1 Cleaned | 0 Built in 52 ms Watching for changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Program_Green\\hugo_extended_0.82.0_Windows-64bit\\sites\\KKKPJSKEY's-Case-Archives\\config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 执行后在http://localhost:1313/可以进行访问（-D参数表示无论metadata（1.4.1）是否为true都进行发布，不加参数则只发布为false的项目，下面huge生成静态文件相同） 1.7.2、生成静态文件用于发布 使用hugo [-D]生成静态文件，-D参数在1.6.1介绍的功能相同（这里没有切换路径，但必须在网站根目录下进行） Start building sites … | EN -------------------+----- Pages | 15 Paginator pages | 0 Non-page files | 9 Static files | 33 Processed images | 0 Aliases | 5s Sitemaps | 1 Cleaned | 0 Total in 167 ms 以上结果会在网站根目录下的public下生成静态页面 ","date":"2021-01-01","objectID":"/hugo-github/:1:7","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"2 GitHub创建仓库 来到GitHub主页https://github.com/（自行注册登录） 点击左上角新建仓库 输入自己的仓库名（1，我已经创建过不能使用相同的名字因此报错，仓库名没有格式限制，请自行发挥），设置仓库分类（2，公有是所有人能看到，私有是只有项目内成员能看到），点击创建即可（3） ","date":"2021-01-01","objectID":"/hugo-github/:2:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"3 使用Git提交生成的静态页面（1.6.2） #切换到网站名字下的public下 cd public #以下为git指令 ##git 初始化 git init ##添加当前目录下的所有文件到暂存区 git add [.][-u][-A][-all] ##提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息 git commit [-m \"{message}\"] ##从将本地的分支版本上传到远程并合并。 git push 详细Git教程、参数解释在Git笔记（填坑，挖新坑）中，请移步 ","date":"2021-01-01","objectID":"/hugo-github/:3:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"4在GitHub中进行页面展示设置 在你的仓库页面点击Settings（1），在新的页面向下滑动找到GitHub Pages下的Branch（2），选择master（3，或自己的分支），在对应的网址即可访问（4） ","date":"2021-01-01","objectID":"/hugo-github/:4:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["documentation","note"],"content":"5 结语 至此使用hugo、Github.io搭建个人静态博客彻底完成 ","date":"2021-01-01","objectID":"/hugo-github/:5:0","tags":["Blog","Hugo","Markdown","Git","GitHub","Repository","Commit","GitHubPages","CodeIt","Config"],"title":"Hogo创建GitHub Pages","uri":"/hugo-github/"},{"categories":["Operation","note"],"content":"记录Docker常用指令的笔记","date":"2020-12-21","objectID":"/docker-command-note/","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"容器管理指令 # 进入docker容器内部 docker exec -it id /bash/bin # 退出容器 exit # 启动docker容器 sudo systemctl start docker # 设置docker容器开机启动 sudo systemctl enable docker ","date":"2020-12-21","objectID":"/docker-command-note/:1:0","tags":["Linux","CentOS7","Docker"],"title":"Docker常用指令","uri":"/docker-command-note/"},{"categories":["Operation","note"],"content":"记录CentOS7 查询的几种方式和区别解释","date":"2020-12-12","objectID":"/cnetos7-shell-search/","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"1. find 　Java代码 　find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。与查询数据库（/var/lib/locatedb）文件不同，find查找磁盘空间 　find的使用格式如下： $ find \u003c指定目录\u003e \u003c指定条件\u003e \u003c指定动作\u003e 　- \u003c指定目录\u003e: 所要搜索的目录及其所有子目录。默认为当前目录。 　- \u003c指定条件\u003e: 所要搜索的文件的特征。 　- \u003c指定动作\u003e: 对搜索结果进行特定的处理。 　如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。 　find的使用实例： $ find . -name 'my*' 　搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 $ find . -name 'my*' -ls 　搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。 $ find . -type f -mmin -10 　搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。 根据文件名查询 find -name [文件名] 根据文件夹名查询 find [文件夹名] ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:1:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"2. locate 　Java代码 　locate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 　locate命令的使用实例： $ locate /etc/sh 　搜索etc目录下所有以sh开头的文件。 $ locate ~/m 　搜索用户主目录下，所有以m开头的文件。 $ locate -i ~/m 　搜索用户主目录下，所有以m开头的文件，并且忽略大小写。 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:2:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"3. whereis 　Java代码 　whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。同locate一样，查询数据库（/var/lib/locatedb）文件 　whereis命令的使用实例： $ whereis grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:3:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"4. which 　Java代码 　which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 　which命令的使用实例： $ which grep ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:4:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"5. type 　Java代码 　type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 　type命令的使用实例： $ type cd 　系统会提示，cd是shell的自带命令（build-in）。 $ type grep 　系统会提示，grep是一个外部命令，并显示该命令的路径。 $ type -p grep 　加上-p参数后，就相当于which命令 ","date":"2020-12-12","objectID":"/cnetos7-shell-search/:5:0","tags":["Linux","CentOS7","Search"],"title":"CentOS7 查询的几种方式","uri":"/cnetos7-shell-search/"},{"categories":["Operation","note"],"content":"Linux的CentOS7 中对文件权限管理的指令笔记","date":"2020-11-27","objectID":"/centos7-file-auth/","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件权限管理","uri":"/centos7-file-auth/"},{"categories":["Operation","note"],"content":"修改文件权限和群组 sudo chmod -R 777 etc(文件名|文件夹名) # -R 要大写，代表递归作用，文件夹下所有子目录权限一致 修改组群的命令使chgrp，即change group，那么修改文件拥有者的命令自然就是chown，即change owner。chown功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数。 语法如下： chown [-R]** #**账号名称** **文件****/****目录 chown [-R]** # **账号名称**:**组群** **文件****/****目录** ","date":"2020-11-27","objectID":"/centos7-file-auth/:1:0","tags":["Linux","CentOS7","File"],"title":"CentOS7 文件权限管理","uri":"/centos7-file-auth/"},{"categories":["Operation","note"],"content":"在Linux和Windows环境中为Git配置生成公私密钥","date":"2020-11-02","objectID":"/git-ssh-key/","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"Windows 在Windows下查看**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]**下是否有*“id_rsa、id_rsa.pub”*文件，如果没有需要从第一步开始手动生成,有的话直接跳到第二步。 ","date":"2020-11-02","objectID":"/git-ssh-key/:1:0","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"第1步：创建SSH Key 打开Git Bash，在控制台中输入以下命令: $ ssh-keygen -t rsa -C “youremail@example.com” 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行,当然，如果不想要这些可以直接输入： $ ssh-keygen 我一般就是这么做的。 输入完毕后按回车，程序会要求输入一个密码，输入完密码后按回车会要求再确认一次密码，如果不想要密码可以在要求输入密码的时候按两次回车，表示密码为空，并且确认密码为空，此时**[c盘\u003e用户\u003e自己的用户名\u003e.ssh]**目录下已经生成好了。 ","date":"2020-11-02","objectID":"/git-ssh-key/:1:1","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"第2步：将SSH添加到版本管理仓库 不同的版本管理代码仓库都大同小异，这里以Github举例，登录Github。打开setting-\u003eSSH keys，点击右上角 New SSH key，把**[c盘-\u003e用户-\u003e自己的用户名-\u003e.ssh]**目录下生成好的公钥*“id_rsa.pub”*文件以文本打开复制放进 key输入框中，再为当前的key起一个title来区分每个key ","date":"2020-11-02","objectID":"/git-ssh-key/:1:2","tags":["Git","SSH","Key"],"title":"Git生成公私密钥","uri":"/git-ssh-key/"},{"categories":["Operation","note"],"content":"记录CentOS7 防火墙操作指令笔记","date":"2020-10-10","objectID":"/cnetos7-firewall/","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":" #防火墙端口列表 firewall-cmd --list-port #添加规则 firewall-cmd --zone=public --add-port=80/tcp --permanent #重启防火墙 systemctl restart firewalld.service #移除端口: firewall-cmd --zone=public --remove-port=80/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #多个端口: firewall-cmd --zone=public --add-port=80-90/tcp --permanent #删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent #centos7启动防火墙 systemctl start firewalld.service #centos7停止防火墙/关闭防火墙 systemctl stop firewalld.service #centos7重启防火墙 systemctl restart firewalld.service #设置开机启用防火墙 systemctl enable firewalld.service #设置开机不启动防火墙 systemctl disable firewalld.service # 开启端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 命令含义： # --zone #作用域 # --add-port=80/tcp #添加端口，格式为：端口/通讯协议 # --permanent #永久生效，没有此参数重启后失效 # 重启防火墙 firewall-cmd --reload #常用命令介绍 firewall-cmd --state ##查看防火墙状态，是否是running firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd --get-zones ##列出支持的zone firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd --add-service=ftp ##临时开放ftp服务 firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务 firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务 firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 # 更多命令，使用 firewall-cmd --help # 查看帮助文件 #\u003e\u003e\u003eCentOS 7默认使用的是firewall作为防火墙，使用iptables必须重新设置下 #直接关闭防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 # 设置 iptables service yum -y install iptables-services # 如果要修改防火墙配置，如增加防火墙端口3306 vi /etc/sysconfig/iptables # 增加规则 # -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 保存退出后 systemctl restart iptables.service #重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 # 最后重启系统使设置生效即可。 # 查询端口号80 是否开启： firewall-cmd --query-port=80/tcp ","date":"2020-10-10","objectID":"/cnetos7-firewall/:0:0","tags":["Linux","CentOS7","Firewall"],"title":"CentOS7 防火墙操作指令","uri":"/cnetos7-firewall/"},{"categories":["Operation","note"],"content":"记录CentOS7 端口管理指令的笔记","date":"2020-10-02","objectID":"/centos-port/","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation","note"],"content":" lsof -i tcp:80 # 查看80端口占用情况 netstat -ntlp # 列出所有端口 ","date":"2020-10-02","objectID":"/centos-port/:0:0","tags":["Linux","CentOS7","Port"],"title":"CentOS7 端口管理指令","uri":"/centos-port/"},{"categories":["Operation"],"content":"解决 CentOS7下 javac:未找到命令 问题 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"问题描述： 在linux下编译java程序，执行javac编译生成class文件时，在centos7终端输入如，javac hello.java 会提示未找到指令，但用java -verison测试环境变量是没问题的。 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:1:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"尝试解决： 重新再linux配置环境变量，输入 vi /etc/profile进入，添加以下代码： export JAVA_HOME=/usr/local/jdk1.8.0_144 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:2:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation"],"content":"再测试，最后也没有成功 后来在stackoverflow上看到了这个 84 down vote accepted You installed the Java Runtime Environment (JRE) only, which does not contain javac. For javac, you have to install the OpenJDK Development Environment. You can install java-devel or java-1.6.0-openjdk-devel, which both include javac. By the way: you can find out which package provides javac with a yum search, e.g. su -c ‘yum provides javac’ Another note: using yum and openjdk is only one possibility to install the JDK. Many people prefer Sun/Oracle’s “original” SDK. See How to install Java SDK on CentOS? and links for alternatives. 大意就是我们用yum来装原生的就行了 在终端输入 yum install java-devel 执行安装，再测试就行了 补充：Vi编辑常用快捷键 复制：ctrl+insert 粘贴：shift+insert 按Esc保存退出编译，shift+zz退出 ","date":"2020-09-12","objectID":"/centos7-javac-command-not-find/:3:0","tags":["Linux","CentOS7","Java","Error"],"title":"CentOS7下 javac:未找到命令","uri":"/centos7-javac-command-not-find/"},{"categories":["Operation","note"],"content":"记录CentOS7 管理MariaDB指令的笔记","date":"2020-09-09","objectID":"/centos7-mariadb/","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"基本管理指令 systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 ","date":"2020-09-09","objectID":"/centos7-mariadb/:1:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation","note"],"content":"连接数据库报错Too Many Connectionsbaocuo 重启数据库即可 ","date":"2020-09-09","objectID":"/centos7-mariadb/:2:0","tags":["Linux","CentOS7","MariaDB","DataBase"],"title":"CentOS7 管理MariaDB指令","uri":"/centos7-mariadb/"},{"categories":["Operation"],"content":"修改Tomcat配置文件导致Tomcat部署Jstl项目报错","date":"2020-08-30","objectID":"/tomcat-jstl-error/","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"问题来源 原Tomcat启动有一条警告，由于看着不爽就查了办法去掉了 办法是修改Tomcat根目录下的conf文件夹下的catalina.properties文件（我这个版本的Tomcat大概在110行） apache-tomcat-9.0.41\\conf\\catalina.properties 改成如下图的样子，报错就消失了 改的时候还很年轻，并不知道自己改了什么，觉得还不错，于是天坑就挖好了 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:1:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"翻车 后面跟着老师开发jsp的时候使用了jstl，然后就死活报错 四处百度无果，向老师求助，老师怀疑是未正确导包，加上我正使用最新版idea，没有j2ee创建web项目了，只能创建普通项目，进入后在添加web模块，加深了老师怀疑导包问题。 期间曾将tld文件直接解压出来使用，被老师喊停，并劝我用maven，我于是转普通j2ee项目为Maven的Web项目，结果肯定问题没解决。 后有尝试创建普通Maven项目，再加入Web组件，依然没解决。 后由于课程时间有限，老师放弃了我。 不甘心，只能解压出tld文件直接使用，熬夜追赶任务进度 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:2:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"解决 项目部署时，同学没有服务器，委托我进行部署，巧妙的发现同学的项目在我这也有问题，将我的代码发给同学，同学可以运行。同时发现部署在服务器上没有任何问题，故深刻怀疑Tomcat的问题。 经过这个思路的稍作搜索，下载了新的tomcat，发现警告，想起了我对Tomcat配置文件下手的事情，所以恢复修改 系统顺利运行！！！问题终于解决。鬼问题纠结了我许久 ","date":"2020-08-30","objectID":"/tomcat-jstl-error/:3:0","tags":["Operation","Jsp","Jstl","Config"],"title":"Tomcat部署Jstl项目报错","uri":"/tomcat-jstl-error/"},{"categories":["Operation"],"content":"云服务器安装软件（端口）连接失败解决办法,附各种常用默认端口","date":"2020-08-20","objectID":"/server-port-cant-connect/","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Operation"],"content":" 服务器需要进行控制面板对服务器端口进行放行如3306、8080 软件 默认、常用端口 协议 HTTP协议代理服务器 80/8080/3128/8081/9080 HTTP SOCKS代理协议服务器 1080 FTP（文件传输）协议代理服务器 21 Telnet（远程登录）协议代理服务器 23 HTTP服务器，默认的端口号（木马Executor开放此端口） 80 tcp HTTPS（securely transferring web pages）服务器 443 tcp /udp Telnet（不安全的文本传送）（木马Tiny Telnet Server所开放的端口） 23 tcp FTP（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）； 21 tcp TFTP（Trivial File Transfer Protocol ） 69 udp SSH（安全登录）、SCP（文件传输）、端口重定向， 22 tcp SMTP Simple Mail Transfer Protocol (E-mail)，（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）； 25 tcp POP3 Post Office Protocol (E-mail) 110 tcp WebLogic 7001 WebSphere应用程序 9080 WebSphere管理工具 9090 JBOSS 8080 TOMCAT 8080 WIN2003远程登陆 3389 Symantec AV/Filter for MSE 8081 Mysql数据库 3306 Oracle 数据库 1521 ORACLE EMCTL 1158 Oracle XDB（ XML 数据库） 8080 Oracle XDB FTP服务 2100 MS SQL SERVER数据库server 1433 tcp /udp MS SQL*SERVER数据库monitor 1434 tcp /udp QQ 1080 udp ","date":"2020-08-20","objectID":"/server-port-cant-connect/:0:0","tags":["Port","Error"],"title":"云服务器安装软件（端口）连接失败","uri":"/server-port-cant-connect/"},{"categories":["Environment","note"],"content":"两种VScode代码行检测插件，支持多种语言","date":"2020-07-28","objectID":"/vscode-count-line/","tags":["Editor","VScode","Plugin","Code-Line"],"title":"VScode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Environment","note"],"content":"VScode Counter 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:0","tags":["Editor","VScode","Plugin","Code-Line"],"title":"VScode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Environment","note"],"content":"使用 ctrl + shift +p，输入counter，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:1:1","tags":["Editor","VScode","Plugin","Code-Line"],"title":"VScode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Environment","note"],"content":"loc 搜索并安装即可 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:0","tags":["Editor","VScode","Plugin","Code-Line"],"title":"VScode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Environment","note"],"content":"使用 ctrl + shift +p，输入LineCount，即可使用 ","date":"2020-07-28","objectID":"/vscode-count-line/:2:1","tags":["Editor","VScode","Plugin","Code-Line"],"title":"VScode代码行的统计插件","uri":"/vscode-count-line/"},{"categories":["Operation","note"],"content":"记录CentOS7 查看系统参数指令","date":"2020-07-01","objectID":"/centos7-version/","tags":["Linux","CentOS7","System"],"title":"CentOS7  查看系统参数","uri":"/centos7-version/"},{"categories":["Operation","note"],"content":"CentOS7 查看系统版本 cat /etc/redhat-release ","date":"2020-07-01","objectID":"/centos7-version/:1:0","tags":["Linux","CentOS7","System"],"title":"CentOS7  查看系统参数","uri":"/centos7-version/"},{"categories":["Operation"],"content":"分析/bin、/usr/bin、/sbin、/usr/sbin的主要区别","date":"2020-06-15","objectID":"/linux-bin-sbin/","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":" /bin: bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。 /usr/bin:主 要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。 /sbin: 主 要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。 /usr/sbin:放置一些网路管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。 ","date":"2020-06-15","objectID":"/linux-bin-sbin/:0:0","tags":["Linux","File","bin","Difference"],"title":"/bin、/usr/bin、/sbin、/usr/sbin的主要区别","uri":"/linux-bin-sbin/"},{"categories":["Operation"],"content":"项目中途添加.gitignore不生效的办法","date":"2020-06-03","objectID":"/git-mid-gitignore/","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法一 # 清除 缓存区 git rm -r --cached . # 再执行正常的提交流程即可 # 我的 gitignore **/*.md ","date":"2020-06-03","objectID":"/git-mid-gitignore/:1:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation"],"content":"方法二 删除.git文件，重新执行 # 初始化 git init 即可 ","date":"2020-06-03","objectID":"/git-mid-gitignore/:2:0","tags":["Git","gitignore","Bug"],"title":"项目中途添加.gitignore不生效","uri":"/git-mid-gitignore/"},{"categories":["Operation","note"],"content":"使用管理工具宝塔面板创建部署网站","date":"2020-05-31","objectID":"/bt-site/","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"1、请自行装好宝塔面板以及Nginx、PHP（其他项目请装对应的服务器以及应用服务器） ","date":"2020-05-31","objectID":"/bt-site/:1:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"2、进入对应的宝塔面板页面点击左侧导航栏的网站（1），再点击添加站点（2）， ","date":"2020-05-31","objectID":"/bt-site/:2:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"3、一下添加对应的数据，并点击提交即可 ","date":"2020-05-31","objectID":"/bt-site/:3:0","tags":["BT","Site"],"title":"宝塔面板建站","uri":"/bt-site/"},{"categories":["Operation","note"],"content":"在Linux的CentOS8上更换国内yum源","date":"2020-04-29","objectID":"/centos8-change-source/","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":" cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo_back vi CentOS-Base.repo ","date":"2020-04-29","objectID":"/centos8-change-source/:0:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # [BaseOS] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=BaseOS\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/BaseOS/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=extras\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=centosplus\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [AppStream] name=CentOS-$releasever - AppStream #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=AppStream\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/AppStream/$basearch/os/ gpgcheck=1 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial [PowerTools] name=CentOS-$releasever - PowerTools #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026arch=$basearch\u0026repo=PowerTools\u0026infra=$infra baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/PowerTools/$basearch/os/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial yum clean all yum makecache ","date":"2020-04-29","objectID":"/centos8-change-source/:1:0","tags":["Linux","CentOS8","yum"],"title":"CentOS8 更换yum源","uri":"/centos8-change-source/"},{"categories":["Operation","note"],"content":"在Linux的Centos7系统上安装Docker","date":"2020-03-20","objectID":"/docker-centos7/","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。 社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。 ","date":"2020-03-20","objectID":"/docker-centos7/:0:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"一、安装docker 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0 $ sudo yum install \u003cFQPN\u003e # 例如：sudo yum install docker-ce-17.12.0.ce 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version ","date":"2020-03-20","objectID":"/docker-centos7/:1:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation","note"],"content":"二、问题 1、因为之前已经安装过旧版本的docker，在安装的时候报错如下： Transaction check error: file /usr/bin/docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 file /usr/bin/dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 2、卸载旧版本的包 $ sudo yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64 3、再次安装docker $ sudo yum install docker-ce ","date":"2020-03-20","objectID":"/docker-centos7/:2:0","tags":["Linux","CentOS7","Docker"],"title":"CentOS7上安装Docker","uri":"/docker-centos7/"},{"categories":["Operation"],"content":"解决centos安装不上apache:No match for argument: httpd","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"找到yum.conf [root@d78acc291c9e var]# find / -name yum.conf /etc/yum.conf ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:1:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Operation"],"content":"注释掉exclude那行，也可只删除httpd [main] gpgcheck=1 installonly_limit=3 clean_requirements_on_remove=True best=True #exclude=httpd nginx php mysql mairadb python-psutil python2-psutil //重新安装yum install httpd -y systemctl enable httpd systemctl start httpd systemctl status httpd 　Active: active (running) 　Status: “Started, listening on: port 80” [root@d78acc291c9e var]# httpd -v Server version: Apache/2.4.37 (centos) Server built: Dec 23 2019 20:45:34 ","date":"2020-02-01","objectID":"/apache-no-match-for-argument-httpd/:2:0","tags":["Site","Apache","CentOS7","Linux","Error"],"title":"Apache:No match for argument: httpd","uri":"/apache-no-match-for-argument-httpd/"},{"categories":["Total","note"],"content":"Idea设置XML模板并创建xml文件","date":"2020-01-11","objectID":"/idea-xml/","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Total","note"],"content":"1、File—-\u003eSettings 2、Editor(3)—-\u003eFile And Code Templates(4) —\u003e中间选中Files(5) —–\u003e点击左边+号(6)，右边是建立子模版（7），添加模板 —–\u003e输入模板名字：Name:XML File.xml （8，name可以自定义） ——\u003e后缀名extension：xml （9）—\u003e在面板中间输入内容（10，内容请根据自己需求更改，或建立子模版）： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cconfig\u003e \u003cclassName\u003eclassName\u003c/className\u003e \u003c/config\u003e —–\u003e把enable live Template(激活模板)勾选上（11） ——\u003e点击Apply（12）—ok 3、选中文件夹（1）—–\u003eNew（2）——–\u003e找到XML File（3），输入名字，点击确定，就可以创建xml文件了 ","date":"2020-01-11","objectID":"/idea-xml/:0:0","tags":["XML","File","IDE","Idea\"","Component","Config"],"title":"Idea创建xml文件","uri":"/idea-xml/"},{"categories":["Operation"],"content":"Docker 容器常见故障排查及处理，将常见问题分类","date":"2019-12-30","objectID":"/docker-error-by-type/","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"Docker是一种相对使用较简单的容器，我们可以通过以下几种方式获取信息： 1、通过docker run执行命令，或许返回信息 2、通过docker logs 去获取日志，做有针对性的筛选 3、通过systemctl status docker查看docker服务状态 4、通过journalctl -u docker.service 查看日志 ","date":"2019-12-30","objectID":"/docker-error-by-type/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"以下是整理的docker容器类问题故障，分为9个类 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:0","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"一、启动类故障 1、docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 原因：Docker未正常启动 解决方式： systemctl start docker 2、can’t create unix socket /var/run/docker.sock: is a directory 原因：docker.sock不能创建 解决方式： rm -rf /var/run/docker.sock 然后重新启动docker 3、Job for docker.service failed. Failed to start Docker Application 原因：Selinux引起 解决方式： /etc/sysconfig/selinux , 把 selinux 值改为disabled 重启docker解决 4、docker: Error response from daemon: /var/lib/docker/overlay/XXXXXXXXXXXXXXXXXXXXXXX: no such file or directory. 原因：docker没有指定目录或文件 解决方式： systemctl stop docker rm -rf /var/lib/docker/* systemctl start docker 重启run镜像启动容器 5、docker: Error response from daemon: Conflict. The container name “XXX” is already in use by container “XXX”. You have to remove (or rename) that container to be able to reuse that name. 原因：docker name重名 解决方式： 改名容器或者删除重建容器 6、Error: Connection activation failed: No suitable device found for this connection 原因：网卡配置问题 解决方式： 重启网卡 7、系统重启后docker无法启动 报错为：docker0: iptables: No chain/target/match by that name 原因：docker服务iptables问题 解决方式： 重启docker服务system restart docker 8、Error starting daemon: error initializing graphdriver: driver not supported 使用overlay2存储驱动启动docker daemon报错 原因：daemon缺少配置 解决方式： 添加配置： /etc/docker/daemon.json {“storage-driver”: “overlay2”, “storage-opts”: [“overlay2.override_kernel_check=true”]} 9、Failed to start docker.service: Unit docker.service is masked. 未知原因：docker 被mask 解决方式： systemctl unmask docker.service systemctl unmask docker.socket systemctl start docker.service 10、Failed to start docker.service: Unit is not loaded properly: Invalid argument. 未知原因：docker服务无法正常load 解决方式： 卸载docker， 删除docker.service 重新安装docker 11、docker-compose启动容器时报错： /usr/lib/python2.7/site-packages/requests/init.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn’t match a supported version! RequestsDependencyWarning) 未知原因：pip相应组件版本不支持 解决方式： pip uninstall urllib3 pip uninstall chardet pip install requests 12、docker容器重启故障 强杀docker进程后，重启docker。docker中的容器无法启动并报错 docker restart XXXXXXX Error response from daemon: Cannot restart container XXXXXXX: container “XXXXXXXXXXXXXXXX”: already exists 原因：旧容器未安全退出 解决方式： docker-containerd-ctr –address /run/docker/containerd/docker-containerd.sock –namespace c rm \u003c容器hash_id\u003e docker start 容器 13、docker重启错误-重启命令一直卡住 systemctl restart docker 卡住 未知原因：可能是启动的容器数量过多，或者磁盘IO问题 解决方式： systemctl start docker-cleanup.service systemctl start docker ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:1","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"二、权限问题报错 14、Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock 解决方式： 查看 /var/run/docker.sock所在用户组 将用户重新加入docker组中，usermod -aG docker ${USER} 15、chown socket at step GROUP: No such process 原因：docker无法找到Group组信息，docker组有可能被误删除， 解决方式： groupadd docker 16、Post http:///var/run/docker.sock/v1.XXX /auth: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS-enabled daemon without TLS? 原因：非Root用户管理Docker时，权限不足 解决方式： groupadd docker usermod -a -G docker user 17、docker commit镜像时报错 Error processing tar file(exit status 1): unexpected EOF 原因：可能是权限问题引起 解决方式： chmod +x 加一个执行权限 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:2","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"三、镜像和仓库问题报错 18、Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io 原因：Docker仓库无法访问 解决方式： 修改Docker仓库源为国内或者自建的仓库源 修改/etc/docker/daemon.json 19、推送本地镜像报错 The push refers to a repository [XXXX] Get https://xxx/v1/_ping: http: server gave HTTP response to HTTPS client 原因：docker registry未采用https服务所致 解决方式： /etc/docker/daemon.json 文件写入： { “insecure-registries”:[\"\"] } 20、/usr/bin/docker-current: Error response from daemon: oci runtime error: container_linux.go: starting container process caused “exec: “/bin/bash”: executable file not found in $PATH”. 原因：Docker镜像自身问题或者Docker引擎版本比较低导致 解决方式： 可以升级Docker版本服务 21、构建镜像，执行chown -R非常慢 原因：Docker使用写时复制策略，所以chown命令执行时，会将上层镜像文件全部复制到当前层，然后再修改权限，再写入文件系统。 解决方式： 不应该使用chown -R 这类大批量修改文件的命令 22、docker build构建镜像的时候报错： Message from syslogd kernel:unregister_netdevice: waiting for lo to become free. Usage count = 1 原因：docker engine版本过高 解决方式： docker engine版本需要和docker内部镜像的内核版本匹配 23、docker: Error response from daemon: containerd: container did not start before the specified time-out.ERRO[0133] error getting events from daemon: context canceled 原因：修改完docker root dir，重启后，下载镜像报错 解决方式： 重启docker服务 或者重启服务器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:3","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"四、资源问题报错 25、Docker no space left on device 原因：空间不足 解决方式：清理空间,删除未被使用的容器，镜像等资源 docker system prune -a 26、/var/lib/docker/containers 占用过大 原因：日志文件占用过大 解决方式： cat /dev/null \u003e *-json.log 或者 增加dockerd启动参数，/etc/docker/daemon.json {“log-driver”:“json-file”, “log-opts”: {“max-size”:“2G”, “max-file”:“10”} 27、max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 原因：系统参数默认配置过小 解决方式： 修改/etc/sysctl.conf里面的vm.max_map_count 调大 28、Got starting container process caused “process_linux.go:301:running exec setns process for init caused “exit status 40””: unknown.from time to time 原因：可能是cache问题引起 解决方式： echo 1 \u003e /proc/sys/vm/drop_caches 29、docker本机启动多台容器导致出现后续容器启动失败 原因：查看硬盘空间是否满，如果不是硬盘空间问题引起 解决方式： vim /etc/sysctl.conf 添加参数 fs.aio-max-nr = 1048576 sysctl -p 30、Docker启动异常，状态反复restarting Docker logs 容器名，查看异常日志 查看/var/log/messages 原因：内存跑满，引起OOM 解决方式： 释放内存后，再启动容器 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:4","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"五、版本不兼容报错 31、overlayfs: Can’t delete file moved from base layer to newly created dir even on ext4 原因：Centos 提供的文件系统 XFS 和 Overlay 兼容问题导致, 解决方式： 这个问题的修复在内核 4.4.6以上 32、docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused “process_linux.go:297: getting the final child’s pid from pipe caused “read init-p: connection reset by peer””: unknown. 原因：Docker版本和操作系统版本不匹配 解决方式： 重新安装和操作系统内核支持的docker 版本 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:5","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"六、网络或端口问题报错 33、WARNING: IPv4 forwarding is disabled. Networking will not work. 原因：ipv4网络无法转发 解决方式: /usr/lib/sysctl.d/00-system.conf 在最后一行添加net.ipv4.ip_forward=1 重启network服务。删除错误的容器，再次创建新容器 34、Creating network “xxxxxxx” with the default driver 原因：docker网关冲突 启动容器、docker-compose启动容器后，断网问题 解决方式： 配置 docker-compose.yml内给启动的容器配置参数network_mode: “bridge” 35、Unable to find a node that satisfies the following conditions [port xxxx] 原因：当容器使用端口映射(docker run -p xxxx:xxxx或 compose模板中的 ports)之后 系统会在宿主机上创建一个port，通过NAT来访问容器的指定port。如果宿主机上的端口被容器或者系统进程占用，就会导致端口分配失败。 解决方式： 清除占用端口的容器或者进程，或调整容器端口映射的宿主机端口避免冲突 36、Error response from daemon: service endpoint with name xxx already 原因：端口已经被占用 解决方式： 重启docker容器 37、docker: Error response from daemon: driver failed programming external connectivity on endpoint XXXXX: Bind for 0.0.0.0:80 failed: port is already allocated 原因：容器端口冲突 解决方式： 更换宿主机绑定端口 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:6","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"七、Docker安装报错 38、安装docker报Requires: container-selinux \u003e= 2.9 原因：container-selinux版本低或者是没安装的原因 解决方式： wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install epel-release yum makecache yum install container-selinux 39、安装docker-compose时报错 “ImportError: ‘module’ object has no attribute ‘check_specifier’” 原因：setuptools版本问题 解决方式： 升级setuptools到30.1.0版本以上版本 pip install –upgrade setuptools 40、安装docker-compose时报错 DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7. 原因：python2.7提示升级 解决方式： pip install -i https://pypi.douban.com/simple docker-compose ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:7","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"八、Docker删除报错 41、docker删除容器报错 Error response from daemon:Driver overlay failed to remove root filesystem xxxxx: remove/var/lib/docker/overlay2/xxxxx/merged: device or resource busy 原因：容器挂载数据卷，无法直接删除 解决方式： grep docker /proc/*/mountinfo | grep xxxxx kill进程后 再重新删除容器 42、状态dead的容器删除报错 Error response from daemon: Driver aufs failed to remove root filesystem XXXXXXXXXXXXXXXX: aufs: unmount error after retries: /var/lib/docker/aufs/mnt/xxxxxxxx: device or resource busy 原因：dead状态容器无法删除，还在占用资源 解决方式： docker rm -fv 容器id 过几分钟后会自动删除 43、docker删除镜像报错 Error response from daemon: conflict: unable to remove repository reference “XXXX” (must force) - container XXXX is using its referenced image YYYY 原因：镜像正在被某容器使用 解决方式： 需要删除相关ID容器后，才能删除镜像 44、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXXXXXXXXX (must be forced) - image is referenced in multiple repositories 原因：镜像login push 了远端其他仓库 解决方式： 如果不需要此镜像， docker rmi -f 强删 45、docker删除镜像报错 Error response from daemon: conflict: unable to delete XXX (cannot be forced) - image has dependent child images 原因：存在依赖于父镜像的子镜像 解决方式： 强制删除镜像或者批量删除容器，再删除镜像 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:8","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"九、其他报错 46、docker: Error response from daemon: driver failed programming external connectivity on end-point XXXXXXX: (iptables failed: iptables –wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 –dport 8080 -j ACCEPT: iptables: No chain/target/match by that name. 原因：防火墙问题引起 解决方式： 关闭防火墙，重启docker 47、执行docker info出现如下警告 WARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled 原因：配置问题引起，需要启用bridge-nf-call-iptables 解决方式： vi /etc/sysctl.conf 添加以下内容 net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-arptables = 1 48、docker数据库相关报错 使用Docker创建mysql容器闪退 Database is uninitialized and password option is not specified 解决方式： docker run -d -e MYSQL_ROOT_PASSWORD=[密码] -p 3306:3306 mysql镜像 Docker使用规范建议 尽量使用最近1-2年的新的稳定的docker版本 不要去安装今年前很老的版本，大量的bug已经被新版本更新解决掉了 尽量不要去创建非常大的镜像，比如5G10G以上的 镜像要尽量轻量化，去除不必要的软件，数据等 容器内挂载宿主机配置，使用只读 容器需要-v 宿主机的配置文件，尽量使用ro只读 数据要挂载宿主机物理硬盘或存储节点上 不要直接在容器里run，避免容器宕机引起数据丢失 应用日志一定要挂到宿主机上 不要直接打印到容器内，避免只能docker logs方式查看，避免去vulume目录里查看日志 不要只使用latest标签 Tag要有个管理标准，可以根据tag查找对应版本 不要使用容器ip，配置里更不能写死（默认172.17.0.x） 容器重启后，ip很可能会变 尽量不要在单容器内跑多进程 容器不是虚拟机，尽量做到1个容器，1个进程 跨环境镜像保持一致 不论是测试，UAT，生产环境，尽量保持同一个镜像，不要变更，环境变更只需要变更环境变量参数做区分 一定监控docker容器，即使发现问题 建议使用prometheus监控容器 一定要限制docker容器的资源， 尤其是CPU、内存、硬盘空间，甚至是网络等，避免侵占宿主机的硬件资源 ","date":"2019-12-30","objectID":"/docker-error-by-type/:2:9","tags":["Linux","CentOS7","Docker","Error"],"title":"Docker 容器常见故障排查及处理","uri":"/docker-error-by-type/"},{"categories":["Operation"],"content":"解决Git提交错误怎么办的集中办法和相关知识","date":"2019-12-05","objectID":"/git-commit-wrong/","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-wrong/"},{"categories":["Operation"],"content":"方法: git reset --hard \u003ccommit_id\u003e git push origin HEAD --force ","date":"2019-12-05","objectID":"/git-commit-wrong/:1:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-wrong/"},{"categories":["Operation"],"content":"其他: #根据–soft –mixed –hard，会对working tree和index和HEAD进行重置: git reset –mixed #此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft #回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset –hard #彻底回退到某个版本，本地的源码也会变为上一个版本的内容 HEAD 最近一个提交 HEAD^ 上一次 \u003ccommit_id\u003e 每次commit的SHA1值. 可以用git log 看到,也可以在页面上commit标签页里找到. ","date":"2019-12-05","objectID":"/git-commit-wrong/:2:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-wrong/"},{"categories":["Operation"],"content":"commit合并 有时commit太多，而且可能一个commit只是提交一个小bug，那么合并commit势在必行。 有两种方法： 一是在提交最后一个修改的commit使用参数，这时之前的一个commit将会合并到这个即将提交的commit中来： git commit -a --amend -m \"my message here\"如果之前有一个提交，并且信息为: git commit -a -m \"my last commit message\" 则这个commit message将不存在。但该commit的信息已经合并到\"my message here\"中了。 第二个是，如果你提交了最后的修改，这时可用： $ git reset --soft HEAD^ #或HEAD^意为取消最后commit $ git commit --amend 这将会把最后一个commit合并到前一个提交中去，例如（由上往下读）： git add b.text git commit -a -m \"my message here\" git add a.text git commit -a -m \"my last commit message\" 那么最后存在的将是\"my last commit message\"。也可后退n个，合并到前面第n+1个commit中去： $ git reset --soft HEAD~n #后退到第n，我也不清楚具体含义。 $ git commit --amend [-m \"new message\"] 我觉得最方面的是调用reflog查看操作历史，找到具体的commit id，然后直接git reset –hard [commit_id]就回到你要的版本！ ","date":"2019-12-05","objectID":"/git-commit-wrong/:3:0","tags":["Git","Commit","Error"],"title":"Git提交错误怎么办","uri":"/git-commit-wrong/"},{"categories":["Operation"],"content":"解决CentOS7运行Docker报错 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\" 问题","date":"2019-11-01","objectID":"/docker-daemon-is-running/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Operation"],"content":"执行命令：sudo dockerd –debug 注意此条指令不能Ctrl+C停止，否则还会出现一样的错误 之后重启docker：systemctl restart docker就可以了 在网上搜了半天，有的是去编辑 /etc/docker/daemon.json 文件，而有的是在 docker.service 如果在 /etc/docker/daemon.json 的解决办法：添加 insecure-registries 即可 sudo vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://zydiol88.mirror.aliyuncs.com\"], \"insecure-registries\": [\"161.17.60.38:85\"] } 如果是在 docker.service 解决办法：在 ExecStart 添加 –insecure-registry find / -name docker.service -type f /usr/lib/systemd/system/docker.service # 在 ExecStart 这行后面加上 -insecure-registry=Harbor登录地址 sudo vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --insecure-registry=161.17.60.38:85 sudo systemctl daemon-reload sudo systemctl restart docker 重启完成后重新登录即可 # 在linux总端登录Harbor： sudo docker login -u tens -p Tens123456 161.17.60.38:85 ","date":"2019-11-01","objectID":"/docker-daemon-is-running/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7运行Docker报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. ","uri":"/docker-daemon-is-running/"},{"categories":["Back","note"],"content":"Idea在Maven中和手动导入Jar包中直接查看Jar包源码","date":"2019-10-03","objectID":"/idea-jar-src/","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"Maven 1、从maven相关仓库添加依赖到Pom文件 2、点击Idea中的Maven（1）下的依赖文件夹（2）下的你想找源码的包（3），右键单击download source（下载源码） 3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:1:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Back","note"],"content":"手动导jar包 1、自行手动导jar包到项目 2、直接使用Maven分类的全局搜索即可 Maven：3、在Idea界面按住Ctrl+Shift+P进行全局搜索，最上面的框看可以输入你需要查找的函数名（1），（2）可以全局替换，此时用不上，再选择范围最大的Scope（3），进行搜索，在下方进行单击选择函数进行查看即可。 ","date":"2019-10-03","objectID":"/idea-jar-src/:2:0","tags":["Java","IDE","Idea","Jar","Source-Code"],"title":"Idea 查看Jar包源码","uri":"/idea-jar-src/"},{"categories":["Operation","note"],"content":"GitLab（私服）修改仓库成员可见属性","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Operation","note"],"content":"在 UI 界面中，选择 Settings \u003e General。 在弹出的界面中，选择 Visibility, project features, permissions 后面的 Expand 按钮。 然后在弹出的界面中，将 Project Visibility 下面从 Private 选择为 Public。 你的项目就可以被 Public 访问到了。 最后，不要忘记将你的修改保存以便于生效。 ","date":"2019-09-10","objectID":"/gitlab-change-repo-visibility/:0:0","tags":["Git","GitLab","Repository","Config"],"title":"GitLab（私服）修改仓库可见性","uri":"/gitlab-change-repo-visibility/"},{"categories":["Environment","note"],"content":"记录常用的Vim笔记","date":"2019-08-31","objectID":"/vim-note/","tags":["Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Environment","note"],"content":"指令模式下的指令 # vim高亮搜索 /名字 或 选中后 shift+3（非小键盘） # 关闭vim搜索高亮 输入:nohlsearch 或:set nohlsearch； # vim增加页码 ：set num # 或 ：set number ","date":"2019-08-31","objectID":"/vim-note/:1:0","tags":["Editor","Vim","Command-Mode"],"title":"Vim笔记","uri":"/vim-note/"},{"categories":["Operation","note"],"content":"在Linux的CentOS7系统中使用shell指令查看Git安装的路径","date":"2019-07-01","objectID":"/centos7-git-path/","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation","note"],"content":" command -v git ","date":"2019-07-01","objectID":"/centos7-git-path/:0:0","tags":["Linux","CentOS7","Git","Search"],"title":"CentOS7查看Git安装的路径","uri":"/centos7-git-path/"},{"categories":["Operation"],"content":"解决CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）报错","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":" # service docker start Redirecting to /bin/systemctl start docker.service Job for docker.service failed because the control process exited with error code. See \"systemctl status docker.service\" and \"journalctl -xe\" for details. # systemctl status docker.service ● docker.service - Docker Application Container Engine Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled) Drop-In: /usr/lib/systemd/system/docker.service.d └─flannel.conf Active: failed (Result: exit-code) since Wed 2018-08-29 04:54:57 UTC; 20s ago Docs: https://docs.docker.com Process: 10689 ExecStart=/usr/bin/dockerd (code=exited, status=1/FAILURE) Main PID: 10689 (code=exited, status=1/FAILURE) ****** systemd[1]: Starting Docker Application Container Engine... ****** dockerd[10689]: can't create unix socket /var/run/docker.sock: is a directory ****** systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE ******systemd[1]: Failed to start Docker Application Container Engine. ******systemd[1]: Unit docker.service entered failed state. ******systemd[1]: docker.service failed. ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:0:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation"],"content":"解决 # 删除docker.sock rm -rf /var/run/docker.sock # 重新启动即可 service docker restart ","date":"2019-06-01","objectID":"/docker-cant-create-unix-socket/:1:0","tags":["Linux","CentOS7","Docker","Error"],"title":"CentOS7 Docker启动失败（can't create unix socket /var/run/docker.sock: is a directory）","uri":"/docker-cant-create-unix-socket/"},{"categories":["Operation","note"],"content":"Git-Branch分支操作的常用指令笔记","date":"2019-05-01","objectID":"/git-branch/","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"创建分支 # 根据名称创建分支,并切换分支 git checkout -b {name} # 示例 git checkout -b zhangsan # 这条指令是 git checkout zhangsan # 和 git branch zhangsan # 两条指令的结合体 ","date":"2019-05-01","objectID":"/git-branch/:1:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"查看分支 # 查看所有分支，当前分支为绿色 git branch [-a] # -a 所有分支 # 创建分支 git branch mybranch # 切换分支 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:2:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改分支名称 # 需要将分支br_rename_old修改为br_rename_new，执行如下步骤： ## 1、切换到br_rename_old分支，如果已经在这个分支下，可以不执行此步骤 git checkout br_rename_old ## 2、将代码更新到和远程仓库一致 git pull origin br_rename_old ## 3.1、将本地仓库的br_rename_old的名称修改为br_rename_new git branch -m br_rename_old br_rename_new ## 3.2、将本地仓库的当前分支的名称修改为br_rename_new git branch -m br_rename_new ## 4、将远程分支br_rename_old删除 git push origin --delete br_rename_old ## 5、将本地分支push到远程仓库 git push --set-upstream origin br_rename_new ","date":"2019-05-01","objectID":"/git-branch/:3:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"备份分支 根据git当前提交节点创建分支button-and-input，继承之前所有提交代码 git branch button-and-input ","date":"2019-05-01","objectID":"/git-branch/:4:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法一 将本地创建的button-and-input分支提交到远程，名字为button-and-input git push origin button-and-input:button-and-input ","date":"2019-05-01","objectID":"/git-branch/:4:1","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"方法二 正常提交代码流程但最后一步提交到新创建的仓库或之前做过直接可以提交至新创建的远程仓库分支 git add . git commit -m \"Message\" git push origin button-and-input 二者都能达到备份代码目的 ","date":"2019-05-01","objectID":"/git-branch/:4:2","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"其他 合并分支：(merge from) $ git checkout master $ git merge mybranch (merge from mybranch) 删除本地分支： $ git branch -d mybranch 强制删除分支： $ git branch -D mybranch 列出所有分支： $ git branch ","date":"2019-05-01","objectID":"/git-branch/:5:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"非绝对必要且明白产生其他后果时才能进行的操作 # 切换分支 在没有commit时请备份代码或者commit、push后再进行提交否则，会导致当前代码全部丢失 git checkout mybranch ","date":"2019-05-01","objectID":"/git-branch/:6:0","tags":["Git","Branch"],"title":"Git-Branch分支操作","uri":"/git-branch/"},{"categories":["Operation","note"],"content":"修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改","date":"2019-04-30","objectID":"/git-package-rename/","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":" “修改Git文件夹名字，并不能在本地直接用操作系统的文件系统修改 git mv -f [file] [newfile] #示例 git mv -f Github GitHub #-f=--forse,即使目标存在，也强制重命名或移动文件 ","date":"2019-04-30","objectID":"/git-package-rename/:0:0","tags":["Git","Repository","File","Package"],"title":"修改Git文件夹名字","uri":"/git-package-rename/"},{"categories":["Operation","note"],"content":"展示Git常规提交流程和部分参数之间的区别","date":"2019-03-15","objectID":"/git-push/","tags":["Git","Repository","Commit"],"title":"Git常规提交流程","uri":"/git-push/"},{"categories":["Operation","note"],"content":" # 1.添加当前目录下的所有文件到暂存区： git add [.][-u][-A][-all] # -u 将文件的修改、文件的删除，添加到暂存区。 # . 将文件的修改，文件的新建，添加到暂存区。 # -A/-all 将文件的修改，文件的删除，文件的新建，添加到暂存区。 # 2.提交暂存区的指定文件到仓库区 -m是添加标签（Tag）信息，不添加-m参数会弹出问价，要求填写message git commit [-m \"{message}\"] # 示例 git commit -m \"这是个标签1\" # 3.从将本地的分支版本上传到远程并合并。不添加origin master会提交到默认分支，添加后可以分开分支进行开发互不干扰 git push [origin {master}] ","date":"2019-03-15","objectID":"/git-push/:0:0","tags":["Git","Repository","Commit"],"title":"Git常规提交流程","uri":"/git-push/"},{"categories":["Operation","note"],"content":"Git在本地初始化仓库流程","date":"2019-02-04","objectID":"/git-repo-init/","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":" 自行在系统环境中安装Git，这里不做介绍 #Git 本地仓库初始化，生成.git的隐藏文件 git init # 配置个人信息邮箱、姓名 --global是指全局有效，无论在哪个仓库均有效 ## 姓名 git config --global user.name \"{name}\" # 示例 git config --global user.name \"zhangsan\" ## 邮箱 git config --global user.email {email.example.com} # 示例 git config --global user.name \"{zhangsan.qq.com}\" # 查看配置信息 git config --list # 修改配置信息 # 重新添加一次即可覆盖 # 或 git config --global configName configValue # 删除 git config --global --unset configName (只针对存在唯一值的情况) ","date":"2019-02-04","objectID":"/git-repo-init/:0:0","tags":["Git","Repository"],"title":"Git仓库初始化","uri":"/git-repo-init/"},{"categories":["Operation","note"],"content":"从底层解释yum makecache的作用","date":"2019-01-24","objectID":"/yum-makecache/","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Operation","note"],"content":"疑问： yum makecache 的作用到底是什么呢? 查看了很多的资料，都说是会从服务器中下载一些信息，但是我做了一个测试。 [root@localhost 7]# yum clean all [root@localhost 7]# yum install createrepo -y [root@localhost 7]# yum remove createrepo -y 断网之后 [root@localhost 7]# yum install createrepo -y #安装成功 #发现还是可以安装成功，所以可以判断这时通过缓存安装的。但是为了严谨再执行以下命令。 [root@localhost 7]# yum clean all #清理缓存再安装 [root@localhost 7]# yum install createrepo -y #安装失败 根据上述实验，我们可以判断yum 安装软件包的时候就已经把该软件包缓存起来了，而不需要执行yum makecache 进行额外的缓存。 但是很多资料中都说安装好软件之后需要执行yum makecache 这个命令进行缓存。(不知道是什么原因) 总结：yum安装的时候会将安装包进行缓存，不过最好还是再执行一下yum makecache命令。 ","date":"2019-01-24","objectID":"/yum-makecache/:0:0","tags":["Linux","CentOS7","yum"],"title":"yum makecache的作用","uri":"/yum-makecache/"},{"categories":["Hardware"],"content":"Win10鼠标出现延迟现象","date":"2018-12-31","objectID":"/windows-mouse-delay/","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"1、修改控制面板电源选项 控制面板下的电源选项 找到自己当前的电源计划，点击更改计划设置 点击更改高级电源设置 在Usb设置下的USB选择性暂停设置下的使用电池和接通电源均禁用（该操作可能耗电，情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:1:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"2、由于连接在扩展坞上，切换至USB无此情况，怀疑扩展坞问题，更换扩展坞情况有点好转，但鼠标还是不灵敏） ","date":"2018-12-31","objectID":"/windows-mouse-delay/:2:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Hardware"],"content":"3、随着Win10 更新，原扩展坞和鼠标延迟现象彻底消失，最新版的Win10还是有Bug的 ","date":"2018-12-31","objectID":"/windows-mouse-delay/:3:0","tags":["Windows","Windows10","Mouse","Bug"],"title":"Win10鼠标出现延迟现象","uri":"/windows-mouse-delay/"},{"categories":["Operation","note"],"content":"部署Hugo，并使用其创建静态网站，推送到Github，配置GitHub Pages","date":"2018-11-11","objectID":"/shell-script/","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"set -e的作用 #!/bin/bash set -e ... command 1 command 2 ... exit 0 你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。 这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。 ","date":"2018-11-11","objectID":"/shell-script/:1:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"特殊变量（$0、$1、$2、 $?、 $# 、$@、 $*） shell编程中有一些特殊的变量可以使用。这些变量在脚本中可以作为全局变量来使用。 名称 说明 $0 脚本名称 $1-9 脚本执行时的参数1到参数9 $? 脚本的返回值 $# 脚本执行时，输入的参数的个数 $@ 输入的参数的具体内容（将输入的参数作为一个多个对象，即是所有参数的一个列表） $* 输入的参数的具体内容（将输入的参数作为一个单词） $@与$*的区别： 　$@与$*都可以使用一个变量来来表示所有的参数内容，但这两个变量之间有一些不同之处。 　$@：将输入的参数作为一个列表对象 　$*：将输入的参数作为一个单词 #源代码： echo \"脚本的名字是：\"$0 n=1 echo \"使用\\$@的参数列表为：\"$@ for temstr in \"$@\" do echo \"第$n个参数是：\" $temstr let n+=1 done n=1 echo \"使用\\$*的参数列表为：\"$* for temstr in \"$*\" do echo \"第$n个参数是：\" $temstr let n+=1 done #执行结果： $ ./test.sh 1 2 3 4 脚本的名字是：./test.sh 使用$@的参数列表为：1 2 3 4 第1个参数是： 1 第2个参数是： 2 第3个参数是： 3 第4个参数是： 4 使用$*的参数列表为：1 2 3 4 第1个参数是： 1 2 3 4 在上面的例子中，使用$@与$*是，都是用双引号引起来，但当$*不使用双引号时，结果与$@的结果相同。 　原因分析： 　当都使用双引号时，我们可以看到参数列表输出都是一样的，说明确实两个变量都可以存储所有的参数内容，也就显示出来两个变量之间的对参数处理的不同，即一个将其作为列表处理，一个讲所有参数作为一个单词处理。 　当$*不适用双引号时，执行到for语句时，会首先将$*的值（1 2 3 4 ）取出来，然后循环语句就变成了　for tem in 1 2 3 4 ，最后的输出结果也就变成了列表的循环输出。 #源码： #!/bin/bash n=1 for tem in $* do echo $n is $tem let n+=1 done 执行结果： # ./test.sh 1 2 3 4 1 is 1 2 is 2 3 is 3 4 is 4 　在这里补充一下单引号、双引号以及没有引号的区别： 单引号： 　可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看见的是什么就会输出什么。 双引号： 　把双引号内的内容输出出来；如果内容中有命令，变量等，会先把变量，命令解析出结果，然后在输出最终内容来。 　双引号内命令或变量的写法为命令或变量或$（命令或变量）。 无引号： 　把内容输出出来，可能不会讲含有空格的字符串视为一个整体输出； 　如果内容中有命令、变量等，会先把变量、命令解析结果，然后在输出最终内容来； 　如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用，不过最好用双引号替代之 ","date":"2018-11-11","objectID":"/shell-script/:2:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"Shell脚本IF条件判断和判断条件总结 这里有IF条件判断的语法和常用的判断条件总结,需要的朋友可以参考下 ","date":"2018-11-11","objectID":"/shell-script/:3:0","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"前言: 无论什么编程语言都离不开条件判断。SHELL也不例外。 代码如下: if list then do something here elif list then do another thing here else do something else here fi ","date":"2018-11-11","objectID":"/shell-script/:3:1","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"EX: 代码如下: \\#!/bin/sh SYSTEM=`uname -s` #获取操作系统类型，我本地是linux if [ $SYSTEM = \"Linux\" ] ; then #如果是linux的话打印linux字符串 echo \"Linux\" elif [ $SYSTEM = \"FreeBSD\" ] ; then echo \"FreeBSD\" elif [ $SYSTEM = \"Solaris\" ] ; then echo \"Solaris\" else echo \"What?\" fi #ifend 基本上和其他脚本语言一样。没有太大区别。不过值得注意的是。[]里面的条件判断。 ","date":"2018-11-11","objectID":"/shell-script/:3:2","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"1、字符串判断 条件 解释 str1 = str2 当两个串有相同内容、长度时为真 str1 != str2 当串str1和str2不等时为真 -n str1 当串的长度大于0时为真(串非空) -z str1 当串的长度为0时为真(空串) str1 当串str1为非空时为真 ","date":"2018-11-11","objectID":"/shell-script/:3:3","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"2、数字的判断 条件 解释 int1 -eq int2 两数相等为真 int1 -ne int2 两数不等为真 int1 -gt int2 int1大于int2为真 int1 -ge int2 int1大于等于int2为真 int1 -lt int2 int1小于int2为真 int1 -le int2 int1小于等于int2为真 ","date":"2018-11-11","objectID":"/shell-script/:3:4","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"3、文件的判断 参数 解释 -r file 用户可读为真 -w file 用户可写为真 -x file 用户可执行为真 -f file 文件为正规文件为真 -d file 文件为目录为真 -c file 文件为字符特殊文件为真 -b file 文件为块特殊文件为真 -s file 文件大小非0时为真 -t file 当文件描述符(默认为1)指定的设备为终端时为真 ","date":"2018-11-11","objectID":"/shell-script/:3:5","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"4、复杂逻辑判断 参数 解释 -a 与 -o 或 ! 非 ","date":"2018-11-11","objectID":"/shell-script/:3:6","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"结尾： 语法虽然简单，但是在SHELL里使用的时候，他的功能变得强大了。 ================================================================== ","date":"2018-11-11","objectID":"/shell-script/:3:7","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Operation","note"],"content":"附 表： 参数 解释 [ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 [ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。 [ STRING1 != STRING2 ] 如果字符串不相等则为真。 [ STRING1 \u003c STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 [ STRING1 \u003e STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 [ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers. ","date":"2018-11-11","objectID":"/shell-script/:3:8","tags":["Linux","CentOS7","Shell","Script"],"title":"ShellScript（.sh）脚本语法知识","uri":"/shell-script/"},{"categories":["Front","note"],"content":"在火狐浏览器设置禁用js","date":"2018-10-15","objectID":"/firefox-forbid-js/","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器禁用js","uri":"/firefox-forbid-js/"},{"categories":["Front","note"],"content":"首先打开火狐浏览器 接着再地址栏输入about:config，点击回车键 接着看到如下画面。去掉下次任显示此警告前面的方框里的钩，再点击我 保证会小心按钮 点击后看到如下画面，在搜索地址栏中输入javascript.enabled 接着就会看到如下图，原来有很多的内容变成之后两个了。 鼠标右键第一个，弹出菜单。再点击切换 当一行的中的，值由trun变成false。时候说明已经关闭了。 如下图只要打开有javascript，页面就会无法使用了。有些页面还会提示。 ","date":"2018-10-15","objectID":"/firefox-forbid-js/:0:0","tags":["Browser","FireFox","JavaScript","Config"],"title":"火狐浏览器禁用js","uri":"/firefox-forbid-js/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错","date":"2018-09-15","objectID":"/win10-update-80070003/","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Operation"],"content":"Win10系统更新出现请重试(Ox80070003)报错 关闭Windows Update服务 删除C:\\Windows\\SoftwareDistribution\\Download下的内容 启动Windows Update服务 再次更新即可 ","date":"2018-09-15","objectID":"/win10-update-80070003/:1:0","tags":["Windows","Windows10","Update","Error"],"title":"Win10更新失败","uri":"/win10-update-80070003/"},{"categories":["Hardware","note"],"content":"记录键盘符号中英文对照表","date":"2018-08-20","objectID":"/keyboard-chinese-english/","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["Hardware","note"],"content":" 键 英文 中文 ~ tilde 波浪符 ` back quote 反引号 ! exclamation mark or bang 叹号 @ at 艾特 # hash or number or sharp 井号 $ dollar 美元符 % percent 百分号 ^ caret 脱字符、插入符 \u0026 and or ampersand 与和符 ***** asterisk 星号 ( ) parentheses 圆括号、小括号 [ ] brackets 方括号、中括号 { } curly brackets 花括号、大括号 - hyphen or dash or minus 连字符、减号 _ underscore 下划线 + plus 加号 = equal 等号 / slash 斜线 ** back slask 反斜线 | pipe or bar 竖线 : colon 冒号 ; semicolon 分号 ' single quote 单引号 \" “ quote 双引号 \u003c less than or angle brackets 小于 \u003e greater than or angle brackets 大于 , comma 逗号 . period or dot 句号 ? question mark 问号 ESC escape key 跳离键 Backspace backspace key 退格键 Insert insert key 插入建 Home home key 原位键 Delete delete key 删除键 End end key 结尾键 Page Up page up key 向上翻页键 Page Down page down key 向下翻页键 Enter enter key 回车键 Tab tab key 制表键 Caps Lock caps lock key 大写锁定键 ALT alternate key 可选键 CTRL control key 控制键 SHIFT shift key 上档键 Space space bar 空格键 Num num lock key 数字键盘锁定键 ","date":"2018-08-20","objectID":"/keyboard-chinese-english/:0:0","tags":["Keyboard","Comparison"],"title":"键盘符号中英文对照表","uri":"/keyboard-chinese-english/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - CodeIT 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.78.1). 推荐使用 Hugo extended 版本\r\r由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 CodeIT 主题的仓库是: https://github.com/sunt-programator/CodeIT. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/sunt-programator/CodeIT.git themes/CodeIT 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/sunt-programator/CodeIT.git themes/CodeIT ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 CodeIT 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"CodeIT\" [params] # CodeIT 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/sunt-programator/CodeIT/issues/158) noClasses = false 注意\r\r在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意\r\r默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \"\r基本配置下的预览\r 技巧\r\r当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\r\r 注意\r\r由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender \r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧\r\r网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多…\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, CodeIT 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # CodeIT 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"CodeIT\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # (HTML format is supported) # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意\r\rHugo extended 版本对于自定义样式是必需的.\r\r 通过定义自定义 .scss 样式文件, CodeIT 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/CodeIT/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url(\"https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext\"); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n CodeIT 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \"\r语言切换\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo 如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意\r\r请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容.\r\r 技巧\r\r也可以使用 文章前置参数 来翻译网址.\r\r ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/CodeIT/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, CodeIT 主题支持搜索功能. ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎?\r\r以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. \r\r 关于 algolia 的使用技巧\r\r你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json…\r\r","date":"2020-03-06","objectID":"/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\" \u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.1 instagram(旧版) instagram 的文档 instagram官方文档（Facebook） 一个 instagram 示例: {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} 呈现的输出效果如下: 这个instagram的shortcode功能依赖于 Instagram的一个API, 然而自从2020年10月24日起就被弃用了。因此，无法从此API端点获取任何图像，从而导致在使用instagram的shortcode时出错。有关更多信息，请查看GitHub问题[#7879] #7879. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4.2 instagram(我搜索并根据官方文档的办法) instagram 的文档（Hugo官方未更新） instagram官方文档（Facebook） #1.在开发者官方注册 #在开发者工具中创建任务获取app-id和app-secret，填入下面的请求地址 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id={your-app-id} \u0026client_secret={your-app-secret} \u0026grant_type=client_credentials\" # 示例 curl -X GET \"https://graph.facebook.com/oauth/access_token ?client_id=123\u0026client_secret={456} \u0026grant_type=client_credentials\" #获得token后填入下面的地址，即可获得返回的html代码 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url={url}\u0026access_token={access-token}\" # 示例 curl -X GET \\ 'https://graph.facebook.com/v10.0/instagram_oembed?url=https://www.instagram.com/p/fA9uwTtkSN/\u0026access_token=IGQVJ...\" 总结如下，新版无法进行直接内嵌完成，需要完成以下步骤（两种方式均可）参考前端大佬js获取的方式 Instagram oEmbed 嵌入 IG 貼文 Facebook：应用程式、ID、密钥、URL 4.2.1直接使用手机客户端应用打开，找到对应的文章，点击三点，再点击内嵌即可生成对应的访问地址 4.2.2使用代码方式步骤 到Facebook for Developers上建立一个应用程序，取得编号、密钥 要在Firebase 开启Facebook 登入功能，需要有一组Facebook 应用程式的ID、密钥。 本篇建立的应用程式是示范用，本篇上线时就会删除，因此应用程式编号、密钥都会不存在。 进到FACEBOOK for Developers的页面并登入FB帐号后，点击「建立应用程式」： 工作的部份选「更多选项」： 下一个是要填写应用程式的显示名称，就填一个我们看得懂在做什么的名称： 填完后按下「建立应用程式」，就会建立完成。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"应用程式编号、密钥、OAuth URL 应用程式建立完，进到应用程式，左侧选单点击「设定\u003e 基本资料」，就会看到「应用程式编号」、「应用程式密钥」，以及一些需要填写的栏位： 应用程序上新增产品：oEmbed，并把应用程序调整成「上线」 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增产品：oEmbed 应用程式建立完成后，左侧选单点击「产品」旁边的「+」： 然后找到「oEmbed」这项，点击「设定」： 会跳一个确认框，打勾后按下「确认」，左侧的产品清单就会新增oEmbed，代表新增成功。 最后顶部那条有一个显示为「调整中」的Toggle 按钮： 我们点一下按钮，并确认要切换模式，让它变成「上线」，这个应用程式就可以对外使用了： 在Google云端硬盘上新增Google Apps Script的档案，档案中写取得Access Token的代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"新增GAS 档案当后端，取得FB Access Token 为了要能够使用FB 的应用程式，必须要有一个Access Token 才能够被FB 放行，因为取Token 的过程会用到密钥，因此要写在后端，写在前端会被看光光。 最快写一支后端的方式就是用Google 云端硬碟里的Google Apps Script 档案，以下简称GAS。 进到Google 云端硬碟，点左上角的「新增\u003e 更多\u003e Google Apps Script」： 进到档案后，我们先改个档名进行存档，滑到左上角的档案名称上，点击一次就可以开始改档名 右侧预设会有一个myFunction，整个删掉后，贴上以下程式码，主要是来取得Access Token的： var appId = '从FB后台取得的「应用程式编号」' ; var secret = '从FB后台取得的「应用程式密钥」' ; var uri = 'https://graph.facebook.com/oauth/access_token?client_id=' + appId + '\u0026client_secret=' + secret + '\u0026grant_type=client_credentials' ; function doGet ( e ) { var response = UrlFetchApp . fetch ( uri ) ; return ContentService . createTextOutput ( response ) . setMimeType ( ContentService . MimeType . JSON ) ; } appId、secret这二个变数记得要修改。 doGet指的是当这个GAS预到GET时要执行哪些动作，function里面写的是向FB取得Access Token。 程式码贴上并更新好变数后，按下右上角的「部署\u003e 新增部署作业」： 点击「选取类型」右边的齿轮icon，选择「网页应用程式」： 接着右侧「谁可以存取」的地方改为所有人： 按下「部署」后，第一次部署会需要开存取权： 点击上图的「授予存取权」后，会出现一个警告视窗： 因为这个应用程式是我们自己写的，是可以相信的，点击上图左上角的「进阶」后，会展开一小行字： 点击上图左下角的「前往XXX（不安全）」，因为我们的应用程式没向Google 请求验证过，这边就会一直秀出不安全的字样。 点击了以后会要授予存取权： 按下「允许」，这个GAS 档就成功部署，并且会给一串网址： 这个网址很重要，就像API一样，GET这个网址，就会回传一组Access Token回来。 用JavaScript、Postman、浏览器等取Access Token，并用Access Token取得Instagram贴文的嵌入代码 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"取Token、取IG 贴文 在上一步的最后我们取得了部署的网址，首先我们先用GET取得Access Token回来： const getToken = '部署完取得的网址' ; fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) Console 出来的response 资料会像这样： { access_token: \"405342487221016|50nqwaePxasUkpNVyIwrJpoA2H0\", token_type: \"bearer\" } 所以我们可以知道，response.access_token就是我们要的Access Token。 接下来就是拿这个Access Token 去取得IG 的贴文内容。 首先我们要先有IG 贴文的网址，在贴文上面点右上角的点点点，在点击「复制连结」，就取到贴文的网址了： 有了贴文的网址，也有了Token，我们可以用一个GET来取得贴文的资讯： const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //要不要隐藏描述，true隐藏、false不隐藏 fetch ( getToken ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e response . access_token ) . then ( token =\u003e { fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }` ) . then ( response =\u003e response . json ( ) ) . then ( response =\u003e { console . log ( response ) ; } ) } ) ; 从API 的URL 上可以看到，需要的参数有：IG 贴文网址、Access Token，跟hidecaption 是否要隐藏描述。 hidecaption 没有写在新的文件里，神奇的是却有写在旧文件里，这是Augustus 看了前一篇的文章后试出来的，所以如果哪天FB 把这参数拿掉也不用意外。 另外，复制出的IG 贴文网址本身会带一个参数，像这样： https://www.instagram.com/p/CK6wSwfpuVi/?igshid=1wy9n8xgtbe89 实测后，有没有写到igshid 这个参数都没关系，都抓得到贴文资料回来。 除了上面三个参数，还有二个参数是官方文件有提供的：maxwidth、omitscript。 maxwidth 是可以指定嵌入贴文时的最大宽度。 omitscript是Boolean值，预设为false，一般来说我们在嵌入IG贴文时，IG会自动把贴文的资料载入，如果我们想要有另外执行载入贴文的需求，这边就可以写true，之后再执行：instgrm.Embeds.process()就可以把贴文载进页面中。 But！实作时，不确定是不是Augustus有写错，不论omitscript是true或false，如果没执行instgrm.Embeds.process()那贴文就会是呈现白白的样子，像这样： 而且旧的方法吐回来的html，里面会自行引用IG 的embed.js，新的看起来是跟FB 整并所以就没有了，要自行引用： \u003cscript src=\"https://www.instagram.com/embed.js\"\u003e\u003c/script\u003e console 出来的response 会长这样： 可以看到的值有： author_name html provider_name provider_url thumbnail_height thumbnail_url thumbnail_width type version width 其中html就是我们要嵌入IG贴文的程式码，整段放到我们要放的地方就行，这篇的Demo是放在\u003cdiv id=\"ig-iframe\"\u003e\u003c/div\u003e这个div中。 完整嵌入IG 贴文的程式码如下： \u003c div id =\" ig-iframe \" \u003e \u003c/ div \u003e \u003c script src =\" https://www.instagram.com/embed.js \" \u003e \u003c/ script \u003e \u003c script \u003e const getToken = '部署完取得的网址' ; const igUri = 'IG贴文的网址' ; const hideCaption = true ; //选填，要不要隐藏描述，true隐藏、false不隐藏，预设为false const maxWidth = 400 ; //选填，贴文的最大宽度是多少 fetch ( getToken ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const token = res . access_token ; fetch ( `https://graph.facebook.com/v9.0/instagram_oembed?url= ${ igUri }\u0026access_token= ${ token }\u0026hidecaption= ${ hideCaption }\u0026maxwidth= ${ maxWidth }` ) . then ( res =\u003e res . json ( ) ) . then ( res =\u003e { const wrap = document . getElementById ( 'ig-iframe' ) ; wrap . insertAdjacentHTML ( 'afterbegin' , res . html ) ; instgrm . Embeds . process ( ) ; } ) . catch ( err =\u003e { throw Error ( e ) } ) } ) . catch ( err =\u003e { throw Error ( e ) } ) ; \u003c/ script \u003e 完成的IG 贴文嵌入就完成啦~ 如此两种方式并不能简洁快速的嵌入instagram，需要同一般资源一样进行嵌入，Hugo官方表示不能继续使用，且暂时并未做出修改适配，若已经适配请联系我。 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} 呈现的输出效果如下: Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ## 8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 CodeIT 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用\r\r有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意\r\r不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做.\r\r 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧\r\rfeaturedImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg \r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 CodeIT 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \"\r文章摘要预览\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意\r\r请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 CodeIT 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意\r\r不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等.\r\r ","date":"2020-03-05","objectID":"/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 CodeIT 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 CodeIT 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧\r\r有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单.\r\r 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int\\_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧\r\r你可以在 网站配置 中自定义公式块和行内公式的分割符.\r\r Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 CodeIT 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 CodeIT 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome CodeIT 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧\r\r这个方法可以间接解决一个还未解决的 Hugo 的 issue.\r\r 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"CodeIT 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意\r\rHugo extended 版本对于 style shortcode 是必需的.\r\r style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\"\rLighthouse (image)\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip\r\r一个 技巧 横幅\r\r ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 _-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --_ C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K 线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: \r如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 _段落_... {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: \r\r","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意\r\r脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库.\r\r 一个 script 示例: {{\u003c script \u003e}} console.log('Hello CodeIT!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation","note"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 CodeIT 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003e Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. \u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e这是 \u003cb\u003eHTML\u003c/b\u003e\u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** **渲染为粗体** 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. _渲染为斜体_ _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. **_加粗和斜体_** ~~**删除线和加粗**~~ ~~_删除线和斜体_~~ ~~**_加粗, 斜体和删除线_**~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel \u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del \u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. \u003e Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e \u003e \u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor \u003e \u003e odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: - 一项内容 * 一项内容 - 一项内容 例如: - Lorem ipsum dolor sit amet - Consectetur adipiscing elit - Integer molestie lorem at massa - Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at - Faucibus porta lacus fringilla vel - Aenean sit amet erat nunc - Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003e Nulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ------------------------------------------------------------------------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003e path to data files to supply the data that will be passed into templates. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003e engine to be used for processing templates. Handlebars is the default. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | | :----: | ------------------------------------------------------------------------: | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents - [Chapter 1](#chapter-1) - [Chapter 2](#chapter-2) - [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rCodeIT 主题提供了一个包含更多功能的 图片的 shortcode.\r\r ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"14 转义 文档中一下部分字符特别是类似于\u003cscript\u003e、\u003clink\u003e这样的标签等符号不能直接写大于小于号，需要进行转义，否则会使页面报错 显示结果 描述 实体名称 实体编号 空格     \u003c 小于号 \u003c \u003c \u003e 大于号 \u003e \u003e \u0026 与和号 \u0026 \u0026 \" 双引号 \" \" ' 单引号 '(IE不支持) ' 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:14:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation","note"],"content":"Hugo 和 CodeIT 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/emoji-support/:1:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人与身体 ","date":"2019-10-01","objectID":"/emoji-support/:2:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/emoji-support/:3:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/emoji-support/:4:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/emoji-support/:5:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"活动 ","date":"2019-10-01","objectID":"/emoji-support/:6:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"物品 ","date":"2019-10-01","objectID":"/emoji-support/:7:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"符号 ","date":"2019-10-01","objectID":"/emoji-support/:8:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"旗帜 ","date":"2019-10-01","objectID":"/emoji-support/:9:0","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation","note"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","tags":["Markdown","emoji","HTML"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":null,"content":" 警告\r\rSorry, this article has not been completely translated into French. Welcome to take the time to propose a translation by  making a PR to the theme!\r\r  CodeIT is a clean, elegant but advanced blog theme for Hugo. It is based on the original LoveIt Theme, LeaveIt Theme, and KeepIt Theme. Hugo Theme CodeITHugo Theme CodeIT \"\rHugo Theme CodeIT\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 CodeIT","uri":"/about/"},{"categories":null,"content":"许可协议 CodeIT 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 CodeIT 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 CodeIT","uri":"/about/"}]