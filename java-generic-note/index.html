<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Java泛型笔记 - KKKPJSKEY&#39;s-Case-Archives</title><meta name="description" content="记录Java泛型相关笔记"><meta property="og:title" content="Java泛型笔记" />
<meta property="og:description" content="记录Java泛型相关笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kkkpjskey.github.io/java-generic-note/" /><meta property="og:image" content="https://kkkpjskey.github.io/java-generic-note/featured-image.jpg"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-14T16:31:28+08:00" />
<meta property="article:modified_time" content="2022-06-08T08:29:22+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://kkkpjskey.github.io/java-generic-note/featured-image.jpg"/>
<meta name="twitter:title" content="Java泛型笔记"/>
<meta name="twitter:description" content="记录Java泛型相关笔记"/>
<meta name="application-name" content="KKKPJSKEY&#39;s-Case-Archives">
<meta name="apple-mobile-web-app-title" content="KKKPJSKEY&#39;s-Case-Archives"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://kkkpjskey.github.io/java-generic-note/" /><link rel="prev" href="https://kkkpjskey.github.io/docker-note/" /><link rel="next" href="https://kkkpjskey.github.io/chocolatey-install-error/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.c7b8c5b85fd75a61ccb5e4d67876bcea7a86730af33a2c32f518a595ee670885455e303041833dfdf22b05a4eed86b37.css" integrity="sha384-x7jFuF/XWmHMteTWeHa86nqGcwrzOiwy9Rille5nCIVFXjAwQYM9/fIrBaTu2Gs3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Java泛型笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/kkkpjskey.github.io\/java-generic-note\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/kkkpjskey.github.io\/java-generic-note\/featured-image.jpg",
                            "width":  1900 ,
                            "height":  570 
                        }],"genre": "posts","keywords": "Java, Generic, JavaNote","wordcount":  25747 ,
        "url": "https:\/\/kkkpjskey.github.io\/java-generic-note\/","datePublished": "2021-12-14T16:31:28+08:00","dateModified": "2022-06-08T08:29:22+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": {
                    "@type": "ImageObject",
                    "url": "https:\/\/kkkpjskey.github.io\/images\/avatar.png",
                    "width":  528 ,
                    "height":  560 
                }},"author": {
                "@type": "Person",
                "name": "KKKPSJKEY"
            },"description": "记录Java泛型相关笔记"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="KKKPJSKEY&#39;s-Case-Archives"><span class="header-title-pre"><i class='fas fa-laptop-code fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/note/"> 笔记 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KKKPJSKEY" title="GitHub" rel="noopener noreferrer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item language" title="选择语言">简体中文<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/java-generic-note/" selected>简体中文</option></select>
                    </a><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="KKKPJSKEY&#39;s-Case-Archives"><span class="header-title-pre"><i class='fas fa-laptop-code fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/note/" title="">笔记</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KKKPJSKEY" title="GitHub" rel="noopener noreferrer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">简体中文<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/java-generic-note/" selected>简体中文</option></select>
                </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Java泛型笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/KKKPJSKEY" title="Author" target="_blank" rel="noopener noreferrer author" class="author"><i class="fas fa-user-circle fa-fw"></i>KKKPSJKEY</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/back/"><i class="far fa-folder fa-fw"></i>Back</a>&nbsp;<a href="/categories/note/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-12-14">2021-12-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 25747 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 52 分钟&nbsp;<span id="/java-generic-note/" class="leancloud_visitors" data-flag-title="Java泛型笔记">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/java-generic-note/featured-image.jpg"
        data-srcset="/java-generic-note/featured-image.jpg, /java-generic-note/featured-image.jpg 1.5x, /java-generic-note/featured-image.jpg 2x"
        data-sizes="auto"
        alt="/java-generic-note/featured-image.jpg"
        title="记录Java泛型相关笔记" /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a>
      <ul>
        <li><a href="#引言">引言</a></li>
        <li><a href="#泛型的基本概念">泛型的基本概念</a></li>
        <li><a href="#参数化类型的意义">参数化类型的意义</a></li>
        <li><a href="#泛型可以在哪里使用语法总结">泛型可以在哪里使用（语法总结）</a></li>
        <li><a href="#那泛型有什么用意义">那泛型有什么用（意义）</a></li>
      </ul>
    </li>
    <li><a href="#泛型的使用和类型擦除">泛型的使用和类型擦除</a>
      <ul>
        <li><a href="#在字节码文件中的形式">在字节码文件中的形式</a></li>
        <li><a href="#在内存中的形式">在内存中的形式</a></li>
      </ul>
    </li>
    <li><a href="#分类">分类</a>
      <ul>
        <li><a href="#泛型类">泛型类</a>
          <ul>
            <li><a href="#示例代码">示例代码：</a></li>
          </ul>
        </li>
        <li><a href="#泛型接口">泛型接口</a>
          <ul>
            <li><a href="#示例代码-1">示例代码：</a></li>
          </ul>
        </li>
        <li><a href="#泛型方法">泛型方法</a>
          <ul>
            <li><a href="#示例代码-2">示例代码：</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#泛型通配符及上下边界">泛型通配符及上下边界</a>
      <ul>
        <li><a href="#引言-1">引言</a></li>
        <li><a href="#原理">原理</a></li>
      </ul>
    </li>
    <li><a href="#协变与逆变">协变与逆变</a>
      <ul>
        <li><a href="#定义">定义</a>
          <ul>
            <li><a href="#数组是协变的">数组是协变的</a></li>
            <li><a href="#泛型是不变的">泛型是不变的</a></li>
          </ul>
        </li>
        <li><a href="#通配符引入协变逆变">通配符引入协变、逆变</a>
          <ul>
            <li><a href="#泛型的协变">泛型的协变</a>
              <ul>
                <li><a href="#泛型协变的使用">泛型协变的使用</a></li>
                <li><a href="#泛型协变存在的问题">泛型协变存在的问题</a>
                  <ul>
                    <li><a href="#java当中桥接方法的来由">Java当中桥接方法的来由</a></li>
                    <li><a href="#为什么泛型协变时不允许添加元素呢">为什么泛型协变时，不允许添加元素呢</a></li>
                    <li><a href="#从java字节码的角度去看桥接方法">从Java字节码的角度去看桥接方法</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#泛型逆变">泛型逆变</a>
              <ul>
                <li><a href="#泛型逆变的使用">泛型逆变的使用</a></li>
                <li><a href="#泛型逆变会有什么问题">泛型逆变会有什么问题</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#pecs">PECS</a>
          <ul>
            <li><a href="#例子">例子</a></li>
          </ul>
        </li>
        <li><a href="#自限定的类型">自限定的类型</a>
          <ul>
            <li><a href="#理解自限定">理解自限定</a></li>
            <li><a href="#自限定与协变">自限定与协变</a>
              <ul>
                <li><a href="#协变返回类型">协变返回类型</a></li>
                <li><a href="#协变参数类型">协变参数类型</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#捕获转换">捕获转换</a></li>
      </ul>
    </li>
    <li><a href="#引入泛型后java的类型体系">引入泛型后Java的类型体系</a>
      <ul>
        <li><a href="#泛型的相关类型">泛型的相关类型</a>
          <ul>
            <li><a href="#parameterizedtype">ParameterizedType</a></li>
            <li><a href="#typevariable">TypeVariable</a></li>
            <li><a href="#genericarraytype">GenericArrayType</a></li>
            <li><a href="#wildcardtype">WildcardType</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#泛型的编译期检查">泛型的编译期检查</a></li>
    <li><a href="#类型擦除">类型擦除</a>
      <ul>
        <li><a href="#引言c模板与java泛型">引言C++模板与Java泛型</a>
          <ul>
            <li><a href="#c模板">C++模板</a></li>
            <li><a href="#java泛型有点不太一样">Java泛型有点不太一样</a></li>
          </ul>
        </li>
        <li><a href="#介绍-1">介绍</a>
          <ul>
            <li><a href="#类型擦除机制编译时擦除为object">类型擦除机制（编译时擦除为Object）</a></li>
            <li><a href="#优势">优势</a></li>
            <li><a href="#缺陷">缺陷</a></li>
          </ul>
        </li>
        <li><a href="#代码片段1if一致">代码片段1（if一致）</a></li>
        <li><a href="#代码片段2type为泛型">代码片段2（Type为泛型）</a></li>
        <li><a href="#代码片段3泛型不能实例化">代码片段3（泛型不能实例化）</a></li>
        <li><a href="#代码片段4内部一致性边界动作">代码片段4（内部一致性，边界动作）</a></li>
        <li><a href="#代码片段5内部一致性输入输出">代码片段5（内部一致性，输入输出）</a></li>
        <li><a href="#字节码分析">字节码分析</a></li>
        <li><a href="#擦除的补偿解决擦除问题">擦除的补偿（解决擦除问题）</a>
          <ul>
            <li><a href="#问题示例">问题示例</a></li>
            <li><a href="#引入类型标签使用动态的isinstance代替instanceof">引入类型标签，使用动态的isInstance()代替instanceof</a></li>
            <li><a href="#代码片段6classnewinstance">代码片段6（Class.newInstance）</a></li>
            <li><a href="#代码片段7用arraylist代替数组或者是传入类型标记">代码片段7（用ArrayList代替数组，或者是传入类型标记）</a></li>
          </ul>
        </li>
        <li><a href="#真的完全擦除了吗">真的完全擦除了吗</a>
          <ul>
            <li><a href="#字节码分析签名">字节码分析签名</a>
              <ul>
                <li><a href="#泛型签名信息">泛型签名信息</a>
                  <ul>
                    <li><a href="#类上的泛型签名信息">类上的泛型签名信息</a></li>
                    <li><a href="#成员变量上的泛型签名信息">成员变量上的泛型签名信息</a></li>
                    <li><a href="#方法上的泛型签名信息">方法上的泛型签名信息</a></li>
                    <li><a href="#静态方法的上的泛型签名信息">静态方法的上的泛型签名信息</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#获取签名信息">获取签名信息</a>
              <ul>
                <li><a href="#附加的签名信息特定场景下反射可以获取">附加的签名信息特定场景下反射可以获取</a></li>
                <li><a href="#gson中泛型签名的应用">Gson中泛型签名的应用</a></li>
                <li><a href="#泛型混淆签名问题混淆后签名找不到了导致反射后拿不到">泛型混淆，签名问题，混淆后签名找不到了，导致反射后拿不到</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#retrofit库对泛型的应用">retrofit库对泛型的应用</a></li>
    <li><a href="#回顾">回顾</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="介绍">介绍</h2>
<h3 id="引言">引言</h3>
<p>Java语言的泛型采用的是 类型<strong>擦除法</strong>实现的 <strong>伪泛型</strong>，泛型信息（类型变量、参数化类型）编译之后通通被除掉了。但是不可能完全擦除，因为运行时还是要知道泛型的真实类型的，那这个真是类型是如何存储的，又如何能拿到？顺着这个问题可以把Java内存划分、类文件结构和对象内存布局串联起来。</p>
<h3 id="泛型的基本概念">泛型的基本概念</h3>
<p>Java 泛型（generics）是 JDK 1.5 中引入的一个新特性,泛型提供了编译时类型安全检测机制，该机制允许程序在编译期检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<h3 id="参数化类型的意义">参数化类型的意义</h3>
<p>参数化类型的意义是将原来具体的类型参数化，类似方法中的变量参数，此时类型也可以定义成参数形式。</p>
<p>比如JDK集合包的List接口，这里的T可以称为类型形参，在使用/调用时可以传入具体的类型(类型实参)。</p>
<p>泛型的引入实现了在不创建新的类型的情况下，通过泛型指定不同类型来控制形参具体限制的类型。也就是说在泛型的使用过程中，操作的数据类型被指定为了一个类型参数。</p>
<h3 id="泛型可以在哪里使用语法总结">泛型可以在哪里使用（语法总结）</h3>
<p>泛型可以使用在类、接口、方法和构造器中。</p>
<p>泛型的声明 都是在Class类型后面紧跟一个&lt;&gt;符号，在&lt;&gt;内可以定义1至多个类型参数;泛型可以使用统配符 **?**表示无边界类型，另外可以使用 extends 、super 操作符 分别定义泛型的上界或者下界。</p>
<h3 id="那泛型有什么用意义">那泛型有什么用（意义）</h3>
<p>可能就有小伙伴疑惑了，上面的泛型好像并没有什么用，我直接写下面这种手动擦除的代码不行吗。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manipulator3</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">HasF</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Manipulator3</span><span class="o">(</span><span class="n">HasF</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">manipulate</span><span class="o">()</span> <span class="o">{</span> <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这提出了很重要的一点：只有当你希望使用的类型参数比某个具体类型（以及它的所有子类型）更加泛化化时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。</p>
<p>泛型参数和他们在有用的泛型代码中的应用，通常比简单的替换来的更复杂。例如，如果某个类有一个返回T的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型。</p>
<p>例如对于下面两种写法，泛型的写法可以不用强制转换类型。编译器会 <strong>在编译期执行类型检查并插入转型代码</strong>。理解编译器对泛型的处理非常重要。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// SimpleHolder.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">obj</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SimpleHolder</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleHolder</span><span class="o">();</span>
        <span class="n">Holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;Item&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">string</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">Holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// GenericHolder.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericHolder</span><span class="o">&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">obj</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericHolder</span><span class="o">&lt;&gt;();</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;Item&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实它们生成的字节码是完全相同的。对进入set()的类型检查是不需要的，因为这是由编译器执行的，而对从get()返回的值进行转型仍旧是需要的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">GenericHolder</span><span class="o">();</span>
    <span class="n">Code</span><span class="o">:</span>
        <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
        <span class="n">1</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">1</span>                  <span class="c1">// Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>        <span class="n">4</span><span class="o">:</span> <span class="k">return</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span><span class="o">);</span>
    <span class="n">Code</span><span class="o">:</span>
        <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
        <span class="n">1</span><span class="o">:</span> <span class="n">aload_1</span>
        <span class="n">2</span><span class="o">:</span> <span class="n">putfield</span>      <span class="err">#</span><span class="n">2</span>                  <span class="c1">// Field obj:Ljava/lang/Object;
</span><span class="c1"></span>        <span class="n">5</span><span class="o">:</span> <span class="k">return</span>

<span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
    <span class="n">Code</span><span class="o">:</span>
        <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
        <span class="n">1</span><span class="o">:</span> <span class="n">getfield</span>      <span class="err">#</span><span class="n">2</span>                  <span class="c1">// Field obj:Ljava/lang/Object;
</span><span class="c1"></span>        <span class="n">4</span><span class="o">:</span> <span class="n">areturn</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
    <span class="n">Code</span><span class="o">:</span>
        <span class="n">0</span><span class="o">:</span> <span class="k">new</span>           <span class="err">#</span><span class="n">3</span>                  <span class="c1">// class GenericHolder
</span><span class="c1"></span>        <span class="n">3</span><span class="o">:</span> <span class="n">dup</span>
        <span class="n">4</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">4</span>                  <span class="c1">// Method &#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>        <span class="n">7</span><span class="o">:</span> <span class="n">astore_1</span>
        <span class="n">8</span><span class="o">:</span> <span class="n">aload_1</span>
        <span class="n">9</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="n">5</span>                  <span class="c1">// String Item
</span><span class="c1"></span>       <span class="n">11</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="n">6</span>                  <span class="c1">// Method set:(Ljava/lang/Object;)V
</span><span class="c1"></span>       <span class="n">14</span><span class="o">:</span> <span class="n">aload_1</span>
       <span class="n">15</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="n">7</span>                  <span class="c1">// Method get:()Ljava/lang/Object;
</span><span class="c1"></span>       <span class="n">18</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="n">8</span>                  <span class="c1">// class java/lang/String
</span><span class="c1"></span>       <span class="n">21</span><span class="o">:</span> <span class="n">astore_2</span>
       <span class="n">22</span><span class="o">:</span> <span class="k">return</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出，使用泛型机制编写的代码要比哪些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型是我们需要的程序设计手段。</p>
<h2 id="泛型的使用和类型擦除">泛型的使用和类型擦除</h2>
<p>泛型本质上是参数化类型(paramentersized type)的应用，可以声明在类、接口或者方法上。没有泛型时可以用<code>Object</code>结合强制类型转化实现相似需求，但是运行时风险就明显了，泛型就是用于解决这个问题的。</p>
<p>Java泛型并没有真的新增类型，<code>List&lt;String&gt;和List&lt;Int&gt;</code>在编译后都是<code>List</code>，依靠的是<a href="https://kkkpjskey.github.io/java-generic-note/#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4" target="_blank" rel="noopener noreferrer">类型擦除</a>和强制转换来实现的。</p>
<h3 id="在字节码文件中的形式">在字节码文件中的形式</h3>
<p>这里只简单介绍下相关基础，Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件中。</p>
<p>结构中只有无符号数和表两种结构，无符号数描述数字、索引引用、数量值等，表由无符号数和其它表组合。</p>
<p>文件中依次为Class版本、常量池、访问标志、父类信息、字段表、方法表等。类、字段表、方法表等都有属性表，在属性表中有个Signature属性就是用于记录泛型签名信息的。</p>
<p>属性表中有个Code属性，即是方法编译成后的字节码指令序列，泛型擦除仅仅是擦除Code表中的泛型信息。</p>
<h3 id="在内存中的形式">在内存中的形式</h3>
<p>直接指针模型，对象在堆内存中有对象头和对象实例两部分，对象头包括mark word和类型指针两部分。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./3.webp"
        data-srcset="./3.webp, ./3.webp 1.5x, ./3.webp 2x"
        data-sizes="auto"
        alt="./3.webp"
        title="3" /></p>
<center>Java内存模型</center>
<p>泛型信息以参数化类型信息(paramentersized typ)的方式存储在对象类型实例(即方法区中的Class)中，各种泛型实例的类型指针都指向方法区中同一class类型实例。</p>
<h2 id="分类">分类</h2>
<h3 id="泛型类">泛型类</h3>
<p>不用泛型的容器类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Container</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Container</span><span class="o">(</span><span class="n">String</span> <span class="n">k</span><span class="o">,</span> <span class="n">String</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Container类保存了一对key-value键值对，但是类型是定死的，也就说如果我想要创建一个键值对是String-Integer类型的，当前这个Container是做不到的，必须再自定义。那么这明显重用性就非常低。</p>
<p>当然，我可以用Object来代替String，并且在Java  SE5之前，我们也只能这么做，由于Object是所有类型的基类，所以可以直接转型。但是这样灵活性还是不够，因为还是指定类型了，只不过这次指定的类型层级更高而已，有没有可能不指定类型？有没有可能在运行时才知道具体的类型是什么？</p>
<p>这，就是泛型出现的意义！</p>
</blockquote>
<h4 id="示例代码">示例代码：</h4>
<p>使用泛型的容器类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Container</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">V</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Container</span><span class="o">(</span><span class="n">K</span> <span class="n">k</span><span class="o">,</span> <span class="n">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">V</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在编译期，是无法知道K和V具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。可以看一下现在Container类对于不同类型的支持情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Container</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;findingsea&#34;</span><span class="o">);</span>
        <span class="n">Container</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="s">&#34;age&#34;</span><span class="o">,</span> <span class="n">24</span><span class="o">);</span>
        <span class="n">Container</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">c3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;(</span><span class="n">1</span><span class="o">.</span><span class="na">1</span><span class="o">,</span> <span class="n">2</span><span class="o">.</span><span class="na">2</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; : &#34;</span> <span class="o">+</span> <span class="n">c1</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c2</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; : &#34;</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c3</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; : &#34;</span> <span class="o">+</span> <span class="n">c3</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<blockquote>
<p>name : findingsea 
age : 24 
1.1 : 2.2</p>
</blockquote>
<p>我们可以在Java类上定义泛型，最常见的比如JDK中的集合类 <code>List</code>、<code>Map&lt;K,V&gt;</code>等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">add</span><span class="o">(</span><span class="n">size</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="泛型接口">泛型接口</h3>
<h4 id="示例代码-1">示例代码：</h4>
<p>在泛型接口中，生成器是一个很好的理解，看如下的生成器接口定义:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">next</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后定义一个生成器类来实现这个接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitGenerator</span> <span class="kd">implements</span> <span class="n">Generator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">String</span><span class="o">[]</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">&#34;Apple&#34;</span><span class="o">,</span> <span class="s">&#34;Banana&#34;</span><span class="o">,</span> <span class="s">&#34;Pear&#34;</span><span class="o">};</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">fruits</span><span class="o">[</span><span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">3</span><span class="o">)];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FruitGenerator</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitGenerator</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">generator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">generator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">generator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">generator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Banana</span>
<span class="n">Banana</span>
<span class="n">Pear</span>
<span class="n">Banana</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="泛型方法">泛型方法</h3>
<blockquote>
<p>一个基本的编程原则是：</p>
<p>无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛化，那么应该有限采用泛型方法。</p>
</blockquote>
<h4 id="示例代码-2">示例代码：</h4>
<p>下面来看一个简单的泛型方法的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">(</span><span class="s">&#34;findingsea&#34;</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">123</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">11</span><span class="o">.</span><span class="na">11</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到方法的参数彻底泛化了，这个过程涉及到编译器的类型推导和自动打包，也就说原来需要我们自己对类型进行的判断和处理，现在编译器帮我们做了。这样在定义方法的时候不必考虑以后到底需要处理哪些类型的参数，大大增加了编程的灵活性。</p>
<p>再看一个泛型方法和可变参数的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="n">T</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">(</span><span class="s">&#34;findingsea&#34;</span><span class="o">,</span> <span class="n">123</span><span class="o">,</span> <span class="n">11</span><span class="o">.</span><span class="na">11</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以在方法上定义泛型，此时该泛型的作用域只在该方法中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>比如JDK中Collections的sort函数在&lt;&gt;内声明了一个泛型T,在函数的第二个参数的类型声明为Comparator&lt;? super T&gt;,使用了 super 操作符 对Comparator接口的泛形参数做了下界限制，这样任何能够处理T类及其父类的Comparator都可以作为一个合法的参数，拓宽了这个函数的使用场景。</p>
<h2 id="泛型通配符及上下边界">泛型通配符及上下边界</h2>
<h3 id="引言-1">引言</h3>
<blockquote>
<p>思考这种情形</p>
</blockquote>
<p>　我们先定义一个水果类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fruit</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Fruit</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>　　然后再定义一个苹果类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Apple</span> <span class="kd">extends</span> <span class="n">Fruit</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Apple</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>　　接下来定义一个泛型容器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericHolder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericHolder</span><span class="o">(){}</span>

    <span class="kd">public</span> <span class="nf">GenericHolder</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getObj</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObj</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>　　接下来开始我们的测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * 吃水果
</span><span class="cm">     * @param fruitHolder
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">eatFruit</span><span class="o">(</span><span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">fruitHolder</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我正在吃 &#34;</span> <span class="o">+</span> <span class="n">fruitHolder</span><span class="o">.</span><span class="na">getObj</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
        <span class="c1">//这是一个贴了水果标签的袋子
</span><span class="c1"></span>        <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">fruitHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;();</span>
        <span class="c1">//这是一个贴了苹果标签的袋子
</span><span class="c1"></span>        <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;</span> <span class="n">appHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
        <span class="c1">//这是一个水果
</span><span class="c1"></span>        <span class="n">Fruit</span> <span class="n">fruit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fruit</span><span class="o">(</span><span class="s">&#34;水果&#34;</span><span class="o">);</span>
        <span class="c1">//这是一个苹果
</span><span class="c1"></span>        <span class="n">Apple</span> <span class="n">apple</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">(</span><span class="s">&#34;苹果&#34;</span><span class="o">);</span>

        <span class="c1">//现在我们把水果放进去
</span><span class="c1"></span>        <span class="n">fruitHolder</span><span class="o">.</span><span class="na">setObj</span><span class="o">(</span><span class="n">fruit</span><span class="o">);</span>
        <span class="c1">//调用一下吃水果的方法
</span><span class="c1"></span>        <span class="n">eatFruit</span><span class="o">(</span><span class="n">fruitHolder</span><span class="o">);</span>

        <span class="c1">//贴了水果标签的袋子放水果当然没有问题
</span><span class="c1"></span>        <span class="c1">//现在我们把水果的子类——苹果放到这个袋子里看看
</span><span class="c1"></span>        <span class="n">fruitHolder</span><span class="o">.</span><span class="na">setObj</span><span class="o">(</span><span class="n">apple</span><span class="o">);</span>
        <span class="c1">//同样是可以的，其实这时候会发生自动向上转型，apple向上转型为Fruit类型后再传入fruitHolder中
</span><span class="c1"></span>        <span class="c1">//但不能再将取出来的对象赋值给redApple了
</span><span class="c1"></span>        <span class="c1">//因为袋子的标签是水果，所以取出来的对象只能赋值给水果类的变量
</span><span class="c1"></span>        <span class="c1">//无法通过编译检测 redApple = fruitHolder.getObj();
</span><span class="c1"></span>        <span class="n">eatFruit</span><span class="o">(</span><span class="n">fruitHolder</span><span class="o">);</span>

        <span class="c1">//放苹果的标签，自然只能放苹果
</span><span class="c1"></span>        <span class="n">appHolder</span><span class="o">.</span><span class="na">setObj</span><span class="o">(</span><span class="n">apple</span><span class="o">);</span>
        <span class="c1">// 这时候无法把appHolder 传入eatFruit
</span><span class="c1"></span>        <span class="c1">// 因为GenericHolder&lt;Fruit&gt; 和 GenericHolder&lt;Apple&gt;是两种不同的类型
</span><span class="c1"></span>        <span class="c1">// eatFruit(appHolder);
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>　　运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">我正在吃 水果
我正在吃 苹果
</code></pre></td></tr></table>
</div>
</div><h3 id="原理">原理</h3>
<p>　　在这里，我们往eatFruit方法里传入fuitHolder的时候，是可以正常编译的，但是如果将appHolder传入，就无法通过编译了，因为作为参数时，<code>GenericHolder&lt;Fruit&gt;</code> 和 <code>GenericHolder&lt;Apple&gt;</code>是两种不同的类型，所以无法通过编译，那么问题来了，如果我想让eatFruit方法能同时处理<code>GenericHolder&lt;Fruit&gt;</code> 和 <code>GenericHolder&lt;Apple&gt;</code>两种类型怎么办？而且这也是很合理的需求，毕竟Apple是Fruit的子类，能吃水果，为啥不能吃苹果？？？如果要把这个方法重载一次，未免也有些小题大做了（而且事实上也无法通过编译，具体原因之后会有说明）。</p>
<p>　　在代码的逻辑里：</p>
<ul>
<li>苹果 <em>IS-A</em> 水果</li>
<li>装苹果的盘子 <em>NOT-IS-A</em> 装水果的盘子</li>
</ul>
<p>　　这个时候，泛型的边界符就有它的用武之地了。我们先来看效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * 吃水果
</span><span class="cm">     * @param fruitHolder
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">eatFruit</span><span class="o">(</span><span class="n">GenericHolder</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">fruitHolder</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我正在吃 &#34;</span> <span class="o">+</span> <span class="n">fruitHolder</span><span class="o">.</span><span class="na">getObj</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
        <span class="c1">//这是一个贴了水果标签的袋子
</span><span class="c1"></span>        <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">fruitHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;();</span>
        <span class="c1">//这是一个贴了苹果标签的袋子
</span><span class="c1"></span>        <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;</span> <span class="n">appHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericHolder</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
        <span class="c1">//这是一个水果
</span><span class="c1"></span>        <span class="n">Fruit</span> <span class="n">fruit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fruit</span><span class="o">(</span><span class="s">&#34;水果&#34;</span><span class="o">);</span>
        <span class="c1">//这是一个苹果
</span><span class="c1"></span>        <span class="n">Apple</span> <span class="n">apple</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">(</span><span class="s">&#34;苹果&#34;</span><span class="o">);</span>

        <span class="c1">//现在我们把水果放进去
</span><span class="c1"></span>        <span class="n">fruitHolder</span><span class="o">.</span><span class="na">setObj</span><span class="o">(</span><span class="n">fruit</span><span class="o">);</span>
        <span class="c1">//调用一下吃水果的方法
</span><span class="c1"></span>        <span class="n">eatFruit</span><span class="o">(</span><span class="n">fruitHolder</span><span class="o">);</span>

        <span class="c1">//放苹果的标签，自然只能放苹果
</span><span class="c1"></span>        <span class="n">appHolder</span><span class="o">.</span><span class="na">setObj</span><span class="o">(</span><span class="n">apple</span><span class="o">);</span>
        <span class="c1">// 这时候可以顺利把appHolder 传入eatFruit
</span><span class="c1"></span>        <span class="n">eatFruit</span><span class="o">(</span><span class="n">appHolder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>　　运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">我正在吃 水果
我正在吃 苹果
</code></pre></td></tr></table>
</div>
</div><p>　　这里我们只是使用了一点小小的魔法，把参数类型改成了<code>GenericHolder&lt;? extends Fruit&gt;</code>，这样就能将 <code>GenericHolder&lt;Apple&gt;</code>类型的参数顺利传入了，怎么样？很好用吧，这就是泛型的边界符，用&lt;? extends Fruit&gt;的形式表示。边界符的意思，自然就是定义一个边界，这里用？表示传入的泛型类型不是固定类型，而是符合规则范围的所有类型，用extends关键字定义了一个上边界，也就是说这里的？可以代表任何继承于Fruit的类型，你也许会问，为什么是上边界，好问题，一图胜千言：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1.jpg"
        data-srcset="./1.jpg, ./1.jpg 1.5x, ./1.jpg 2x"
        data-sizes="auto"
        alt="./1.jpg"
        title="1" /></p>
<p>　　从这个图可以很好的看出这个“上边界”的概念了吧。有上边界，自然有下边界，泛型里使用形如&lt;? super Fruit&gt;的方式使用下边界，此时，？只能代表Fruit及其父类。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./2.jpg"
        data-srcset="./2.jpg, ./2.jpg 1.5x, ./2.jpg 2x"
        data-sizes="auto"
        alt="./2.jpg"
        title="2" /></p>
<p>　　这两种方式基本上解决了我们之前的问题，但是同时，也有一定的限制。</p>
<p>0.无边界的通配符(Unbounded Wildcards), 就是<code>&lt;?&gt;</code>, 比如<code>Class&lt;?&gt;</code>。无边界的通配符的主要作用就是让泛型能够接受未知类型的数据。</p>
<p>1.固定上边界的通配符(Upper Bounded Wildcards):<code>&lt;? extends T&gt;</code>不能往里存，只能往外取</p>
<p>　　可以指定某个类型及其子类类型. 要声明使用该类通配符, 采用 <code>&lt;? extends T&gt;</code> 的形式, 这里的T就是该泛型的上边界。</p>
<p>​		不要太疑惑，其实很好理解，因为编译器只知道容器里的是Fruit或者Fruit的子类，但不知道它具体是什么类型，所以存的时候，无法判断是否要存入的数据的类型与容器种的类型一致，所以会拒绝set操作。</p>
<p>2.固定下边界的通配符(Lower Bounded Wildcards):<code>&lt;? super T&gt;</code>往外取只能赋值给Object变量，不影响往里存</p>
<p>　　可以指代某个类型及其父类类型. 要声明使用该类通配符, 采用<code>&lt;? super E&gt;</code>的形式, 这里的E就是该泛型的下边界</p>
<p>​		因为编译器只知道它是Fruit或者它的父类，这样实际上是放松了类型限制，Fruit的父类一直到Object类型的对象都可以往里存，但是取的时候，就只能当成Object对象使用了。</p>
<p>　　所以如果需要经常往外读，则使用<code>&lt;? extends T&gt;</code>，如果需要经常往外取，则使用<code>&lt;? super T&gt;</code>。</p>
<h2 id="协变与逆变">协变与逆变</h2>
<h3 id="定义">定义</h3>
<p><strong>逆变与协变用来描述类型转换（type transformation）后的继承关系</strong>，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类）
f(⋅)是 **逆变（contravariant）**的，当A≤B时有f(B)≤f(A)成立；
f(⋅)是 **协变（covariant）**的，当A≤B时有f(A)≤f(B)成立；
f(⋅)是 **不变（invariant）**的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</p>
<h4 id="数组是协变的">数组是协变的</h4>
<p>Java中数组是协变的，可以向子类型的数组赋予基类型的数组引用，请看下面代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// CovariantArrays.java
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Fruit</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Apple</span> <span class="kd">extends</span> <span class="n">Fruit</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Jonathan</span> <span class="kd">extends</span> <span class="n">Apple</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Orange</span> <span class="kd">extends</span> <span class="n">Fruit</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CovariantArrays</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Fruit</span><span class="o">[]</span> <span class="n">fruit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">[</span><span class="n">10</span><span class="o">];</span>
        <span class="n">fruit</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">();</span>
        <span class="n">fruit</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jonathan</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">fruit</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fruit</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">fruit</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Orange</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>main()中第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用。编译器允许你把Fruit放置到这个数组中，这对于编译器是有意义的，因为它是一个Fruit引用——它有什么理由不允许将Fruit对象或者任何从Fruit继承出来的对象（例如Orange），放置到这个数组中呢？</p>
<p>可能有同学会疑惑，明明Fruit[]引用的是一个Apple数组，编译器看不出来吗？还允许往里面放Fruit和Orange类的对象。你要站在编译器的角度看问题，编译器可没有人这么聪明。现代编译器大多采用的是上下文无关文法（编译器：老子归约一句是一句），符号表中存储的标识符fruit是Fruit[]类型（不然咱还怎么多态），在以后的解析过程中编译器看到fruit只会认为是Fruit[]类型。</p>
<p>不过，尽管编译器允许了这样做，运行时的数组机制知道它处理的是Apple[]，因此会在向数组中放置异构类型时抛出异常。程序的运行结果如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ArrayStoreException</span><span class="o">:</span> <span class="n">generics</span><span class="o">.</span><span class="na">Fruit</span>
<span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ArrayStoreException</span><span class="o">:</span> <span class="n">generics</span><span class="o">.</span><span class="na">Orange</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="泛型是不变的">泛型是不变的</h4>
<p>当我们使用泛型容器来替代数组时，看看会发生什么。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonCovariantGenerics</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">flist</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span> <span class="c1">// 编译错误
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>直接在编译时报错了。与数组不同，泛型没有 <strong>内建的协变类型</strong>。这是因为数组在语言中是完全定义的，因此内建了编译期和运行时的检查，但是在使用泛型时，类型信息在编译期被擦除了（如果你不知道什么是擦除，可以去看这篇文章补补课<a href="https://www.jianshu.com/p/2bfbe041e6b7" target="_blank" rel="noopener noreferrer">类型擦除</a>），运行时也就无从检查。因此，泛型将这种错误检测移入到编译期。</p>
<h3 id="通配符引入协变逆变">通配符引入协变、逆变</h3>
<p>泛型的协变和逆变是什么？对应于Java当中，协变对应的就是<code>&lt;? extends XXX&gt;</code>，而逆变对应的就是<code>&lt;? super XXX&gt;</code>。</p>
<h4 id="泛型的协变">泛型的协变</h4>
<h5 id="泛型协变的使用">泛型协变的使用</h5>
<p>当我们有一个有方法，方法的签名定义成为如下的方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这时，如果我们想要给test方法传入一个<code>List&lt;Double&gt;</code>或者是<code>List&lt;Integer&gt;</code>可以吗？很显然不行，因为传递参数，肯定是要传递它的子类才行，但是<code>List&lt;Double&gt;</code>或者是<code>List&lt;Integer&gt;</code>是它的子类吗？很明显不是，这时我们就需要用到泛型的协变。</p>
<p>我们将方法的参数变成如下的这种形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Java泛型是不变的，可有时需要实现协变，在两个类型之间建立某种类型的向上转型关系，怎么办呢？</p>
<p>这时，如果我们想要给test方法传入一个<code>List&lt;Double&gt;</code>或者是<code>List&lt;Integer&gt;</code>可以吗？很显然不行，因为传递参数，肯定是要传递它的子类才行，但是<code>List&lt;Double&gt;</code>或者是<code>List&lt;Integer&gt;</code>是它的子类吗？很明显不是，这时通配符派上了用场，我们就需要用到泛型的协变。</p>
<p>我们将方法的参数变成如下的这种形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这时，我们的泛型，就只需要传入一个是Number的子类型的泛型即可。因为Integer和Double，它们都是Number的子类，因此很明显是合法的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">        <span class="n">test</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;());</span>
        <span class="n">test</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;());</span>
</code></pre></td></tr></table>
</div>
</div><p>在test方法中：</p>
<ul>
<li>1.如果我们想要去<strong>获取</strong>集合当中的某个元素时，因为约定了元素的所有类型都得是Number类型极其子类的，因此我们获取的元素一定可以用它们的共同父类Number去进行接收。</li>
<li>2.但是当我们想要往集合当中添加元素时，竟然无法往list当中添加元素？奇奇怪怪的！而且关键我们的list，只要求元素的类型是Number或者它的子类类型。但是我们加入的是1，是个Intger类型，很明显是符合规范的呀！</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Number</span> <span class="n">number</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>  <span class="c1">// right
</span><span class="c1"></span>        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// error
</span><span class="c1"></span>    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="泛型协变存在的问题">泛型协变存在的问题</h5>
<p>泛型的协变，不能让我们往集合当中添加元素。那么为什么不能添加呢？</p>
<p>要知道为什么，我们首先需要了解Java当中桥接方法的来由。</p>
<h6 id="java当中桥接方法的来由">Java当中桥接方法的来由</h6>
<p>我们首先定义如下的自定义ArrayList类，并重写了它的add方法，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyArrayList</span> <span class="kd">extends</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Double</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，我们肯定知道ArrayList类中的add方法的原型是下面这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>在Java当中，是在编译时去进行类型擦除的，在运行时并无泛型类型一说。也就是说，该原型方法，会被抹掉成为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Object</span> <span class="n">e</span><span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>但是，我们定义了自己的ArrayList，我们自己的add方法的原型为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Double</span> <span class="n">e</span><span class="o">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>这个两个方法的签名并不相同，但是当使用下的代码创建一个ArrayList时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">.</span><span class="na">0</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>它实际调用的方法的原型是<code>public boolean add(Object e)</code>，但是我们子类中的重写的方法的原型时什么？<code>public booleab add(Double e)</code>。</p>
<p>也就是说，通过父类的方法调用的和子类重写的方法，并不是同一个方法，因为它们连方法签名都不同。这时候，就需要要一个方式，将<code>public booleab add(Object e)</code>转到<code>public booleab add(Double e)</code>当中去执行。这时候，就会涉及到桥接方法的存在了。</p>
<p>Java的实现方式是：通过在Javac编译器编译时，为我们生成一个<code>public boolean add(Object e)</code>这样的方法，而这个方法当中，要做的实际上就是调用<code>public booleab add(Double e)</code>这个方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">add</span><span class="o">((</span><span class="n">Double</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过桥接方法的方式，就可以让我们能在针对泛型方法进行重写时，可以被JVM执行到。</p>
<h6 id="为什么泛型协变时不允许添加元素呢">为什么泛型协变时，不允许添加元素呢</h6>
<p><strong>例1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsAndCovariance</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">flist</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
        <span class="n">flist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Apple</span><span class="o">());</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>        <span class="n">flist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Fruit</span><span class="o">());</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>        <span class="n">flist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在flist的类型是<code>&lt;? extends Fruit&gt;</code>，extends指出了泛型的上界为Fruit，<code>&lt;? extends T&gt;</code>称为<strong>子类通配符</strong>，意味着某个继承自Fruit的具体类型。使用通配符可以将<code>ArrayList&lt;Apple&gt;</code>向上转型了，也就实现了协变。</p>
<p>然而，事情变得怪异了，观察上面代码，你再也不能往容器里放入任何东西，甚至连Apple都不行。</p>
<p>原因在于，<code>List&lt;? extends Fruit&gt;</code>也可以合法的指向一个<code>List&lt;Orange&gt;</code>，显然往里面放Apple、Fruit、Object都是非法的。编译器不知道<code>List&lt;? extends Fruit&gt;</code>所持有的具体类型是什么，所以一旦执行这种类型的向上转型，你就将丢失掉向其中传递任何对象的能力。</p>
<p>类比数组，尽管你可以把Apple[]向上转型成Fruit[]，然而往里面添加Fruit和Orange等对象都是非法的，会在运行时抛出ArrayStoreException异常。</p>
<p><strong>例2</strong></p>
<p>当我们使用下面的代码创建了一个我们自定义的MyArrayList对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyArrayList</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>这时，我们调用test方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">test</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>test方法对于list的泛型定义为<code>&lt;? entends Number&gt;</code>，理论上应该是可以往里面放入任何<code>Number</code>子类类型的元素的。但是别忘了，我们MyArrayList中对于方法的定义，是下面这样子的！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Object</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">add</span><span class="o">((</span><span class="n">Double</span><span class="o">)</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Double</span> <span class="n">e</span><span class="o">)</span>  <span class="o">{</span>
    <span class="c1">// ......
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果我们往集合当中添加一个Integer类型的1，走到桥接方法当中时会有<code>(Double)e</code>这样的强制类型转换，这不就是抛出了<code>ClassCastException</code>异常了吗？很明显，是不允许我们这样干的。</p>
<p><strong>结论</strong></p>
<p>因此Java的做法就是，泛型把类型检查移到了编译期，在编译期就去禁止这种做法，协变过程丢掉了类型信息，避免产生运行时的<code>ClassCastException</code>，编译器拒绝所有不安全的操作。</p>
<p>有的人也许会说</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyArrayList</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>我们创建list时，不是约束了泛型类型为<code>Double</code>了吗，为什么test方法内就不能默认它是Double的泛型呢？问题就是：我写test方法时，我怎么知道你传递的是<code>Double</code>类型的泛型，玩意别人传递的是Integer的泛型呢？所以很明显是行不通的。</p>
<h6 id="从java字节码的角度去看桥接方法">从Java字节码的角度去看桥接方法</h6>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./7.webp"
        data-srcset="./7.webp, ./7.webp 1.5x, ./7.webp 2x"
        data-sizes="auto"
        alt="./7.webp"
        title="7" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./8.webp"
        data-srcset="./8.webp, ./8.webp 1.5x, ./8.webp 2x"
        data-sizes="auto"
        alt="./8.webp"
        title="8" /></p>
<p>我们可以看到，Javac编译器，在对Java代码进行编译时，其实针对add方法去生成了两个方法，而它们的访问标识符并不相同。我们自己的方法的访问标识符为<code>0x0001[public]</code>，而Javac编译器为我们生成的桥接方法的返回值，为<code>0x1041[pubic synthetic bridge]</code>，多了两个访问标识符<code>synthetic</code>和<code>bridge</code>。</p>
<p>我们打开桥接方法的code字节码</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./9.webp"
        data-srcset="./9.webp, ./9.webp 1.5x, ./9.webp 2x"
        data-sizes="auto"
        alt="./9.webp"
        title="9" /></p>
<p>我们来分析下字节码</p>
<ul>
<li>1.<code>aload_0</code>，众所周知，就是从LocalVariableTable(局部变量表)获取this对象的引用，并压栈。</li>
<li>2.<code>aload_1</code>，自然就是将传入的元素e的引用压栈。</li>
<li>3.<code>checkcast #3 &lt;java/lang/Double&gt;</code>，自然是检查能否执行强制类型转换。</li>
<li>4.<code>invokevirtual #4 &lt;com/wanna/generics/java/MyArrayList.add : (Ljava/lang/Double;)Z&gt;</code>，做到实际上就是从常量池的4号元素当中拿到要执行的方法，也就是我们自己实现的方法。<code>invokevirtual</code>就是执行目标方法，没毛病。</li>
<li>5.<code>ireturn</code>，自然就是返回一个int类型的值，为什么是int类型？而不是boolean类型？因为Java当中，在存放到局部变量表和栈中的情况下，int/byte/boolean/char，都是使用的int的形式存放的，占用一个局部变量表的槽位。</li>
</ul>
<p>我们通过分析得到的信息和我们之前的分析一致，就是通过桥接方法桥接一下，去调用我们自己实现的方法。我们接下来，尝试使用反射的方式去获取到add方法有几个，方法信息是什么。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">MyArrayList</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethods</span><span class="o">()).</span><span class="na">filter</span><span class="o">(</span><span class="n">method</span> <span class="o">-&gt;</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;add&#34;</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterCount</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">method</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;方法名为：%s，方法的返回值类型为：%s，方法的参数列表为：%s%n&#34;</span><span class="o">,</span>
                    <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">(),</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">()));</span>
        <span class="o">});</span>
</code></pre></td></tr></table>
</div>
</div><p>代码的最终执行结果为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">方法名为</span><span class="err">：</span><span class="n">add</span><span class="err">，</span><span class="n">方法的返回值类型为</span><span class="err">：</span><span class="kt">boolean</span><span class="err">，</span><span class="n">方法的参数列表为</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Double</span><span class="o">]</span>
<span class="n">方法名为</span><span class="err">：</span><span class="n">add</span><span class="err">，</span><span class="n">方法的返回值类型为</span><span class="err">：</span><span class="kt">boolean</span><span class="err">，</span><span class="n">方法的参数列表为</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，生成的桥接方法，是我们可以通过反射拿到的，它是一个真实的方法。</p>
<p>通过反射拿到<code>Method</code>之后，我们还可以通过访问标识符判断该方法是否是桥接方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">method</span><span class="o">.</span><span class="na">isBridge</span><span class="o">()</span> 
<span class="n">method</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">()</span>
</code></pre></td></tr></table>
</div>
</div><p>判断桥接方法，实际上，在Spring框架当中的反射工具类(<code>ReflectionUtils</code>)当中就有用到，用来判断一个方法是否是用户定义的方法。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./10.webp"
        data-srcset="./10.webp, ./10.webp 1.5x, ./10.webp 2x"
        data-sizes="auto"
        alt="./10.webp"
        title="10" /></p>
<h4 id="泛型逆变">泛型逆变</h4>
<h5 id="泛型逆变的使用">泛型逆变的使用</h5>
<p>我们还可以走另外一条路，就是逆变。</p>
<p>泛型逆变的泛型形式是： <code>&lt;? super XXX&gt;</code>，它的作用是赋值给它的约束容器的泛型类型，只能是 <code>XXX</code>以及它的父类。</p>
<p>那么我们可以往容器里放入它的子类吗？也许会说，上面不是都说了需要放入的是 <code>XXX</code>以及它的父类吗，那肯定是不能放入它的子类的呀！但是我们需要想到一个问题，那就是 <code>XXX</code>的所有子类，其实都是可以隐式转换为 <code>XXX</code>类型，或者可以直接说，它的子类就是 <code>XXX</code>类型。</p>
<p>例1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SuperTypeWildcards</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">writeTo</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Apple</span><span class="o">&gt;</span> <span class="n">apples</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">apples</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Apple</span><span class="o">());</span>
        <span class="n">apples</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Jonathan</span><span class="o">());</span>
        <span class="n">apples</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Fruit</span><span class="o">());</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们重用了关键字super指出泛型的下界为Apple，<code>&lt;？ super T&gt;</code>称为<strong>超类通配符</strong>，代表一个具体类型，而这个类型是Apple的超类。这样编译器就知道向其中添加Apple或Apple的子类型（例如Jonathan）是安全的了。但是，既然Apple是下界，那么可以知道向这样的List中添加Fruit是不安全的。</p>
<p><strong>例2</strong></p>
<p>我们依次定义三个类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">extends</span> <span class="n">Person</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="n">User</span> <span class="o">{</span>

    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接着，定义一个使用逆变的泛型参数的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">User</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面我们说了，可以接收的容器泛型类型是User以及它的父类，也就是说，容器的泛型可以是User也基于是Person。因此，我们可以传入下面这样的容器给test方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">        <span class="n">test</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;());</span>
</code></pre></td></tr></table>
</div>
</div><p>在test方法当中，我们可以执行下面的才做</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">User</span><span class="o">());</span> <span class="c1">// 放入User
</span><span class="c1"></span>        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">());</span>  <span class="c1">// 放入User的子类
</span></code></pre></td></tr></table>
</div>
</div><h5 id="泛型逆变会有什么问题">泛型逆变会有什么问题</h5>
<p>我们需要想想一个问题：我们使用了逆变约定了，接收的容器的泛型类型是User以及User的父类。我们往容器当中放入的元素，可以是User以及User的子类。也就是说，我们获取容器中的元素时，根本不知道是什么类型， <strong>只能用Object去接收从容器中获取的元素类型</strong>，因为只是约定了容器的泛型为User和User的父类，而Object也是它的父类，因此我们甚至可以传入一个容器类型为 <code>ArrayList&lt;object&gt;&lt;/object&gt;</code>，我们根本无法决定元素类型的上限，只能用Object去进行接收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>现在又有一个问题：之前协变时，会出现因为执行桥接方法时，发生类型转换异常，在逆变当中会出现这种情况吗？</p>
<p>我们仔细想想，接收的容器泛型类型为User以及User的父类，而可以往容器里存放的是User以及User的子类，也就是说，我们放入到容器中的元素类型，比你原来约束的类型还严格，因为：&ldquo;User以及User的子类&quot;一定是&quot;User以及User的父类&quot;的子类。也就是说，逆变当中，并不会因为桥接方法中进行的类型导致 <code>ClassCastException</code>，所以允许add。</p>
<p>对于协变和逆变，有这样的一个原则：称为PECS(Producer Extends Consumer Super)。也就是说：</p>
<ul>
<li>1.Extends应该用在生产者的情况，也就是要根据泛型类型去返回对象的形式。</li>
<li>2.Super应该用在消费者的情况，应该传入一个泛型类型的容器，应该利用该容器对数据进行处理，但是不能根据泛型去进行返回，如果要进行返回，只能返回Object，但是这就失去了泛型的意义。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">testCS</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// Consumer Super
</span><span class="c1"></span>        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(...);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">testPE</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// Producer Extends
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="pecs">PECS</h3>
<p>上面说的可能有点绕，那么总结下：什么使用extends，什么时候使用super。《Effective Java》给出精炼的描述： <strong>producer-extends, consumer-super（PECS）</strong>。</p>
<p>说直白点就是，从数据流来看，extends是限制数据来源的（<strong>生产者</strong>），也就是要根据泛型类型去返回对象的形式。而super是限制数据流入的（<strong>消费者</strong>），应该传入一个泛型类型的容器，应该利用该容器对数据进行处理，但是不能根据泛型去进行返回，如果要进行返回，只能返回Object，但是这就失去了泛型的意义。</p>
<p>例如上面SuperTypeWildcards类里，使用<code>&lt;? super Apple&gt;</code>就是限制add方法传入的类型必须是Apple及其子类型。</p>
<p>仿照上面的代码，我写了个ExtendTypeWildcards类，可以看出<code>&lt;? extends Apple&gt;</code>限制了get方法返回的类型必须是Apple及其父类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExtendTypeWildcards</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">readFrom</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Apple</span><span class="o">&gt;</span> <span class="n">apples</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Apple</span> <span class="n">apple</span> <span class="o">=</span> <span class="n">apples</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="n">Jonathan</span> <span class="n">jonathan</span> <span class="o">=</span> <span class="n">apples</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>        <span class="n">Fruit</span> <span class="n">fruit</span> <span class="o">=</span> <span class="n">apples</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">testCS</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// Consumer Super
</span><span class="c1"></span>        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(...);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">testPE</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// Producer Extends
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="例子">例子</h4>
<p>框架和库代码中到处都是PECS，下面我们来看一些具体的例子，加深理解。</p>
<ul>
<li><strong>java.util.Collections的copy方法</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Collections.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">srcSize</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">srcSize</span> <span class="o">&gt;</span> <span class="n">dest</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&#34;Source does not fit in dest&#34;</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">srcSize</span> <span class="o">&lt;</span> <span class="n">COPY_THRESHOLD</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">src</span> <span class="k">instanceof</span> <span class="n">RandomAccess</span> <span class="o">&amp;&amp;</span> <span class="n">dest</span> <span class="k">instanceof</span> <span class="n">RandomAccess</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">srcSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">ListIterator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">di</span><span class="o">=</span><span class="n">dest</span><span class="o">.</span><span class="na">listIterator</span><span class="o">();</span>
        <span class="n">ListIterator</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">si</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="na">listIterator</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">srcSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">di</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">di</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">si</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>copy方法限制了拷贝源src必须是T或者是它的子类，而拷贝目的地dest必须是T或者是它的父类，这样就保证了类型的合法性。</p>
<ul>
<li><strong>Rxjava的变换</strong></li>
</ul>
<p>这里我们贴出一小段Rxjava2.0中map函数的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Observable.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Observable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ObjectHelper</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">mapper</span><span class="o">,</span> <span class="s">&#34;mapper is null&#34;</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">RxJavaPlugins</span><span class="o">.</span><span class="na">onAssembly</span><span class="o">(</span><span class="k">new</span> <span class="n">ObservableMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">mapper</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Function函数将<code>&lt;? super T&gt;</code>类型转变为<code>&lt;? extends R&gt;</code>类型（类似于代理模式的拦截器），可以看出extends和super分别限制输入和输出，它们可以是不同类型。</p>
<h3 id="自限定的类型">自限定的类型</h3>
<h4 id="理解自限定">理解自限定</h4>
<p>Java泛型中，有一个好像是经常性出现的惯用法，它相当令人费解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span> <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>SelfBounded类接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为其参数的SelfBounded，看起来是一种无限循环。</p>
<p>先给出结论：这种语法定义了一个基类，这个基类能够使用子类作为其参数、返回类型、作用域。为了理解这个含义，我们从一个简单的版本入手。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// BasicHolder.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BasicHolder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="n">element</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="n">element</span> <span class="o">=</span> <span class="n">arg</span><span class="o">;</span> <span class="o">}</span>
    <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">element</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// CRGWithBasicHolder.java
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Subtype</span> <span class="kd">extends</span> <span class="n">BasicHolder</span><span class="o">&lt;</span><span class="n">Subtype</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CRGWithBasicHolder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Subtype</span> <span class="n">st1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subtype</span><span class="o">(),</span> <span class="n">st2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subtype</span><span class="o">();</span>
        <span class="n">st1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">st2</span><span class="o">);</span>
        <span class="n">Subtype</span> <span class="n">st3</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">st1</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>  
<span class="cm">/* 程序输出
</span><span class="cm">Subtype
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>新类Subtype接受的参数和返回的值具有Subtype类型而不仅仅是基类BasicHolder类型。所以自限定类型的本质就是： <strong>基类用子类代替其参数</strong>。这意味着泛型基类变成了一种其所有子类的 <strong>公共功能模版</strong>，但是在所产生的类中将使用确切类型而不是基类型。因此，Subtype中，传递给set()的参数和从get() 返回的类型都确切是Subtype。</p>
<h4 id="自限定与协变">自限定与协变</h4>
<p>自限定类型的价值在于它们可以产生 <strong>协变参数类型</strong>——方法参数类型会随子类而变化。其实自限定还可以产生 <strong>协变返回类型</strong>，但是这并不重要，因为JDK1.5引入了协变返回类型。</p>
<h5 id="协变返回类型">协变返回类型</h5>
<p>下面这段代码子类接口把基类接口的方法重写了，返回更确切的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// CovariantReturnTypes.java
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Base</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Derived</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{}</span>

<span class="kd">interface</span> <span class="nc">OrdinaryGetter</span> <span class="o">{</span> 
    <span class="n">Base</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">DerivedGetter</span> <span class="kd">extends</span> <span class="n">OrdinaryGetter</span> <span class="o">{</span>
    <span class="n">Derived</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CovariantReturnTypes</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">DerivedGetter</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Derived</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>继承自定义类型基类的子类将产生确切的子类型作为其返回值，就像上面的get()一样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// GenericsAndReturnTypes.java
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">GenericsGetter</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">GenericsGetter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Getter</span> <span class="kd">extends</span> <span class="n">GenericsGetter</span><span class="o">&lt;</span><span class="n">Getter</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsAndReturnTypes</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="n">Getter</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Getter</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">GenericsGetter</span> <span class="n">genericsGetter</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="协变参数类型">协变参数类型</h5>
<p>在非泛型代码中，参数类型不能随子类型发生变化。方法只能 <strong>重载</strong>不能 <strong>重写</strong>。见下面代码示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// OrdinaryArguments.java
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">OrdinarySetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Base</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;OrdinarySetter.set(Base)&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">DerivedSetter</span> <span class="kd">extends</span> <span class="n">OrdinarySetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Derived</span> <span class="n">derived</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;DerivedSetter.set(Derived)&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrdinaryArguments</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Base</span> <span class="n">base</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Base</span><span class="o">();</span>
        <span class="n">Derived</span> <span class="n">derived</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="o">();</span>
        <span class="n">DerivedSetter</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedSetter</span><span class="o">();</span>
        <span class="n">ds</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">derived</span><span class="o">);</span>
        <span class="n">ds</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">base</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* 程序输出
</span><span class="cm">DerivedSetter.set(Derived)
</span><span class="cm">OrdinarySetter.set(Base)
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，在使用自限定类型时，在子类中只有一个方法，并且这个方法接受子类型而不是基类型为参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SelfBoundSetter</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBoundSetter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">args</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Setter</span> <span class="kd">extends</span> <span class="n">SelfBoundSetter</span><span class="o">&lt;</span><span class="n">Setter</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SelfBoundAndCovariantArguments</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">testA</span><span class="o">(</span><span class="n">Setter</span> <span class="n">s1</span><span class="o">,</span> <span class="n">Setter</span> <span class="n">s2</span><span class="o">,</span> <span class="n">SelfBoundSetter</span> <span class="n">sbs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">sbs</span><span class="o">);</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="捕获转换">捕获转换</h3>
<p><code>&lt;?&gt;</code>被称为<strong>无界通配符</strong>，无界通配符有什么作用这里不再详细说明了，理解了前面东西的同学应该能推断出来。无界通配符还有一个特殊的作用，如果向一个使用<code>&lt;?&gt;</code>的方法传递原生类型，那么对编译期来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法。这种技术被称为<strong>捕获转换</strong>。下面代码演示了这种技术。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CaptureConversion</span><span class="o">{</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">f1</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">holder</span><span class="o">){</span>
        <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">f2</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;?&gt;</span> <span class="n">holder</span><span class="o">){</span>
        <span class="n">f1</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="c1">//    @SuppressWarnings(&#34;unchecked&#34;)
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="n">Holder</span> <span class="n">raw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Holder</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">f1</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span><span class="c1">//Unchecked invocation f1(Holder) of the generic method f1(Holder&lt;T&gt;) of type
</span><span class="c1"></span>        <span class="n">f2</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span><span class="c1">//No warnings
</span><span class="c1"></span>        <span class="n">Holder</span> <span class="n">rawBasic</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Holder</span><span class="o">();</span>
        <span class="n">rawBasic</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span><span class="c1">//Type safety: The method set(Object) belongs to the raw type Holder. References to generic type Holder&lt;T&gt; should be parameterized
</span><span class="c1"></span>        <span class="n">f2</span><span class="o">(</span><span class="n">rawBasic</span><span class="o">);</span><span class="c1">//No warnings
</span><span class="c1"></span>        <span class="c1">//Upcast to Holder&lt;?&gt;, still figures out:
</span><span class="c1"></span>        <span class="n">Holder</span><span class="o">&lt;?&gt;</span> <span class="n">wildcarded</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Holder</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">1</span><span class="o">.</span><span class="na">0</span><span class="o">);</span>
        <span class="n">f2</span><span class="o">(</span><span class="n">wildcarded</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* 程序输出
</span><span class="cm">Integer
</span><span class="cm">Integer
</span><span class="cm">Object
</span><span class="cm">Double
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>获转换允许我们在处理通配符时绕开编译器的限制。当f2() 调用 f1() 时，它知道这么做是安全的，因为它自身的 holder  参数对一些未知的 V 而言一定是<code>Holder&lt;V&gt;</code>。同时类型参数 T  被引入到方法签名中并且没有绑定到其他任何类型参数，它也可以表示任何未知类型，因此，某些未知 T 的 <code>Holder&lt;T&gt;</code>  也可能是某些未知 V 的 <code>Box&lt;V&gt;</code>。</p>
<p>f1()中的类型参数都是确切的，没有通配符或者边界。在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的。但是，在f2()中，f1()被调用，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用。</p>
<p>捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。</p>
<p>注意：不能从f2()中返回T，因为T对于f2()来说是未知的。</p>
<p>一般来说，带有通配符的 API 比带有泛型方法的 API 更简单，在更复杂的方法声明中类型名称的增多会降低声明的可读性。因为在需要时始终可以通过专有的捕获转换来恢复名称，这个方法可以保持 API 整洁，同时不会删除有用的信息。</p>
<p>捕获转换十分有趣，但是非常受限。</p>
<h2 id="引入泛型后java的类型体系">引入泛型后Java的类型体系</h2>
<p>在引入泛型之前,Java只有所谓的原始类型(raw types),即在此之前所有的类类型都可以通过Class类进行抽象，Class 类的一个具体对象就代表一个指定的原始类型。</p>
<p>在引入泛型之后,为了将泛型类跟原始类型区分，Java引入了Type类型体系，在新的Type类型体系下，包含了
Class(原生类型)、ParameterizedType(参数化类型)、TypeVariable(类型变量类型)、WildcardType(包含通配符的类型)、GenericArrayType(泛型数组类型)、</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./4.png"
        data-srcset="./4.png, ./4.png 1.5x, ./4.png 2x"
        data-sizes="auto"
        alt="./4.png"
        title="4" /></p>
<h3 id="泛型的相关类型">泛型的相关类型</h3>
<h4 id="parameterizedtype">ParameterizedType</h4>
<p>ParameterizedType(参数化类型)形如Class&lt;Type…&gt;，比如 Collection 就是一个参数化类型。</p>
<h4 id="typevariable">TypeVariable</h4>
<p>TypeVariable 表示的是类型变量类型，比如List类型是参数化类型，这个参数化类型的第1个位置的参数类型是 T，这里的T类型是类型变量类型。</p>
<h4 id="genericarraytype">GenericArrayType</h4>
<p>GenericArrayType表示的是参数化类型或者类型变量的数组类型，形如：A[]或T[]的类型。</p>
<h4 id="wildcardtype">WildcardType</h4>
<p>包含通配符的类型，形如 ? 、 ? extends Number, ? super Long
比如List&lt;? extends User&gt;类型是一个WildcardType类型。</p>
<h2 id="泛型的编译期检查">泛型的编译期检查</h2>
<p>这里简单演示下，由泛型参数带来的编译时检查的特性。</p>
<p>在下面的代码中，我们创建了一个List，并添加Integer对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">array</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为List接口是一个参数化类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">//...
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用泛型改造一下最初的代码，我们希望List只接收Integer类型的对象，因此我们可以在定义List类型时加上泛型参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">sample1</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">array</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;1&#34;</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显 array.add(“1”) 是一段错误的代码，如果能够正常编译通过，那么在运行时可能会带来意想不到的结果，比如当我们从List中取出参数时 强转成成Integer类型会出现类型转化的异常。</p>
<p>我们先尝试使用 javac 编译文件，幸好编译器提前给出了代码的错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">GenericTest.java:10: 错误: 对于add<span class="o">(</span>int<span class="o">)</span>, 找不到合适的方法
        array.add<span class="o">(</span>1<span class="o">)</span><span class="p">;</span>
             ^
    方法 Collection.add<span class="o">(</span>String<span class="o">)</span>不适用
      <span class="o">(</span>参数不匹配<span class="p">;</span> int无法转换为String<span class="o">)</span>
    方法 List.add<span class="o">(</span>String<span class="o">)</span>不适用
      <span class="o">(</span>参数不匹配<span class="p">;</span> int无法转换为String<span class="o">)</span>
    方法 AbstractCollection.add<span class="o">(</span>String<span class="o">)</span>不适用
      <span class="o">(</span>参数不匹配<span class="p">;</span> int无法转换为String<span class="o">)</span>
    方法 AbstractList.add<span class="o">(</span>String<span class="o">)</span>不适用
      <span class="o">(</span>参数不匹配<span class="p">;</span> int无法转换为String<span class="o">)</span>
    方法 ArrayList.add<span class="o">(</span>String<span class="o">)</span>不适用
      <span class="o">(</span>参数不匹配<span class="p">;</span> int无法转换为String<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="类型擦除">类型擦除</h2>
<h3 id="引言c模板与java泛型">引言C++模板与Java泛型</h3>
<h4 id="c模板">C++模板</h4>
<p>下面是使用模板的C++示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">HasF</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;HasF::f()&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Manipulator</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Manipulator</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">manipulate</span><span class="p">()</span> <span class="p">{</span> <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">HasF</span> <span class="n">hf</span><span class="p">;</span>
    <span class="n">Manipulator</span><span class="o">&lt;</span><span class="n">HasF</span><span class="o">&gt;</span> <span class="n">manipulator</span><span class="p">(</span><span class="n">hf</span><span class="p">);</span>
    <span class="n">manipulator</span><span class="p">.</span><span class="n">manipulate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序运行无误，输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HasF</span><span class="o">::</span><span class="n">f</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们调用一个模板时，C++编译器用实参来为我们推断模板实参，并为我们 <strong>实例化</strong>（instantiate）一个特定版本的代码。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新&quot;实例&rdquo;。被编译器生成的版本通常称为模板的 <strong>实例</strong>。</p>
<p>对于上面代码，在编译时，编译器会将T替换成HasF并生成模板实例，类似于这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Manipulator</span> <span class="p">{</span>
    <span class="n">HasF</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Manipulator</span><span class="p">(</span><span class="n">HasF</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">manipulate</span><span class="p">()</span> <span class="p">{</span> <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="java泛型有点不太一样">Java泛型有点不太一样</h4>
<p>用C++编写这种代码很简单，因为当模板实例化时，模板代码知道其模板参数的类型，Java泛型就不同了。下面是HasF的Java版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// HasF.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HasF</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;HasF.f()&#34;</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Manipulation.java
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Manipulator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Manipulator</span><span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">manipulate</span><span class="o">()</span> <span class="o">{</span> <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// 编译错误
</span><span class="c1"></span><span class="o">}</span>
    
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manipulation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HasF</span> <span class="n">hf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HasF</span><span class="o">();</span>
        <span class="n">Manipulator</span><span class="o">&lt;</span><span class="n">HasF</span><span class="o">&gt;</span> <span class="n">manipulator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Manipulator</span><span class="o">(</span><span class="n">hf</span><span class="o">);</span>
        <span class="n">manipulator</span><span class="o">.</span><span class="na">manipulate</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码不能编译，报错</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&#34;main&#34;</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Error</span><span class="o">:</span> <span class="n">Unresolved</span> <span class="n">compilation</span> <span class="n">problem</span><span class="o">:</span> 
    <span class="n">The</span> <span class="n">method</span> <span class="nf">f</span><span class="o">()</span> <span class="n">is</span> <span class="n">undefined</span> <span class="k">for</span> <span class="n">the</span> <span class="n">type</span> <span class="n">T</span>
</code></pre></td></tr></table>
</div>
</div><p>从上面报错信息可以看出，编译器认为类型T没有f()方法。这是由于Java的泛型是使用擦除来实现的，意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。由于有了擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF拥有f()这一事实上。</p>
<p>从表面上看，Java的泛型类类似于C++的模板类，唯一明显的不同是Java没有专用的template关键字，但是，其实 <strong>这两种机制着本质的区别</strong>。</p>
<p>在第一个示例中，博主演示了 C++ 和 Java 中的泛型在编译时的不同表现。其中的关键就在于泛型 T 能否调用方法 f。C++  认为这是可行的，即使我们没有对 T 做出任何约束。Java 认为这是不可行的，因为 T 没有受到约束。这种区别的实质是啥，实质是 C++  里面的模版是个爹，是除了类、接口这这两大爹之外的一个新爹，T 是规则的制定者。一个类如果想做 T，就需要实现 T  在模板里面用到的所有方法，即类需要实现模板。实现模板是一种对类的约束，这种约束与继承父类、实现接口是处于同一层面的。Java  不一样，它没有模版这个爹，类永远只对接口、父类负责，T 是规则的遵守者，所以不能凭空调用对 T 来说并不存在的 f。</p>
<blockquote>
<p>本文为对Java泛型技术类型擦除部分的一个总结</p>
</blockquote>
<h3 id="介绍-1">介绍</h3>
<h4 id="类型擦除机制编译时擦除为object">类型擦除机制（编译时擦除为Object）</h4>
<ul>
<li>使用泛型的时候加上的类型参数，泛型类型只有在 <strong>静态类型检查期间</strong>才出现，在此之后，会在编译的时候，程序中的所有泛型类型都将被擦除，替换成它们<a href="https://kkkpjskey.github.io/java-generic-note/#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8F%8A%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C" target="_blank" rel="noopener noreferrer">非泛型上界</a>。（在生成的Java字节码中是不包含泛型中的类型信息的）。这个过程就称为类型擦除。</li>
</ul>
<h4 id="优势">优势</h4>
<ul>
<li>实现简单</li>
<li>容易Backport，最开始的版本是不支持泛型的，Java 1.5 才开始引入泛型，为了兼容以前的库而不得不使用擦除法，是一种折中</li>
<li>运行期节省一些类型所占的内存空间</li>
</ul>
<h4 id="缺陷">缺陷</h4>
<ul>
<li>实现的泛型远不如真泛型灵活和强大
<ul>
<li>基本类型无法作为泛型实参（因为编译时被擦除为Object类型），只能用包装类型，装箱开箱有开销</li>
<li>泛型类型无法当做真实的类型使用，因为编译后的泛型为Object类型</li>
<li>泛型类型无法用方法重载，因为编译后都是List list</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin">    <span class="k">public</span> <span class="n">void</span> <span class="n">print</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Integer</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">){</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">print</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="n">list</span><span class="p">){</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>静态方法无法引用类泛型参数（可以给静态方法单独加上泛型参数），因为只有类实例化的时候才会知道泛型参数，而静态方法不需要持有类的实例</li>
<li>类型强转时的开销（Object强转到对应的类型）</li>
</ul>
<h3 id="代码片段1if一致">代码片段1（if一致）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;().</span><span class="na">getClass</span><span class="o">();</span>
<span class="n">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;().</span><span class="na">getClass</span><span class="o">();</span> 
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="o">);</span>

<span class="c1">//输出：true
</span></code></pre></td></tr></table>
</div>
</div><p>尽管<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>看上去或在使用中，是完全不同的类型，但是上面的程序会的的确确认为它们是相同的类型，会输出true。<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>在运行时事实上是相同的类型。这两种类型都被擦除成它们的“原生”类型，即ArrayList。无论何时，编写泛型代码时，必须提醒自己“它的类型被擦除了”。</p>
<blockquote>
<p>这就是Java泛型的类型擦除造成的!</p>
</blockquote>
<p>因为不管是<code>ArrayList&lt;Integer&gt;()</code>还是<code>ArrayList&lt;String&gt;()</code>，都在编译器被编译器擦除成了ArrayList。那编译器为什么要做这件事？原因也和大多数的Java让人不爽的点一样——兼容性。由于泛型并不是从Java诞生就存在的一个特性，而是等到SE5才被加入的，所以为了兼容之前并未使用泛型的类库和代码，不得不让编译器擦除掉代码中有关于泛型类型信息的部分，这样最后生成出来的代码其实是『泛型无关』的，我们使用别人的代码或者类库时也就不需要关心对方代码是否已经『泛化』，反之亦然。</p>
<p>在编译器层面做的这件事（擦除具体的类型信息），使得Java的泛型先天都存在一个让人非常难受的缺点：</p>
<blockquote>
<p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>
</blockquote>
<p>如果想要运行上面<a href="https://kkkpjskey.github.io/java-generic-note/#%E5%BC%95%E8%A8%80c%E6%A8%A1%E6%9D%BF%E4%B8%8Ejava%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener noreferrer">类型擦除引言部分Java版本的HasF</a>，必须协助泛型类，给定泛型的边界，以告知编译器只能接收遵循这个边界的类型。这里重用了 <strong>extends</strong>关键字（与类的继承有点类似，但又不完全相同），给出类型的 <strong>上界</strong>。之所以称为上界，是通过继承树来考虑的，对于继承树父节点在上，子节点在下，那么extends关键字就限定了类型最多能上了继承树的什么地方，也就是上界。由于有了边界，下面的代码就可以编译了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manipulator2</span><span class="o">&lt;</span><span class="n">t</span> <span class="kd">extends</span> <span class="n">hasf</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Manipulator2</span><span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">manipulate</span><span class="o">()</span> <span class="o">{</span> <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>泛型类型参数将擦除到它的第一个边界（可以有多个边界）。编译时，Java编译器会将T擦除成HasF，就好像在类的声明中用HasF替换了T一样。</p>
<h3 id="代码片段2type为泛型">代码片段2（Type为泛型）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getTypeParameters</span><span class="o">()));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getTypeParameters</span><span class="o">()));</span>

<span class="c1">//输出：
</span><span class="c1"></span><span class="o">[</span><span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>关于getTypeParameters()的解释：</p>
<blockquote>
<p>Returns an array of TypeVariable objects that represent the type  variables declared by the generic declaration represented by this  GenericDeclaration object, in declaration order. Returns an array of  length 0 if the underlying generic declaration declares no type  variables.</p>
</blockquote>
<p>我们期待的是得到泛型参数的类型，但是实际上我们只得到了一堆占位符。</p>
<h3 id="代码片段3泛型不能实例化">代码片段3（泛型不能实例化）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">makeArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// error: Type parameter &#39;T&#39; cannot be instantiated directly
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="n">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们无法在泛型内部创建一个T类型的数组，原因也和之前一样，T仅仅是个占位符，并没有真实的类型信息，实际上，除了new表达式之外，instanceof操作和转型（会收到警告）在泛型内部都是无法使用的，而造成这个的原因就是之前讲过的编译器对类型信息进行了擦除。</p>
<p>同时，面对泛型内部形如T var;的代码时，记得多念几遍：它只是个Object，它只是个Object……</p>
<h3 id="代码片段4内部一致性边界动作">代码片段4（内部一致性，边界动作）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">T</span> <span class="n">t</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">m</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;findingsea&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//输出：findingsea
</span></code></pre></td></tr></table>
</div>
</div><p>虽然有类型擦除的存在，使得编译器在泛型内部其实完全无法知道有关T的任何信息，但是编译器可以保证重要的一点：</p>
<blockquote>
<p>内部一致性，也是我们放进去的是什么类型的对象，取出来还是相同类型的对象，这一点让Java的泛型起码还是有用武之地的。</p>
</blockquote>
<p>代码片段四展现就是编译器确保了我们放在t上的类型的确是T（即便它并不知道有关T的任何类型信息）。这种确保其实做了两步工作：</p>
<p><strong>set()</strong> 处的类型检验 
<strong>get()</strong> 处的类型转换 
这两步工作也成为<strong>边界动作</strong>。</p>
<h3 id="代码片段5内部一致性输入输出">代码片段5（内部一致性，输入输出）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">fillList</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">fillList</span><span class="o">(</span><span class="s">&#34;findingsea&#34;</span><span class="o">,</span> <span class="n">5</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//输出：[findingsea, findingsea, findingsea, findingsea, findingsea]
</span></code></pre></td></tr></table>
</div>
</div><p>代码片段5同样展示的是泛型的内部一致性。</p>
<h3 id="字节码分析">字节码分析</h3>
<blockquote>
<p>我们简单了解了方法中的泛型的使用会在编译期进行类型检查,下面我们进一步研究下在字节码层面泛型的信息。</p>
</blockquote>
<p>在方法体中使用声明并创建了2个泛型对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">sample1</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用<code>javac</code> 命令 编译该java文件 生成 GnericTest.class</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">javac GenericTest.java
</code></pre></td></tr></table>
</div>
</div><p>如果是在Intellij环境下，可以直接打开该class文件</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./5.png"
        data-srcset="./5.png, ./5.png 1.5x, ./5.png 2x"
        data-sizes="auto"
        alt="./5.png"
        title="5" /></p>
<p>可以看到在class文件中，方法内部并不存在泛型信息，我们可以简单的得出结论：在方法体中的泛型信息在编译后会被擦除。</p>
<p>我们稍微修改一下代码，在代码中尝试向List 列表中插入数据后取出元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">sample1</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">strList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再次编译该代码，并使用Intellij打开class文件，此时可以看到，调用List类型的add方法时，编译器并没有做出任何改动，但是在取出元素时，编译器会自动强转成String类型。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./6.JPEG"
        data-srcset="./6.JPEG, ./6.JPEG 1.5x, ./6.JPEG 2x"
        data-sizes="auto"
        alt="./6.JPEG"
        title="6" /></p>
<p>从字节码的层级来看，实际上编译器所做的额外工作是在取出元素后，加入了一个 <strong>checkcast class java/lang/String</strong>（类型转化)指令。</p>
<p>读者可以通过 <strong><code>javap -v GenericTest</code></strong> 查看 GnericTest类文件可以看到下面的指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">        <span class="n">27</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="n">6</span><span class="o">,</span>  <span class="n">2</span>            <span class="c1">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
</span><span class="c1"></span>        <span class="n">32</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="n">7</span>                  <span class="c1">// class java/lang/String
</span><span class="c1"></span>        <span class="n">35</span><span class="o">:</span> <span class="n">astore_3</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="擦除的补偿解决擦除问题">擦除的补偿（解决擦除问题）</h3>
<h4 id="问题示例">问题示例</h4>
<p>擦除丢失了在泛型代码中执行某些操作的能力。任何运行时都需要知道确切的类型信息的操作都无法工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Erased</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">(</span><span class="n">Object</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="k">instanceof</span> <span class="n">T</span><span class="o">)</span> <span class="o">{}</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>        <span class="n">T</span> <span class="n">var</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">();</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>        <span class="n">T</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">[</span><span class="n">SIZE</span><span class="o">];</span>  <span class="c1">// 编译错误
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上看到的，但凡是涉及到确切类型信息的操作，在泛型内部都是无法工作的。那是否有办法绕过这个问题来编程，答案就是:</p>
<blockquote>
<p>显式地传递类型标签。</p>
</blockquote>
<p>下面给出一些方法解决上面的问题。</p>
<h4 id="引入类型标签使用动态的isinstance代替instanceof">引入类型标签，使用动态的isInstance()代替instanceof</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">class Building {}
class House extends Building {}

public class ClassTypeCapture&lt;t&gt; {
    Class&lt;t&gt; kind;
    public ClassTypeCapture(Class&lt;t&gt; kind) {
        this.kind = kind;
    }
    public boolean f(Object arg) {
        return kind.isInstance(arg);
    }
    public static void main(String[] args) {
        ClassTypeCapture&lt;building&gt; ctt1 = new ClassTypeCapture&lt;&gt;(Building.class);
        System.out.println(ctt1.f(new Building()));
        System.out.println(ctt1.f(new House()));
        ClassTypeCapture&lt;house&gt; ctt2 = new ClassTypeCapture&lt;&gt;(House.class);
        System.out.println(ctt2.f(new Building()));
        System.out.println(ctt2.f(new House()));
    }
}
&lt;/house&gt;&lt;/building&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">true
true
false
true
</code></pre></td></tr></table>
</div>
</div><h4 id="代码片段6classnewinstance">代码片段6（Class.newInstance）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">create</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">type</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Main</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码片段6展示了一种用类型标签生成新对象的方法，但是这个办法很脆弱，因为这种办法要求对应的类型必须有默认构造函数，遇到Integer类型的时候就失败了，而且这个错误还不能在编译器捕获。</p>
<p>进阶的方法可以用限制类型的显式工厂和模板方法设计模式来改进这个问题，具体可以参见《Java编程思想 （第4版）》P382。</p>
<blockquote>
<p><strong>用工厂方法或模版方法创建类型实例</strong></p>
<p>下面的两段代码是学习设计模式的好材料。先来看工厂方法模式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">FactoryI</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span> <span class="n">T</span> <span class="nf">create</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">Foo2</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">F</span> <span class="kd">extends</span> <span class="n">FactoryI</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">Foo2</span><span class="o">(</span><span class="n">F</span> <span class="n">factory</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">IntegerFactory</span> <span class="kd">implements</span> <span class="n">FactoryI</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Widget</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="kd">implements</span> <span class="n">FactoryI</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">Widget</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Widget</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactoryConstraint</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="n">Foo2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="k">new</span> <span class="n">IntegerFactory</span><span class="o">());</span>
        <span class="k">new</span> <span class="n">Foo2</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;(</span><span class="k">new</span> <span class="n">Widget</span><span class="o">.</span><span class="na">Factory</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>模板方法模式</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GenericWithCreate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">T</span> <span class="n">element</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">GenericWithCreate</span><span class="o">()</span> <span class="o">{</span> <span class="n">element</span> <span class="o">=</span> <span class="n">create</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">X</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Creater</span> <span class="kd">extends</span> <span class="n">GenericWithCreate</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">X</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">X</span><span class="o">();</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreatorGeneric</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Creater</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Creater</span><span class="o">();</span>
        <span class="n">c</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h4 id="代码片段7用arraylist代替数组或者是传入类型标记">代码片段7（用ArrayList代替数组，或者是传入类型标记）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericArrayWithTypeToken</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nf">GenericArrayWithTypeToken</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span><span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">sz</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">rep</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">array</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">GenericArrayWithTypeToken</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">gai</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericArrayWithTypeToken</span><span class="o">&lt;&gt;(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">10</span><span class="o">);</span>
        <span class="n">Integer</span><span class="o">[]</span> <span class="n">ia</span> <span class="o">=</span> <span class="n">gai</span><span class="o">.</span><span class="na">rep</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">//public class Main&lt;T&gt; {
</span><span class="c1">//
</span><span class="c1">//    public T[] create(Class&lt;T&gt; type) {
</span><span class="c1">//        return (T[]) Array.newInstance(type, 10);
</span><span class="c1">//    }
</span><span class="c1">//
</span><span class="c1">//    public static void main(String[] args) {
</span><span class="c1">//        Main&lt;String&gt; m = new Main&lt;String&gt;();
</span><span class="c1">//        String[] strings = m.create(String.class);
</span><span class="c1">//    }
</span><span class="c1">//}
</span></code></pre></td></tr></table>
</div>
</div><p>代码片段7展示了对泛型数组的擦除补偿，本质方法还是通过显式地传递类型标签，通过Array.newInstance(type, size)来生成数组，同时也是最为推荐的在泛型内部生成数组的方法。</p>
<h3 id="真的完全擦除了吗">真的完全擦除了吗</h3>
<p>在JDK1.5后Signature属性被增加到了Class文件规范中，它是一个可选的定长属性，可以出现在类、字段表和方法表结构的属性表中。在JDK1.5中大幅度增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Singature属性会为它记录泛型签名信息。Signature属性就是为了弥补擦除法的缺陷而增设的，Java可以通过反射获得泛型类型，最终的数据来源也就是这个属性。</p>
<h4 id="字节码分析签名">字节码分析签名</h4>
<h5 id="泛型签名信息">泛型签名信息</h5>
<p>在上文中  方法中使用泛型的例子中，我们发现在方法中的泛型在编译后会被擦除。那么在泛型类、泛型方法中的泛型信息也会被擦除吗？实际上Java在引入泛型时，考虑了这个问题，为了能够在Class文件中保存泛型信息，在JDK1.5后Signature属性被增加到了Class文件规范中，它是一个可选的定长属性，可以出现在类、字段表和方法表结构的属性表中。任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized  Types），则Singature属性会为它记录泛型签名信息。Signature属性就是为了弥补擦除法的缺陷而增设的，Java可以通过反射获得泛型类型，最终的数据来源也就是这个属性。</p>
<p>编写一个简单的泛型示例代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">,</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">T</span> <span class="n">param1</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">K</span> <span class="n">param2</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">strList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod1</span><span class="o">(</span><span class="n">T</span> <span class="n">p1</span><span class="o">,</span> <span class="n">K</span> <span class="n">p2</span><span class="o">,</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">javac</span> <span class="n">GenericTest</span><span class="o">.</span><span class="na">java</span>
</code></pre></td></tr></table>
</div>
</div><p>编译生成 GenericTest.class文件</p>
<p>运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">javap -v -p GenericTest
</code></pre></td></tr></table>
</div>
</div><p>查看GenericTest.class文件中的字节码信息</p>
<p>以下是生成的GenericTest.class的字节码信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Number</span><span class="o">,</span> <span class="n">K</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span>
  <span class="n">minor</span> <span class="n">version</span><span class="o">:</span> <span class="n">0</span>
  <span class="n">major</span> <span class="n">version</span><span class="o">:</span> <span class="n">52</span>
  <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_SUPER</span>
<span class="n">Constant</span> <span class="n">pool</span><span class="o">:</span>
   <span class="err">#</span><span class="n">1</span> <span class="o">=</span> <span class="n">Methodref</span>          <span class="err">#</span><span class="n">9</span><span class="o">.</span><span class="err">#</span><span class="n">35</span>         <span class="c1">// java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>   <span class="err">#</span><span class="n">2</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="n">36</span>            <span class="c1">// java/util/ArrayList
</span><span class="c1"></span>   <span class="err">#</span><span class="n">3</span> <span class="o">=</span> <span class="n">Methodref</span>          <span class="err">#</span><span class="n">2</span><span class="o">.</span><span class="err">#</span><span class="n">35</span>         <span class="c1">// java/util/ArrayList.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>   <span class="err">#</span><span class="n">4</span> <span class="o">=</span> <span class="n">String</span>             <span class="err">#</span><span class="n">37</span>            <span class="c1">// hello
</span><span class="c1"></span>   <span class="err">#</span><span class="n">5</span> <span class="o">=</span> <span class="n">InterfaceMethodref</span> <span class="err">#</span><span class="n">38</span><span class="o">.</span><span class="err">#</span><span class="n">39</span>        <span class="c1">// java/util/List.add:(Ljava/lang/Object;)Z
</span><span class="c1"></span>   <span class="err">#</span><span class="n">6</span> <span class="o">=</span> <span class="n">InterfaceMethodref</span> <span class="err">#</span><span class="n">38</span><span class="o">.</span><span class="err">#</span><span class="n">40</span>        <span class="c1">// java/util/List.get:(I)Ljava/lang/Object;
</span><span class="c1"></span>   <span class="err">#</span><span class="n">7</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="n">41</span>            <span class="c1">// java/lang/String
</span><span class="c1"></span>   <span class="err">#</span><span class="n">8</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="n">42</span>            <span class="c1">// GenericTest
</span><span class="c1"></span>   <span class="err">#</span><span class="n">9</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="n">43</span>            <span class="c1">// java/lang/Object
</span><span class="c1"></span>  <span class="err">#</span><span class="n">10</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">param1</span>
  <span class="err">#</span><span class="n">11</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
  <span class="err">#</span><span class="n">12</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Signature</span>
  <span class="err">#</span><span class="n">13</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">TT</span><span class="o">;</span>
  <span class="err">#</span><span class="n">14</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">param2</span>
  <span class="err">#</span><span class="n">15</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span>
  <span class="err">#</span><span class="n">16</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">TK</span><span class="o">;</span>
  <span class="err">#</span><span class="n">17</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">&lt;</span><span class="n">init</span><span class="o">&gt;</span>
  <span class="err">#</span><span class="n">18</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">()</span><span class="n">V</span>
  <span class="err">#</span><span class="n">19</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">Code</span>
  <span class="err">#</span><span class="n">20</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">LineNumberTable</span>
  <span class="err">#</span><span class="n">21</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">main</span>
  <span class="err">#</span><span class="n">22</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">([</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">V</span>
  <span class="err">#</span><span class="n">23</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">genericMethod</span>
  <span class="err">#</span><span class="n">24</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
  <span class="err">#</span><span class="n">25</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">()</span><span class="n">TT</span><span class="o">;</span>
  <span class="err">#</span><span class="n">26</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">genericMethod1</span>
  <span class="err">#</span><span class="n">27</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
  <span class="err">#</span><span class="n">28</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">TT</span><span class="o">;</span><span class="n">TK</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">TT</span><span class="o">;</span>
  <span class="err">#</span><span class="n">29</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">sort</span>
  <span class="err">#</span><span class="n">30</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">Comparator</span><span class="o">;)</span><span class="n">V</span>
  <span class="err">#</span><span class="n">31</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;&gt;(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TT</span><span class="o">;&gt;;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">Comparator</span><span class="o">&lt;+</span><span class="n">TT</span><span class="o">;&gt;;)</span><span class="n">V</span>
  <span class="err">#</span><span class="n">32</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span><span class="n">K</span><span class="o">:</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;&gt;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span>
  <span class="err">#</span><span class="n">33</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">SourceFile</span>
  <span class="err">#</span><span class="n">34</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">GenericTest</span><span class="o">.</span><span class="na">java</span>
  <span class="err">#</span><span class="n">35</span> <span class="o">=</span> <span class="n">NameAndType</span>        <span class="err">#</span><span class="n">17</span><span class="o">:</span><span class="err">#</span><span class="n">18</span>        <span class="c1">// &#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>  <span class="err">#</span><span class="n">36</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">java</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">ArrayList</span>
  <span class="err">#</span><span class="n">37</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">hello</span>
  <span class="err">#</span><span class="n">38</span> <span class="o">=</span> <span class="n">Class</span>              <span class="err">#</span><span class="n">44</span>            <span class="c1">// java/util/List
</span><span class="c1"></span>  <span class="err">#</span><span class="n">39</span> <span class="o">=</span> <span class="n">NameAndType</span>        <span class="err">#</span><span class="n">45</span><span class="o">:</span><span class="err">#</span><span class="n">46</span>        <span class="c1">// add:(Ljava/lang/Object;)Z
</span><span class="c1"></span>  <span class="err">#</span><span class="n">40</span> <span class="o">=</span> <span class="n">NameAndType</span>        <span class="err">#</span><span class="n">47</span><span class="o">:</span><span class="err">#</span><span class="n">48</span>        <span class="c1">// get:(I)Ljava/lang/Object;
</span><span class="c1"></span>  <span class="err">#</span><span class="n">41</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">java</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span>
  <span class="err">#</span><span class="n">42</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">GenericTest</span>
  <span class="err">#</span><span class="n">43</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">java</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span>
  <span class="err">#</span><span class="n">44</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">java</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span>
  <span class="err">#</span><span class="n">45</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">add</span>
  <span class="err">#</span><span class="n">46</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;)</span><span class="n">Z</span>
  <span class="err">#</span><span class="n">47</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="n">get</span>
  <span class="err">#</span><span class="n">48</span> <span class="o">=</span> <span class="n">Utf8</span>               <span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span>
<span class="o">{</span>
  <span class="kd">private</span> <span class="n">T</span> <span class="n">param1</span><span class="o">;</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">13</span>                          <span class="c1">// TT;
</span><span class="c1"></span>
  <span class="kd">private</span> <span class="n">K</span> <span class="n">param2</span><span class="o">;</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">16</span>                          <span class="c1">// TK;
</span><span class="c1"></span>
  <span class="kd">public</span> <span class="nf">GenericTest</span><span class="o">();</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">()</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">1</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">1</span>                  <span class="c1">// Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>         <span class="n">4</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">5</span><span class="o">:</span> <span class="n">0</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">([</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_STATIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">4</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">1</span>
         <span class="n">0</span><span class="o">:</span> <span class="k">new</span>           <span class="err">#</span><span class="n">2</span>                  <span class="c1">// class java/util/ArrayList
</span><span class="c1"></span>         <span class="n">3</span><span class="o">:</span> <span class="n">dup</span>
         <span class="n">4</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">3</span>                  <span class="c1">// Method java/util/ArrayList.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>         <span class="n">7</span><span class="o">:</span> <span class="n">astore_1</span>
         <span class="n">8</span><span class="o">:</span> <span class="k">new</span>           <span class="err">#</span><span class="n">2</span>                  <span class="c1">// class java/util/ArrayList
</span><span class="c1"></span>        <span class="n">11</span><span class="o">:</span> <span class="n">dup</span>
        <span class="n">12</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">3</span>                  <span class="c1">// Method java/util/ArrayList.&#34;&lt;init&gt;&#34;:()V
</span><span class="c1"></span>        <span class="n">15</span><span class="o">:</span> <span class="n">astore_2</span>
        <span class="n">16</span><span class="o">:</span> <span class="n">aload_1</span>
        <span class="n">17</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="n">4</span>                  <span class="c1">// String hello
</span><span class="c1"></span>        <span class="n">19</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="n">5</span><span class="o">,</span>  <span class="n">2</span>            <span class="c1">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
</span><span class="c1"></span>        <span class="n">24</span><span class="o">:</span> <span class="n">pop</span>
        <span class="n">25</span><span class="o">:</span> <span class="n">aload_1</span>
        <span class="n">26</span><span class="o">:</span> <span class="n">iconst_0</span>
        <span class="n">27</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="n">6</span><span class="o">,</span>  <span class="n">2</span>            <span class="c1">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
</span><span class="c1"></span>        <span class="n">32</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="n">7</span>                  <span class="c1">// class java/lang/String
</span><span class="c1"></span>        <span class="n">35</span><span class="o">:</span> <span class="n">astore_3</span>
        <span class="n">36</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">12</span><span class="o">:</span> <span class="n">0</span>
        <span class="n">line</span> <span class="n">13</span><span class="o">:</span> <span class="n">8</span>
        <span class="n">line</span> <span class="n">14</span><span class="o">:</span> <span class="n">16</span>
        <span class="n">line</span> <span class="n">15</span><span class="o">:</span> <span class="n">25</span>
        <span class="n">line</span> <span class="n">16</span><span class="o">:</span> <span class="n">36</span>

  <span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod</span><span class="o">();</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">1</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aconst_null</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">areturn</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">19</span><span class="o">:</span> <span class="n">0</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">25</span>                          <span class="c1">// ()TT;
</span><span class="c1"></span>
  <span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod1</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">K</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">4</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">4</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aconst_null</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">areturn</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">23</span><span class="o">:</span> <span class="n">0</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">28</span>                          <span class="c1">// (TT;TK;Ljava/lang/String;)TT;
</span><span class="c1"></span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Comparator</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">Comparator</span><span class="o">;)</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_STATIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">0</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">2</span>
         <span class="n">0</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">28</span><span class="o">:</span> <span class="n">0</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">31</span>                          <span class="c1">// &lt;T:Ljava/lang/Object;&gt;(Ljava/util/List&lt;TT;&gt;;Ljava/util/Comparator&lt;+TT;&gt;;)V
</span><span class="c1"></span><span class="o">}</span>
<span class="nl">Signature:</span> <span class="err">#</span><span class="n">32</span>                          <span class="c1">// &lt;T:Ljava/lang/Number;K:Ljava/lang/Object;&gt;Ljava/lang/Object;
</span><span class="c1"></span><span class="nl">SourceFile:</span> <span class="s">&#34;GenericTest.java&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="类上的泛型签名信息">类上的泛型签名信息</h6>
<p>由于GenericTest类声明了泛型类型 <strong>T</strong>、<strong>K</strong> 因此，在打印的字节码内容尾部有 <strong>signature</strong>属性为该类记录泛型签名信息 s</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nl">Signature:</span> <span class="err">#</span><span class="n">33</span>                          <span class="c1">// &lt;T:Ljava/lang/Number;K:Ljava/lang/Object;&gt;Ljava/lang/Object;
</span></code></pre></td></tr></table>
</div>
</div><h6 id="成员变量上的泛型签名信息">成员变量上的泛型签名信息</h6>
<p>类的成员变量 <strong>param1</strong> <strong>param2</strong> 类型为泛型，因此 字段信息中会有 **<em>signature</em>属性记录该字段的泛型签名信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">  <span class="kd">private</span> <span class="n">T</span> <span class="n">param1</span><span class="o">;</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">14</span>                          <span class="c1">// TT;
</span><span class="c1"></span>
  <span class="kd">private</span> <span class="n">K</span> <span class="n">param2</span><span class="o">;</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">17</span>                          <span class="c1">// TK;
</span></code></pre></td></tr></table>
</div>
</div><p>这里的<strong>TT</strong> <strong>TK</strong> 第一个T表示该类型是泛型类型，<strong>T</strong>后面跟随着泛型的标识。</p>
<h6 id="方法上的泛型签名信息">方法上的泛型签名信息</h6>
<p>类的成员方法 <strong>genericMethod()<strong>方法返回类型为泛型 和 <code>genericMethod1(T p1, K p2)</code> 方法的参数及返回类型为泛型类，因此，在字节码中这两个方法的信息中也会有</strong>Signature</strong>记录该方法包含泛型的签名信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod</span><span class="o">();</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">1</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aconst_null</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">areturn</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">19</span><span class="o">:</span> <span class="n">0</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">26</span>                          <span class="c1">// ()TT;
</span><span class="c1"></span>
  <span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod1</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">K</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;)</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Number</span><span class="o">;</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PRIVATE</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">1</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">4</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">4</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aconst_null</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">areturn</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">23</span><span class="o">:</span> <span class="n">0</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">29</span>                          <span class="c1">// (TT;TK;Ljava/lang/String;)TT;
</span></code></pre></td></tr></table>
</div>
</div><p>方法的泛型签名由两部分组成，分别是方法参数和方法返回类型；下面会简单的解析下这两个方法的签名组成.
首先方法的签名信息由两部分组成，分别是方法的参数部分和返回类型部分。</p>
<p>1.genericMethod方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod</span><span class="o">()</span>
</code></pre></td></tr></table>
</div>
</div><p><code>genericMethod()</code>方法的签名信息为 <strong>()TT;</strong></p>
<p>方法参数部分的签名为()，因为该方法没有任何参数</p>
<p>方法的返回类型为泛型类型<strong>T</strong>，因此方法返回类型部分的签名为<strong>TT</strong></p>
<p>2.genericMethod1方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span> <span class="nf">genericMethod1</span><span class="o">(</span><span class="n">T</span> <span class="n">p1</span><span class="o">,</span> <span class="n">K</span> <span class="n">p2</span><span class="o">,</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>该方法的参数部分签名为<code>(TT;TK;Ljava/lang/String;)</code>,因为方法分别有3个参数，其中泛型化类型T在方法签名中的标识为 <strong>TT</strong> ,泛型类型K的标识为 <strong>TK</strong> ,String类型为 <code>Ljava/lang/String</code>,类型直接以“;”作为分隔。（引用数据类型在字节码中的标识的格式为<strong>LClassName</strong>,其中ClassName为类的全路径名称，全路径名称中的“.”号由“/”代替,最终方法签名的参数部分为<code>(TT;TK;Ljava/lang/String;)</code>。</p>
<p>该方法的返回类型为泛型T，因此返回类型部分为<strong>TT</strong></p>
<h6 id="静态方法的上的泛型签名信息">静态方法的上的泛型签名信息</h6>
<p>泛型静态方法中,泛型的类型不能直接引用类上的泛型类型，静态方法如果要使用泛型，必须自己定义泛型类型，比如这里 <strong>sort</strong>方法的泛型类型T是在通过方法的  声明的，这里的泛型类型T跟类的上的泛型类型T<strong>并不是同一个</strong>。</p>
<p>我们看下该静态方法的签名信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span><span class="o">;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">Comparator</span><span class="o">;)</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_STATIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">2</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">aload_1</span>
         <span class="n">2</span><span class="o">:</span> <span class="n">invokeinterface</span> <span class="err">#</span><span class="n">8</span><span class="o">,</span>  <span class="n">2</span>            <span class="c1">// InterfaceMethod java/util/List.sort:(Ljava/util/Comparator;)V
</span><span class="c1"></span>         <span class="n">7</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">28</span><span class="o">:</span> <span class="n">0</span>
        <span class="n">line</span> <span class="n">29</span><span class="o">:</span> <span class="n">7</span>
    <span class="n">Signature</span><span class="o">:</span> <span class="err">#</span><span class="n">32</span>                          <span class="c1">// &lt;T:Ljava/lang/Object;&gt;(Ljava/util/List&lt;TT;&gt;;Ljava/util/Comparator&lt;-TT;&gt;;)V
</span></code></pre></td></tr></table>
</div>
</div><p>签名信息为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;&gt;(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">List</span><span class="o">&lt;</span><span class="n">TT</span><span class="o">;&gt;;</span><span class="n">Ljava</span><span class="o">/</span><span class="n">util</span><span class="o">/</span><span class="n">Comparator</span><span class="o">&lt;-</span><span class="n">TT</span><span class="o">;&gt;;)</span><span class="n">V</span>
</code></pre></td></tr></table>
</div>
</div><p>注意这里签名信息的开头部分，在函数参数的标识部分的左边提前描述了泛型类型T的签名信息 <strong>&lt;T:Ljava/lang/Object;&gt;</strong>。 另外函数参数
Comparator&lt;? super T&gt;在方法签名中的标识为<code>Ljava/util/Comparator&lt;-TT;&gt;</code>,如果这里的<strong>super</strong>变为<strong>extends</strong>则签名信息变为<code>Ljava/util/Comparator&lt;+TT;&gt;</code>。因为<strong>super</strong>操作符在字节码中的标识为符号 <strong>-</strong>，<strong>extends</strong>操作符在字节码中的标识为符号 <strong>+</strong>。</p>
<h4 id="获取签名信息">获取签名信息</h4>
<h5 id="附加的签名信息特定场景下反射可以获取">附加的签名信息特定场景下反射可以获取</h5>
<ul>
<li>
<p>获取泛型类型</p>
<p>我们已经介绍了泛型的相关类型，以及泛型在字节码中的信息。为了在运行时获取泛型的类型，Java提供相应的api实现。</p>
<p>首先我们上文介绍了,包括原生类型及泛型类型，所有的类型都可以用<strong>Type</strong>接口表示。 因此我写了一个工具方法打印所有具体Type类型的具体信息。有关这些Type类型的具体api信息可以直接查看jdk上这些类的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printTypeInfo</span><span class="o">(</span><span class="n">Type</span> <span class="n">argumentType</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">Class</span><span class="o">&lt;?&gt;)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;原生类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">Class</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getCanonicalName</span><span class="o">());</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">ParameterizedType</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;参数化类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">ParameterizedType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">Type</span><span class="o">[]</span> <span class="n">actualTypeArguments</span> <span class="o">=</span> <span class="o">((</span><span class="n">ParameterizedType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getActualTypeArguments</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;    参数化类型中的泛型参数信息如下:&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">actualTypeArguments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Type</span> <span class="n">actualTypeArgument</span> <span class="o">=</span> <span class="n">actualTypeArguments</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个泛型参数类型为&#34;</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;              &#34;</span><span class="o">);</span>
            <span class="n">printTypeInfo</span><span class="o">(</span><span class="n">actualTypeArgument</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">GenericArrayType</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;泛型类型数组-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">GenericArrayType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;    泛型类型数组存储的类型为&#34;</span><span class="o">);</span>
        <span class="n">printTypeInfo</span><span class="o">(((</span><span class="n">GenericArrayType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getGenericComponentType</span><span class="o">());</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">TypeVariable</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;类型变量类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">TypeVariable</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">WildcardType</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;包含通配符的类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">Type</span><span class="o">[]</span> <span class="n">upperBounds</span> <span class="o">=</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getUpperBounds</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">upperBounds</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;    通配符的上界包括:&#34;</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">upperBounds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        &#34;</span> <span class="o">+</span> <span class="n">upperBounds</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">Type</span><span class="o">[]</span> <span class="n">lowerBounds</span> <span class="o">=</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getLowerBounds</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lowerBounds</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;  通配符的下界包括:&#34;</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">lowerBounds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        &#34;</span> <span class="o">+</span> <span class="n">lowerBounds</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getClass</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>以下这些api获取的泛型数据的来源就是class文件字节码中 类及方法上的signature的信息。</p>
<ul>
<li>
<p>获取类所继承泛型类信息</p>
<p>Class类提供了getGenericSuperclass、getGenericInterfaces方法</p>
<ul>
<li>
<p>getGenericSuperclass 获得类所继承的父类的上的泛型参数类型。</p>
</li>
<li>
<p>getGenericInterfaces
获得类所继承的接口上声明的泛型参数类型。</p>
</li>
<li>
<p>因为类型擦除，创建子类才可以获取到父类的泛型信息</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">class</span> <span class="nc">SuperClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>

<span class="p">}</span>

<span class="k">class</span> <span class="nc">SubClass</span> <span class="n">extends</span> <span class="n">SuperClass</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;&gt;</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ATest</span> <span class="p">{</span>
    <span class="nd">@Test</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">test3</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">SuperClass</span><span class="p">&gt;</span> <span class="n">aClass1</span> <span class="p">=</span> <span class="n">new</span> <span class="n">SuperClass</span><span class="p">&lt;</span><span class="n">Integer</span><span class="p">&gt;().</span><span class="n">getClass</span><span class="p">();</span>
        <span class="n">Class</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">SuperClass</span><span class="p">&lt;</span><span class="n">Integer</span><span class="p">&gt;&gt;</span> <span class="n">aClass2</span> <span class="p">=</span> <span class="n">new</span> <span class="n">SuperClass</span><span class="p">&lt;</span><span class="n">Integer</span><span class="p">&gt;()</span> <span class="p">{</span>
        <span class="p">}.</span><span class="n">getClass</span><span class="p">();</span>
        <span class="n">Class</span><span class="p">&lt;</span><span class="n">SubClass</span><span class="p">&gt;</span> <span class="n">aClass3</span> <span class="p">=</span> <span class="n">SubClass</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
        <span class="c1">//
</span><span class="c1"></span>        <span class="n">printType</span><span class="p">(</span><span class="n">aClass3</span><span class="p">);</span>
        <span class="n">printType</span><span class="p">(</span><span class="n">aClass2</span><span class="p">);</span>
        <span class="n">printType</span><span class="p">(</span><span class="n">aClass1</span><span class="p">);</span><span class="c1">//报错
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">void</span> <span class="n">printType</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">SuperClass</span><span class="p">&gt;</span> <span class="n">aClass</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ParameterizedType</span> <span class="n">genericSuperclass</span> <span class="p">=</span> <span class="p">(</span><span class="n">ParameterizedType</span><span class="p">)</span> <span class="n">aClass</span><span class="p">.</span><span class="n">getGenericSuperclass</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">genericSuperclass</span><span class="p">.</span><span class="n">getActualTypeArguments</span><span class="p">()[</span><span class="m">0</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">class java.lang.String
</span><span class="cm">class java.lang.Integer
</span><span class="cm">java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Kotlin版本</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Kotlin" data-lang="Kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">SuperClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>

 <span class="p">}</span>

 <span class="k">class</span> <span class="nc">TestClass</span><span class="p">:</span> <span class="n">SuperClass</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;()</span> <span class="p">{</span>
     <span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">Float</span><span class="p">&gt;()</span>

     <span class="k">private</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">E</span><span class="p">&gt;</span> <span class="nf">parameterizedFun</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">E</span><span class="p">):</span> <span class="n">E</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">element</span>
     <span class="p">}</span>

     <span class="k">fun</span> <span class="nf">testParameter</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>根据上面的分析可以知道从参数化类型信息中就可以得到真实类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Kotlin" data-lang="Kotlin"> <span class="nd">@Test</span>
 <span class="k">fun</span> <span class="nf">testFun</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">val</span> <span class="py">clazz</span> <span class="p">=</span> <span class="n">TestClass</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span>

     <span class="c1">//获取类泛型
</span><span class="c1"></span>     <span class="k">if</span> <span class="p">(</span><span class="n">clazz</span><span class="p">.</span><span class="n">genericSuperclass</span> <span class="k">is</span> <span class="n">ParameterizedType</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">val</span> <span class="py">parameterizedType</span> <span class="p">=</span> <span class="n">clazz</span><span class="p">.</span><span class="n">genericSuperclass</span> <span class="k">as</span> <span class="n">ParameterizedType</span>
         <span class="k">val</span> <span class="py">parameterClass</span> <span class="p">=</span> <span class="n">parameterizedType</span><span class="p">.</span><span class="n">actualTypeArguments</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>  <span class="k">as</span> <span class="n">Class</span><span class="p">&lt;*&gt;</span>
         <span class="n">println</span><span class="p">(</span><span class="n">parameterClass</span><span class="p">)</span>
     <span class="p">}</span>

     <span class="c1">//获取方法参数的泛型
</span><span class="c1"></span>     <span class="k">val</span> <span class="py">method</span> <span class="p">=</span> <span class="n">clazz</span><span class="p">.</span><span class="n">getMethod</span><span class="p">(</span><span class="s2">&#34;testParameter&#34;</span><span class="p">,</span> <span class="n">List</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">method</span><span class="p">.</span><span class="n">genericParameterTypes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="k">is</span> <span class="n">ParameterizedType</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">val</span> <span class="py">parameterizedType</span> <span class="p">=</span> <span class="n">method</span><span class="p">.</span><span class="n">genericParameterTypes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="k">as</span> <span class="n">ParameterizedType</span>
         <span class="k">val</span> <span class="py">parameterClass</span> <span class="p">=</span> <span class="n">parameterizedType</span><span class="p">.</span><span class="n">actualTypeArguments</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>  <span class="k">as</span> <span class="n">Class</span><span class="p">&lt;*&gt;</span>
         <span class="n">println</span><span class="p">(</span><span class="n">parameterClass</span><span class="p">)</span>
     <span class="p">}</span>

     <span class="c1">//获取变量类型
</span><span class="c1"></span>     <span class="k">val</span> <span class="py">field</span> <span class="p">=</span> <span class="n">clazz</span><span class="p">.</span><span class="n">getDeclaredField</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">)</span>
     <span class="k">if</span> <span class="p">(</span><span class="k">field</span><span class="p">.</span><span class="n">genericType</span> <span class="k">is</span> <span class="n">ParameterizedType</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">val</span> <span class="py">parameterizedType</span> <span class="p">=</span> <span class="k">field</span><span class="p">.</span><span class="n">genericType</span> <span class="k">as</span> <span class="n">ParameterizedType</span>
         <span class="k">val</span> <span class="py">parameterClass</span> <span class="p">=</span> <span class="n">parameterizedType</span><span class="p">.</span><span class="n">actualTypeArguments</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>  <span class="k">as</span> <span class="n">Class</span><span class="p">&lt;*&gt;</span>
         <span class="n">println</span><span class="p">(</span><span class="n">parameterClass</span><span class="p">)</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Kotlin" data-lang="Kotlin"><span class="k">class</span> <span class="nc">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">Double</span>
<span class="k">class</span> <span class="nc">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">String</span>
<span class="k">class</span> <span class="nc">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">Float</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p>获取方法中的泛型信息</p>
<p>Method类提供了获取方法泛型信息的两个api为
<code>getGenericReturnType</code>、<code>getGenericParameterTypes</code></p>
<ul>
<li>getGenericReturnType() 获得方法的方法类型对应的type</li>
<li>getGenericParameterTypes() 获得方法上所有参数的泛型类型信息，因为方法参数可能有多个，所以这个方法的返回值是一个 Type数组。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SuperClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="kd">extends</span> <span class="n">SuperClass</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ATest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test4</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NoSuchMethodException</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;</span><span class="n">SubClass</span><span class="o">&gt;</span> <span class="n">aClass3</span> <span class="o">=</span> <span class="n">SubClass</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="n">ParameterizedType</span> <span class="n">genericSuperclass</span> <span class="o">=</span> <span class="o">(</span><span class="n">ParameterizedType</span><span class="o">)</span><span class="n">aClass3</span>
        <span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;getValue&#34;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">getGenericReturnType</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">genericSuperclass</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">()[</span><span class="n">0</span><span class="o">]);</span>
    <span class="o">}</span>

<span class="o">}</span>
 <span class="c1">//java.util.Map&lt;java.lang.String, java.lang.String&gt;
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="gson中泛型签名的应用">Gson中泛型签名的应用</h5>
<ul>
<li><code>new TypeToken&lt;List&gt;() { }.getType()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin">    <span class="nd">@Test</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">test5</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Gson</span> <span class="n">gson</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Gson</span><span class="p">();</span>
        <span class="n">User</span> <span class="n">user1</span> <span class="p">=</span> <span class="n">new</span> <span class="n">User</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="s2">&#34;bob&#34;</span><span class="p">);</span>
        <span class="n">User</span> <span class="n">user2</span> <span class="p">=</span> <span class="n">new</span> <span class="n">User</span><span class="p">(</span><span class="m">12</span><span class="p">,</span> <span class="s2">&#34;jack&#34;</span><span class="p">);</span>
        <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="n">users</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="p">&lt;&gt;();</span>
        <span class="n">users</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">user1</span><span class="p">);</span>
        <span class="n">users</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">user2</span><span class="p">);</span>
        <span class="c1">//序列化（Java对象转换为字节序列的过程）
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">json</span> <span class="p">=</span> <span class="n">gson</span><span class="p">.</span><span class="n">toJson</span><span class="p">(</span><span class="n">users</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">json</span><span class="p">);</span>
        <span class="c1">//反序列化（把字节序列恢复为Java对象的过程）
</span><span class="c1"></span>        <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="n">userList</span> <span class="p">=</span> <span class="n">gson</span><span class="p">.</span><span class="n">fromJson</span><span class="p">(</span><span class="n">json</span><span class="p">,</span>
                <span class="n">new</span> <span class="n">TypeToken</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;()</span> <span class="p">{</span>
                <span class="p">}.</span><span class="n">getType</span><span class="p">());</span>
        <span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">userList</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*
</span><span class="cm">     * [{&#34;age&#34;:10,&#34;name&#34;:&#34;bob&#34;},{&#34;age&#34;:12,&#34;name&#34;:&#34;jack&#34;}]
</span><span class="cm">     * [User(age=10, name=bob), User(age=12, name=jack)]
</span><span class="cm">     */</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Gson中的源码
创建子类可以获取到父类的泛型信息，所以需要创建一个匿名子类<code>new TypeToken&lt;List&gt;() { }.getType()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="cm">/*
</span><span class="cm">客户端创建一个空的匿名子类。
</span><span class="cm">这样做会将类型参数嵌入到匿名类的类型层次结构中，这样我们就可以在运行时重建它，而不用考虑擦除。
</span><span class="cm">创建子类可以获取到父类的泛型信息，所以需要创建一个匿名子类new TypeToken&lt;List&lt;User&gt;&gt;() { }.getType()
</span><span class="cm">*/</span>
  <span class="k">protected</span> <span class="n">TypeToken</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">type</span> <span class="p">=</span> <span class="n">getSuperclassTypeParameter</span><span class="p">(</span><span class="n">getClass</span><span class="p">());</span><span class="c1">//此处获取type泛型的信息
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="n">rawType</span> <span class="p">=</span> <span class="p">(</span><span class="n">Class</span><span class="p">&lt;?</span> <span class="k">super</span> <span class="n">T</span><span class="p">&gt;)</span> <span class="err">$</span><span class="n">Gson</span><span class="err">$</span><span class="n">Types</span><span class="p">.</span><span class="n">getRawType</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="n">hashCode</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">hashCode</span><span class="p">();</span>
  <span class="p">}</span>
  
  <span class="c1">//获取泛型类型
</span><span class="c1"></span>  <span class="n">static</span> <span class="n">Type</span> <span class="n">getSuperclassTypeParameter</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">subclass</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Type</span> <span class="n">superclass</span> <span class="p">=</span> <span class="n">subclass</span><span class="p">.</span><span class="n">getGenericSuperclass</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">superclass</span> <span class="n">instanceof</span> <span class="n">Class</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">new</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s2">&#34;Missing type parameter.&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ParameterizedType</span> <span class="n">parameterized</span> <span class="p">=</span> <span class="p">(</span><span class="n">ParameterizedType</span><span class="p">)</span> <span class="n">superclass</span><span class="p">;</span>
    <span class="k">return</span> <span class="err">$</span><span class="n">Gson</span><span class="err">$</span><span class="n">Types</span><span class="p">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">parameterized</span><span class="p">.</span><span class="n">getActualTypeArguments</span><span class="p">()[</span><span class="m">0</span><span class="p">]);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="泛型混淆签名问题混淆后签名找不到了导致反射后拿不到">泛型混淆，签名问题，混淆后签名找不到了，导致反射后拿不到</h5>
<ul>
<li>
<p>保留签名信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">-keepattributes Signature
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Kotlin中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">-keep class kotlin.Metadata <span class="o">{</span>*<span class="p">;</span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="retrofit库对泛型的应用">retrofit库对泛型的应用</h2>
<p>之前写过一篇Retrofit框架的文章,简单的介绍了Retrofit库的组成部分，其中Retrofit一个很优雅的部分就是内部自动会跟你局接口方法所定义的Model类型自动做JSON类型转换。</p>
<p>我们可以简单演示下这里的泛型应用场景，获取方法返回类型上的泛型参数的具体类型。</p>
<p>在下面的例子中，我简单仿写了使用了Retrofit库在项目中的工程代码，在main方法打印Service接口中方法的返回泛型类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.lang.reflect.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span><span class="o">{</span>

    <span class="kd">static</span> <span class="kd">interface</span> <span class="nc">Call</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">interface</span> <span class="nc">Service</span> <span class="o">{</span>
        <span class="n">Call</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">login</span><span class="o">(</span><span class="n">String</span> <span class="n">account</span><span class="o">,</span> <span class="n">String</span> <span class="n">password</span><span class="o">);</span>

        <span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Post</span><span class="o">&gt;&gt;</span> <span class="nf">getPosts</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;开始打印Service接口的方法信息&#34;</span><span class="o">);</span>
        <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">Service</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethods</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">methods</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">methods</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">//方法的getReturnType返回的是Class类型，如果希望能够获取到泛型信息，则应该使用JDK 1.5 之后的 getGenericReturnType方法
</span><span class="c1"></span>            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">returnType</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">();</span>
            <span class="n">Type</span> <span class="n">genericReturnType</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getGenericReturnType</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;方法的返回&#34;</span><span class="o">);</span>
            <span class="n">printTypeInfo</span><span class="o">(</span><span class="n">genericReturnType</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printTypeInfo</span><span class="o">(</span><span class="n">Type</span> <span class="n">argumentType</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">Class</span><span class="o">&lt;?&gt;)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;原生类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">Class</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getCanonicalName</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">ParameterizedType</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;参数化类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">ParameterizedType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">Type</span><span class="o">[]</span> <span class="n">actualTypeArguments</span> <span class="o">=</span> <span class="o">((</span><span class="n">ParameterizedType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getActualTypeArguments</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;    参数化类型中的泛型参数信息如下:&#34;</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">actualTypeArguments</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">Type</span> <span class="n">actualTypeArgument</span> <span class="o">=</span> <span class="n">actualTypeArguments</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        第&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;个泛型参数类型为&#34;</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;              &#34;</span><span class="o">);</span>
                <span class="n">printTypeInfo</span><span class="o">(</span><span class="n">actualTypeArgument</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">GenericArrayType</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;泛型类型数组-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">GenericArrayType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;    泛型类型数组存储的类型为&#34;</span><span class="o">);</span>
            <span class="n">printTypeInfo</span><span class="o">(((</span><span class="n">GenericArrayType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getGenericComponentType</span><span class="o">());</span>

        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">TypeVariable</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;类型变量类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">TypeVariable</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>

        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">argumentType</span> <span class="k">instanceof</span> <span class="n">WildcardType</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;包含通配符的类型-&gt; &#34;</span> <span class="o">+</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">Type</span><span class="o">[]</span> <span class="n">upperBounds</span> <span class="o">=</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getUpperBounds</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">upperBounds</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;    通配符的上界包括:&#34;</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">upperBounds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        &#34;</span> <span class="o">+</span> <span class="n">upperBounds</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getTypeName</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">Type</span><span class="o">[]</span> <span class="n">lowerBounds</span> <span class="o">=</span> <span class="o">((</span><span class="n">WildcardType</span><span class="o">)</span> <span class="n">argumentType</span><span class="o">).</span><span class="na">getLowerBounds</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lowerBounds</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;  通配符的下界包括:&#34;</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">lowerBounds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;        &#34;</span> <span class="o">+</span> <span class="n">lowerBounds</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getClass</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行结果中可以看到我们最终获取了方法的返回类型上的泛型参数中的原生类型 User类及Post类，拿到具体的类型后，Retrofit框架内部就可以做Json转换了(实际上大部分Json转换库如Gson只需要获取到Type类型就可以了)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">开始打印Service接口的方法信息
login方法的返回类型为参数化类型-&gt; GenericTest.GenericTest<span class="nv">$Call</span>&lt;GenericTest<span class="nv">$User</span>&gt;
    参数化类型中的泛型参数信息如下:
        第0个泛型参数类型为
              原生类型-&gt; GenericTest.User

getPosts方法的返回类型为参数化类型-&gt; GenericTest.GenericTest<span class="nv">$Call</span>&lt;java.util.List&lt;GenericTest<span class="nv">$Post</span>&gt;&gt;
    参数化类型中的泛型参数信息如下:
        第0个泛型参数类型为
              参数化类型-&gt; java.util.List&lt;GenericTest<span class="nv">$Post</span>&gt;
    参数化类型中的泛型参数信息如下:
        第0个泛型参数类型为
              原生类型-&gt; GenericTest.Post
</code></pre></td></tr></table>
</div>
</div><h2 id="回顾">回顾</h2>
<p>在全文中我们首先简单介绍了泛型的概念、泛型的类型系统，之后从字节码角度解读了泛型在字节码层面的信息，最后回到应用层，我们介绍了泛型相关的反射api，并使用这些api完成一个小需求。</p>
<p>Java  泛型的引入为开发者在很多场景下带来了很多的灵活度。如果希望进一步的掌握泛型的使用，一方面可以在平时的开发过程中思考在哪些场景下可以引入泛型参数，活学活用;另一方面可以研究系统的类库比如Class类、集合类中泛型的使用，也可以研究一些开源框架比如Retrofit库。</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.jianshu.com/p/2bfbe041e6b7" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/2bfbe041e6b7</a></p>
<p><a href="https://www.it610.com/article/5763404.htm" target="_blank" rel="noopener noreferrer">https://www.it610.com/article/5763404.htm</a></p>
<p><a href="https://www.likecs.com/show-204186098.html" target="_blank" rel="noopener noreferrer">https://www.likecs.com/show-204186098.html</a></p>
<p><a href="https://www.jianshu.com/p/be3edf42cfb2" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/be3edf42cfb2</a></p>
<p><a href="https://blog.csdn.net/yu540135101/article/details/112998209" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/yu540135101/article/details/112998209</a></p>
<p>《Java编程思想 第4版》</p>
<p>《Java核心技术 第10版》</p>
<p>《深入理解Java虚拟机 第2版》</p>
<p>Java编程思想（部分Demo）</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-06-08</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/java-generic-note/index.md" target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://kkkpjskey.github.io/java-generic-note/" data-title="Java泛型笔记" data-hashtags="Java,Generic,JavaNote"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://kkkpjskey.github.io/java-generic-note/" data-hashtag="Java"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://kkkpjskey.github.io/java-generic-note/" data-title="Java泛型笔记" data-ralateuid="3960792616"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://kkkpjskey.github.io/java-generic-note/" data-title="Java泛型笔记"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/java/">Java</a>,&nbsp;<a href="/tags/generic/">Generic</a>,&nbsp;<a href="/tags/javanote/">JavaNote</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/docker-note/" class="prev" rel="prev" title="Docker笔记"><i class="fas fa-angle-left fa-fw"></i>Docker笔记</a>
            <a href="/chocolatey-install-error/" class="next" rel="next" title="Window10安装Chocolatey &#39;An existing Chocolatey installation was detected&#39;">Window10安装Chocolatey &#39;An existing Chocolatey installation was detected&#39;<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.92.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/sunt-programator/CodeIT" target="_blank" rel="noopener noreferrer" title="CodeIT 0.2.10"><i class="fas fa-laptop-code fa-fw"></i> CodeIT</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/KKKPJSKEY" target="_blank" rel="noopener noreferrer">KKKPJSKEY</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://leancloud.hugoCodeIT.com","visitor":true}},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"id-1":"KKKPJSKEY's-Case-Archives","id-2":"KKKPJSKEY's-Case-Archives"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"HQXVPXR7JG","algoliaIndex":"KKKPJSKEY's-Case-Archives","algoliaSearchKey":"19b354f5c6a10bcec6a1c920d95cda23","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.e7a5845171e7810e33987fe5e0126480d67b52c04d579f93f48f97aae1932644ec5f7fa8c1f3377a0613c9a2fcf86bd1.js" integrity="sha384-56WEUXHngQ4zmH/l4BJkgNZ7UsBNV5&#43;T9I&#43;XquGTJkTsX3&#43;owfM3egYTyaL8&#43;GvR"></script></body>
</html>
